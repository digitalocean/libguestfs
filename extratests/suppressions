{
   libnuma_numa_node_size64_cond
   Memcheck:Cond
   fun:*
   fun:numa_node_size64
   fun:numa_init
}
{
   libnuma_numa_node_size64_cond_2
   Memcheck:Cond
   fun:numa_node_size64
   fun:numa_init
}
{
   libnuma_numa_node_size64_value8
   Memcheck:Value8
   fun:numa_node_size64
   fun:numa_init
}

{
   libnl_add_routing_table_name_leak
   Memcheck:Leak
   fun:malloc
   fun:strdup
   fun:add_routing_table_name
}
{
   libnl_add_routing_table_name_leak_2
   Memcheck:Leak
   fun:calloc
   fun:add_routing_table_name
}
{
   libnl_add_proto_name_leak
   Memcheck:Leak
   fun:malloc
   fun:strdup
   fun:add_proto_name
}
{
   libnl_add_proto_name_leak_2
   Memcheck:Leak
   fun:calloc
   fun:add_proto_name
}

{
   libnl1_malloc_leak
   Memcheck:Leak
   fun:malloc
   fun:strdup
   obj:/usr/lib/libnl.so.1.1
}
{
   libnl1_calloc_leak
   Memcheck:Leak
   fun:calloc
   obj:/usr/lib/libnl.so.1.1
}

# OCaml, by design, doesn't bother to free the major heap before
# calling exit.  Ignore that leak.
{
   ocaml_heap_leak
   Memcheck:Leak
   ...
   fun:caml_alloc_for_heap
}
# On the other hand, these seem to be a real bugs in OCaml:
{
   ocaml_heap_leak_2
   Memcheck:Leak
   fun:malloc
   fun:caml_thread_new_descriptor
   fun:caml_thread_new
}
{
   ocaml_heap_leak_3
   Memcheck:Leak
   fun:malloc
   fun:caml_thread_new_descriptor
   fun:caml_thread_initialize
}
{
   ocaml_heap_leak_4
   Memcheck:Leak
   ...
   fun:pthread_create*
   ...
   fun:caml_thread_new
}
