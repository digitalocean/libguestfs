/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include <guestfs.h>
#include "fish.h"

void list_commands (void)
{
  printf ("    %-16s     %s\n", "Command", "Description");
  list_builtin_commands ();
  printf ("%-20s %s\n", "add-cdrom", "add a CD-ROM disk image to examine");
  printf ("%-20s %s\n", "add-drive", "add an image to examine or modify");
  printf ("%-20s %s\n", "add-drive-ro", "add a drive in snapshot mode (read-only)");
  printf ("%-20s %s\n", "aug-close", "close the current Augeas handle");
  printf ("%-20s %s\n", "aug-defnode", "define an Augeas node");
  printf ("%-20s %s\n", "aug-defvar", "define an Augeas variable");
  printf ("%-20s %s\n", "aug-get", "look up the value of an Augeas path");
  printf ("%-20s %s\n", "aug-init", "create a new Augeas handle");
  printf ("%-20s %s\n", "aug-insert", "insert a sibling Augeas node");
  printf ("%-20s %s\n", "aug-load", "load files into the tree");
  printf ("%-20s %s\n", "aug-ls", "list Augeas nodes under a path");
  printf ("%-20s %s\n", "aug-match", "return Augeas nodes which match path");
  printf ("%-20s %s\n", "aug-mv", "move Augeas node");
  printf ("%-20s %s\n", "aug-rm", "remove an Augeas path");
  printf ("%-20s %s\n", "aug-save", "write all pending Augeas changes to disk");
  printf ("%-20s %s\n", "aug-set", "set Augeas path to value");
  printf ("%-20s %s\n", "blockdev-flushbufs", "flush device buffers");
  printf ("%-20s %s\n", "blockdev-getbsz", "get blocksize of block device");
  printf ("%-20s %s\n", "blockdev-getro", "is block device set to read-only");
  printf ("%-20s %s\n", "blockdev-getsize64", "get total size of device in bytes");
  printf ("%-20s %s\n", "blockdev-getss", "get sectorsize of block device");
  printf ("%-20s %s\n", "blockdev-getsz", "get total size of device in 512-byte sectors");
  printf ("%-20s %s\n", "blockdev-rereadpt", "reread partition table");
  printf ("%-20s %s\n", "blockdev-setbsz", "set blocksize of block device");
  printf ("%-20s %s\n", "blockdev-setro", "set block device to read-only");
  printf ("%-20s %s\n", "blockdev-setrw", "set block device to read-write");
  printf ("%-20s %s\n", "cat", "list the contents of a file");
  printf ("%-20s %s\n", "checksum", "compute MD5, SHAx or CRC checksum of file");
  printf ("%-20s %s\n", "chmod", "change file mode");
  printf ("%-20s %s\n", "chown", "change file owner and group");
  printf ("%-20s %s\n", "command", "run a command from the guest filesystem");
  printf ("%-20s %s\n", "command-lines", "run a command, returning lines");
  printf ("%-20s %s\n", "config", "add qemu parameters");
  printf ("%-20s %s\n", "cp", "copy a file");
  printf ("%-20s %s\n", "cp-a", "copy a file or directory recursively");
  printf ("%-20s %s\n", "debug", "debugging and internals");
  printf ("%-20s %s\n", "dmesg", "return kernel messages");
  printf ("%-20s %s\n", "download", "download a file to the local machine");
  printf ("%-20s %s\n", "drop-caches", "drop kernel page cache, dentries and inodes");
  printf ("%-20s %s\n", "e2fsck-f", "check an ext2/ext3 filesystem");
  printf ("%-20s %s\n", "equal", "test if two files have equal contents");
  printf ("%-20s %s\n", "exists", "test if file or directory exists");
  printf ("%-20s %s\n", "file", "determine file type");
  printf ("%-20s %s\n", "find", "find all files and directories");
  printf ("%-20s %s\n", "fsck", "run the filesystem checker");
  printf ("%-20s %s\n", "get-append", "get the additional kernel options");
  printf ("%-20s %s\n", "get-autosync", "get autosync mode");
  printf ("%-20s %s\n", "get-e2label", "get the ext2/3/4 filesystem label");
  printf ("%-20s %s\n", "get-e2uuid", "get the ext2/3/4 filesystem UUID");
  printf ("%-20s %s\n", "get-path", "get the search path");
  printf ("%-20s %s\n", "get-qemu", "get the qemu binary");
  printf ("%-20s %s\n", "get-state", "get the current state");
  printf ("%-20s %s\n", "get-verbose", "get verbose mode");
  printf ("%-20s %s\n", "grub-install", "install GRUB");
  printf ("%-20s %s\n", "hexdump", "dump a file in hexadecimal");
  printf ("%-20s %s\n", "is-busy", "is busy processing a command");
  printf ("%-20s %s\n", "is-config", "is in configuration state");
  printf ("%-20s %s\n", "is-dir", "test if file exists");
  printf ("%-20s %s\n", "is-file", "test if file exists");
  printf ("%-20s %s\n", "is-launching", "is launching subprocess");
  printf ("%-20s %s\n", "is-ready", "is ready to accept commands");
  printf ("%-20s %s\n", "kill-subprocess", "kill the qemu subprocess");
  printf ("%-20s %s\n", "launch", "launch the qemu subprocess");
  printf ("%-20s %s\n", "list-devices", "list the block devices");
  printf ("%-20s %s\n", "list-partitions", "list the partitions");
  printf ("%-20s %s\n", "ll", "list the files in a directory (long format)");
  printf ("%-20s %s\n", "ls", "list the files in a directory");
  printf ("%-20s %s\n", "lstat", "get file information for a symbolic link");
  printf ("%-20s %s\n", "lvcreate", "create an LVM volume group");
  printf ("%-20s %s\n", "lvm-remove-all", "remove all LVM LVs, VGs and PVs");
  printf ("%-20s %s\n", "lvremove", "remove an LVM logical volume");
  printf ("%-20s %s\n", "lvresize", "resize an LVM logical volume");
  printf ("%-20s %s\n", "lvs", "list the LVM logical volumes (LVs)");
  printf ("%-20s %s\n", "lvs-full", "list the LVM logical volumes (LVs)");
  printf ("%-20s %s\n", "mkdir", "create a directory");
  printf ("%-20s %s\n", "mkdir-p", "create a directory and parents");
  printf ("%-20s %s\n", "mkfs", "make a filesystem");
  printf ("%-20s %s\n", "mount", "mount a guest disk at a position in the filesystem");
  printf ("%-20s %s\n", "mount-options", "mount a guest disk with mount options");
  printf ("%-20s %s\n", "mount-ro", "mount a guest disk, read-only");
  printf ("%-20s %s\n", "mount-vfs", "mount a guest disk with mount options and vfstype");
  printf ("%-20s %s\n", "mounts", "show mounted filesystems");
  printf ("%-20s %s\n", "mv", "move a file");
  printf ("%-20s %s\n", "ping-daemon", "ping the guest daemon");
  printf ("%-20s %s\n", "pvcreate", "create an LVM physical volume");
  printf ("%-20s %s\n", "pvremove", "remove an LVM physical volume");
  printf ("%-20s %s\n", "pvresize", "resize an LVM physical volume");
  printf ("%-20s %s\n", "pvs", "list the LVM physical volumes (PVs)");
  printf ("%-20s %s\n", "pvs-full", "list the LVM physical volumes (PVs)");
  printf ("%-20s %s\n", "read-lines", "read file as lines");
  printf ("%-20s %s\n", "resize2fs", "resize an ext2/ext3 filesystem");
  printf ("%-20s %s\n", "rm", "remove a file");
  printf ("%-20s %s\n", "rm-rf", "remove a file or directory recursively");
  printf ("%-20s %s\n", "rmdir", "remove a directory");
  printf ("%-20s %s\n", "set-append", "add options to kernel command line");
  printf ("%-20s %s\n", "set-autosync", "set autosync mode");
  printf ("%-20s %s\n", "set-e2label", "set the ext2/3/4 filesystem label");
  printf ("%-20s %s\n", "set-e2uuid", "set the ext2/3/4 filesystem UUID");
  printf ("%-20s %s\n", "set-path", "set the search path");
  printf ("%-20s %s\n", "set-qemu", "set the qemu binary");
  printf ("%-20s %s\n", "set-verbose", "set verbose mode");
  printf ("%-20s %s\n", "sfdisk", "create partitions on a block device");
  printf ("%-20s %s\n", "sfdisk-N", "modify a single partition on a block device");
  printf ("%-20s %s\n", "sfdisk-disk-geometry", "display the disk geometry from the partition table");
  printf ("%-20s %s\n", "sfdisk-kernel-geometry", "display the kernel geometry");
  printf ("%-20s %s\n", "sfdisk-l", "display the partition table");
  printf ("%-20s %s\n", "sleep", "sleep for some seconds");
  printf ("%-20s %s\n", "stat", "get file information");
  printf ("%-20s %s\n", "statvfs", "get file system statistics");
  printf ("%-20s %s\n", "strings", "print the printable strings in a file");
  printf ("%-20s %s\n", "strings-e", "print the printable strings in a file");
  printf ("%-20s %s\n", "sync", "sync disks, writes are flushed through to the disk image");
  printf ("%-20s %s\n", "tar-in", "unpack tarfile to directory");
  printf ("%-20s %s\n", "tar-out", "pack directory into tarfile");
  printf ("%-20s %s\n", "tgz-in", "unpack compressed tarball to directory");
  printf ("%-20s %s\n", "tgz-out", "pack directory into compressed tarball");
  printf ("%-20s %s\n", "touch", "update file timestamps or create a new file");
  printf ("%-20s %s\n", "tune2fs-l", "get ext2/ext3/ext4 superblock details");
  printf ("%-20s %s\n", "umount", "unmount a filesystem");
  printf ("%-20s %s\n", "umount-all", "unmount all filesystems");
  printf ("%-20s %s\n", "upload", "upload a file from the local machine");
  printf ("%-20s %s\n", "vg-activate", "activate or deactivate some volume groups");
  printf ("%-20s %s\n", "vg-activate-all", "activate or deactivate all volume groups");
  printf ("%-20s %s\n", "vgcreate", "create an LVM volume group");
  printf ("%-20s %s\n", "vgremove", "remove an LVM volume group");
  printf ("%-20s %s\n", "vgs", "list the LVM volume groups (VGs)");
  printf ("%-20s %s\n", "vgs-full", "list the LVM volume groups (VGs)");
  printf ("%-20s %s\n", "write-file", "create a file");
  printf ("%-20s %s\n", "zero", "write zeroes to the device");
  printf ("%-20s %s\n", "zerofree", "zero unused inodes and disk blocks on ext2/3 filesystem");
  printf ("    Use -h <cmd> / help <cmd> to show detailed help for a command.\n");
}

void display_command (const char *cmd)
{
  if (strcasecmp (cmd, "launch") == 0 || strcasecmp (cmd, "run") == 0)
    pod2text ("launch - launch the qemu subprocess", " launch\n\nInternally libguestfs is implemented by running a virtual machine\nusing L<qemu(1)>.\n\nYou should call this after configuring the handle\n(eg. adding drives) but before performing any actions.\n\nYou can use 'run' as an alias for this command.");
  else
  if (strcasecmp (cmd, "kill_subprocess") == 0 || strcasecmp (cmd, "kill-subprocess") == 0)
    pod2text ("kill-subprocess - kill the qemu subprocess", " kill-subprocess\n\nThis kills the qemu subprocess.  You should never need to call this.");
  else
  if (strcasecmp (cmd, "add_drive") == 0 || strcasecmp (cmd, "add-drive") == 0 || strcasecmp (cmd, "add") == 0)
    pod2text ("add-drive - add an image to examine or modify", " add-drive <filename>\n\nThis function adds a virtual machine disk image C<filename> to the\nguest.  The first time you call this function, the disk appears as IDE\ndisk 0 (C</dev/sda>) in the guest, the second time as C</dev/sdb>, and\nso on.\n\nYou don't necessarily need to be root when using libguestfs.  However\nyou obviously do need sufficient permissions to access the filename\nfor whatever operations you want to perform (ie. read access if you\njust want to read the image or write access if you want to modify the\nimage).\n\nThis is equivalent to the qemu parameter C<-drive file=filename>.\n\nNote that this call checks for the existence of C<filename>.  This\nstops you from specifying other types of drive which are supported\nby qemu such as C<nbd:> and C<http:> URLs.  To specify those, use\nthe general C<config> call instead.\n\nYou can use 'add' as an alias for this command.");
  else
  if (strcasecmp (cmd, "add_cdrom") == 0 || strcasecmp (cmd, "add-cdrom") == 0 || strcasecmp (cmd, "cdrom") == 0)
    pod2text ("add-cdrom - add a CD-ROM disk image to examine", " add-cdrom <filename>\n\nThis function adds a virtual CD-ROM disk image to the guest.\n\nThis is equivalent to the qemu parameter C<-cdrom filename>.\n\nNote that this call checks for the existence of C<filename>.  This\nstops you from specifying other types of drive which are supported\nby qemu such as C<nbd:> and C<http:> URLs.  To specify those, use\nthe general C<config> call instead.\n\nYou can use 'cdrom' as an alias for this command.");
  else
  if (strcasecmp (cmd, "add_drive_ro") == 0 || strcasecmp (cmd, "add-drive-ro") == 0 || strcasecmp (cmd, "add-ro") == 0)
    pod2text ("add-drive-ro - add a drive in snapshot mode (read-only)", " add-drive-ro <filename>\n\nThis adds a drive in snapshot mode, making it effectively\nread-only.\n\nNote that writes to the device are allowed, and will be seen for\nthe duration of the guestfs handle, but they are written\nto a temporary file which is discarded as soon as the guestfs\nhandle is closed.  We don't currently have any method to enable\nchanges to be committed, although qemu can support this.\n\nThis is equivalent to the qemu parameter\nC<-drive file=filename,snapshot=on>.\n\nNote that this call checks for the existence of C<filename>.  This\nstops you from specifying other types of drive which are supported\nby qemu such as C<nbd:> and C<http:> URLs.  To specify those, use\nthe general C<config> call instead.\n\nYou can use 'add-ro' as an alias for this command.");
  else
  if (strcasecmp (cmd, "config") == 0)
    pod2text ("config - add qemu parameters", " config <qemuparam> <qemuvalue>\n\nThis can be used to add arbitrary qemu command line parameters\nof the form C<-param value>.  Actually it's not quite arbitrary - we\nprevent you from setting some parameters which would interfere with\nparameters that we use.\n\nThe first character of C<param> string must be a C<-> (dash).\n\nC<value> can be NULL.");
  else
  if (strcasecmp (cmd, "set_qemu") == 0 || strcasecmp (cmd, "set-qemu") == 0 || strcasecmp (cmd, "qemu") == 0)
    pod2text ("set-qemu - set the qemu binary", " set-qemu <qemu>\n\nSet the qemu binary that we will use.\n\nThe default is chosen when the library was compiled by the\nconfigure script.\n\nYou can also override this by setting the C<LIBGUESTFS_QEMU>\nenvironment variable.\n\nSetting C<qemu> to C<NULL> restores the default qemu binary.\n\nYou can use 'qemu' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_qemu") == 0 || strcasecmp (cmd, "get-qemu") == 0)
    pod2text ("get-qemu - get the qemu binary", " get-qemu\n\nReturn the current qemu binary.\n\nThis is always non-NULL.  If it wasn't set already, then this will\nreturn the default qemu binary name.");
  else
  if (strcasecmp (cmd, "set_path") == 0 || strcasecmp (cmd, "set-path") == 0 || strcasecmp (cmd, "path") == 0)
    pod2text ("set-path - set the search path", " set-path <path>\n\nSet the path that libguestfs searches for kernel and initrd.img.\n\nThe default is C<$libdir/guestfs> unless overridden by setting\nC<LIBGUESTFS_PATH> environment variable.\n\nSetting C<path> to C<NULL> restores the default path.\n\nYou can use 'path' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_path") == 0 || strcasecmp (cmd, "get-path") == 0)
    pod2text ("get-path - get the search path", " get-path\n\nReturn the current search path.\n\nThis is always non-NULL.  If it wasn't set already, then this will\nreturn the default path.");
  else
  if (strcasecmp (cmd, "set_append") == 0 || strcasecmp (cmd, "set-append") == 0 || strcasecmp (cmd, "append") == 0)
    pod2text ("set-append - add options to kernel command line", " set-append <append>\n\nThis function is used to add additional options to the\nguest kernel command line.\n\nThe default is C<NULL> unless overridden by setting\nC<LIBGUESTFS_APPEND> environment variable.\n\nSetting C<append> to C<NULL> means I<no> additional options\nare passed (libguestfs always adds a few of its own).\n\nYou can use 'append' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_append") == 0 || strcasecmp (cmd, "get-append") == 0)
    pod2text ("get-append - get the additional kernel options", " get-append\n\nReturn the additional kernel options which are added to the\nguest kernel command line.\n\nIf C<NULL> then no options are added.");
  else
  if (strcasecmp (cmd, "set_autosync") == 0 || strcasecmp (cmd, "set-autosync") == 0 || strcasecmp (cmd, "autosync") == 0)
    pod2text ("set-autosync - set autosync mode", " set-autosync <autosync>\n\nIf C<autosync> is true, this enables autosync.  Libguestfs will make a\nbest effort attempt to run C<umount_all> followed by\nC<sync> when the handle is closed\n(also if the program exits without closing handles).\n\nThis is disabled by default (except in guestfish where it is\nenabled by default).\n\nYou can use 'autosync' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_autosync") == 0 || strcasecmp (cmd, "get-autosync") == 0)
    pod2text ("get-autosync - get autosync mode", " get-autosync\n\nGet the autosync flag.");
  else
  if (strcasecmp (cmd, "set_verbose") == 0 || strcasecmp (cmd, "set-verbose") == 0 || strcasecmp (cmd, "verbose") == 0)
    pod2text ("set-verbose - set verbose mode", " set-verbose <verbose>\n\nIf C<verbose> is true, this turns on verbose messages (to C<stderr>).\n\nVerbose messages are disabled unless the environment variable\nC<LIBGUESTFS_DEBUG> is defined and set to C<1>.\n\nYou can use 'verbose' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_verbose") == 0 || strcasecmp (cmd, "get-verbose") == 0)
    pod2text ("get-verbose - get verbose mode", " get-verbose\n\nThis returns the verbose messages flag.");
  else
  if (strcasecmp (cmd, "is_ready") == 0 || strcasecmp (cmd, "is-ready") == 0)
    pod2text ("is-ready - is ready to accept commands", " is-ready\n\nThis returns true iff this handle is ready to accept commands\n(in the C<READY> state).\n\nFor more information on states, see L<guestfs(3)>.");
  else
  if (strcasecmp (cmd, "is_config") == 0 || strcasecmp (cmd, "is-config") == 0)
    pod2text ("is-config - is in configuration state", " is-config\n\nThis returns true iff this handle is being configured\n(in the C<CONFIG> state).\n\nFor more information on states, see L<guestfs(3)>.");
  else
  if (strcasecmp (cmd, "is_launching") == 0 || strcasecmp (cmd, "is-launching") == 0)
    pod2text ("is-launching - is launching subprocess", " is-launching\n\nThis returns true iff this handle is launching the subprocess\n(in the C<LAUNCHING> state).\n\nFor more information on states, see L<guestfs(3)>.");
  else
  if (strcasecmp (cmd, "is_busy") == 0 || strcasecmp (cmd, "is-busy") == 0)
    pod2text ("is-busy - is busy processing a command", " is-busy\n\nThis returns true iff this handle is busy processing a command\n(in the C<BUSY> state).\n\nFor more information on states, see L<guestfs(3)>.");
  else
  if (strcasecmp (cmd, "get_state") == 0 || strcasecmp (cmd, "get-state") == 0)
    pod2text ("get-state - get the current state", " get-state\n\nThis returns the current state as an opaque integer.  This is\nonly useful for printing debug and internal error messages.\n\nFor more information on states, see L<guestfs(3)>.");
  else
  if (strcasecmp (cmd, "mount") == 0)
    pod2text ("mount - mount a guest disk at a position in the filesystem", " mount <device> <mountpoint>\n\nMount a guest disk at a position in the filesystem.  Block devices\nare named C</dev/sda>, C</dev/sdb> and so on, as they were added to\nthe guest.  If those block devices contain partitions, they will have\nthe usual names (eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style\nnames can be used.\n\nThe rules are the same as for L<mount(2)>:  A filesystem must\nfirst be mounted on C</> before others can be mounted.  Other\nfilesystems can only be mounted on directories which already\nexist.\n\nThe mounted filesystem is writable, if we have sufficient permissions\non the underlying device.\n\nThe filesystem options C<sync> and C<noatime> are set with this\ncall, in order to improve reliability.");
  else
  if (strcasecmp (cmd, "sync") == 0)
    pod2text ("sync - sync disks, writes are flushed through to the disk image", " sync\n\nThis syncs the disk, so that any writes are flushed through to the\nunderlying disk image.\n\nYou should always call this if you have modified a disk image, before\nclosing the handle.");
  else
  if (strcasecmp (cmd, "touch") == 0)
    pod2text ("touch - update file timestamps or create a new file", " touch <path>\n\nTouch acts like the L<touch(1)> command.  It can be used to\nupdate the timestamps on a file, or, if the file does not exist,\nto create a new zero-length file.");
  else
  if (strcasecmp (cmd, "cat") == 0)
    pod2text ("cat - list the contents of a file", " cat <path>\n\nReturn the contents of the file named C<path>.\n\nNote that this function cannot correctly handle binary files\n(specifically, files containing C<\\0> character which is treated\nas end of string).  For those you need to use the C<download>\nfunction which has a more complex interface.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "ll") == 0)
    pod2text ("ll - list the files in a directory (long format)", " ll <directory>\n\nList the files in C<directory> (relative to the root directory,\nthere is no cwd) in the format of 'ls -la'.\n\nThis command is mostly useful for interactive sessions.  It\nis I<not> intended that you try to parse the output string.");
  else
  if (strcasecmp (cmd, "ls") == 0)
    pod2text ("ls - list the files in a directory", " ls <directory>\n\nList the files in C<directory> (relative to the root directory,\nthere is no cwd).  The '.' and '..' entries are not returned, but\nhidden files are shown.\n\nThis command is mostly useful for interactive sessions.  Programs\nshould probably use C<readdir> instead.");
  else
  if (strcasecmp (cmd, "list_devices") == 0 || strcasecmp (cmd, "list-devices") == 0)
    pod2text ("list-devices - list the block devices", " list-devices\n\nList all the block devices.\n\nThe full block device names are returned, eg. C</dev/sda>");
  else
  if (strcasecmp (cmd, "list_partitions") == 0 || strcasecmp (cmd, "list-partitions") == 0)
    pod2text ("list-partitions - list the partitions", " list-partitions\n\nList all the partitions detected on all block devices.\n\nThe full partition device names are returned, eg. C</dev/sda1>\n\nThis does not return logical volumes.  For that you will need to\ncall C<lvs>.");
  else
  if (strcasecmp (cmd, "pvs") == 0)
    pod2text ("pvs - list the LVM physical volumes (PVs)", " pvs\n\nList all the physical volumes detected.  This is the equivalent\nof the L<pvs(8)> command.\n\nThis returns a list of just the device names that contain\nPVs (eg. C</dev/sda2>).\n\nSee also C<pvs_full>.");
  else
  if (strcasecmp (cmd, "vgs") == 0)
    pod2text ("vgs - list the LVM volume groups (VGs)", " vgs\n\nList all the volumes groups detected.  This is the equivalent\nof the L<vgs(8)> command.\n\nThis returns a list of just the volume group names that were\ndetected (eg. C<VolGroup00>).\n\nSee also C<vgs_full>.");
  else
  if (strcasecmp (cmd, "lvs") == 0)
    pod2text ("lvs - list the LVM logical volumes (LVs)", " lvs\n\nList all the logical volumes detected.  This is the equivalent\nof the L<lvs(8)> command.\n\nThis returns a list of the logical volume device names\n(eg. C</dev/VolGroup00/LogVol00>).\n\nSee also C<lvs_full>.");
  else
  if (strcasecmp (cmd, "pvs_full") == 0 || strcasecmp (cmd, "pvs-full") == 0)
    pod2text ("pvs-full - list the LVM physical volumes (PVs)", " pvs-full\n\nList all the physical volumes detected.  This is the equivalent\nof the L<pvs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "vgs_full") == 0 || strcasecmp (cmd, "vgs-full") == 0)
    pod2text ("vgs-full - list the LVM volume groups (VGs)", " vgs-full\n\nList all the volumes groups detected.  This is the equivalent\nof the L<vgs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "lvs_full") == 0 || strcasecmp (cmd, "lvs-full") == 0)
    pod2text ("lvs-full - list the LVM logical volumes (LVs)", " lvs-full\n\nList all the logical volumes detected.  This is the equivalent\nof the L<lvs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "read_lines") == 0 || strcasecmp (cmd, "read-lines") == 0)
    pod2text ("read-lines - read file as lines", " read-lines <path>\n\nReturn the contents of the file named C<path>.\n\nThe file contents are returned as a list of lines.  Trailing\nC<LF> and C<CRLF> character sequences are I<not> returned.\n\nNote that this function cannot correctly handle binary files\n(specifically, files containing C<\\0> character which is treated\nas end of line).  For those you need to use the C<read_file>\nfunction which has a more complex interface.");
  else
  if (strcasecmp (cmd, "aug_init") == 0 || strcasecmp (cmd, "aug-init") == 0)
    pod2text ("aug-init - create a new Augeas handle", " aug-init <root> <flags>\n\nCreate a new Augeas handle for editing configuration files.\nIf there was any previous Augeas handle associated with this\nguestfs session, then it is closed.\n\nYou must call this before using any other C<aug_*>\ncommands.\n\nC<root> is the filesystem root.  C<root> must not be NULL,\nuse C</> instead.\n\nThe flags are the same as the flags defined in\nE<lt>augeas.hE<gt>, the logical I<or> of the following\nintegers:\n\n=over 4\n\n=item C<AUG_SAVE_BACKUP> = 1\n\nKeep the original file with a C<.augsave> extension.\n\n=item C<AUG_SAVE_NEWFILE> = 2\n\nSave changes into a file with extension C<.augnew>, and\ndo not overwrite original.  Overrides C<AUG_SAVE_BACKUP>.\n\n=item C<AUG_TYPE_CHECK> = 4\n\nTypecheck lenses (can be expensive).\n\n=item C<AUG_NO_STDINC> = 8\n\nDo not use standard load path for modules.\n\n=item C<AUG_SAVE_NOOP> = 16\n\nMake save a no-op, just record what would have been changed.\n\n=item C<AUG_NO_LOAD> = 32\n\nDo not load the tree in C<aug_init>.\n\n=back\n\nTo close the handle, you can call C<aug_close>.\n\nTo find out more about Augeas, see L<http://augeas.net/>.");
  else
  if (strcasecmp (cmd, "aug_close") == 0 || strcasecmp (cmd, "aug-close") == 0)
    pod2text ("aug-close - close the current Augeas handle", " aug-close\n\nClose the current Augeas handle and free up any resources\nused by it.  After calling this, you have to call\nC<aug_init> again before you can use any other\nAugeas functions.");
  else
  if (strcasecmp (cmd, "aug_defvar") == 0 || strcasecmp (cmd, "aug-defvar") == 0)
    pod2text ("aug-defvar - define an Augeas variable", " aug-defvar <name> <expr>\n\nDefines an Augeas variable C<name> whose value is the result\nof evaluating C<expr>.  If C<expr> is NULL, then C<name> is\nundefined.\n\nOn success this returns the number of nodes in C<expr>, or\nC<0> if C<expr> evaluates to something which is not a nodeset.");
  else
  if (strcasecmp (cmd, "aug_defnode") == 0 || strcasecmp (cmd, "aug-defnode") == 0)
    pod2text ("aug-defnode - define an Augeas node", " aug-defnode <name> <expr> <val>\n\nDefines a variable C<name> whose value is the result of\nevaluating C<expr>.\n\nIf C<expr> evaluates to an empty nodeset, a node is created,\nequivalent to calling C<aug_set> C<expr>, C<value>.\nC<name> will be the nodeset containing that single node.\n\nOn success this returns a pair containing the\nnumber of nodes in the nodeset, and a boolean flag\nif a node was created.");
  else
  if (strcasecmp (cmd, "aug_get") == 0 || strcasecmp (cmd, "aug-get") == 0)
    pod2text ("aug-get - look up the value of an Augeas path", " aug-get <path>\n\nLook up the value associated with C<path>.  If C<path>\nmatches exactly one node, the C<value> is returned.");
  else
  if (strcasecmp (cmd, "aug_set") == 0 || strcasecmp (cmd, "aug-set") == 0)
    pod2text ("aug-set - set Augeas path to value", " aug-set <path> <val>\n\nSet the value associated with C<path> to C<value>.");
  else
  if (strcasecmp (cmd, "aug_insert") == 0 || strcasecmp (cmd, "aug-insert") == 0)
    pod2text ("aug-insert - insert a sibling Augeas node", " aug-insert <path> <label> <before>\n\nCreate a new sibling C<label> for C<path>, inserting it into\nthe tree before or after C<path> (depending on the boolean\nflag C<before>).\n\nC<path> must match exactly one existing node in the tree, and\nC<label> must be a label, ie. not contain C</>, C<*> or end\nwith a bracketed index C<[N]>.");
  else
  if (strcasecmp (cmd, "aug_rm") == 0 || strcasecmp (cmd, "aug-rm") == 0)
    pod2text ("aug-rm - remove an Augeas path", " aug-rm <path>\n\nRemove C<path> and all of its children.\n\nOn success this returns the number of entries which were removed.");
  else
  if (strcasecmp (cmd, "aug_mv") == 0 || strcasecmp (cmd, "aug-mv") == 0)
    pod2text ("aug-mv - move Augeas node", " aug-mv <src> <dest>\n\nMove the node C<src> to C<dest>.  C<src> must match exactly\none node.  C<dest> is overwritten if it exists.");
  else
  if (strcasecmp (cmd, "aug_match") == 0 || strcasecmp (cmd, "aug-match") == 0)
    pod2text ("aug-match - return Augeas nodes which match path", " aug-match <path>\n\nReturns a list of paths which match the path expression C<path>.\nThe returned paths are sufficiently qualified so that they match\nexactly one node in the current tree.");
  else
  if (strcasecmp (cmd, "aug_save") == 0 || strcasecmp (cmd, "aug-save") == 0)
    pod2text ("aug-save - write all pending Augeas changes to disk", " aug-save\n\nThis writes all pending changes to disk.\n\nThe flags which were passed to C<aug_init> affect exactly\nhow files are saved.");
  else
  if (strcasecmp (cmd, "aug_load") == 0 || strcasecmp (cmd, "aug-load") == 0)
    pod2text ("aug-load - load files into the tree", " aug-load\n\nLoad files into the tree.\n\nSee C<aug_load> in the Augeas documentation for the full gory\ndetails.");
  else
  if (strcasecmp (cmd, "aug_ls") == 0 || strcasecmp (cmd, "aug-ls") == 0)
    pod2text ("aug-ls - list Augeas nodes under a path", " aug-ls <path>\n\nThis is just a shortcut for listing C<aug_match>\nC<path/*> and sorting the resulting nodes into alphabetical order.");
  else
  if (strcasecmp (cmd, "rm") == 0)
    pod2text ("rm - remove a file", " rm <path>\n\nRemove the single file C<path>.");
  else
  if (strcasecmp (cmd, "rmdir") == 0)
    pod2text ("rmdir - remove a directory", " rmdir <path>\n\nRemove the single directory C<path>.");
  else
  if (strcasecmp (cmd, "rm_rf") == 0 || strcasecmp (cmd, "rm-rf") == 0)
    pod2text ("rm-rf - remove a file or directory recursively", " rm-rf <path>\n\nRemove the file or directory C<path>, recursively removing the\ncontents if its a directory.  This is like the C<rm -rf> shell\ncommand.");
  else
  if (strcasecmp (cmd, "mkdir") == 0)
    pod2text ("mkdir - create a directory", " mkdir <path>\n\nCreate a directory named C<path>.");
  else
  if (strcasecmp (cmd, "mkdir_p") == 0 || strcasecmp (cmd, "mkdir-p") == 0)
    pod2text ("mkdir-p - create a directory and parents", " mkdir-p <path>\n\nCreate a directory named C<path>, creating any parent directories\nas necessary.  This is like the C<mkdir -p> shell command.");
  else
  if (strcasecmp (cmd, "chmod") == 0)
    pod2text ("chmod - change file mode", " chmod <mode> <path>\n\nChange the mode (permissions) of C<path> to C<mode>.  Only\nnumeric modes are supported.");
  else
  if (strcasecmp (cmd, "chown") == 0)
    pod2text ("chown - change file owner and group", " chown <owner> <group> <path>\n\nChange the file owner to C<owner> and group to C<group>.\n\nOnly numeric uid and gid are supported.  If you want to use\nnames, you will need to locate and parse the password file\nyourself (Augeas support makes this relatively easy).");
  else
  if (strcasecmp (cmd, "exists") == 0)
    pod2text ("exists - test if file or directory exists", " exists <path>\n\nThis returns C<true> if and only if there is a file, directory\n(or anything) with the given C<path> name.\n\nSee also C<is_file>, C<is_dir>, C<stat>.");
  else
  if (strcasecmp (cmd, "is_file") == 0 || strcasecmp (cmd, "is-file") == 0)
    pod2text ("is-file - test if file exists", " is-file <path>\n\nThis returns C<true> if and only if there is a file\nwith the given C<path> name.  Note that it returns false for\nother objects like directories.\n\nSee also C<stat>.");
  else
  if (strcasecmp (cmd, "is_dir") == 0 || strcasecmp (cmd, "is-dir") == 0)
    pod2text ("is-dir - test if file exists", " is-dir <path>\n\nThis returns C<true> if and only if there is a directory\nwith the given C<path> name.  Note that it returns false for\nother objects like files.\n\nSee also C<stat>.");
  else
  if (strcasecmp (cmd, "pvcreate") == 0)
    pod2text ("pvcreate - create an LVM physical volume", " pvcreate <device>\n\nThis creates an LVM physical volume on the named C<device>,\nwhere C<device> should usually be a partition name such\nas C</dev/sda1>.");
  else
  if (strcasecmp (cmd, "vgcreate") == 0)
    pod2text ("vgcreate - create an LVM volume group", " vgcreate <volgroup> <physvols>\n\nThis creates an LVM volume group called C<volgroup>\nfrom the non-empty list of physical volumes C<physvols>.");
  else
  if (strcasecmp (cmd, "lvcreate") == 0)
    pod2text ("lvcreate - create an LVM volume group", " lvcreate <logvol> <volgroup> <mbytes>\n\nThis creates an LVM volume group called C<logvol>\non the volume group C<volgroup>, with C<size> megabytes.");
  else
  if (strcasecmp (cmd, "mkfs") == 0)
    pod2text ("mkfs - make a filesystem", " mkfs <fstype> <device>\n\nThis creates a filesystem on C<device> (usually a partition\nor LVM logical volume).  The filesystem type is C<fstype>, for\nexample C<ext3>.");
  else
  if (strcasecmp (cmd, "sfdisk") == 0)
    pod2text ("sfdisk - create partitions on a block device", " sfdisk <device> <cyls> <heads> <sectors> <lines>\n\nThis is a direct interface to the L<sfdisk(8)> program for creating\npartitions on block devices.\n\nC<device> should be a block device, for example C</dev/sda>.\n\nC<cyls>, C<heads> and C<sectors> are the number of cylinders, heads\nand sectors on the device, which are passed directly to sfdisk as\nthe I<-C>, I<-H> and I<-S> parameters.  If you pass C<0> for any\nof these, then the corresponding parameter is omitted.  Usually for\n'large' disks, you can just pass C<0> for these, but for small\n(floppy-sized) disks, sfdisk (or rather, the kernel) cannot work\nout the right geometry and you will need to tell it.\n\nC<lines> is a list of lines that we feed to C<sfdisk>.  For more\ninformation refer to the L<sfdisk(8)> manpage.\n\nTo create a single partition occupying the whole disk, you would\npass C<lines> as a single element list, when the single element being\nthe string C<,> (comma).\n\nSee also: C<sfdisk_l>, C<sfdisk_N>\n\nB<This command is dangerous.  Without careful use you\ncan easily destroy all your data>.");
  else
  if (strcasecmp (cmd, "write_file") == 0 || strcasecmp (cmd, "write-file") == 0)
    pod2text ("write-file - create a file", " write-file <path> <content> <size>\n\nThis call creates a file called C<path>.  The contents of the\nfile is the string C<content> (which can contain any 8 bit data),\nwith length C<size>.\n\nAs a special case, if C<size> is C<0>\nthen the length is calculated using C<strlen> (so in this case\nthe content cannot contain embedded ASCII NULs).\n\nI<NB.> Owing to a bug, writing content containing ASCII NUL\ncharacters does I<not> work, even if the length is specified.\nWe hope to resolve this bug in a future version.  In the meantime\nuse C<upload>.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "umount") == 0 || strcasecmp (cmd, "unmount") == 0)
    pod2text ("umount - unmount a filesystem", " umount <pathordevice>\n\nThis unmounts the given filesystem.  The filesystem may be\nspecified either by its mountpoint (path) or the device which\ncontains the filesystem.\n\nYou can use 'unmount' as an alias for this command.");
  else
  if (strcasecmp (cmd, "mounts") == 0)
    pod2text ("mounts - show mounted filesystems", " mounts\n\nThis returns the list of currently mounted filesystems.  It returns\nthe list of devices (eg. C</dev/sda1>, C</dev/VG/LV>).\n\nSome internal mounts are not shown.");
  else
  if (strcasecmp (cmd, "umount_all") == 0 || strcasecmp (cmd, "umount-all") == 0 || strcasecmp (cmd, "unmount-all") == 0)
    pod2text ("umount-all - unmount all filesystems", " umount-all\n\nThis unmounts all mounted filesystems.\n\nSome internal mounts are not unmounted by this call.\n\nYou can use 'unmount-all' as an alias for this command.");
  else
  if (strcasecmp (cmd, "lvm_remove_all") == 0 || strcasecmp (cmd, "lvm-remove-all") == 0)
    pod2text ("lvm-remove-all - remove all LVM LVs, VGs and PVs", " lvm-remove-all\n\nThis command removes all LVM logical volumes, volume groups\nand physical volumes.\n\nB<This command is dangerous.  Without careful use you\ncan easily destroy all your data>.");
  else
  if (strcasecmp (cmd, "file") == 0)
    pod2text ("file - determine file type", " file <path>\n\nThis call uses the standard L<file(1)> command to determine\nthe type or contents of the file.  This also works on devices,\nfor example to find out whether a partition contains a filesystem.\n\nThe exact command which runs is C<file -bsL path>.  Note in\nparticular that the filename is not prepended to the output\n(the C<-b> option).");
  else
  if (strcasecmp (cmd, "command") == 0)
    pod2text ("command - run a command from the guest filesystem", " command <arguments>\n\nThis call runs a command from the guest filesystem.  The\nfilesystem must be mounted, and must contain a compatible\noperating system (ie. something Linux, with the same\nor compatible processor architecture).\n\nThe single parameter is an argv-style list of arguments.\nThe first element is the name of the program to run.\nSubsequent elements are parameters.  The list must be\nnon-empty (ie. must contain a program name).\n\nThe return value is anything printed to I<stdout> by\nthe command.\n\nIf the command returns a non-zero exit status, then\nthis function returns an error message.  The error message\nstring is the content of I<stderr> from the command.\n\nThe C<$PATH> environment variable will contain at least\nC</usr/bin> and C</bin>.  If you require a program from\nanother location, you should provide the full path in the\nfirst parameter.\n\nShared libraries and data files required by the program\nmust be available on filesystems which are mounted in the\ncorrect places.  It is the caller's responsibility to ensure\nall filesystems that are needed are mounted at the right\nlocations.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "command_lines") == 0 || strcasecmp (cmd, "command-lines") == 0)
    pod2text ("command-lines - run a command, returning lines", " command-lines <arguments>\n\nThis is the same as C<command>, but splits the\nresult into a list of lines.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "stat") == 0)
    pod2text ("stat - get file information", " stat <path>\n\nReturns file information for the given C<path>.\n\nThis is the same as the C<stat(2)> system call.");
  else
  if (strcasecmp (cmd, "lstat") == 0)
    pod2text ("lstat - get file information for a symbolic link", " lstat <path>\n\nReturns file information for the given C<path>.\n\nThis is the same as C<stat> except that if C<path>\nis a symbolic link, then the link is stat-ed, not the file it\nrefers to.\n\nThis is the same as the C<lstat(2)> system call.");
  else
  if (strcasecmp (cmd, "statvfs") == 0)
    pod2text ("statvfs - get file system statistics", " statvfs <path>\n\nReturns file system statistics for any mounted file system.\nC<path> should be a file or directory in the mounted file system\n(typically it is the mount point itself, but it doesn't need to be).\n\nThis is the same as the C<statvfs(2)> system call.");
  else
  if (strcasecmp (cmd, "tune2fs_l") == 0 || strcasecmp (cmd, "tune2fs-l") == 0)
    pod2text ("tune2fs-l - get ext2/ext3/ext4 superblock details", " tune2fs-l <device>\n\nThis returns the contents of the ext2, ext3 or ext4 filesystem\nsuperblock on C<device>.\n\nIt is the same as running C<tune2fs -l device>.  See L<tune2fs(8)>\nmanpage for more details.  The list of fields returned isn't\nclearly defined, and depends on both the version of C<tune2fs>\nthat libguestfs was built against, and the filesystem itself.");
  else
  if (strcasecmp (cmd, "blockdev_setro") == 0 || strcasecmp (cmd, "blockdev-setro") == 0)
    pod2text ("blockdev-setro - set block device to read-only", " blockdev-setro <device>\n\nSets the block device named C<device> to read-only.\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_setrw") == 0 || strcasecmp (cmd, "blockdev-setrw") == 0)
    pod2text ("blockdev-setrw - set block device to read-write", " blockdev-setrw <device>\n\nSets the block device named C<device> to read-write.\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_getro") == 0 || strcasecmp (cmd, "blockdev-getro") == 0)
    pod2text ("blockdev-getro - is block device set to read-only", " blockdev-getro <device>\n\nReturns a boolean indicating if the block device is read-only\n(true if read-only, false if not).\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_getss") == 0 || strcasecmp (cmd, "blockdev-getss") == 0)
    pod2text ("blockdev-getss - get sectorsize of block device", " blockdev-getss <device>\n\nThis returns the size of sectors on a block device.\nUsually 512, but can be larger for modern devices.\n\n(Note, this is not the size in sectors, use C<blockdev_getsz>\nfor that).\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_getbsz") == 0 || strcasecmp (cmd, "blockdev-getbsz") == 0)
    pod2text ("blockdev-getbsz - get blocksize of block device", " blockdev-getbsz <device>\n\nThis returns the block size of a device.\n\n(Note this is different from both I<size in blocks> and\nI<filesystem block size>).\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_setbsz") == 0 || strcasecmp (cmd, "blockdev-setbsz") == 0)
    pod2text ("blockdev-setbsz - set blocksize of block device", " blockdev-setbsz <device> <blocksize>\n\nThis sets the block size of a device.\n\n(Note this is different from both I<size in blocks> and\nI<filesystem block size>).\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_getsz") == 0 || strcasecmp (cmd, "blockdev-getsz") == 0)
    pod2text ("blockdev-getsz - get total size of device in 512-byte sectors", " blockdev-getsz <device>\n\nThis returns the size of the device in units of 512-byte sectors\n(even if the sectorsize isn't 512 bytes ... weird).\n\nSee also C<blockdev_getss> for the real sector size of\nthe device, and C<blockdev_getsize64> for the more\nuseful I<size in bytes>.\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_getsize64") == 0 || strcasecmp (cmd, "blockdev-getsize64") == 0)
    pod2text ("blockdev-getsize64 - get total size of device in bytes", " blockdev-getsize64 <device>\n\nThis returns the size of the device in bytes.\n\nSee also C<blockdev_getsz>.\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_flushbufs") == 0 || strcasecmp (cmd, "blockdev-flushbufs") == 0)
    pod2text ("blockdev-flushbufs - flush device buffers", " blockdev-flushbufs <device>\n\nThis tells the kernel to flush internal buffers associated\nwith C<device>.\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "blockdev_rereadpt") == 0 || strcasecmp (cmd, "blockdev-rereadpt") == 0)
    pod2text ("blockdev-rereadpt - reread partition table", " blockdev-rereadpt <device>\n\nReread the partition table on C<device>.\n\nThis uses the L<blockdev(8)> command.");
  else
  if (strcasecmp (cmd, "upload") == 0)
    pod2text ("upload - upload a file from the local machine", " upload <filename> <remotefilename>\n\nUpload local file C<filename> to C<remotefilename> on the\nfilesystem.\n\nC<filename> can also be a named pipe.\n\nSee also C<download>.");
  else
  if (strcasecmp (cmd, "download") == 0)
    pod2text ("download - download a file to the local machine", " download <remotefilename> <filename>\n\nDownload file C<remotefilename> and save it as C<filename>\non the local machine.\n\nC<filename> can also be a named pipe.\n\nSee also C<upload>, C<cat>.");
  else
  if (strcasecmp (cmd, "checksum") == 0)
    pod2text ("checksum - compute MD5, SHAx or CRC checksum of file", " checksum <csumtype> <path>\n\nThis call computes the MD5, SHAx or CRC checksum of the\nfile named C<path>.\n\nThe type of checksum to compute is given by the C<csumtype>\nparameter which must have one of the following values:\n\n=over 4\n\n=item C<crc>\n\nCompute the cyclic redundancy check (CRC) specified by POSIX\nfor the C<cksum> command.\n\n=item C<md5>\n\nCompute the MD5 hash (using the C<md5sum> program).\n\n=item C<sha1>\n\nCompute the SHA1 hash (using the C<sha1sum> program).\n\n=item C<sha224>\n\nCompute the SHA224 hash (using the C<sha224sum> program).\n\n=item C<sha256>\n\nCompute the SHA256 hash (using the C<sha256sum> program).\n\n=item C<sha384>\n\nCompute the SHA384 hash (using the C<sha384sum> program).\n\n=item C<sha512>\n\nCompute the SHA512 hash (using the C<sha512sum> program).\n\n=back\n\nThe checksum is returned as a printable string.");
  else
  if (strcasecmp (cmd, "tar_in") == 0 || strcasecmp (cmd, "tar-in") == 0)
    pod2text ("tar-in - unpack tarfile to directory", " tar-in <tarfile> <directory>\n\nThis command uploads and unpacks local file C<tarfile> (an\nI<uncompressed> tar file) into C<directory>.\n\nTo upload a compressed tarball, use C<tgz_in>.");
  else
  if (strcasecmp (cmd, "tar_out") == 0 || strcasecmp (cmd, "tar-out") == 0)
    pod2text ("tar-out - pack directory into tarfile", " tar-out <directory> <tarfile>\n\nThis command packs the contents of C<directory> and downloads\nit to local file C<tarfile>.\n\nTo download a compressed tarball, use C<tgz_out>.");
  else
  if (strcasecmp (cmd, "tgz_in") == 0 || strcasecmp (cmd, "tgz-in") == 0)
    pod2text ("tgz-in - unpack compressed tarball to directory", " tgz-in <tarball> <directory>\n\nThis command uploads and unpacks local file C<tarball> (a\nI<gzip compressed> tar file) into C<directory>.\n\nTo upload an uncompressed tarball, use C<tar_in>.");
  else
  if (strcasecmp (cmd, "tgz_out") == 0 || strcasecmp (cmd, "tgz-out") == 0)
    pod2text ("tgz-out - pack directory into compressed tarball", " tgz-out <directory> <tarball>\n\nThis command packs the contents of C<directory> and downloads\nit to local file C<tarball>.\n\nTo download an uncompressed tarball, use C<tar_out>.");
  else
  if (strcasecmp (cmd, "mount_ro") == 0 || strcasecmp (cmd, "mount-ro") == 0)
    pod2text ("mount-ro - mount a guest disk, read-only", " mount-ro <device> <mountpoint>\n\nThis is the same as the C<mount> command, but it\nmounts the filesystem with the read-only (I<-o ro>) flag.");
  else
  if (strcasecmp (cmd, "mount_options") == 0 || strcasecmp (cmd, "mount-options") == 0)
    pod2text ("mount-options - mount a guest disk with mount options", " mount-options <options> <device> <mountpoint>\n\nThis is the same as the C<mount> command, but it\nallows you to set the mount options as for the\nL<mount(8)> I<-o> flag.");
  else
  if (strcasecmp (cmd, "mount_vfs") == 0 || strcasecmp (cmd, "mount-vfs") == 0)
    pod2text ("mount-vfs - mount a guest disk with mount options and vfstype", " mount-vfs <options> <vfstype> <device> <mountpoint>\n\nThis is the same as the C<mount> command, but it\nallows you to set both the mount options and the vfstype\nas for the L<mount(8)> I<-o> and I<-t> flags.");
  else
  if (strcasecmp (cmd, "debug") == 0)
    pod2text ("debug - debugging and internals", " debug <subcmd> <extraargs>\n\nThe C<debug> command exposes some internals of\nC<guestfsd> (the guestfs daemon) that runs inside the\nqemu subprocess.\n\nThere is no comprehensive help for this command.  You have\nto look at the file C<daemon/debug.c> in the libguestfs source\nto find out what you can do.");
  else
  if (strcasecmp (cmd, "lvremove") == 0)
    pod2text ("lvremove - remove an LVM logical volume", " lvremove <device>\n\nRemove an LVM logical volume C<device>, where C<device> is\nthe path to the LV, such as C</dev/VG/LV>.\n\nYou can also remove all LVs in a volume group by specifying\nthe VG name, C</dev/VG>.");
  else
  if (strcasecmp (cmd, "vgremove") == 0)
    pod2text ("vgremove - remove an LVM volume group", " vgremove <vgname>\n\nRemove an LVM volume group C<vgname>, (for example C<VG>).\n\nThis also forcibly removes all logical volumes in the volume\ngroup (if any).");
  else
  if (strcasecmp (cmd, "pvremove") == 0)
    pod2text ("pvremove - remove an LVM physical volume", " pvremove <device>\n\nThis wipes a physical volume C<device> so that LVM will no longer\nrecognise it.\n\nThe implementation uses the C<pvremove> command which refuses to\nwipe physical volumes that contain any volume groups, so you have\nto remove those first.");
  else
  if (strcasecmp (cmd, "set_e2label") == 0 || strcasecmp (cmd, "set-e2label") == 0)
    pod2text ("set-e2label - set the ext2/3/4 filesystem label", " set-e2label <device> <label>\n\nThis sets the ext2/3/4 filesystem label of the filesystem on\nC<device> to C<label>.  Filesystem labels are limited to\n16 characters.\n\nYou can use either C<tune2fs_l> or C<get_e2label>\nto return the existing label on a filesystem.");
  else
  if (strcasecmp (cmd, "get_e2label") == 0 || strcasecmp (cmd, "get-e2label") == 0)
    pod2text ("get-e2label - get the ext2/3/4 filesystem label", " get-e2label <device>\n\nThis returns the ext2/3/4 filesystem label of the filesystem on\nC<device>.");
  else
  if (strcasecmp (cmd, "set_e2uuid") == 0 || strcasecmp (cmd, "set-e2uuid") == 0)
    pod2text ("set-e2uuid - set the ext2/3/4 filesystem UUID", " set-e2uuid <device> <uuid>\n\nThis sets the ext2/3/4 filesystem UUID of the filesystem on\nC<device> to C<uuid>.  The format of the UUID and alternatives\nsuch as C<clear>, C<random> and C<time> are described in the\nL<tune2fs(8)> manpage.\n\nYou can use either C<tune2fs_l> or C<get_e2uuid>\nto return the existing UUID of a filesystem.");
  else
  if (strcasecmp (cmd, "get_e2uuid") == 0 || strcasecmp (cmd, "get-e2uuid") == 0)
    pod2text ("get-e2uuid - get the ext2/3/4 filesystem UUID", " get-e2uuid <device>\n\nThis returns the ext2/3/4 filesystem UUID of the filesystem on\nC<device>.");
  else
  if (strcasecmp (cmd, "fsck") == 0)
    pod2text ("fsck - run the filesystem checker", " fsck <fstype> <device>\n\nThis runs the filesystem checker (fsck) on C<device> which\nshould have filesystem type C<fstype>.\n\nThe returned integer is the status.  See L<fsck(8)> for the\nlist of status codes from C<fsck>.\n\nNotes:\n\n=over 4\n\n=item *\n\nMultiple status codes can be summed together.\n\n=item *\n\nA non-zero return code can mean \"success\", for example if\nerrors have been corrected on the filesystem.\n\n=item *\n\nChecking or repairing NTFS volumes is not supported\n(by linux-ntfs).\n\n=back\n\nThis command is entirely equivalent to running C<fsck -a -t fstype device>.");
  else
  if (strcasecmp (cmd, "zero") == 0)
    pod2text ("zero - write zeroes to the device", " zero <device>\n\nThis command writes zeroes over the first few blocks of C<device>.\n\nHow many blocks are zeroed isn't specified (but it's I<not> enough\nto securely wipe the device).  It should be sufficient to remove\nany partition tables, filesystem superblocks and so on.");
  else
  if (strcasecmp (cmd, "grub_install") == 0 || strcasecmp (cmd, "grub-install") == 0)
    pod2text ("grub-install - install GRUB", " grub-install <root> <device>\n\nThis command installs GRUB (the Grand Unified Bootloader) on\nC<device>, with the root directory being C<root>.");
  else
  if (strcasecmp (cmd, "cp") == 0)
    pod2text ("cp - copy a file", " cp <src> <dest>\n\nThis copies a file from C<src> to C<dest> where C<dest> is\neither a destination filename or destination directory.");
  else
  if (strcasecmp (cmd, "cp_a") == 0 || strcasecmp (cmd, "cp-a") == 0)
    pod2text ("cp-a - copy a file or directory recursively", " cp-a <src> <dest>\n\nThis copies a file or directory from C<src> to C<dest>\nrecursively using the C<cp -a> command.");
  else
  if (strcasecmp (cmd, "mv") == 0)
    pod2text ("mv - move a file", " mv <src> <dest>\n\nThis moves a file from C<src> to C<dest> where C<dest> is\neither a destination filename or destination directory.");
  else
  if (strcasecmp (cmd, "drop_caches") == 0 || strcasecmp (cmd, "drop-caches") == 0)
    pod2text ("drop-caches - drop kernel page cache, dentries and inodes", " drop-caches <whattodrop>\n\nThis instructs the guest kernel to drop its page cache,\nand/or dentries and inode caches.  The parameter C<whattodrop>\ntells the kernel what precisely to drop, see\nL<http://linux-mm.org/Drop_Caches>\n\nSetting C<whattodrop> to 3 should drop everything.\n\nThis automatically calls L<sync(2)> before the operation,\nso that the maximum guest memory is freed.");
  else
  if (strcasecmp (cmd, "dmesg") == 0)
    pod2text ("dmesg - return kernel messages", " dmesg\n\nThis returns the kernel messages (C<dmesg> output) from\nthe guest kernel.  This is sometimes useful for extended\ndebugging of problems.\n\nAnother way to get the same information is to enable\nverbose messages with C<set_verbose> or by setting\nthe environment variable C<LIBGUESTFS_DEBUG=1> before\nrunning the program.");
  else
  if (strcasecmp (cmd, "ping_daemon") == 0 || strcasecmp (cmd, "ping-daemon") == 0)
    pod2text ("ping-daemon - ping the guest daemon", " ping-daemon\n\nThis is a test probe into the guestfs daemon running inside\nthe qemu subprocess.  Calling this function checks that the\ndaemon responds to the ping message, without affecting the daemon\nor attached block device(s) in any other way.");
  else
  if (strcasecmp (cmd, "equal") == 0)
    pod2text ("equal - test if two files have equal contents", " equal <file1> <file2>\n\nThis compares the two files C<file1> and C<file2> and returns\ntrue if their content is exactly equal, or false otherwise.\n\nThe external L<cmp(1)> program is used for the comparison.");
  else
  if (strcasecmp (cmd, "strings") == 0)
    pod2text ("strings - print the printable strings in a file", " strings <path>\n\nThis runs the L<strings(1)> command on a file and returns\nthe list of printable strings found.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "strings_e") == 0 || strcasecmp (cmd, "strings-e") == 0)
    pod2text ("strings-e - print the printable strings in a file", " strings-e <encoding> <path>\n\nThis is like the C<strings> command, but allows you to\nspecify the encoding.\n\nSee the L<strings(1)> manpage for the full list of encodings.\n\nCommonly useful encodings are C<l> (lower case L) which will\nshow strings inside Windows/x86 files.\n\nThe returned strings are transcoded to UTF-8.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "hexdump") == 0)
    pod2text ("hexdump - dump a file in hexadecimal", " hexdump <path>\n\nThis runs C<hexdump -C> on the given C<path>.  The result is\nthe human-readable, canonical hex dump of the file.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "zerofree") == 0)
    pod2text ("zerofree - zero unused inodes and disk blocks on ext2/3 filesystem", " zerofree <device>\n\nThis runs the I<zerofree> program on C<device>.  This program\nclaims to zero unused inodes and disk blocks on an ext2/3\nfilesystem, thus making it possible to compress the filesystem\nmore effectively.\n\nYou should B<not> run this program if the filesystem is\nmounted.\n\nIt is possible that using this program can damage the filesystem\nor data on the filesystem.");
  else
  if (strcasecmp (cmd, "pvresize") == 0)
    pod2text ("pvresize - resize an LVM physical volume", " pvresize <device>\n\nThis resizes (expands or shrinks) an existing LVM physical\nvolume to match the new size of the underlying device.");
  else
  if (strcasecmp (cmd, "sfdisk_N") == 0 || strcasecmp (cmd, "sfdisk-N") == 0)
    pod2text ("sfdisk-N - modify a single partition on a block device", " sfdisk-N <device> <n> <cyls> <heads> <sectors> <line>\n\nThis runs L<sfdisk(8)> option to modify just the single\npartition C<n> (note: C<n> counts from 1).\n\nFor other parameters, see C<sfdisk>.  You should usually\npass C<0> for the cyls/heads/sectors parameters.\n\nB<This command is dangerous.  Without careful use you\ncan easily destroy all your data>.");
  else
  if (strcasecmp (cmd, "sfdisk_l") == 0 || strcasecmp (cmd, "sfdisk-l") == 0)
    pod2text ("sfdisk-l - display the partition table", " sfdisk-l <device>\n\nThis displays the partition table on C<device>, in the\nhuman-readable output of the L<sfdisk(8)> command.  It is\nnot intended to be parsed.");
  else
  if (strcasecmp (cmd, "sfdisk_kernel_geometry") == 0 || strcasecmp (cmd, "sfdisk-kernel-geometry") == 0)
    pod2text ("sfdisk-kernel-geometry - display the kernel geometry", " sfdisk-kernel-geometry <device>\n\nThis displays the kernel's idea of the geometry of C<device>.\n\nThe result is in human-readable format, and not designed to\nbe parsed.");
  else
  if (strcasecmp (cmd, "sfdisk_disk_geometry") == 0 || strcasecmp (cmd, "sfdisk-disk-geometry") == 0)
    pod2text ("sfdisk-disk-geometry - display the disk geometry from the partition table", " sfdisk-disk-geometry <device>\n\nThis displays the disk geometry of C<device> read from the\npartition table.  Especially in the case where the underlying\nblock device has been resized, this can be different from the\nkernel's idea of the geometry (see C<sfdisk_kernel_geometry>).\n\nThe result is in human-readable format, and not designed to\nbe parsed.");
  else
  if (strcasecmp (cmd, "vg_activate_all") == 0 || strcasecmp (cmd, "vg-activate-all") == 0)
    pod2text ("vg-activate-all - activate or deactivate all volume groups", " vg-activate-all <activate>\n\nThis command activates or (if C<activate> is false) deactivates\nall logical volumes in all volume groups.\nIf activated, then they are made known to the\nkernel, ie. they appear as C</dev/mapper> devices.  If deactivated,\nthen those devices disappear.\n\nThis command is the same as running C<vgchange -a y|n>");
  else
  if (strcasecmp (cmd, "vg_activate") == 0 || strcasecmp (cmd, "vg-activate") == 0)
    pod2text ("vg-activate - activate or deactivate some volume groups", " vg-activate <activate> <volgroups>\n\nThis command activates or (if C<activate> is false) deactivates\nall logical volumes in the listed volume groups C<volgroups>.\nIf activated, then they are made known to the\nkernel, ie. they appear as C</dev/mapper> devices.  If deactivated,\nthen those devices disappear.\n\nThis command is the same as running C<vgchange -a y|n volgroups...>\n\nNote that if C<volgroups> is an empty list then B<all> volume groups\nare activated or deactivated.");
  else
  if (strcasecmp (cmd, "lvresize") == 0)
    pod2text ("lvresize - resize an LVM logical volume", " lvresize <device> <mbytes>\n\nThis resizes (expands or shrinks) an existing LVM logical\nvolume to C<mbytes>.  When reducing, data in the reduced part\nis lost.");
  else
  if (strcasecmp (cmd, "resize2fs") == 0)
    pod2text ("resize2fs - resize an ext2/ext3 filesystem", " resize2fs <device>\n\nThis resizes an ext2 or ext3 filesystem to match the size of\nthe underlying device.\n\nI<Note:> It is sometimes required that you run C<e2fsck_f>\non the C<device> before calling this command.  For unknown reasons\nC<resize2fs> sometimes gives an error about this and sometimes not.\nIn any case, it is always safe to call C<e2fsck_f> before\ncalling this function.");
  else
  if (strcasecmp (cmd, "find") == 0)
    pod2text ("find - find all files and directories", " find <directory>\n\nThis command lists out all files and directories, recursively,\nstarting at C<directory>.  It is essentially equivalent to\nrunning the shell command C<find directory -print> but some\npost-processing happens on the output, described below.\n\nThis returns a list of strings I<without any prefix>.  Thus\nif the directory structure was:\n\n /tmp/a\n /tmp/b\n /tmp/c/d\n\nthen the returned list from C<find> C</tmp> would be\n4 elements:\n\n a\n b\n c\n c/d\n\nIf C<directory> is not a directory, then this command returns\nan error.\n\nThe returned list is sorted.");
  else
  if (strcasecmp (cmd, "e2fsck_f") == 0 || strcasecmp (cmd, "e2fsck-f") == 0)
    pod2text ("e2fsck-f - check an ext2/ext3 filesystem", " e2fsck-f <device>\n\nThis runs C<e2fsck -p -f device>, ie. runs the ext2/ext3\nfilesystem checker on C<device>, noninteractively (C<-p>),\neven if the filesystem appears to be clean (C<-f>).\n\nThis command is only needed because of C<resize2fs>\n(q.v.).  Normally you should use C<fsck>.");
  else
  if (strcasecmp (cmd, "sleep") == 0)
    pod2text ("sleep - sleep for some seconds", " sleep <secs>\n\nSleep for C<secs> seconds.");
  else
    display_builtin_command (cmd);
}

static void print_pv (struct guestfs_lvm_pv *pv)
{
  int i;

  printf ("pv_name: %s\n", pv->pv_name);
  printf ("pv_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", pv->pv_uuid[i]);
  printf ("\n");
  printf ("pv_fmt: %s\n", pv->pv_fmt);
  printf ("pv_size: %" PRIu64 "\n", pv->pv_size);
  printf ("dev_size: %" PRIu64 "\n", pv->dev_size);
  printf ("pv_free: %" PRIu64 "\n", pv->pv_free);
  printf ("pv_used: %" PRIu64 "\n", pv->pv_used);
  printf ("pv_attr: %s\n", pv->pv_attr);
  printf ("pv_pe_count: %" PRIi64 "\n", pv->pv_pe_count);
  printf ("pv_pe_alloc_count: %" PRIi64 "\n", pv->pv_pe_alloc_count);
  printf ("pv_tags: %s\n", pv->pv_tags);
  printf ("pe_start: %" PRIu64 "\n", pv->pe_start);
  printf ("pv_mda_count: %" PRIi64 "\n", pv->pv_mda_count);
  printf ("pv_mda_free: %" PRIu64 "\n", pv->pv_mda_free);
}

static void print_pv_list (struct guestfs_lvm_pv_list *pvs)
{
  int i;

  for (i = 0; i < pvs->len; ++i)
    print_pv (&pvs->val[i]);
}

static void print_vg (struct guestfs_lvm_vg *vg)
{
  int i;

  printf ("vg_name: %s\n", vg->vg_name);
  printf ("vg_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", vg->vg_uuid[i]);
  printf ("\n");
  printf ("vg_fmt: %s\n", vg->vg_fmt);
  printf ("vg_attr: %s\n", vg->vg_attr);
  printf ("vg_size: %" PRIu64 "\n", vg->vg_size);
  printf ("vg_free: %" PRIu64 "\n", vg->vg_free);
  printf ("vg_sysid: %s\n", vg->vg_sysid);
  printf ("vg_extent_size: %" PRIu64 "\n", vg->vg_extent_size);
  printf ("vg_extent_count: %" PRIi64 "\n", vg->vg_extent_count);
  printf ("vg_free_count: %" PRIi64 "\n", vg->vg_free_count);
  printf ("max_lv: %" PRIi64 "\n", vg->max_lv);
  printf ("max_pv: %" PRIi64 "\n", vg->max_pv);
  printf ("pv_count: %" PRIi64 "\n", vg->pv_count);
  printf ("lv_count: %" PRIi64 "\n", vg->lv_count);
  printf ("snap_count: %" PRIi64 "\n", vg->snap_count);
  printf ("vg_seqno: %" PRIi64 "\n", vg->vg_seqno);
  printf ("vg_tags: %s\n", vg->vg_tags);
  printf ("vg_mda_count: %" PRIi64 "\n", vg->vg_mda_count);
  printf ("vg_mda_free: %" PRIu64 "\n", vg->vg_mda_free);
}

static void print_vg_list (struct guestfs_lvm_vg_list *vgs)
{
  int i;

  for (i = 0; i < vgs->len; ++i)
    print_vg (&vgs->val[i]);
}

static void print_lv (struct guestfs_lvm_lv *lv)
{
  int i;

  printf ("lv_name: %s\n", lv->lv_name);
  printf ("lv_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", lv->lv_uuid[i]);
  printf ("\n");
  printf ("lv_attr: %s\n", lv->lv_attr);
  printf ("lv_major: %" PRIi64 "\n", lv->lv_major);
  printf ("lv_minor: %" PRIi64 "\n", lv->lv_minor);
  printf ("lv_kernel_major: %" PRIi64 "\n", lv->lv_kernel_major);
  printf ("lv_kernel_minor: %" PRIi64 "\n", lv->lv_kernel_minor);
  printf ("lv_size: %" PRIu64 "\n", lv->lv_size);
  printf ("seg_count: %" PRIi64 "\n", lv->seg_count);
  printf ("origin: %s\n", lv->origin);
  if (lv->snap_percent >= 0) printf ("snap_percent: %g %%\n", lv->snap_percent);
  else printf ("snap_percent: \n");
  if (lv->copy_percent >= 0) printf ("copy_percent: %g %%\n", lv->copy_percent);
  else printf ("copy_percent: \n");
  printf ("move_pv: %s\n", lv->move_pv);
  printf ("lv_tags: %s\n", lv->lv_tags);
  printf ("mirror_log: %s\n", lv->mirror_log);
  printf ("modules: %s\n", lv->modules);
}

static void print_lv_list (struct guestfs_lvm_lv_list *lvs)
{
  int i;

  for (i = 0; i < lvs->len; ++i)
    print_lv (&lvs->val[i]);
}

static void print_stat (struct guestfs_stat *stat)
{
  printf ("dev: %" PRIi64 "\n", stat->dev);
  printf ("ino: %" PRIi64 "\n", stat->ino);
  printf ("mode: %" PRIi64 "\n", stat->mode);
  printf ("nlink: %" PRIi64 "\n", stat->nlink);
  printf ("uid: %" PRIi64 "\n", stat->uid);
  printf ("gid: %" PRIi64 "\n", stat->gid);
  printf ("rdev: %" PRIi64 "\n", stat->rdev);
  printf ("size: %" PRIi64 "\n", stat->size);
  printf ("blksize: %" PRIi64 "\n", stat->blksize);
  printf ("blocks: %" PRIi64 "\n", stat->blocks);
  printf ("atime: %" PRIi64 "\n", stat->atime);
  printf ("mtime: %" PRIi64 "\n", stat->mtime);
  printf ("ctime: %" PRIi64 "\n", stat->ctime);
}

static void print_statvfs (struct guestfs_statvfs *statvfs)
{
  printf ("bsize: %" PRIi64 "\n", statvfs->bsize);
  printf ("frsize: %" PRIi64 "\n", statvfs->frsize);
  printf ("blocks: %" PRIi64 "\n", statvfs->blocks);
  printf ("bfree: %" PRIi64 "\n", statvfs->bfree);
  printf ("bavail: %" PRIi64 "\n", statvfs->bavail);
  printf ("files: %" PRIi64 "\n", statvfs->files);
  printf ("ffree: %" PRIi64 "\n", statvfs->ffree);
  printf ("favail: %" PRIi64 "\n", statvfs->favail);
  printf ("fsid: %" PRIi64 "\n", statvfs->fsid);
  printf ("flag: %" PRIi64 "\n", statvfs->flag);
  printf ("namemax: %" PRIi64 "\n", statvfs->namemax);
}

static int run_launch (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = launch (g);
  return r;
}

static int run_kill_subprocess (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_kill_subprocess (g);
  return r;
}

static int run_add_drive (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *filename;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  filename = argv[0];
  r = guestfs_add_drive (g, filename);
  return r;
}

static int run_add_cdrom (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *filename;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  filename = argv[0];
  r = guestfs_add_cdrom (g, filename);
  return r;
}

static int run_add_drive_ro (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *filename;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  filename = argv[0];
  r = guestfs_add_drive_ro (g, filename);
  return r;
}

static int run_config (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *qemuparam;
  const char *qemuvalue;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  qemuparam = argv[0];
  qemuvalue = strcmp (argv[1], "") != 0 ? argv[1] : NULL;
  r = guestfs_config (g, qemuparam, qemuvalue);
  return r;
}

static int run_set_qemu (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *qemu;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  qemu = argv[0];
  r = guestfs_set_qemu (g, qemu);
  return r;
}

static int run_get_qemu (const char *cmd, int argc, char *argv[])
{
  const char *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_qemu (g);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  return 0;
}

static int run_set_path (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_set_path (g, path);
  return r;
}

static int run_get_path (const char *cmd, int argc, char *argv[])
{
  const char *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_path (g);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  return 0;
}

static int run_set_append (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *append;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  append = argv[0];
  r = guestfs_set_append (g, append);
  return r;
}

static int run_get_append (const char *cmd, int argc, char *argv[])
{
  const char *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_append (g);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  return 0;
}

static int run_set_autosync (const char *cmd, int argc, char *argv[])
{
  int r;
  int autosync;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  autosync = is_true (argv[0]) ? 1 : 0;
  r = guestfs_set_autosync (g, autosync);
  return r;
}

static int run_get_autosync (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_autosync (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_set_verbose (const char *cmd, int argc, char *argv[])
{
  int r;
  int verbose;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  verbose = is_true (argv[0]) ? 1 : 0;
  r = guestfs_set_verbose (g, verbose);
  return r;
}

static int run_get_verbose (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_verbose (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_is_ready (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_is_ready (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_is_config (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_is_config (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_is_launching (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_is_launching (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_is_busy (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_is_busy (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_get_state (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_state (g);
  if (r == -1) return -1;
  printf ("%d\n", r);
  return 0;
}

static int run_mount (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *mountpoint;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  mountpoint = argv[1];
  r = guestfs_mount (g, device, mountpoint);
  return r;
}

static int run_sync (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_sync (g);
  return r;
}

static int run_touch (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_touch (g, path);
  return r;
}

static int run_cat (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_cat (g, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_ll (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_ll (g, directory);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_ls (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_ls (g, directory);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_list_devices (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_list_devices (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_list_partitions (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_list_partitions (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_pvs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_pvs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_vgs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_vgs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_lvs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_pvs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_pv_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_pvs_full (g);
  if (r == NULL) return -1;
  print_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  return 0;
}

static int run_vgs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_vg_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_vgs_full (g);
  if (r == NULL) return -1;
  print_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  return 0;
}

static int run_lvs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_lv_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvs_full (g);
  if (r == NULL) return -1;
  print_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  return 0;
}

static int run_read_lines (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_read_lines (g, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_aug_init (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *root;
  int flags;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  root = argv[0];
  flags = atoi (argv[1]);
  r = guestfs_aug_init (g, root, flags);
  return r;
}

static int run_aug_close (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_aug_close (g);
  return r;
}

static int run_aug_defvar (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *name;
  const char *expr;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  name = argv[0];
  expr = strcmp (argv[1], "") != 0 ? argv[1] : NULL;
  r = guestfs_aug_defvar (g, name, expr);
  if (r == -1) return -1;
  printf ("%d\n", r);
  return 0;
}

static int run_aug_defnode (const char *cmd, int argc, char *argv[])
{
  struct guestfs_int_bool *r;
  const char *name;
  const char *expr;
  const char *val;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  name = argv[0];
  expr = argv[1];
  val = argv[2];
  r = guestfs_aug_defnode (g, name, expr, val);
  if (r == NULL) return -1;
  printf ("%d, %s\n", r->i,
    r->b ? "true" : "false");
  guestfs_free_int_bool (r);
  return 0;
}

static int run_aug_get (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_get (g, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_aug_set (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  const char *val;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  val = argv[1];
  r = guestfs_aug_set (g, path, val);
  return r;
}

static int run_aug_insert (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  const char *label;
  int before;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  label = argv[1];
  before = is_true (argv[2]) ? 1 : 0;
  r = guestfs_aug_insert (g, path, label, before);
  return r;
}

static int run_aug_rm (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_rm (g, path);
  if (r == -1) return -1;
  printf ("%d\n", r);
  return 0;
}

static int run_aug_mv (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *src;
  const char *dest;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  src = argv[0];
  dest = argv[1];
  r = guestfs_aug_mv (g, src, dest);
  return r;
}

static int run_aug_match (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_match (g, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_aug_save (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_aug_save (g);
  return r;
}

static int run_aug_load (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_aug_load (g);
  return r;
}

static int run_aug_ls (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_ls (g, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_rm (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_rm (g, path);
  return r;
}

static int run_rmdir (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_rmdir (g, path);
  return r;
}

static int run_rm_rf (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_rm_rf (g, path);
  return r;
}

static int run_mkdir (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_mkdir (g, path);
  return r;
}

static int run_mkdir_p (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_mkdir_p (g, path);
  return r;
}

static int run_chmod (const char *cmd, int argc, char *argv[])
{
  int r;
  int mode;
  const char *path;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  mode = atoi (argv[0]);
  path = argv[1];
  r = guestfs_chmod (g, mode, path);
  return r;
}

static int run_chown (const char *cmd, int argc, char *argv[])
{
  int r;
  int owner;
  int group;
  const char *path;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  owner = atoi (argv[0]);
  group = atoi (argv[1]);
  path = argv[2];
  r = guestfs_chown (g, owner, group, path);
  return r;
}

static int run_exists (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_exists (g, path);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_is_file (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_is_file (g, path);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_is_dir (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_is_dir (g, path);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_pvcreate (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_pvcreate (g, device);
  return r;
}

static int run_vgcreate (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *volgroup;
  char **physvols;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  volgroup = argv[0];
  physvols = parse_string_list (argv[1]);
  r = guestfs_vgcreate (g, volgroup, physvols);
  return r;
}

static int run_lvcreate (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *logvol;
  const char *volgroup;
  int mbytes;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  logvol = argv[0];
  volgroup = argv[1];
  mbytes = atoi (argv[2]);
  r = guestfs_lvcreate (g, logvol, volgroup, mbytes);
  return r;
}

static int run_mkfs (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *fstype;
  const char *device;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  fstype = argv[0];
  device = argv[1];
  r = guestfs_mkfs (g, fstype, device);
  return r;
}

static int run_sfdisk (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  int cyls;
  int heads;
  int sectors;
  char **lines;
  if (argc != 5) {
    fprintf (stderr, "%s should have 5 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  cyls = atoi (argv[1]);
  heads = atoi (argv[2]);
  sectors = atoi (argv[3]);
  lines = parse_string_list (argv[4]);
  r = guestfs_sfdisk (g, device, cyls, heads, sectors, lines);
  return r;
}

static int run_write_file (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  const char *content;
  int size;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  content = argv[1];
  size = atoi (argv[2]);
  r = guestfs_write_file (g, path, content, size);
  return r;
}

static int run_umount (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *pathordevice;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  pathordevice = argv[0];
  r = guestfs_umount (g, pathordevice);
  return r;
}

static int run_mounts (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_mounts (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_umount_all (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_umount_all (g);
  return r;
}

static int run_lvm_remove_all (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvm_remove_all (g);
  return r;
}

static int run_file (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_file (g, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_command (const char *cmd, int argc, char *argv[])
{
  char *r;
  char **arguments;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  arguments = parse_string_list (argv[0]);
  r = guestfs_command (g, arguments);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_command_lines (const char *cmd, int argc, char *argv[])
{
  char **r;
  char **arguments;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  arguments = parse_string_list (argv[0]);
  r = guestfs_command_lines (g, arguments);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_stat (const char *cmd, int argc, char *argv[])
{
  struct guestfs_stat *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_stat (g, path);
  if (r == NULL) return -1;
  print_stat (r);
  free (r);
  return 0;
}

static int run_lstat (const char *cmd, int argc, char *argv[])
{
  struct guestfs_stat *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_lstat (g, path);
  if (r == NULL) return -1;
  print_stat (r);
  free (r);
  return 0;
}

static int run_statvfs (const char *cmd, int argc, char *argv[])
{
  struct guestfs_statvfs *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_statvfs (g, path);
  if (r == NULL) return -1;
  print_statvfs (r);
  free (r);
  return 0;
}

static int run_tune2fs_l (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_tune2fs_l (g, device);
  if (r == NULL) return -1;
  print_table (r);
  free_strings (r);
  return 0;
}

static int run_blockdev_setro (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_setro (g, device);
  return r;
}

static int run_blockdev_setrw (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_setrw (g, device);
  return r;
}

static int run_blockdev_getro (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_getro (g, device);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_blockdev_getss (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_getss (g, device);
  if (r == -1) return -1;
  printf ("%d\n", r);
  return 0;
}

static int run_blockdev_getbsz (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_getbsz (g, device);
  if (r == -1) return -1;
  printf ("%d\n", r);
  return 0;
}

static int run_blockdev_setbsz (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  int blocksize;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  blocksize = atoi (argv[1]);
  r = guestfs_blockdev_setbsz (g, device, blocksize);
  return r;
}

static int run_blockdev_getsz (const char *cmd, int argc, char *argv[])
{
  int64_t r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_getsz (g, device);
  if (r == -1) return -1;
  printf ("%" PRIi64 "\n", r);
  return 0;
}

static int run_blockdev_getsize64 (const char *cmd, int argc, char *argv[])
{
  int64_t r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_getsize64 (g, device);
  if (r == -1) return -1;
  printf ("%" PRIi64 "\n", r);
  return 0;
}

static int run_blockdev_flushbufs (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_flushbufs (g, device);
  return r;
}

static int run_blockdev_rereadpt (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_blockdev_rereadpt (g, device);
  return r;
}

static int run_upload (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *filename;
  const char *remotefilename;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  filename = strcmp (argv[0], "-") != 0 ? argv[0] : "/dev/stdin";
  remotefilename = argv[1];
  r = guestfs_upload (g, filename, remotefilename);
  return r;
}

static int run_download (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *remotefilename;
  const char *filename;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  remotefilename = argv[0];
  filename = strcmp (argv[1], "-") != 0 ? argv[1] : "/dev/stdout";
  r = guestfs_download (g, remotefilename, filename);
  return r;
}

static int run_checksum (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *csumtype;
  const char *path;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  csumtype = argv[0];
  path = argv[1];
  r = guestfs_checksum (g, csumtype, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_tar_in (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *tarfile;
  const char *directory;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  tarfile = strcmp (argv[0], "-") != 0 ? argv[0] : "/dev/stdin";
  directory = argv[1];
  r = guestfs_tar_in (g, tarfile, directory);
  return r;
}

static int run_tar_out (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *directory;
  const char *tarfile;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  tarfile = strcmp (argv[1], "-") != 0 ? argv[1] : "/dev/stdout";
  r = guestfs_tar_out (g, directory, tarfile);
  return r;
}

static int run_tgz_in (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *tarball;
  const char *directory;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  tarball = strcmp (argv[0], "-") != 0 ? argv[0] : "/dev/stdin";
  directory = argv[1];
  r = guestfs_tgz_in (g, tarball, directory);
  return r;
}

static int run_tgz_out (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *directory;
  const char *tarball;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  tarball = strcmp (argv[1], "-") != 0 ? argv[1] : "/dev/stdout";
  r = guestfs_tgz_out (g, directory, tarball);
  return r;
}

static int run_mount_ro (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *mountpoint;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  mountpoint = argv[1];
  r = guestfs_mount_ro (g, device, mountpoint);
  return r;
}

static int run_mount_options (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *options;
  const char *device;
  const char *mountpoint;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  options = argv[0];
  device = argv[1];
  mountpoint = argv[2];
  r = guestfs_mount_options (g, options, device, mountpoint);
  return r;
}

static int run_mount_vfs (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *options;
  const char *vfstype;
  const char *device;
  const char *mountpoint;
  if (argc != 4) {
    fprintf (stderr, "%s should have 4 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  options = argv[0];
  vfstype = argv[1];
  device = argv[2];
  mountpoint = argv[3];
  r = guestfs_mount_vfs (g, options, vfstype, device, mountpoint);
  return r;
}

static int run_debug (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *subcmd;
  char **extraargs;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  subcmd = argv[0];
  extraargs = parse_string_list (argv[1]);
  r = guestfs_debug (g, subcmd, extraargs);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_lvremove (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_lvremove (g, device);
  return r;
}

static int run_vgremove (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *vgname;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  vgname = argv[0];
  r = guestfs_vgremove (g, vgname);
  return r;
}

static int run_pvremove (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_pvremove (g, device);
  return r;
}

static int run_set_e2label (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *label;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  label = argv[1];
  r = guestfs_set_e2label (g, device, label);
  return r;
}

static int run_get_e2label (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_get_e2label (g, device);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_set_e2uuid (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *uuid;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  uuid = argv[1];
  r = guestfs_set_e2uuid (g, device, uuid);
  return r;
}

static int run_get_e2uuid (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_get_e2uuid (g, device);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_fsck (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *fstype;
  const char *device;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  fstype = argv[0];
  device = argv[1];
  r = guestfs_fsck (g, fstype, device);
  if (r == -1) return -1;
  printf ("%d\n", r);
  return 0;
}

static int run_zero (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_zero (g, device);
  return r;
}

static int run_grub_install (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *root;
  const char *device;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  root = argv[0];
  device = argv[1];
  r = guestfs_grub_install (g, root, device);
  return r;
}

static int run_cp (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *src;
  const char *dest;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  src = argv[0];
  dest = argv[1];
  r = guestfs_cp (g, src, dest);
  return r;
}

static int run_cp_a (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *src;
  const char *dest;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  src = argv[0];
  dest = argv[1];
  r = guestfs_cp_a (g, src, dest);
  return r;
}

static int run_mv (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *src;
  const char *dest;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  src = argv[0];
  dest = argv[1];
  r = guestfs_mv (g, src, dest);
  return r;
}

static int run_drop_caches (const char *cmd, int argc, char *argv[])
{
  int r;
  int whattodrop;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  whattodrop = atoi (argv[0]);
  r = guestfs_drop_caches (g, whattodrop);
  return r;
}

static int run_dmesg (const char *cmd, int argc, char *argv[])
{
  char *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_dmesg (g);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_ping_daemon (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_ping_daemon (g);
  return r;
}

static int run_equal (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *file1;
  const char *file2;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  file1 = argv[0];
  file2 = argv[1];
  r = guestfs_equal (g, file1, file2);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_strings (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_strings (g, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_strings_e (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *encoding;
  const char *path;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  encoding = argv[0];
  path = argv[1];
  r = guestfs_strings_e (g, encoding, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_hexdump (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_hexdump (g, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_zerofree (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_zerofree (g, device);
  return r;
}

static int run_pvresize (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_pvresize (g, device);
  return r;
}

static int run_sfdisk_N (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  int n;
  int cyls;
  int heads;
  int sectors;
  const char *line;
  if (argc != 6) {
    fprintf (stderr, "%s should have 6 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  n = atoi (argv[1]);
  cyls = atoi (argv[2]);
  heads = atoi (argv[3]);
  sectors = atoi (argv[4]);
  line = argv[5];
  r = guestfs_sfdisk_N (g, device, n, cyls, heads, sectors, line);
  return r;
}

static int run_sfdisk_l (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_sfdisk_l (g, device);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_sfdisk_kernel_geometry (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_sfdisk_kernel_geometry (g, device);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_sfdisk_disk_geometry (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_sfdisk_disk_geometry (g, device);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_vg_activate_all (const char *cmd, int argc, char *argv[])
{
  int r;
  int activate;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  activate = is_true (argv[0]) ? 1 : 0;
  r = guestfs_vg_activate_all (g, activate);
  return r;
}

static int run_vg_activate (const char *cmd, int argc, char *argv[])
{
  int r;
  int activate;
  char **volgroups;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  activate = is_true (argv[0]) ? 1 : 0;
  volgroups = parse_string_list (argv[1]);
  r = guestfs_vg_activate (g, activate, volgroups);
  return r;
}

static int run_lvresize (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  int mbytes;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  mbytes = atoi (argv[1]);
  r = guestfs_lvresize (g, device, mbytes);
  return r;
}

static int run_resize2fs (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_resize2fs (g, device);
  return r;
}

static int run_find (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_find (g, directory);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_e2fsck_f (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  r = guestfs_e2fsck_f (g, device);
  return r;
}

static int run_sleep (const char *cmd, int argc, char *argv[])
{
  int r;
  int secs;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  secs = atoi (argv[0]);
  r = guestfs_sleep (g, secs);
  return r;
}

int run_action (const char *cmd, int argc, char *argv[])
{
  if (strcasecmp (cmd, "launch") == 0 || strcasecmp (cmd, "run") == 0)
    return run_launch (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "kill_subprocess") == 0 || strcasecmp (cmd, "kill-subprocess") == 0)
    return run_kill_subprocess (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "add_drive") == 0 || strcasecmp (cmd, "add-drive") == 0 || strcasecmp (cmd, "add") == 0)
    return run_add_drive (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "add_cdrom") == 0 || strcasecmp (cmd, "add-cdrom") == 0 || strcasecmp (cmd, "cdrom") == 0)
    return run_add_cdrom (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "add_drive_ro") == 0 || strcasecmp (cmd, "add-drive-ro") == 0 || strcasecmp (cmd, "add-ro") == 0)
    return run_add_drive_ro (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "config") == 0)
    return run_config (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_qemu") == 0 || strcasecmp (cmd, "set-qemu") == 0 || strcasecmp (cmd, "qemu") == 0)
    return run_set_qemu (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_qemu") == 0 || strcasecmp (cmd, "get-qemu") == 0)
    return run_get_qemu (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_path") == 0 || strcasecmp (cmd, "set-path") == 0 || strcasecmp (cmd, "path") == 0)
    return run_set_path (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_path") == 0 || strcasecmp (cmd, "get-path") == 0)
    return run_get_path (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_append") == 0 || strcasecmp (cmd, "set-append") == 0 || strcasecmp (cmd, "append") == 0)
    return run_set_append (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_append") == 0 || strcasecmp (cmd, "get-append") == 0)
    return run_get_append (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_autosync") == 0 || strcasecmp (cmd, "set-autosync") == 0 || strcasecmp (cmd, "autosync") == 0)
    return run_set_autosync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_autosync") == 0 || strcasecmp (cmd, "get-autosync") == 0)
    return run_get_autosync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_verbose") == 0 || strcasecmp (cmd, "set-verbose") == 0 || strcasecmp (cmd, "verbose") == 0)
    return run_set_verbose (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_verbose") == 0 || strcasecmp (cmd, "get-verbose") == 0)
    return run_get_verbose (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "is_ready") == 0 || strcasecmp (cmd, "is-ready") == 0)
    return run_is_ready (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "is_config") == 0 || strcasecmp (cmd, "is-config") == 0)
    return run_is_config (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "is_launching") == 0 || strcasecmp (cmd, "is-launching") == 0)
    return run_is_launching (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "is_busy") == 0 || strcasecmp (cmd, "is-busy") == 0)
    return run_is_busy (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_state") == 0 || strcasecmp (cmd, "get-state") == 0)
    return run_get_state (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mount") == 0)
    return run_mount (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sync") == 0)
    return run_sync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "touch") == 0)
    return run_touch (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "cat") == 0)
    return run_cat (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ll") == 0)
    return run_ll (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ls") == 0)
    return run_ls (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "list_devices") == 0 || strcasecmp (cmd, "list-devices") == 0)
    return run_list_devices (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "list_partitions") == 0 || strcasecmp (cmd, "list-partitions") == 0)
    return run_list_partitions (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvs") == 0)
    return run_pvs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgs") == 0)
    return run_vgs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvs") == 0)
    return run_lvs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvs_full") == 0 || strcasecmp (cmd, "pvs-full") == 0)
    return run_pvs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgs_full") == 0 || strcasecmp (cmd, "vgs-full") == 0)
    return run_vgs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvs_full") == 0 || strcasecmp (cmd, "lvs-full") == 0)
    return run_lvs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "read_lines") == 0 || strcasecmp (cmd, "read-lines") == 0)
    return run_read_lines (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_init") == 0 || strcasecmp (cmd, "aug-init") == 0)
    return run_aug_init (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_close") == 0 || strcasecmp (cmd, "aug-close") == 0)
    return run_aug_close (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_defvar") == 0 || strcasecmp (cmd, "aug-defvar") == 0)
    return run_aug_defvar (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_defnode") == 0 || strcasecmp (cmd, "aug-defnode") == 0)
    return run_aug_defnode (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_get") == 0 || strcasecmp (cmd, "aug-get") == 0)
    return run_aug_get (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_set") == 0 || strcasecmp (cmd, "aug-set") == 0)
    return run_aug_set (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_insert") == 0 || strcasecmp (cmd, "aug-insert") == 0)
    return run_aug_insert (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_rm") == 0 || strcasecmp (cmd, "aug-rm") == 0)
    return run_aug_rm (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_mv") == 0 || strcasecmp (cmd, "aug-mv") == 0)
    return run_aug_mv (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_match") == 0 || strcasecmp (cmd, "aug-match") == 0)
    return run_aug_match (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_save") == 0 || strcasecmp (cmd, "aug-save") == 0)
    return run_aug_save (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_load") == 0 || strcasecmp (cmd, "aug-load") == 0)
    return run_aug_load (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_ls") == 0 || strcasecmp (cmd, "aug-ls") == 0)
    return run_aug_ls (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "rm") == 0)
    return run_rm (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "rmdir") == 0)
    return run_rmdir (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "rm_rf") == 0 || strcasecmp (cmd, "rm-rf") == 0)
    return run_rm_rf (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mkdir") == 0)
    return run_mkdir (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mkdir_p") == 0 || strcasecmp (cmd, "mkdir-p") == 0)
    return run_mkdir_p (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "chmod") == 0)
    return run_chmod (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "chown") == 0)
    return run_chown (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "exists") == 0)
    return run_exists (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "is_file") == 0 || strcasecmp (cmd, "is-file") == 0)
    return run_is_file (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "is_dir") == 0 || strcasecmp (cmd, "is-dir") == 0)
    return run_is_dir (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvcreate") == 0)
    return run_pvcreate (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgcreate") == 0)
    return run_vgcreate (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvcreate") == 0)
    return run_lvcreate (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mkfs") == 0)
    return run_mkfs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sfdisk") == 0)
    return run_sfdisk (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "write_file") == 0 || strcasecmp (cmd, "write-file") == 0)
    return run_write_file (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "umount") == 0 || strcasecmp (cmd, "unmount") == 0)
    return run_umount (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mounts") == 0)
    return run_mounts (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "umount_all") == 0 || strcasecmp (cmd, "umount-all") == 0 || strcasecmp (cmd, "unmount-all") == 0)
    return run_umount_all (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvm_remove_all") == 0 || strcasecmp (cmd, "lvm-remove-all") == 0)
    return run_lvm_remove_all (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "file") == 0)
    return run_file (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "command") == 0)
    return run_command (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "command_lines") == 0 || strcasecmp (cmd, "command-lines") == 0)
    return run_command_lines (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "stat") == 0)
    return run_stat (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lstat") == 0)
    return run_lstat (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "statvfs") == 0)
    return run_statvfs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "tune2fs_l") == 0 || strcasecmp (cmd, "tune2fs-l") == 0)
    return run_tune2fs_l (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_setro") == 0 || strcasecmp (cmd, "blockdev-setro") == 0)
    return run_blockdev_setro (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_setrw") == 0 || strcasecmp (cmd, "blockdev-setrw") == 0)
    return run_blockdev_setrw (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_getro") == 0 || strcasecmp (cmd, "blockdev-getro") == 0)
    return run_blockdev_getro (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_getss") == 0 || strcasecmp (cmd, "blockdev-getss") == 0)
    return run_blockdev_getss (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_getbsz") == 0 || strcasecmp (cmd, "blockdev-getbsz") == 0)
    return run_blockdev_getbsz (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_setbsz") == 0 || strcasecmp (cmd, "blockdev-setbsz") == 0)
    return run_blockdev_setbsz (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_getsz") == 0 || strcasecmp (cmd, "blockdev-getsz") == 0)
    return run_blockdev_getsz (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_getsize64") == 0 || strcasecmp (cmd, "blockdev-getsize64") == 0)
    return run_blockdev_getsize64 (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_flushbufs") == 0 || strcasecmp (cmd, "blockdev-flushbufs") == 0)
    return run_blockdev_flushbufs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "blockdev_rereadpt") == 0 || strcasecmp (cmd, "blockdev-rereadpt") == 0)
    return run_blockdev_rereadpt (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "upload") == 0)
    return run_upload (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "download") == 0)
    return run_download (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "checksum") == 0)
    return run_checksum (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "tar_in") == 0 || strcasecmp (cmd, "tar-in") == 0)
    return run_tar_in (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "tar_out") == 0 || strcasecmp (cmd, "tar-out") == 0)
    return run_tar_out (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "tgz_in") == 0 || strcasecmp (cmd, "tgz-in") == 0)
    return run_tgz_in (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "tgz_out") == 0 || strcasecmp (cmd, "tgz-out") == 0)
    return run_tgz_out (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mount_ro") == 0 || strcasecmp (cmd, "mount-ro") == 0)
    return run_mount_ro (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mount_options") == 0 || strcasecmp (cmd, "mount-options") == 0)
    return run_mount_options (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mount_vfs") == 0 || strcasecmp (cmd, "mount-vfs") == 0)
    return run_mount_vfs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "debug") == 0)
    return run_debug (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvremove") == 0)
    return run_lvremove (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgremove") == 0)
    return run_vgremove (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvremove") == 0)
    return run_pvremove (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_e2label") == 0 || strcasecmp (cmd, "set-e2label") == 0)
    return run_set_e2label (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_e2label") == 0 || strcasecmp (cmd, "get-e2label") == 0)
    return run_get_e2label (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_e2uuid") == 0 || strcasecmp (cmd, "set-e2uuid") == 0)
    return run_set_e2uuid (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_e2uuid") == 0 || strcasecmp (cmd, "get-e2uuid") == 0)
    return run_get_e2uuid (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "fsck") == 0)
    return run_fsck (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "zero") == 0)
    return run_zero (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "grub_install") == 0 || strcasecmp (cmd, "grub-install") == 0)
    return run_grub_install (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "cp") == 0)
    return run_cp (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "cp_a") == 0 || strcasecmp (cmd, "cp-a") == 0)
    return run_cp_a (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mv") == 0)
    return run_mv (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "drop_caches") == 0 || strcasecmp (cmd, "drop-caches") == 0)
    return run_drop_caches (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "dmesg") == 0)
    return run_dmesg (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ping_daemon") == 0 || strcasecmp (cmd, "ping-daemon") == 0)
    return run_ping_daemon (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "equal") == 0)
    return run_equal (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "strings") == 0)
    return run_strings (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "strings_e") == 0 || strcasecmp (cmd, "strings-e") == 0)
    return run_strings_e (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "hexdump") == 0)
    return run_hexdump (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "zerofree") == 0)
    return run_zerofree (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvresize") == 0)
    return run_pvresize (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sfdisk_N") == 0 || strcasecmp (cmd, "sfdisk-N") == 0)
    return run_sfdisk_N (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sfdisk_l") == 0 || strcasecmp (cmd, "sfdisk-l") == 0)
    return run_sfdisk_l (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sfdisk_kernel_geometry") == 0 || strcasecmp (cmd, "sfdisk-kernel-geometry") == 0)
    return run_sfdisk_kernel_geometry (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sfdisk_disk_geometry") == 0 || strcasecmp (cmd, "sfdisk-disk-geometry") == 0)
    return run_sfdisk_disk_geometry (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vg_activate_all") == 0 || strcasecmp (cmd, "vg-activate-all") == 0)
    return run_vg_activate_all (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vg_activate") == 0 || strcasecmp (cmd, "vg-activate") == 0)
    return run_vg_activate (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvresize") == 0)
    return run_lvresize (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "resize2fs") == 0)
    return run_resize2fs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "find") == 0)
    return run_find (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "e2fsck_f") == 0 || strcasecmp (cmd, "e2fsck-f") == 0)
    return run_e2fsck_f (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sleep") == 0)
    return run_sleep (cmd, argc, argv);
  else
    {
      fprintf (stderr, "%s: unknown command\n", cmd);
      return -1;
    }
  return 0;
}

