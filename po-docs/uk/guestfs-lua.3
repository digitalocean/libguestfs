.\" Automatically generated by Podwrapper::Man 1.36.4 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "guestfs-lua 3"
.TH guestfs-lua 3 "2017-05-19" "libguestfs-1.36.4" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
guestfs-lua \- How to use libguestfs from Lua
.SH "КОРОТКИЙ ОПИС"
.IX Header "КОРОТКИЙ ОПИС"
.Vb 6
\& local G = require "guestfs"
\& g = G.create ()
\& g:add_drive ("test.img", { format = "raw", readonly = true })
\& g:launch ()
\& devices = g:list_devices ()
\& g:close ()
.Ve
.SH "ОПИС"
.IX Header "ОПИС"
This manual page documents how to call libguestfs from the Lua programming
language.  This page just documents the differences from the C \s-1API\s0 and gives
some examples.  If you are not familiar with using libguestfs, you also need
to read \fIguestfs\fR\|(3).
.SS "\s-1REQUIRING THE MODULE\s0"
.IX Subsection "REQUIRING THE MODULE"
\&\f(CW\*(C`require "guestfs"\*(C'\fR returns the module, so you have to assign it to a local
variable.  Typical usage is:
.PP
.Vb 1
\& local G = require "guestfs"
.Ve
.PP
(you can use any name you want instead of \f(CW\*(C`G\*(C'\fR, but in the examples in this
man page we always use \f(CW\*(C`G\*(C'\fR).
.SS "\s-1OPENING AND CLOSING THE HANDLE\s0"
.IX Subsection "OPENING AND CLOSING THE HANDLE"
To create a new handle, call:
.PP
.Vb 1
\& g = G.create ()
.Ve
.PP
You can also use the optional arguments:
.PP
.Vb 1
\& g = G.create { environment = 0, close_on_exit = 0 }
.Ve
.PP
to set the flags \f(CW\*(C`GUESTFS_CREATE_NO_ENVIRONMENT\*(C'\fR and/or
\&\f(CW\*(C`GUESTFS_CREATE_NO_CLOSE_ON_EXIT\*(C'\fR.
.PP
The handle will be closed by the garbage collector, but you can also close
it explicitly by doing:
.PP
.Vb 1
\& g:close ()
.Ve
.SS "ЯК ВИКЛИКАТИ МЕТОДИ"
.IX Subsection "ЯК ВИКЛИКАТИ МЕТОДИ"
Use the ordinary Lua convention for calling methods on the handle.  For
example:
.PP
.Vb 1
\& g:set_verbose (true)
.Ve
.SS "ФУНКЦІЇ І ДОДАТКОВІ ПАРАМЕТРИ"
.IX Subsection "ФУНКЦІЇ І ДОДАТКОВІ ПАРАМЕТРИ"
For functions that take optional arguments, the first arguments are the
non-optional ones.  The optional final argument is a table supplying the
optional arguments.
.PP
.Vb 1
\& g:add_drive ("test.img")
.Ve
.PP
або:
.PP
.Vb 1
\& g:add_drive ("test.img", { format = "raw", readonly = true })
.Ve
.SS "64\-БІТОВІ ЗНАЧЕННЯ"
.IX Subsection "64-БІТОВІ ЗНАЧЕННЯ"
Currently 64 bit values must be passed as strings, and are returned as
strings.  This is because 32 bit Lua cannot handle 64 bit integers
properly.  We hope to come up with a better solution later.
.SS "ПОМИЛКИ"
.IX Subsection "ПОМИЛКИ"
Most (but not all) errors are converted into objects (ie. tables)
containing the following fields:
.IP "msg" 4
.IX Item "msg"
The error message (corresponding to \*(L"guestfs_last_error\*(R" in \fIguestfs\fR\|(3)).
.IP "code" 4
.IX Item "code"
The \f(CW\*(C`errno\*(C'\fR (corresponding to \*(L"guestfs_last_errno\*(R" in \fIguestfs\fR\|(3)).
.PP
These objects also have \f(CW\*(C`_\|_tostring\*(C'\fR functions attached to them so you can
use \f(CW\*(C`tostring\*(C'\fR (or implicit conversion) to convert them into printable
strings.
.PP
Note that the library also throws some errors as plain strings.  You may
need to check the type.
.SS "ПОДІЇ"
.IX Subsection "ПОДІЇ"
Реєструвати події можна за допомогою викликів \f(CW\*(C`set_event_callback\*(C'\fR:
.PP
.Vb 1
\& eh = g:set_event_callback (cb, "close")
.Ve
.PP
or to register a single callback for multiple events make the second
argument a list:
.PP
.Vb 1
\& eh = g:set_event_callback (cb, { "appliance", "library", "trace" })
.Ve
.PP
A list of all valid event types (strings) is in the global variable
\&\f(CW\*(C`G.event_all\*(C'\fR.
.PP
The callback (\f(CW\*(C`cb\*(C'\fR) is called with the following parameters:
.PP
.Vb 8
\& function cb (g, event, eh, flags, buf, array)
\&   \-\- g is the guestfs handle
\&   \-\- event is a string which is the name of the event that fired
\&   \-\- flags is always zero
\&   \-\- buf is the data buffer (eg. log message etc)
\&   \-\- array is the array of 64 bit ints (eg. progress bar status etc)
\&   ...
\& end
.Ve
.PP
You can also remove a callback using the event handle (\f(CW\*(C`eh\*(C'\fR) that was
returned when you registered the callback:
.PP
.Vb 1
\& g:delete_event_callback (eh)
.Ve
.SH "ПРИКЛАД 1. СТВОРЕННЯ ОБРАЗУ ДИСКА"
.IX Header "ПРИКЛАД 1. СТВОРЕННЯ ОБРАЗУ ДИСКА"
\&\f(CW@EXAMPLE1\fR@
.SH "ПРИКЛАД 2. ПЕРЕВІРКА ОБРАЗУ ДИСКА ВІРТУАЛЬНОЇ МАШИНИ"
.IX Header "ПРИКЛАД 2. ПЕРЕВІРКА ОБРАЗУ ДИСКА ВІРТУАЛЬНОЇ МАШИНИ"
\&\f(CW@EXAMPLE2\fR@
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fIguestfs\fR\|(3), \fIguestfs\-examples\fR\|(3), \fIguestfs\-erlang\fR\|(3),
\&\fIguestfs\-golang\fR\|(3), \fIguestfs\-java\fR\|(3), \fIguestfs\-ocaml\fR\|(3),
\&\fIguestfs\-perl\fR\|(3), \fIguestfs\-python\fR\|(3), \fIguestfs\-recipes\fR\|(1),
\&\fIguestfs\-ruby\fR\|(3), http://www.lua.org/, http://libguestfs.org/.
.SH "АВТОРИ"
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
© Red Hat Inc., 2012
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
