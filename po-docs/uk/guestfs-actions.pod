=encoding utf8

=head2 guestfs_add_cdrom

 int
 guestfs_add_cdrom (guestfs_h *g,
                    const char *filename);

This function adds a virtual CD-ROM disk image to the guest.

This is equivalent to the qemu parameter I<-cdrom filename>.

Нотатки:

=over 4

=item *

This call checks for the existence of C<filename>.  This stops you from
specifying other types of drive which are supported by qemu such as C<nbd:>
and C<http:> URLs.  To specify those, use the general C<guestfs_config> call
instead.

=item *

If you just want to add an ISO file (often you use this as an efficient way
to transfer large files into the guest), then you should probably use
C<guestfs_add_drive_ro> instead.

=back

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the
L</guestfs_add_drive_opts> call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 0.3)

=head2 guestfs_add_domain

 int
 guestfs_add_domain (guestfs_h *g,
                     const char *dom,
                     ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_ADD_DOMAIN_LIBVIRTURI, const char *libvirturi,
 GUESTFS_ADD_DOMAIN_READONLY, int readonly,
 GUESTFS_ADD_DOMAIN_IFACE, const char *iface,
 GUESTFS_ADD_DOMAIN_LIVE, int live,
 GUESTFS_ADD_DOMAIN_ALLOWUUID, int allowuuid,

This function adds the disk(s) attached to the named libvirt domain C<dom>.
It works by connecting to libvirt, requesting the domain and domain XML from
libvirt, parsing it for disks, and calling C<guestfs_add_drive_opts> on each
one.

The number of disks added is returned.  This operation is atomic: if an
error is returned, then no disks are added.

This function does some minimal checks to make sure the libvirt domain is
not running (unless C<readonly> is true).  In a future version we will try
to acquire the libvirt lock on each disk.

Disks must be accessible locally.  This often means that adding disks from a
remote libvirt connection (see L<http://libvirt.org/remote.html>)  will fail
unless those disks are accessible via the same device path locally too.

The optional C<libvirturi> parameter sets the libvirt URI (see
L<http://libvirt.org/uri.html>).  If this is not set then we connect to the
default libvirt URI (or one set through an environment variable, see the
libvirt documentation for full details).

The optional C<live> flag controls whether this call will try to connect to
a running virtual machine C<guestfsd> process if it sees a suitable
E<lt>channelE<gt> element in the libvirt XML definition.  The default (if
the flag is omitted) is never to try.  See L<guestfs(3)/ATTACHING TO RUNNING
DAEMONS> for more information.

If the C<allowuuid> flag is true (default is false) then a UUID I<may> be
passed instead of the domain name.  The C<dom> string is treated as a UUID
first and looked up, and if that lookup fails then we treat C<dom> as a name
as usual.

The other optional parameters are passed directly through to
C<guestfs_add_drive_opts>.

On error this function returns -1.

(Added in 1.7.4)

=head2 guestfs_add_domain_va

 int
 guestfs_add_domain_va (guestfs_h *g,
                        const char *dom,
                        va_list args);

This is the "va_list variant" of L</guestfs_add_domain>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_add_domain_argv

 int
 guestfs_add_domain_argv (guestfs_h *g,
                          const char *dom,
                          const struct guestfs_add_domain_argv *optargs);

This is the "argv variant" of L</guestfs_add_domain>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_add_drive

 int
 guestfs_add_drive (guestfs_h *g,
                    const char *filename);

This function is the equivalent of calling C<guestfs_add_drive_opts> with no
optional parameters, so the disk is added writable, with the format being
detected automatically.

Automatic detection of the format opens you up to a potential security hole
when dealing with untrusted raw-format images.  See CVE-2010-3851 and
RHBZ#642934.  Specifying the format closes this security hole.  Therefore
you should think about replacing calls to this function with calls to
C<guestfs_add_drive_opts>, and specifying the format.

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_add_drive_opts

 int
 guestfs_add_drive_opts (guestfs_h *g,
                         const char *filename,
                         ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_ADD_DRIVE_OPTS_READONLY, int readonly,
 GUESTFS_ADD_DRIVE_OPTS_FORMAT, const char *format,
 GUESTFS_ADD_DRIVE_OPTS_IFACE, const char *iface,

This function adds a virtual machine disk image C<filename> to libguestfs.
The first time you call this function, the disk appears as C</dev/sda>, the
second time as C</dev/sdb>, and so on.

You don't necessarily need to be root when using libguestfs.  However you
obviously do need sufficient permissions to access the filename for whatever
operations you want to perform (ie. read access if you just want to read the
image or write access if you want to modify the image).

This call checks that C<filename> exists.

The optional arguments are:

=over 4

=item C<readonly>

If true then the image is treated as read-only.  Writes are still allowed,
but they are stored in a temporary snapshot overlay which is discarded at
the end.  The disk that you add is not modified.

=item C<format>

This forces the image format.  If you omit this (or use C<guestfs_add_drive>
or C<guestfs_add_drive_ro>) then the format is automatically detected.
Possible formats include C<raw> and C<qcow2>.

Automatic detection of the format opens you up to a potential security hole
when dealing with untrusted raw-format images.  See CVE-2010-3851 and
RHBZ#642934.  Specifying the format closes this security hole.

=item C<iface>

This rarely-used option lets you emulate the behaviour of the deprecated
C<guestfs_add_drive_with_if> call (q.v.)

=back

This function returns 0 on success or -1 on error.

(Added in 1.5.23)

=head2 guestfs_add_drive_opts_va

 int
 guestfs_add_drive_opts_va (guestfs_h *g,
                            const char *filename,
                            va_list args);

This is the "va_list variant" of L</guestfs_add_drive_opts>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_add_drive_opts_argv

 int
 guestfs_add_drive_opts_argv (guestfs_h *g,
                              const char *filename,
                              const struct guestfs_add_drive_opts_argv *optargs);

This is the "argv variant" of L</guestfs_add_drive_opts>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_add_drive_ro

 int
 guestfs_add_drive_ro (guestfs_h *g,
                       const char *filename);

This function is the equivalent of calling C<guestfs_add_drive_opts> with
the optional parameter C<GUESTFS_ADD_DRIVE_OPTS_READONLY> set to 1, so the
disk is added read-only, with the format being detected automatically.

This function returns 0 on success or -1 on error.

(Added in 1.0.38)

=head2 guestfs_add_drive_ro_with_if

 int
 guestfs_add_drive_ro_with_if (guestfs_h *g,
                               const char *filename,
                               const char *iface);

This is the same as C<guestfs_add_drive_ro> but it allows you to specify the
QEMU interface emulation to use at run time.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the
L</guestfs_add_drive_opts> call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.84)

=head2 guestfs_add_drive_with_if

 int
 guestfs_add_drive_with_if (guestfs_h *g,
                            const char *filename,
                            const char *iface);

This is the same as C<guestfs_add_drive> but it allows you to specify the
QEMU interface emulation to use at run time.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the
L</guestfs_add_drive_opts> call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.84)

=head2 guestfs_aug_clear

 int
 guestfs_aug_clear (guestfs_h *g,
                    const char *augpath);

Set the value associated with C<path> to C<NULL>.  This is the same as the
L<augtool(1)> C<clear> command.

This function returns 0 on success or -1 on error.

(Added in 1.3.4)

=head2 guestfs_aug_close

 int
 guestfs_aug_close (guestfs_h *g);

Close the current Augeas handle and free up any resources used by it.  After
calling this, you have to call C<guestfs_aug_init> again before you can use
any other Augeas functions.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_aug_defnode

 struct guestfs_int_bool *
 guestfs_aug_defnode (guestfs_h *g,
                      const char *name,
                      const char *expr,
                      const char *val);

Defines a variable C<name> whose value is the result of evaluating C<expr>.

If C<expr> evaluates to an empty nodeset, a node is created, equivalent to
calling C<guestfs_aug_set> C<expr>, C<value>.  C<name> will be the nodeset
containing that single node.

On success this returns a pair containing the number of nodes in the
nodeset, and a boolean flag if a node was created.

This function returns a C<struct guestfs_int_bool *>, or NULL if there was
an error.  I<The caller must call C<guestfs_free_int_bool> after use>.

(Added in 0.7)

=head2 guestfs_aug_defvar

 int
 guestfs_aug_defvar (guestfs_h *g,
                     const char *name,
                     const char *expr);

Defines an Augeas variable C<name> whose value is the result of evaluating
C<expr>.  If C<expr> is NULL, then C<name> is undefined.

On success this returns the number of nodes in C<expr>, or C<0> if C<expr>
evaluates to something which is not a nodeset.

On error this function returns -1.

(Added in 0.7)

=head2 guestfs_aug_get

 char *
 guestfs_aug_get (guestfs_h *g,
                  const char *augpath);

Look up the value associated with C<path>.  If C<path> matches exactly one
node, the C<value> is returned.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 0.7)

=head2 guestfs_aug_init

 int
 guestfs_aug_init (guestfs_h *g,
                   const char *root,
                   int flags);

Create a new Augeas handle for editing configuration files.  If there was
any previous Augeas handle associated with this guestfs session, then it is
closed.

You must call this before using any other C<guestfs_aug_*> commands.

C<root> is the filesystem root.  C<root> must not be NULL, use C</> instead.

The flags are the same as the flags defined in E<lt>augeas.hE<gt>, the
logical I<or> of the following integers:

=over 4

=item C<AUG_SAVE_BACKUP> = 1

Keep the original file with a C<.augsave> extension.

=item C<AUG_SAVE_NEWFILE> = 2

Save changes into a file with extension C<.augnew>, and do not overwrite
original.  Overrides C<AUG_SAVE_BACKUP>.

=item C<AUG_TYPE_CHECK> = 4

Typecheck lenses.

This option is only useful when debugging Augeas lenses.  Use of this option
may require additional memory for the libguestfs appliance.  You may need to
set the C<LIBGUESTFS_MEMSIZE> environment variable or call
C<guestfs_set_memsize>.

=item C<AUG_NO_STDINC> = 8

Do not use standard load path for modules.

=item C<AUG_SAVE_NOOP> = 16

Make save a no-op, just record what would have been changed.

=item C<AUG_NO_LOAD> = 32

Do not load the tree in C<guestfs_aug_init>.

=back

To close the handle, you can call C<guestfs_aug_close>.

To find out more about Augeas, see L<http://augeas.net/>.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_aug_insert

 int
 guestfs_aug_insert (guestfs_h *g,
                     const char *augpath,
                     const char *label,
                     int before);

Create a new sibling C<label> for C<path>, inserting it into the tree before
or after C<path> (depending on the boolean flag C<before>).

C<path> must match exactly one existing node in the tree, and C<label> must
be a label, ie. not contain C</>, C<*> or end with a bracketed index C<[N]>.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_aug_load

 int
 guestfs_aug_load (guestfs_h *g);

Завантажити файли до ієрархії.

See C<aug_load> in the Augeas documentation for the full gory details.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_aug_ls

 char **
 guestfs_aug_ls (guestfs_h *g,
                 const char *augpath);

This is just a shortcut for listing C<guestfs_aug_match> C<path/*> and
sorting the resulting nodes into alphabetical order.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.8)

=head2 guestfs_aug_match

 char **
 guestfs_aug_match (guestfs_h *g,
                    const char *augpath);

Returns a list of paths which match the path expression C<path>.  The
returned paths are sufficiently qualified so that they match exactly one
node in the current tree.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.7)

=head2 guestfs_aug_mv

 int
 guestfs_aug_mv (guestfs_h *g,
                 const char *src,
                 const char *dest);

Move the node C<src> to C<dest>.  C<src> must match exactly one node.
C<dest> is overwritten if it exists.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_aug_rm

 int
 guestfs_aug_rm (guestfs_h *g,
                 const char *augpath);

Remove C<path> and all of its children.

On success this returns the number of entries which were removed.

On error this function returns -1.

(Added in 0.7)

=head2 guestfs_aug_save

 int
 guestfs_aug_save (guestfs_h *g);

This writes all pending changes to disk.

The flags which were passed to C<guestfs_aug_init> affect exactly how files
are saved.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_aug_set

 int
 guestfs_aug_set (guestfs_h *g,
                  const char *augpath,
                  const char *val);

Set the value associated with C<path> to C<val>.

In the Augeas API, it is possible to clear a node by setting the value to
NULL.  Due to an oversight in the libguestfs API you cannot do that with
this call.  Instead you must use the C<guestfs_aug_clear> call.

This function returns 0 on success or -1 on error.

(Added in 0.7)

=head2 guestfs_available

 int
 guestfs_available (guestfs_h *g,
                    char *const *groups);

This command is used to check the availability of some groups of
functionality in the appliance, which not all builds of the libguestfs
appliance will be able to provide.

The libguestfs groups, and the functions that those groups correspond to,
are listed in L<guestfs(3)/AVAILABILITY>.  You can also fetch this list at
runtime by calling C<guestfs_available_all_groups>.

The argument C<groups> is a list of group names, eg: C<["inotify",
"augeas"]> would check for the availability of the Linux inotify functions
and Augeas (configuration file editing) functions.

The command returns no error if I<all> requested groups are available.

It fails with an error if one or more of the requested groups is unavailable
in the appliance.

If an unknown group name is included in the list of groups then an error is
always returned.

I<Нотатки:>

=over 4

=item *

You must call C<guestfs_launch> before calling this function.

The reason is because we don't know what groups are supported by the
appliance/daemon until it is running and can be queried.

=item *

If a group of functions is available, this does not necessarily mean that
they will work.  You still have to check for errors when calling individual
API functions even if they are available.

=item *

It is usually the job of distro packagers to build complete functionality
into the libguestfs appliance.  Upstream libguestfs, if built from source
with all requirements satisfied, will support everything.

=item *

This call was added in version C<1.0.80>.  In previous versions of
libguestfs all you could do would be to speculatively execute a command to
find out if the daemon implemented it.  See also C<guestfs_version>.

=back

This function returns 0 on success or -1 on error.

(Added in 1.0.80)

=head2 guestfs_available_all_groups

 char **
 guestfs_available_all_groups (guestfs_h *g);

This command returns a list of all optional groups that this daemon knows
about.  Note this returns both supported and unsupported groups.  To find
out which ones the daemon can actually support you have to call
C<guestfs_available> on each member of the returned list.

See also C<guestfs_available> and L<guestfs(3)/AVAILABILITY>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.3.15)

=head2 guestfs_base64_in

 int
 guestfs_base64_in (guestfs_h *g,
                    const char *base64file,
                    const char *filename);

This command uploads base64-encoded data from C<base64file> to C<filename>.

This function returns 0 on success or -1 on error.

(Added in 1.3.5)

=head2 guestfs_base64_out

 int
 guestfs_base64_out (guestfs_h *g,
                     const char *filename,
                     const char *base64file);

This command downloads the contents of C<filename>, writing it out to local
file C<base64file> encoded as base64.

This function returns 0 on success or -1 on error.

(Added in 1.3.5)

=head2 guestfs_blockdev_flushbufs

 int
 guestfs_blockdev_flushbufs (guestfs_h *g,
                             const char *device);

This tells the kernel to flush internal buffers associated with C<device>.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

(Added in 0.9.3)

=head2 guestfs_blockdev_getbsz

 int
 guestfs_blockdev_getbsz (guestfs_h *g,
                          const char *device);

This returns the block size of a device.

(Note this is different from both I<size in blocks> and I<filesystem block
size>).

This uses the L<blockdev(8)> command.

On error this function returns -1.

(Added in 0.9.3)

=head2 guestfs_blockdev_getro

 int
 guestfs_blockdev_getro (guestfs_h *g,
                         const char *device);

Returns a boolean indicating if the block device is read-only (true if
read-only, false if not).

This uses the L<blockdev(8)> command.

This function returns a C truth value on success or -1 on error.

(Added in 0.9.3)

=head2 guestfs_blockdev_getsize64

 int64_t
 guestfs_blockdev_getsize64 (guestfs_h *g,
                             const char *device);

This returns the size of the device in bytes.

See also C<guestfs_blockdev_getsz>.

This uses the L<blockdev(8)> command.

On error this function returns -1.

(Added in 0.9.3)

=head2 guestfs_blockdev_getss

 int
 guestfs_blockdev_getss (guestfs_h *g,
                         const char *device);

This returns the size of sectors on a block device.  Usually 512, but can be
larger for modern devices.

(Note, this is not the size in sectors, use C<guestfs_blockdev_getsz> for
that).

This uses the L<blockdev(8)> command.

On error this function returns -1.

(Added in 0.9.3)

=head2 guestfs_blockdev_getsz

 int64_t
 guestfs_blockdev_getsz (guestfs_h *g,
                         const char *device);

This returns the size of the device in units of 512-byte sectors (even if
the sectorsize isn't 512 bytes ... weird).

See also C<guestfs_blockdev_getss> for the real sector size of the device,
and C<guestfs_blockdev_getsize64> for the more useful I<size in bytes>.

This uses the L<blockdev(8)> command.

On error this function returns -1.

(Added in 0.9.3)

=head2 guestfs_blockdev_rereadpt

 int
 guestfs_blockdev_rereadpt (guestfs_h *g,
                            const char *device);

Reread the partition table on C<device>.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

(Added in 0.9.3)

=head2 guestfs_blockdev_setbsz

 int
 guestfs_blockdev_setbsz (guestfs_h *g,
                          const char *device,
                          int blocksize);

This sets the block size of a device.

(Note this is different from both I<size in blocks> and I<filesystem block
size>).

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

(Added in 0.9.3)

=head2 guestfs_blockdev_setro

 int
 guestfs_blockdev_setro (guestfs_h *g,
                         const char *device);

Sets the block device named C<device> to read-only.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

(Added in 0.9.3)

=head2 guestfs_blockdev_setrw

 int
 guestfs_blockdev_setrw (guestfs_h *g,
                         const char *device);

Sets the block device named C<device> to read-write.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

(Added in 0.9.3)

=head2 guestfs_btrfs_filesystem_resize

 int
 guestfs_btrfs_filesystem_resize (guestfs_h *g,
                                  const char *mountpoint,
                                  ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE, int64_t size,

This command resizes a btrfs filesystem.

Note that unlike other resize calls, the filesystem has to be mounted and
the parameter is the mountpoint not the device (this is a requirement of
btrfs itself).

The optional parameters are:

=over 4

=item C<size>

The new size (in bytes) of the filesystem.  If omitted, the filesystem is
resized to the maximum size.

=back

See also L<btrfs(8)>.

This function returns 0 on success or -1 on error.

(Added in 1.11.17)

=head2 guestfs_btrfs_filesystem_resize_va

 int
 guestfs_btrfs_filesystem_resize_va (guestfs_h *g,
                                     const char *mountpoint,
                                     va_list args);

This is the "va_list variant" of L</guestfs_btrfs_filesystem_resize>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_btrfs_filesystem_resize_argv

 int
 guestfs_btrfs_filesystem_resize_argv (guestfs_h *g,
                                       const char *mountpoint,
                                       const struct guestfs_btrfs_filesystem_resize_argv *optargs);

This is the "argv variant" of L</guestfs_btrfs_filesystem_resize>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_case_sensitive_path

 char *
 guestfs_case_sensitive_path (guestfs_h *g,
                              const char *path);

This can be used to resolve case insensitive paths on a filesystem which is
case sensitive.  The use case is to resolve paths which you have read from
Windows configuration files or the Windows Registry, to the true path.

The command handles a peculiarity of the Linux ntfs-3g filesystem driver
(and probably others), which is that although the underlying filesystem is
case-insensitive, the driver exports the filesystem to Linux as
case-sensitive.

One consequence of this is that special directories such as C<c:\windows>
may appear as C</WINDOWS> or C</windows> (or other things) depending on the
precise details of how they were created.  In Windows itself this would not
be a problem.

Bug or feature? You decide:
L<http://www.tuxera.com/community/ntfs-3g-faq/#posixfilenames1>

This function resolves the true case of each element in the path and returns
the case-sensitive path.

Thus C<guestfs_case_sensitive_path> ("/Windows/System32")  might return
C<"/WINDOWS/system32"> (the exact return value would depend on details of
how the directories were originally created under Windows).

I<Note>: This function does not handle drive names, backslashes etc.

See also C<guestfs_realpath>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.75)

=head2 guestfs_cat

 char *
 guestfs_cat (guestfs_h *g,
              const char *path);

Return the contents of the file named C<path>.

Note that this function cannot correctly handle binary files (specifically,
files containing C<\0> character which is treated as end of string).  For
those you need to use the C<guestfs_read_file> or C<guestfs_download>
functions which have a more complex interface.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 0.4)

=head2 guestfs_checksum

 char *
 guestfs_checksum (guestfs_h *g,
                   const char *csumtype,
                   const char *path);

This call computes the MD5, SHAx or CRC checksum of the file named C<path>.

The type of checksum to compute is given by the C<csumtype> parameter which
must have one of the following values:

=over 4

=item C<crc>

Compute the cyclic redundancy check (CRC) specified by POSIX for the
C<cksum> command.

=item C<md5>

Compute the MD5 hash (using the C<md5sum> program).

=item C<sha1>

Compute the SHA1 hash (using the C<sha1sum> program).

=item C<sha224>

Compute the SHA224 hash (using the C<sha224sum> program).

=item C<sha256>

Compute the SHA256 hash (using the C<sha256sum> program).

=item C<sha384>

Compute the SHA384 hash (using the C<sha384sum> program).

=item C<sha512>

Compute the SHA512 hash (using the C<sha512sum> program).

=back

The checksum is returned as a printable string.

To get the checksum for a device, use C<guestfs_checksum_device>.

To get the checksums for many files, use C<guestfs_checksums_out>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.2)

=head2 guestfs_checksum_device

 char *
 guestfs_checksum_device (guestfs_h *g,
                          const char *csumtype,
                          const char *device);

This call computes the MD5, SHAx or CRC checksum of the contents of the
device named C<device>.  For the types of checksums supported see the
C<guestfs_checksum> command.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.3.2)

=head2 guestfs_checksums_out

 int
 guestfs_checksums_out (guestfs_h *g,
                        const char *csumtype,
                        const char *directory,
                        const char *sumsfile);

This command computes the checksums of all regular files in C<directory> and
then emits a list of those checksums to the local output file C<sumsfile>.

This can be used for verifying the integrity of a virtual machine.  However
to be properly secure you should pay attention to the output of the checksum
command (it uses the ones from GNU coreutils).  In particular when the
filename is not printable, coreutils uses a special backslash syntax.  For
more information, see the GNU coreutils info file.

This function returns 0 on success or -1 on error.

(Added in 1.3.7)

=head2 guestfs_chmod

 int
 guestfs_chmod (guestfs_h *g,
                int mode,
                const char *path);

Change the mode (permissions) of C<path> to C<mode>.  Only numeric modes are
supported.

I<Note>: When using this command from guestfish, C<mode> by default would be
decimal, unless you prefix it with C<0> to get octal, ie. use C<0700> not
C<700>.

The mode actually set is affected by the umask.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_chown

 int
 guestfs_chown (guestfs_h *g,
                int owner,
                int group,
                const char *path);

Change the file owner to C<owner> and group to C<group>.

Only numeric uid and gid are supported.  If you want to use names, you will
need to locate and parse the password file yourself (Augeas support makes
this relatively easy).

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_command

 char *
 guestfs_command (guestfs_h *g,
                  char *const *arguments);

This call runs a command from the guest filesystem.  The filesystem must be
mounted, and must contain a compatible operating system (ie. something
Linux, with the same or compatible processor architecture).

The single parameter is an argv-style list of arguments.  The first element
is the name of the program to run.  Subsequent elements are parameters.  The
list must be non-empty (ie. must contain a program name).  Note that the
command runs directly, and is I<not> invoked via the shell (see
C<guestfs_sh>).

The return value is anything printed to I<stdout> by the command.

If the command returns a non-zero exit status, then this function returns an
error message.  The error message string is the content of I<stderr> from
the command.

The C<$PATH> environment variable will contain at least C</usr/bin> and
C</bin>.  If you require a program from another location, you should provide
the full path in the first parameter.

Shared libraries and data files required by the program must be available on
filesystems which are mounted in the correct places.  It is the caller's
responsibility to ensure all filesystems that are needed are mounted at the
right locations.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 0.9.1)

=head2 guestfs_command_lines

 char **
 guestfs_command_lines (guestfs_h *g,
                        char *const *arguments);

This is the same as C<guestfs_command>, but splits the result into a list of
lines.

See also: C<guestfs_sh_lines>

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 0.9.1)

=head2 guestfs_config

 int
 guestfs_config (guestfs_h *g,
                 const char *qemuparam,
                 const char *qemuvalue);

This can be used to add arbitrary qemu command line parameters of the form
I<-param value>.  Actually it's not quite arbitrary - we prevent you from
setting some parameters which would interfere with parameters that we use.

The first character of C<param> string must be a C<-> (dash).

C<value> can be NULL.

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_copy_size

 int
 guestfs_copy_size (guestfs_h *g,
                    const char *src,
                    const char *dest,
                    int64_t size);

This command copies exactly C<size> bytes from one source device or file
C<src> to another destination device or file C<dest>.

Note this will fail if the source is too short or if the destination is not
large enough.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.0.87)

=head2 guestfs_cp

 int
 guestfs_cp (guestfs_h *g,
             const char *src,
             const char *dest);

This copies a file from C<src> to C<dest> where C<dest> is either a
destination filename or destination directory.

This function returns 0 on success or -1 on error.

(Added in 1.0.18)

=head2 guestfs_cp_a

 int
 guestfs_cp_a (guestfs_h *g,
               const char *src,
               const char *dest);

This copies a file or directory from C<src> to C<dest> recursively using the
C<cp -a> command.

This function returns 0 on success or -1 on error.

(Added in 1.0.18)

=head2 guestfs_dd

 int
 guestfs_dd (guestfs_h *g,
             const char *src,
             const char *dest);

This command copies from one source device or file C<src> to another
destination device or file C<dest>.  Normally you would use this to copy to
or from a device or partition, for example to duplicate a filesystem.

If the destination is a device, it must be as large or larger than the
source file or device, otherwise the copy will fail.  This command cannot do
partial copies (see C<guestfs_copy_size>).

This function returns 0 on success or -1 on error.

(Added in 1.0.80)

=head2 guestfs_df

 char *
 guestfs_df (guestfs_h *g);

This command runs the C<df> command to report disk space used.

This command is mostly useful for interactive sessions.  It is I<not>
intended that you try to parse the output string.  Use C<guestfs_statvfs>
from programs.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.54)

=head2 guestfs_df_h

 char *
 guestfs_df_h (guestfs_h *g);

This command runs the C<df -h> command to report disk space used in
human-readable format.

This command is mostly useful for interactive sessions.  It is I<not>
intended that you try to parse the output string.  Use C<guestfs_statvfs>
from programs.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.54)

=head2 guestfs_dmesg

 char *
 guestfs_dmesg (guestfs_h *g);

This returns the kernel messages (C<dmesg> output) from the guest kernel.
This is sometimes useful for extended debugging of problems.

Another way to get the same information is to enable verbose messages with
C<guestfs_set_verbose> or by setting the environment variable
C<LIBGUESTFS_DEBUG=1> before running the program.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.18)

=head2 guestfs_download

 int
 guestfs_download (guestfs_h *g,
                   const char *remotefilename,
                   const char *filename);

Download file C<remotefilename> and save it as C<filename> on the local
machine.

C<filename> can also be a named pipe.

See also C<guestfs_upload>, C<guestfs_cat>.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.0.2)

=head2 guestfs_download_offset

 int
 guestfs_download_offset (guestfs_h *g,
                          const char *remotefilename,
                          const char *filename,
                          int64_t offset,
                          int64_t size);

Download file C<remotefilename> and save it as C<filename> on the local
machine.

C<remotefilename> is read for C<size> bytes starting at C<offset> (this
region must be within the file or device).

Note that there is no limit on the amount of data that can be downloaded
with this call, unlike with C<guestfs_pread>, and this call always reads the
full amount unless an error occurs.

See also C<guestfs_download>, C<guestfs_pread>.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.5.17)

=head2 guestfs_drop_caches

 int
 guestfs_drop_caches (guestfs_h *g,
                      int whattodrop);

This instructs the guest kernel to drop its page cache, and/or dentries and
inode caches.  The parameter C<whattodrop> tells the kernel what precisely
to drop, see L<http://linux-mm.org/Drop_Caches>

Setting C<whattodrop> to 3 should drop everything.

This automatically calls L<sync(2)> before the operation, so that the
maximum guest memory is freed.

This function returns 0 on success or -1 on error.

(Added in 1.0.18)

=head2 guestfs_du

 int64_t
 guestfs_du (guestfs_h *g,
             const char *path);

This command runs the C<du -s> command to estimate file space usage for
C<path>.

C<path> can be a file or a directory.  If C<path> is a directory then the
estimate includes the contents of the directory and all subdirectories
(recursively).

The result is the estimated size in I<kilobytes> (ie. units of 1024 bytes).

On error this function returns -1.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.0.54)

=head2 guestfs_e2fsck_f

 int
 guestfs_e2fsck_f (guestfs_h *g,
                   const char *device);

This runs C<e2fsck -p -f device>, ie. runs the ext2/ext3 filesystem checker
on C<device>, noninteractively (I<-p>), even if the filesystem appears to be
clean (I<-f>).

This command is only needed because of C<guestfs_resize2fs> (q.v.).
Normally you should use C<guestfs_fsck>.

This function returns 0 on success or -1 on error.

(Added in 1.0.29)

=head2 guestfs_echo_daemon

 char *
 guestfs_echo_daemon (guestfs_h *g,
                      char *const *words);

This command concatenates the list of C<words> passed with single spaces
between them and returns the resulting string.

You can use this command to test the connection through to the daemon.

See also C<guestfs_ping_daemon>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.69)

=head2 guestfs_egrep

 char **
 guestfs_egrep (guestfs_h *g,
                const char *regex,
                const char *path);

This calls the external C<egrep> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_egrepi

 char **
 guestfs_egrepi (guestfs_h *g,
                 const char *regex,
                 const char *path);

This calls the external C<egrep -i> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_equal

 int
 guestfs_equal (guestfs_h *g,
                const char *file1,
                const char *file2);

This compares the two files C<file1> and C<file2> and returns true if their
content is exactly equal, or false otherwise.

The external L<cmp(1)> program is used for the comparison.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.18)

=head2 guestfs_exists

 int
 guestfs_exists (guestfs_h *g,
                 const char *path);

This returns C<true> if and only if there is a file, directory (or anything)
with the given C<path> name.

See also C<guestfs_is_file>, C<guestfs_is_dir>, C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 0.8)

=head2 guestfs_fallocate

 int
 guestfs_fallocate (guestfs_h *g,
                    const char *path,
                    int len);

This command preallocates a file (containing zero bytes) named C<path> of
size C<len> bytes.  If the file exists already, it is overwritten.

Do not confuse this with the guestfish-specific C<alloc> command which
allocates a file in the host and attaches it as a device.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the L</guestfs_fallocate64>
call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.66)

=head2 guestfs_fallocate64

 int
 guestfs_fallocate64 (guestfs_h *g,
                      const char *path,
                      int64_t len);

This command preallocates a file (containing zero bytes) named C<path> of
size C<len> bytes.  If the file exists already, it is overwritten.

Note that this call allocates disk blocks for the file.  To create a sparse
file use C<guestfs_truncate_size> instead.

The deprecated call C<guestfs_fallocate> does the same, but owing to an
oversight it only allowed 30 bit lengths to be specified, effectively
limiting the maximum size of files created through that call to 1GB.

Do not confuse this with the guestfish-specific C<alloc> and C<sparse>
commands which create a file in the host and attach it as a device.

This function returns 0 on success or -1 on error.

(Added in 1.3.17)

=head2 guestfs_fgrep

 char **
 guestfs_fgrep (guestfs_h *g,
                const char *pattern,
                const char *path);

This calls the external C<fgrep> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_fgrepi

 char **
 guestfs_fgrepi (guestfs_h *g,
                 const char *pattern,
                 const char *path);

This calls the external C<fgrep -i> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_file

 char *
 guestfs_file (guestfs_h *g,
               const char *path);

This call uses the standard L<file(1)> command to determine the type or
contents of the file.

This call will also transparently look inside various types of compressed
file.

The exact command which runs is C<file -zb path>.  Note in particular that
the filename is not prepended to the output (the I<-b> option).

The output depends on the output of the underlying L<file(1)> command and it
can change in future in ways beyond our control.  In other words, the output
is not guaranteed by the ABI.

See also: L<file(1)>, C<guestfs_vfs_type>, C<guestfs_lstat>,
C<guestfs_is_file>, C<guestfs_is_blockdev> (etc), C<guestfs_is_zero>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 0.9.1)

=head2 guestfs_file_architecture

 char *
 guestfs_file_architecture (guestfs_h *g,
                            const char *filename);

This detects the architecture of the binary C<filename>, and returns it if
known.

Currently defined architectures are:

=over 4

=item "i386"

This string is returned for all 32 bit i386, i486, i586, i686 binaries
irrespective of the precise processor requirements of the binary.

=item "x86_64"

64 bit x86-64.

=item "sparc"

32 bit SPARC.

=item "sparc64"

64 bit SPARC V9 and above.

=item "ia64"

Intel Itanium.

=item "ppc"

32 bit Power PC.

=item "ppc64"

64 bit Power PC.

=back

Libguestfs may return other architecture strings in future.

The function works on at least the following types of files:

=over 4

=item *

many types of Un*x and Linux binary

=item *

many types of Un*x and Linux shared library

=item *

Windows Win32 and Win64 binaries

=item *

Windows Win32 and Win64 DLLs

Win32 binaries and DLLs return C<i386>.

Win64 binaries and DLLs return C<x86_64>.

=item *

Linux kernel modules

=item *

Linux new-style initrd images

=item *

some non-x86 Linux vmlinuz kernels

=back

What it can't do currently:

=over 4

=item *

static libraries (libfoo.a)

=item *

Linux old-style initrd as compressed ext2 filesystem (RHEL 3)

=item *

x86 Linux vmlinuz kernels

x86 vmlinuz images (bzImage format) consist of a mix of 16-, 32- and
compressed code, and are horribly hard to unpack.  If you want to find the
architecture of a kernel, use the architecture of the associated initrd or
kernel module(s) instead.

=back

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_filesize

 int64_t
 guestfs_filesize (guestfs_h *g,
                   const char *file);

This command returns the size of C<file> in bytes.

To get other stats about a file, use C<guestfs_stat>, C<guestfs_lstat>,
C<guestfs_is_dir>, C<guestfs_is_file> etc.  To get the size of block
devices, use C<guestfs_blockdev_getsize64>.

On error this function returns -1.

(Added in 1.0.82)

=head2 guestfs_fill

 int
 guestfs_fill (guestfs_h *g,
               int c,
               int len,
               const char *path);

This command creates a new file called C<path>.  The initial content of the
file is C<len> octets of C<c>, where C<c> must be a number in the range
C<[0..255]>.

To fill a file with zero bytes (sparsely), it is much more efficient to use
C<guestfs_truncate_size>.  To create a file with a pattern of repeating
bytes use C<guestfs_fill_pattern>.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.0.79)

=head2 guestfs_fill_pattern

 int
 guestfs_fill_pattern (guestfs_h *g,
                       const char *pattern,
                       int len,
                       const char *path);

This function is like C<guestfs_fill> except that it creates a new file of
length C<len> containing the repeating pattern of bytes in C<pattern>.  The
pattern is truncated if necessary to ensure the length of the file is
exactly C<len> bytes.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.3.12)

=head2 guestfs_find

 char **
 guestfs_find (guestfs_h *g,
               const char *directory);

This command lists out all files and directories, recursively, starting at
C<directory>.  It is essentially equivalent to running the shell command
C<find directory -print> but some post-processing happens on the output,
described below.

This returns a list of strings I<without any prefix>.  Thus if the directory
structure was:

 /tmp/a
 /tmp/b
 /tmp/c/d

then the returned list from C<guestfs_find> C</tmp> would be 4 elements:

 a
 b
 c
 c/d

If C<directory> is not a directory, then this command returns an error.

The returned list is sorted.

See also C<guestfs_find0>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.27)

=head2 guestfs_find0

 int
 guestfs_find0 (guestfs_h *g,
                const char *directory,
                const char *files);

This command lists out all files and directories, recursively, starting at
C<directory>, placing the resulting list in the external file called
C<files>.

This command works the same way as C<guestfs_find> with the following
exceptions:

=over 4

=item *

The resulting list is written to an external file.

=item *

Items (filenames) in the result are separated by C<\0> characters.  See
L<find(1)> option I<-print0>.

=item *

This command is not limited in the number of names that it can return.

=item *

The result list is not sorted.

=back

This function returns 0 on success or -1 on error.

(Added in 1.0.74)

=head2 guestfs_findfs_label

 char *
 guestfs_findfs_label (guestfs_h *g,
                       const char *label);

This command searches the filesystems and returns the one which has the
given label.  An error is returned if no such filesystem can be found.

To find the label of a filesystem, use C<guestfs_vfs_label>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_findfs_uuid

 char *
 guestfs_findfs_uuid (guestfs_h *g,
                      const char *uuid);

This command searches the filesystems and returns the one which has the
given UUID.  An error is returned if no such filesystem can be found.

To find the UUID of a filesystem, use C<guestfs_vfs_uuid>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_fsck

 int
 guestfs_fsck (guestfs_h *g,
               const char *fstype,
               const char *device);

This runs the filesystem checker (fsck) on C<device> which should have
filesystem type C<fstype>.

The returned integer is the status.  See L<fsck(8)> for the list of status
codes from C<fsck>.

Нотатки:

=over 4

=item *

Multiple status codes can be summed together.

=item *

A non-zero return code can mean "success", for example if errors have been
corrected on the filesystem.

=item *

Checking or repairing NTFS volumes is not supported (by linux-ntfs).

=back

This command is entirely equivalent to running C<fsck -a -t fstype device>.

On error this function returns -1.

(Added in 1.0.16)

=head2 guestfs_get_append

 const char *
 guestfs_get_append (guestfs_h *g);

Return the additional kernel options which are added to the guest kernel
command line.

If C<NULL> then no options are added.

This function returns a string which may be NULL.  There is no way to return
an error from this function.  The string is owned by the guest handle and
must I<not> be freed.

(Added in 1.0.26)

=head2 guestfs_get_attach_method

 char *
 guestfs_get_attach_method (guestfs_h *g);

Return the current attach method.  See C<guestfs_set_attach_method>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.9.8)

=head2 guestfs_get_autosync

 int
 guestfs_get_autosync (guestfs_h *g);

Get the autosync flag.

This function returns a C truth value on success or -1 on error.

(Added in 0.3)

=head2 guestfs_get_direct

 int
 guestfs_get_direct (guestfs_h *g);

Return the direct appliance mode flag.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.72)

=head2 guestfs_get_e2label

 char *
 guestfs_get_e2label (guestfs_h *g,
                      const char *device);

This returns the ext2/3/4 filesystem label of the filesystem on C<device>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

This function is deprecated.  In new code, use the L</guestfs_vfs_label>
call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.15)

=head2 guestfs_get_e2uuid

 char *
 guestfs_get_e2uuid (guestfs_h *g,
                     const char *device);

This returns the ext2/3/4 filesystem UUID of the filesystem on C<device>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

This function is deprecated.  In new code, use the L</guestfs_vfs_uuid> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.15)

=head2 guestfs_get_memsize

 int
 guestfs_get_memsize (guestfs_h *g);

This gets the memory size in megabytes allocated to the qemu subprocess.

If C<guestfs_set_memsize> was not called on this handle, and if
C<LIBGUESTFS_MEMSIZE> was not set, then this returns the compiled-in default
value for memsize.

For more information on the architecture of libguestfs, see L<guestfs(3)>.

On error this function returns -1.

(Added in 1.0.55)

=head2 guestfs_get_network

 int
 guestfs_get_network (guestfs_h *g);

This returns the enable network flag.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.4)

=head2 guestfs_get_path

 const char *
 guestfs_get_path (guestfs_h *g);

Return the current search path.

This is always non-NULL.  If it wasn't set already, then this will return
the default path.

This function returns a string, or NULL on error.  The string is owned by
the guest handle and must I<not> be freed.

(Added in 0.3)

=head2 guestfs_get_pgroup

 int
 guestfs_get_pgroup (guestfs_h *g);

This returns the process group flag.

This function returns a C truth value on success or -1 on error.

(Added in 1.11.18)

=head2 guestfs_get_pid

 int
 guestfs_get_pid (guestfs_h *g);

Return the process ID of the qemu subprocess.  If there is no qemu
subprocess, then this will return an error.

This is an internal call used for debugging and testing.

On error this function returns -1.

(Added in 1.0.56)

=head2 guestfs_get_qemu

 const char *
 guestfs_get_qemu (guestfs_h *g);

Return the current qemu binary.

This is always non-NULL.  If it wasn't set already, then this will return
the default qemu binary name.

This function returns a string, or NULL on error.  The string is owned by
the guest handle and must I<not> be freed.

(Added in 1.0.6)

=head2 guestfs_get_recovery_proc

 int
 guestfs_get_recovery_proc (guestfs_h *g);

Return the recovery process enabled flag.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_get_selinux

 int
 guestfs_get_selinux (guestfs_h *g);

This returns the current setting of the selinux flag which is passed to the
appliance at boot time.  See C<guestfs_set_selinux>.

For more information on the architecture of libguestfs, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.67)

=head2 guestfs_get_state

 int
 guestfs_get_state (guestfs_h *g);

This returns the current state as an opaque integer.  This is only useful
for printing debug and internal error messages.

For more information on states, see L<guestfs(3)>.

On error this function returns -1.

(Added in 1.0.2)

=head2 guestfs_get_trace

 int
 guestfs_get_trace (guestfs_h *g);

Return the command trace flag.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.69)

=head2 guestfs_get_umask

 int
 guestfs_get_umask (guestfs_h *g);

Return the current umask.  By default the umask is C<022> unless it has been
set by calling C<guestfs_umask>.

On error this function returns -1.

(Added in 1.3.4)

=head2 guestfs_get_verbose

 int
 guestfs_get_verbose (guestfs_h *g);

This returns the verbose messages flag.

This function returns a C truth value on success or -1 on error.

(Added in 0.3)

=head2 guestfs_getcon

 char *
 guestfs_getcon (guestfs_h *g);

This gets the SELinux security context of the daemon.

See the documentation about SELINUX in L<guestfs(3)>, and C<guestfs_setcon>

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.67)

=head2 guestfs_getxattr

 char *
 guestfs_getxattr (guestfs_h *g,
                   const char *path,
                   const char *name,
                   size_t *size_r);

Get a single extended attribute from file C<path> named C<name>.  This call
follows symlinks.  If you want to lookup an extended attribute for the
symlink itself, use C<guestfs_lgetxattr>.

Normally it is better to get all extended attributes from a file in one go
by calling C<guestfs_getxattrs>.  However some Linux filesystem
implementations are buggy and do not provide a way to list out attributes.
For these filesystems (notably ntfs-3g)  you have to know the names of the
extended attributes you want in advance and call this function.

Extended attribute values are blobs of binary data.  If there is no extended
attribute named C<name>, this returns an error.

See also: C<guestfs_getxattrs>, C<guestfs_lgetxattr>, L<attr(5)>.

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

(Added in 1.7.24)

=head2 guestfs_getxattrs

 struct guestfs_xattr_list *
 guestfs_getxattrs (guestfs_h *g,
                    const char *path);

This call lists the extended attributes of the file or directory C<path>.

At the system call level, this is a combination of the L<listxattr(2)> and
L<getxattr(2)> calls.

See also: C<guestfs_lgetxattrs>, L<attr(5)>.

This function returns a C<struct guestfs_xattr_list *>, or NULL if there was
an error.  I<The caller must call C<guestfs_free_xattr_list> after use>.

(Added in 1.0.59)

=head2 guestfs_glob_expand

 char **
 guestfs_glob_expand (guestfs_h *g,
                      const char *pattern);

This command searches for all the pathnames matching C<pattern> according to
the wildcard expansion rules used by the shell.

If no paths match, then this returns an empty list (note: not an error).

It is just a wrapper around the C L<glob(3)> function with flags
C<GLOB_MARK|GLOB_BRACE>.  See that manual page for more details.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.50)

=head2 guestfs_grep

 char **
 guestfs_grep (guestfs_h *g,
               const char *regex,
               const char *path);

This calls the external C<grep> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_grepi

 char **
 guestfs_grepi (guestfs_h *g,
                const char *regex,
                const char *path);

This calls the external C<grep -i> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_grub_install

 int
 guestfs_grub_install (guestfs_h *g,
                       const char *root,
                       const char *device);

This command installs GRUB 1 (the Grand Unified Bootloader) on C<device>,
with the root directory being C<root>.

Нотатки:

=over 4

=item *

There is currently no way in the API to install grub2, which is used by most
modern Linux guests.  It is possible to run the grub2 command from the
guest, although see the caveats in L<guestfs(3)/RUNNING COMMANDS>.

=item *

This uses C<grub-install> from the host.  Unfortunately grub is not always
compatible with itself, so this only works in rather narrow circumstances.
Careful testing with each guest version is advisable.

=item *

If grub-install reports the error "No suitable drive was found in the
generated device map." it may be that you need to create a
C</boot/grub/device.map> file first that contains the mapping between grub
device names and Linux device names.  It is usually sufficient to create a
file containing:

 (hd0) /dev/vda

replacing C</dev/vda> with the name of the installation device.

=back

This function returns 0 on success or -1 on error.

(Added in 1.0.17)

=head2 guestfs_head

 char **
 guestfs_head (guestfs_h *g,
               const char *path);

This command returns up to the first 10 lines of a file as a list of
strings.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.54)

=head2 guestfs_head_n

 char **
 guestfs_head_n (guestfs_h *g,
                 int nrlines,
                 const char *path);

If the parameter C<nrlines> is a positive number, this returns the first
C<nrlines> lines of the file C<path>.

If the parameter C<nrlines> is a negative number, this returns lines from
the file C<path>, excluding the last C<nrlines> lines.

If the parameter C<nrlines> is zero, this returns an empty list.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.54)

=head2 guestfs_hexdump

 char *
 guestfs_hexdump (guestfs_h *g,
                  const char *path);

This runs C<hexdump -C> on the given C<path>.  The result is the
human-readable, canonical hex dump of the file.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.22)

=head2 guestfs_initrd_cat

 char *
 guestfs_initrd_cat (guestfs_h *g,
                     const char *initrdpath,
                     const char *filename,
                     size_t *size_r);

This command unpacks the file C<filename> from the initrd file called
C<initrdpath>.  The filename must be given I<without> the initial C</>
character.

For example, in guestfish you could use the following command to examine the
boot script (usually called C</init>)  contained in a Linux initrd or
initramfs image:

 initrd-cat /boot/initrd-<version>.img init

See also C<guestfs_initrd_list>.

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.84)

=head2 guestfs_initrd_list

 char **
 guestfs_initrd_list (guestfs_h *g,
                      const char *path);

This command lists out files contained in an initrd.

The files are listed without any initial C</> character.  The files are
listed in the order they appear (not necessarily alphabetical).  Directory
names are listed as separate items.

Old Linux kernels (2.4 and earlier) used a compressed ext2 filesystem as
initrd.  We I<only> support the newer initramfs format (compressed cpio
files).

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.54)

=head2 guestfs_inotify_add_watch

 int64_t
 guestfs_inotify_add_watch (guestfs_h *g,
                            const char *path,
                            int mask);

Watch C<path> for the events listed in C<mask>.

Note that if C<path> is a directory then events within that directory are
watched, but this does I<not> happen recursively (in subdirectories).

Note for non-C or non-Linux callers: the inotify events are defined by the
Linux kernel ABI and are listed in C</usr/include/sys/inotify.h>.

On error this function returns -1.

(Added in 1.0.66)

=head2 guestfs_inotify_close

 int
 guestfs_inotify_close (guestfs_h *g);

This closes the inotify handle which was previously opened by inotify_init.
It removes all watches, throws away any pending events, and deallocates all
resources.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_inotify_files

 char **
 guestfs_inotify_files (guestfs_h *g);

This function is a helpful wrapper around C<guestfs_inotify_read> which just
returns a list of pathnames of objects that were touched.  The returned
pathnames are sorted and deduplicated.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.66)

=head2 guestfs_inotify_init

 int
 guestfs_inotify_init (guestfs_h *g,
                       int maxevents);

This command creates a new inotify handle.  The inotify subsystem can be
used to notify events which happen to objects in the guest filesystem.

C<maxevents> is the maximum number of events which will be queued up between
calls to C<guestfs_inotify_read> or C<guestfs_inotify_files>.  If this is
passed as C<0>, then the kernel (or previously set)  default is used.  For
Linux 2.6.29 the default was 16384 events.  Beyond this limit, the kernel
throws away events, but records the fact that it threw them away by setting
a flag C<IN_Q_OVERFLOW> in the returned structure list (see
C<guestfs_inotify_read>).

Before any events are generated, you have to add some watches to the
internal watch list.  See: C<guestfs_inotify_add_watch>,
C<guestfs_inotify_rm_watch> and C<guestfs_inotify_watch_all>.

Queued up events should be read periodically by calling
C<guestfs_inotify_read> (or C<guestfs_inotify_files> which is just a helpful
wrapper around C<guestfs_inotify_read>).  If you don't read the events out
often enough then you risk the internal queue overflowing.

The handle should be closed after use by calling C<guestfs_inotify_close>.
This also removes any watches automatically.

See also L<inotify(7)> for an overview of the inotify interface as exposed
by the Linux kernel, which is roughly what we expose via libguestfs.  Note
that there is one global inotify handle per libguestfs instance.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_inotify_read

 struct guestfs_inotify_event_list *
 guestfs_inotify_read (guestfs_h *g);

Return the complete queue of events that have happened since the previous
read call.

If no events have happened, this returns an empty list.

I<Note>: In order to make sure that all events have been read, you must call
this function repeatedly until it returns an empty list.  The reason is that
the call will read events up to the maximum appliance-to-host message size
and leave remaining events in the queue.

This function returns a C<struct guestfs_inotify_event_list *>, or NULL if
there was an error.  I<The caller must call
C<guestfs_free_inotify_event_list> after use>.

(Added in 1.0.66)

=head2 guestfs_inotify_rm_watch

 int
 guestfs_inotify_rm_watch (guestfs_h *g,
                           int wd);

Remove a previously defined inotify watch.  See
C<guestfs_inotify_add_watch>.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_inspect_get_arch

 char *
 guestfs_inspect_get_arch (guestfs_h *g,
                           const char *root);

This returns the architecture of the inspected operating system.  The
possible return values are listed under C<guestfs_file_architecture>.

If the architecture could not be determined, then the string C<unknown> is
returned.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_inspect_get_distro

 char *
 guestfs_inspect_get_distro (guestfs_h *g,
                             const char *root);

This returns the distro (distribution) of the inspected operating system.

Currently defined distros are:

=over 4

=item "archlinux"

Arch Linux.

=item "centos"

CentOS.

=item "debian"

Debian.

=item "fedora"

Fedora.

=item "gentoo"

Gentoo.

=item "linuxmint"

Linux Mint.

=item "mandriva"

Mandriva.

=item "meego"

MeeGo.

=item "pardus"

Pardus.

=item "redhat-based"

Дистрибутив, що походить від Red Hat.

=item "rhel"

Red Hat Enterprise Linux.

=item "scientificlinux"

Scientific Linux.

=item "slackware"

Slackware.

=item "ubuntu"

Ubuntu.

=item "unknown"

Дистрибутив, тип якого не вдалося визначити.

=item "windows"

Windows does not have distributions.  This string is returned if the OS type
is Windows.

=back

Future versions of libguestfs may return other strings here.  The caller
should be prepared to handle any string.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_inspect_get_drive_mappings

 char **
 guestfs_inspect_get_drive_mappings (guestfs_h *g,
                                     const char *root);

This call is useful for Windows which uses a primitive system of assigning
drive letters (like "C:") to partitions.  This inspection API examines the
Windows Registry to find out how disks/partitions are mapped to drive
letters, and returns a hash table as in the example below:

 C      =>     /dev/vda2
 E      =>     /dev/vdb1
 F      =>     /dev/vdc1

Note that keys are drive letters.  For Windows, the key is case insensitive
and just contains the drive letter, without the customary colon separator
character.

In future we may support other operating systems that also used drive
letters, but the keys for those might not be case insensitive and might be
longer than 1 character.  For example in OS-9, hard drives were named C<h0>,
C<h1> etc.

For Windows guests, currently only hard drive mappings are returned.
Removable disks (eg. DVD-ROMs) are ignored.

For guests that do not use drive mappings, or if the drive mappings could
not be determined, this returns an empty hash table.

Please read L<guestfs(3)/INSPECTION> for more details.  See also
C<guestfs_inspect_get_mountpoints>, C<guestfs_inspect_get_filesystems>.

This function returns a NULL-terminated array of strings, or NULL if there
was an error.  The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.  I<The
caller must free the strings and the array after use>.

(Added in 1.9.17)

=head2 guestfs_inspect_get_filesystems

 char **
 guestfs_inspect_get_filesystems (guestfs_h *g,
                                  const char *root);

This returns a list of all the filesystems that we think are associated with
this operating system.  This includes the root filesystem, other ordinary
filesystems, and non-mounted devices like swap partitions.

In the case of a multi-boot virtual machine, it is possible for a filesystem
to be shared between operating systems.

Please read L<guestfs(3)/INSPECTION> for more details.  See also
C<guestfs_inspect_get_mountpoints>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.5.3)

=head2 guestfs_inspect_get_format

 char *
 guestfs_inspect_get_format (guestfs_h *g,
                             const char *root);

This returns the format of the inspected operating system.  You can use it
to detect install images, live CDs and similar.

Currently defined formats are:

=over 4

=item "installed"

Це встановлена операційна система.

=item "installer"

The disk image being inspected is not an installed operating system, but a
I<bootable> install disk, live CD, or similar.

=item "unknown"

The format of this disk image is not known.

=back

Future versions of libguestfs may return other strings here.  The caller
should be prepared to handle any string.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.9.4)

=head2 guestfs_inspect_get_hostname

 char *
 guestfs_inspect_get_hostname (guestfs_h *g,
                               const char *root);

This function returns the hostname of the operating system as found by
inspection of the guest's configuration files.

If the hostname could not be determined, then the string C<unknown> is
returned.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.7.9)

=head2 guestfs_inspect_get_icon

 char *
 guestfs_inspect_get_icon (guestfs_h *g,
                           const char *root,
                           size_t *size_r,
                           ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_INSPECT_GET_ICON_FAVICON, int favicon,
 GUESTFS_INSPECT_GET_ICON_HIGHQUALITY, int highquality,

This function returns an icon corresponding to the inspected operating
system.  The icon is returned as a buffer containing a PNG image (re-encoded
to PNG if necessary).

If it was not possible to get an icon this function returns a zero-length
(non-NULL) buffer.  I<Callers must check for this case>.

Libguestfs will start by looking for a file called C</etc/favicon.png> or
C<C:\etc\favicon.png> and if it has the correct format, the contents of this
file will be returned.  You can disable favicons by passing the optional
C<favicon> boolean as false (default is true).

If finding the favicon fails, then we look in other places in the guest for
a suitable icon.

If the optional C<highquality> boolean is true then only high quality icons
are returned, which means only icons of high resolution with an alpha
channel.  The default (false) is to return any icon we can, even if it is of
substandard quality.

Нотатки:

=over 4

=item *

Unlike most other inspection API calls, the guest's disks must be mounted up
before you call this, since it needs to read information from the guest
filesystem during the call.

=item *

B<Security:> The icon data comes from the untrusted guest, and should be
treated with caution.  PNG files have been known to contain exploits.
Ensure that libpng (or other relevant libraries) are fully up to date before
trying to process or display the icon.

=item *

The PNG image returned can be any size.  It might not be square.  Libguestfs
tries to return the largest, highest quality icon available.  The
application must scale the icon to the required size.

=item *

Extracting icons from Windows guests requires the external C<wrestool>
program from the C<icoutils> package, and several programs (C<bmptopnm>,
C<pnmtopng>, C<pamcut>)  from the C<netpbm> package.  These must be
installed separately.

=item *

Operating system icons are usually trademarks.  Seek legal advice before
using trademarks in applications.

=back

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

(Added in 1.11.12)

=head2 guestfs_inspect_get_icon_va

 char *
 guestfs_inspect_get_icon_va (guestfs_h *g,
                              const char *root,
                              size_t *size_r,
                              va_list args);

This is the "va_list variant" of L</guestfs_inspect_get_icon>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_inspect_get_icon_argv

 char *
 guestfs_inspect_get_icon_argv (guestfs_h *g,
                                const char *root,
                                size_t *size_r,
                                const struct guestfs_inspect_get_icon_argv *optargs);

This is the "argv variant" of L</guestfs_inspect_get_icon>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_inspect_get_major_version

 int
 guestfs_inspect_get_major_version (guestfs_h *g,
                                    const char *root);

This returns the major version number of the inspected operating system.

Windows uses a consistent versioning scheme which is I<not> reflected in the
popular public names used by the operating system.  Notably the operating
system known as "Windows 7" is really version 6.1 (ie. major = 6, minor =
1).  You can find out the real versions corresponding to releases of Windows
by consulting Wikipedia or MSDN.

If the version could not be determined, then C<0> is returned.

Please read L<guestfs(3)/INSPECTION> for more details.

On error this function returns -1.

(Added in 1.5.3)

=head2 guestfs_inspect_get_minor_version

 int
 guestfs_inspect_get_minor_version (guestfs_h *g,
                                    const char *root);

This returns the minor version number of the inspected operating system.

If the version could not be determined, then C<0> is returned.

Please read L<guestfs(3)/INSPECTION> for more details.  See also
C<guestfs_inspect_get_major_version>.

On error this function returns -1.

(Added in 1.5.3)

=head2 guestfs_inspect_get_mountpoints

 char **
 guestfs_inspect_get_mountpoints (guestfs_h *g,
                                  const char *root);

This returns a hash of where we think the filesystems associated with this
operating system should be mounted.  Callers should note that this is at
best an educated guess made by reading configuration files such as
C</etc/fstab>.  I<In particular note> that this may return filesystems which
are non-existent or not mountable and callers should be prepared to handle
or ignore failures if they try to mount them.

Each element in the returned hashtable has a key which is the path of the
mountpoint (eg. C</boot>) and a value which is the filesystem that would be
mounted there (eg. C</dev/sda1>).

Non-mounted devices such as swap devices are I<not> returned in this list.

For operating systems like Windows which still use drive letters, this call
will only return an entry for the first drive "mounted on" C</>.  For
information about the mapping of drive letters to partitions, see
C<guestfs_inspect_get_drive_mappings>.

Please read L<guestfs(3)/INSPECTION> for more details.  See also
C<guestfs_inspect_get_filesystems>.

This function returns a NULL-terminated array of strings, or NULL if there
was an error.  The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.  I<The
caller must free the strings and the array after use>.

(Added in 1.5.3)

=head2 guestfs_inspect_get_package_format

 char *
 guestfs_inspect_get_package_format (guestfs_h *g,
                                     const char *root);

This function and C<guestfs_inspect_get_package_management> return the
package format and package management tool used by the inspected operating
system.  For example for Fedora these functions would return C<rpm> (package
format) and C<yum> (package management).

This returns the string C<unknown> if we could not determine the package
format I<or> if the operating system does not have a real packaging system
(eg. Windows).

Possible strings include: C<rpm>, C<deb>, C<ebuild>, C<pisi>, C<pacman>.
Future versions of libguestfs may return other strings.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.7.5)

=head2 guestfs_inspect_get_package_management

 char *
 guestfs_inspect_get_package_management (guestfs_h *g,
                                         const char *root);

C<guestfs_inspect_get_package_format> and this function return the package
format and package management tool used by the inspected operating system.
For example for Fedora these functions would return C<rpm> (package format)
and C<yum> (package management).

This returns the string C<unknown> if we could not determine the package
management tool I<or> if the operating system does not have a real packaging
system (eg. Windows).

Possible strings include: C<yum>, C<up2date>, C<apt> (for all Debian
derivatives), C<portage>, C<pisi>, C<pacman>, C<urpmi>.  Future versions of
libguestfs may return other strings.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.7.5)

=head2 guestfs_inspect_get_product_name

 char *
 guestfs_inspect_get_product_name (guestfs_h *g,
                                   const char *root);

This returns the product name of the inspected operating system.  The
product name is generally some freeform string which can be displayed to the
user, but should not be parsed by programs.

If the product name could not be determined, then the string C<unknown> is
returned.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_inspect_get_product_variant

 char *
 guestfs_inspect_get_product_variant (guestfs_h *g,
                                      const char *root);

This returns the product variant of the inspected operating system.

For Windows guests, this returns the contents of the Registry key
C<HKLM\Software\Microsoft\Windows NT\CurrentVersion> C<InstallationType>
which is usually a string such as C<Client> or C<Server> (other values are
possible).  This can be used to distinguish consumer and enterprise versions
of Windows that have the same version number (for example, Windows 7 and
Windows 2008 Server are both version 6.1, but the former is C<Client> and
the latter is C<Server>).

For enterprise Linux guests, in future we intend this to return the product
variant such as C<Desktop>, C<Server> and so on.  But this is not
implemented at present.

If the product variant could not be determined, then the string C<unknown>
is returned.

Please read L<guestfs(3)/INSPECTION> for more details.  See also
C<guestfs_inspect_get_product_name>, C<guestfs_inspect_get_major_version>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.9.13)

=head2 guestfs_inspect_get_roots

 char **
 guestfs_inspect_get_roots (guestfs_h *g);

This function is a convenient way to get the list of root devices, as
returned from a previous call to C<guestfs_inspect_os>, but without redoing
the whole inspection process.

This returns an empty list if either no root devices were found or the
caller has not called C<guestfs_inspect_os>.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.7.3)

=head2 guestfs_inspect_get_type

 char *
 guestfs_inspect_get_type (guestfs_h *g,
                           const char *root);

This returns the type of the inspected operating system.  Currently defined
types are:

=over 4

=item "linux"

Any Linux-based operating system.

=item "windows"

Any Microsoft Windows operating system.

=item "freebsd"

FreeBSD.

=item "unknown"

The operating system type could not be determined.

=back

Future versions of libguestfs may return other strings here.  The caller
should be prepared to handle any string.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.3)

=head2 guestfs_inspect_get_windows_current_control_set

 char *
 guestfs_inspect_get_windows_current_control_set (guestfs_h *g,
                                                  const char *root);

This returns the Windows CurrentControlSet of the inspected guest.  The
CurrentControlSet is a registry key name such as C<ControlSet001>.

This call assumes that the guest is Windows and that the Registry could be
examined by inspection.  If this is not the case then an error is returned.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.9.17)

=head2 guestfs_inspect_get_windows_systemroot

 char *
 guestfs_inspect_get_windows_systemroot (guestfs_h *g,
                                         const char *root);

This returns the Windows systemroot of the inspected guest.  The systemroot
is a directory path such as C</WINDOWS>.

This call assumes that the guest is Windows and that the systemroot could be
determined by inspection.  If this is not the case then an error is
returned.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.25)

=head2 guestfs_inspect_is_live

 int
 guestfs_inspect_is_live (guestfs_h *g,
                          const char *root);

If C<guestfs_inspect_get_format> returns C<installer> (this is an install
disk), then this returns true if a live image was detected on the disk.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a C truth value on success or -1 on error.

(Added in 1.9.4)

=head2 guestfs_inspect_is_multipart

 int
 guestfs_inspect_is_multipart (guestfs_h *g,
                               const char *root);

If C<guestfs_inspect_get_format> returns C<installer> (this is an install
disk), then this returns true if the disk is part of a set.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a C truth value on success or -1 on error.

(Added in 1.9.4)

=head2 guestfs_inspect_is_netinst

 int
 guestfs_inspect_is_netinst (guestfs_h *g,
                             const char *root);

If C<guestfs_inspect_get_format> returns C<installer> (this is an install
disk), then this returns true if the disk is a network installer, ie. not a
self-contained install CD but one which is likely to require network access
to complete the install.

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a C truth value on success or -1 on error.

(Added in 1.9.4)

=head2 guestfs_inspect_list_applications

 struct guestfs_application_list *
 guestfs_inspect_list_applications (guestfs_h *g,
                                    const char *root);

Return the list of applications installed in the operating system.

I<Note:> This call works differently from other parts of the inspection
API.  You have to call C<guestfs_inspect_os>, then
C<guestfs_inspect_get_mountpoints>, then mount up the disks, before calling
this.  Listing applications is a significantly more difficult operation
which requires access to the full filesystem.  Also note that unlike the
other C<guestfs_inspect_get_*> calls which are just returning data cached in
the libguestfs handle, this call actually reads parts of the mounted
filesystems during the call.

This returns an empty list if the inspection code was not able to determine
the list of applications.

The application structure contains the following fields:

=over 4

=item C<app_name>

The name of the application.  For Red Hat-derived and Debian-derived Linux
guests, this is the package name.

=item C<app_display_name>

The display name of the application, sometimes localized to the install
language of the guest operating system.

If unavailable this is returned as an empty string C<"">.  Callers needing
to display something can use C<app_name> instead.

=item C<app_epoch>

For package managers which use epochs, this contains the epoch of the
package (an integer).  If unavailable, this is returned as C<0>.

=item C<app_version>

The version string of the application or package.  If unavailable this is
returned as an empty string C<"">.

=item C<app_release>

The release string of the application or package, for package managers that
use this.  If unavailable this is returned as an empty string C<"">.

=item C<app_install_path>

The installation path of the application (on operating systems such as
Windows which use installation paths).  This path is in the format used by
the guest operating system, it is not a libguestfs path.

If unavailable this is returned as an empty string C<"">.

=item C<app_trans_path>

The install path translated into a libguestfs path.  If unavailable this is
returned as an empty string C<"">.

=item C<app_publisher>

The name of the publisher of the application, for package managers that use
this.  If unavailable this is returned as an empty string C<"">.

=item C<app_url>

The URL (eg. upstream URL) of the application.  If unavailable this is
returned as an empty string C<"">.

=item C<app_source_package>

For packaging systems which support this, the name of the source package.
If unavailable this is returned as an empty string C<"">.

=item C<app_summary>

A short (usually one line) description of the application or package.  If
unavailable this is returned as an empty string C<"">.

=item C<app_description>

A longer description of the application or package.  If unavailable this is
returned as an empty string C<"">.

=back

Please read L<guestfs(3)/INSPECTION> for more details.

This function returns a C<struct guestfs_application_list *>, or NULL if
there was an error.  I<The caller must call C<guestfs_free_application_list>
after use>.

(Added in 1.7.8)

=head2 guestfs_inspect_os

 char **
 guestfs_inspect_os (guestfs_h *g);

This function uses other libguestfs functions and certain heuristics to
inspect the disk(s) (usually disks belonging to a virtual machine), looking
for operating systems.

The list returned is empty if no operating systems were found.

If one operating system was found, then this returns a list with a single
element, which is the name of the root filesystem of this operating system.
It is also possible for this function to return a list containing more than
one element, indicating a dual-boot or multi-boot virtual machine, with each
element being the root filesystem of one of the operating systems.

You can pass the root string(s) returned to other C<guestfs_inspect_get_*>
functions in order to query further information about each operating system,
such as the name and version.

This function uses other libguestfs features such as C<guestfs_mount_ro> and
C<guestfs_umount_all> in order to mount and unmount filesystems and look at
the contents.  This should be called with no disks currently mounted.  The
function may also use Augeas, so any existing Augeas handle will be closed.

This function cannot decrypt encrypted disks.  The caller must do that first
(supplying the necessary keys) if the disk is encrypted.

Please read L<guestfs(3)/INSPECTION> for more details.

See also C<guestfs_list_filesystems>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.5.3)

=head2 guestfs_is_blockdev

 int
 guestfs_is_blockdev (guestfs_h *g,
                      const char *path);

This returns C<true> if and only if there is a block device with the given
C<path> name.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.10)

=head2 guestfs_is_busy

 int
 guestfs_is_busy (guestfs_h *g);

This returns true iff this handle is busy processing a command (in the
C<BUSY> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.2)

=head2 guestfs_is_chardev

 int
 guestfs_is_chardev (guestfs_h *g,
                     const char *path);

This returns C<true> if and only if there is a character device with the
given C<path> name.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.10)

=head2 guestfs_is_config

 int
 guestfs_is_config (guestfs_h *g);

This returns true iff this handle is being configured (in the C<CONFIG>
state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.2)

=head2 guestfs_is_dir

 int
 guestfs_is_dir (guestfs_h *g,
                 const char *path);

This returns C<true> if and only if there is a directory with the given
C<path> name.  Note that it returns false for other objects like files.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 0.8)

=head2 guestfs_is_fifo

 int
 guestfs_is_fifo (guestfs_h *g,
                  const char *path);

This returns C<true> if and only if there is a FIFO (named pipe)  with the
given C<path> name.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.10)

=head2 guestfs_is_file

 int
 guestfs_is_file (guestfs_h *g,
                  const char *path);

This returns C<true> if and only if there is a regular file with the given
C<path> name.  Note that it returns false for other objects like
directories.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 0.8)

=head2 guestfs_is_launching

 int
 guestfs_is_launching (guestfs_h *g);

This returns true iff this handle is launching the subprocess (in the
C<LAUNCHING> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.2)

=head2 guestfs_is_lv

 int
 guestfs_is_lv (guestfs_h *g,
                const char *device);

This command tests whether C<device> is a logical volume, and returns true
iff this is the case.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.3)

=head2 guestfs_is_ready

 int
 guestfs_is_ready (guestfs_h *g);

This returns true iff this handle is ready to accept commands (in the
C<READY> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

(Added in 1.0.2)

=head2 guestfs_is_socket

 int
 guestfs_is_socket (guestfs_h *g,
                    const char *path);

This returns C<true> if and only if there is a Unix domain socket with the
given C<path> name.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.10)

=head2 guestfs_is_symlink

 int
 guestfs_is_symlink (guestfs_h *g,
                     const char *path);

This returns C<true> if and only if there is a symbolic link with the given
C<path> name.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

(Added in 1.5.10)

=head2 guestfs_is_zero

 int
 guestfs_is_zero (guestfs_h *g,
                  const char *path);

This returns true iff the file exists and the file is empty or it contains
all zero bytes.

This function returns a C truth value on success or -1 on error.

(Added in 1.11.8)

=head2 guestfs_is_zero_device

 int
 guestfs_is_zero_device (guestfs_h *g,
                         const char *device);

This returns true iff the device exists and contains all zero bytes.

Note that for large devices this can take a long time to run.

This function returns a C truth value on success or -1 on error.

(Added in 1.11.8)

=head2 guestfs_kill_subprocess

 int
 guestfs_kill_subprocess (guestfs_h *g);

This kills the qemu subprocess.  You should never need to call this.

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_launch

 int
 guestfs_launch (guestfs_h *g);

Internally libguestfs is implemented by running a virtual machine using
L<qemu(1)>.

You should call this after configuring the handle (eg. adding drives) but
before performing any actions.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 0.3)

=head2 guestfs_lchown

 int
 guestfs_lchown (guestfs_h *g,
                 int owner,
                 int group,
                 const char *path);

Change the file owner to C<owner> and group to C<group>.  This is like
C<guestfs_chown> but if C<path> is a symlink then the link itself is
changed, not the target.

Only numeric uid and gid are supported.  If you want to use names, you will
need to locate and parse the password file yourself (Augeas support makes
this relatively easy).

This function returns 0 on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_lgetxattr

 char *
 guestfs_lgetxattr (guestfs_h *g,
                    const char *path,
                    const char *name,
                    size_t *size_r);

Get a single extended attribute from file C<path> named C<name>.  If C<path>
is a symlink, then this call returns an extended attribute from the symlink.

Normally it is better to get all extended attributes from a file in one go
by calling C<guestfs_getxattrs>.  However some Linux filesystem
implementations are buggy and do not provide a way to list out attributes.
For these filesystems (notably ntfs-3g)  you have to know the names of the
extended attributes you want in advance and call this function.

Extended attribute values are blobs of binary data.  If there is no extended
attribute named C<name>, this returns an error.

See also: C<guestfs_lgetxattrs>, C<guestfs_getxattr>, L<attr(5)>.

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

(Added in 1.7.24)

=head2 guestfs_lgetxattrs

 struct guestfs_xattr_list *
 guestfs_lgetxattrs (guestfs_h *g,
                     const char *path);

This is the same as C<guestfs_getxattrs>, but if C<path> is a symbolic link,
then it returns the extended attributes of the link itself.

This function returns a C<struct guestfs_xattr_list *>, or NULL if there was
an error.  I<The caller must call C<guestfs_free_xattr_list> after use>.

(Added in 1.0.59)

=head2 guestfs_list_9p

 char **
 guestfs_list_9p (guestfs_h *g);

List all 9p filesystems attached to the guest.  A list of mount tags is
returned.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.11.12)

=head2 guestfs_list_devices

 char **
 guestfs_list_devices (guestfs_h *g);

List all the block devices.

The full block device names are returned, eg. C</dev/sda>.

See also C<guestfs_list_filesystems>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.4)

=head2 guestfs_list_dm_devices

 char **
 guestfs_list_dm_devices (guestfs_h *g);

List all device mapper devices.

The returned list contains C</dev/mapper/*> devices, eg. ones created by a
previous call to C<guestfs_luks_open>.

Device mapper devices which correspond to logical volumes are I<not>
returned in this list.  Call C<guestfs_lvs> if you want to list logical
volumes.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.11.15)

=head2 guestfs_list_filesystems

 char **
 guestfs_list_filesystems (guestfs_h *g);

This inspection command looks for filesystems on partitions, block devices
and logical volumes, returning a list of devices containing filesystems and
their type.

The return value is a hash, where the keys are the devices containing
filesystems, and the values are the filesystem types.  For example:

 "/dev/sda1" => "ntfs"
 "/dev/sda2" => "ext2"
 "/dev/vg_guest/lv_root" => "ext4"
 "/dev/vg_guest/lv_swap" => "swap"

The value can have the special value "unknown", meaning the content of the
device is undetermined or empty.  "swap" means a Linux swap partition.

This command runs other libguestfs commands, which might include
C<guestfs_mount> and C<guestfs_umount>, and therefore you should use this
soon after launch and only when nothing is mounted.

Not all of the filesystems returned will be mountable.  In particular, swap
partitions are returned in the list.  Also this command does not check that
each filesystem found is valid and mountable, and some filesystems might be
mountable but require special options.  Filesystems may not all belong to a
single logical operating system (use C<guestfs_inspect_os> to look for
OSes).

This function returns a NULL-terminated array of strings, or NULL if there
was an error.  The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.  I<The
caller must free the strings and the array after use>.

(Added in 1.5.15)

=head2 guestfs_list_partitions

 char **
 guestfs_list_partitions (guestfs_h *g);

List all the partitions detected on all block devices.

The full partition device names are returned, eg. C</dev/sda1>

This does not return logical volumes.  For that you will need to call
C<guestfs_lvs>.

See also C<guestfs_list_filesystems>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.4)

=head2 guestfs_ll

 char *
 guestfs_ll (guestfs_h *g,
             const char *directory);

List the files in C<directory> (relative to the root directory, there is no
cwd) in the format of 'ls -la'.

This command is mostly useful for interactive sessions.  It is I<not>
intended that you try to parse the output string.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 0.4)

=head2 guestfs_ln

 int
 guestfs_ln (guestfs_h *g,
             const char *target,
             const char *linkname);

This command creates a hard link using the C<ln> command.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_ln_f

 int
 guestfs_ln_f (guestfs_h *g,
               const char *target,
               const char *linkname);

This command creates a hard link using the C<ln -f> command.  The I<-f>
option removes the link (C<linkname>) if it exists already.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_ln_s

 int
 guestfs_ln_s (guestfs_h *g,
               const char *target,
               const char *linkname);

This command creates a symbolic link using the C<ln -s> command.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_ln_sf

 int
 guestfs_ln_sf (guestfs_h *g,
                const char *target,
                const char *linkname);

This command creates a symbolic link using the C<ln -sf> command, The I<-f>
option removes the link (C<linkname>) if it exists already.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_lremovexattr

 int
 guestfs_lremovexattr (guestfs_h *g,
                       const char *xattr,
                       const char *path);

This is the same as C<guestfs_removexattr>, but if C<path> is a symbolic
link, then it removes an extended attribute of the link itself.

This function returns 0 on success or -1 on error.

(Added in 1.0.59)

=head2 guestfs_ls

 char **
 guestfs_ls (guestfs_h *g,
             const char *directory);

List the files in C<directory> (relative to the root directory, there is no
cwd).  The '.' and '..' entries are not returned, but hidden files are
shown.

This command is mostly useful for interactive sessions.  Programs should
probably use C<guestfs_readdir> instead.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.4)

=head2 guestfs_lsetxattr

 int
 guestfs_lsetxattr (guestfs_h *g,
                    const char *xattr,
                    const char *val,
                    int vallen,
                    const char *path);

This is the same as C<guestfs_setxattr>, but if C<path> is a symbolic link,
then it sets an extended attribute of the link itself.

This function returns 0 on success or -1 on error.

(Added in 1.0.59)

=head2 guestfs_lstat

 struct guestfs_stat *
 guestfs_lstat (guestfs_h *g,
                const char *path);

Returns file information for the given C<path>.

This is the same as C<guestfs_stat> except that if C<path> is a symbolic
link, then the link is stat-ed, not the file it refers to.

This is the same as the C<lstat(2)> system call.

This function returns a C<struct guestfs_stat *>, or NULL if there was an
error.  I<The caller must call C<guestfs_free_stat> after use>.

(Додано у 0.9.2)

=head2 guestfs_lstatlist

 struct guestfs_stat_list *
 guestfs_lstatlist (guestfs_h *g,
                    const char *path,
                    char *const *names);

This call allows you to perform the C<guestfs_lstat> operation on multiple
files, where all files are in the directory C<path>.  C<names> is the list
of files from this directory.

On return you get a list of stat structs, with a one-to-one correspondence
to the C<names> list.  If any name did not exist or could not be lstat'd,
then the C<ino> field of that structure is set to C<-1>.

This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also C<guestfs_lxattrlist>
for a similarly efficient call for getting extended attributes.  Very long
directory listings might cause the protocol message size to be exceeded,
causing this call to fail.  The caller must split up such requests into
smaller groups of names.

This function returns a C<struct guestfs_stat_list *>, or NULL if there was
an error.  I<The caller must call C<guestfs_free_stat_list> after use>.

(Added in 1.0.77)

=head2 guestfs_luks_add_key

 int
 guestfs_luks_add_key (guestfs_h *g,
                       const char *device,
                       const char *key,
                       const char *newkey,
                       int keyslot);

This command adds a new key on LUKS device C<device>.  C<key> is any
existing key, and is used to access the device.  C<newkey> is the new key to
add.  C<keyslot> is the key slot that will be replaced.

Note that if C<keyslot> already contains a key, then this command will
fail.  You have to use C<guestfs_luks_kill_slot> first to remove that key.

This function returns 0 on success or -1 on error.

This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section L</KEYS AND PASSPHRASES> for more
information.

(Додано у 1.5.2)

=head2 guestfs_luks_close

 int
 guestfs_luks_close (guestfs_h *g,
                     const char *device);

This closes a LUKS device that was created earlier by C<guestfs_luks_open>
or C<guestfs_luks_open_ro>.  The C<device> parameter must be the name of the
LUKS mapping device (ie. C</dev/mapper/mapname>) and I<not> the name of the
underlying block device.

This function returns 0 on success or -1 on error.

(Додано у 1.5.1)

=head2 guestfs_luks_format

 int
 guestfs_luks_format (guestfs_h *g,
                      const char *device,
                      const char *key,
                      int keyslot);

This command erases existing data on C<device> and formats the device as a
LUKS encrypted device.  C<key> is the initial key, which is added to key
slot C<slot>.  (LUKS supports 8 key slots, numbered 0-7).

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section L</KEYS AND PASSPHRASES> for more
information.

(Додано у 1.5.2)

=head2 guestfs_luks_format_cipher

 int
 guestfs_luks_format_cipher (guestfs_h *g,
                             const char *device,
                             const char *key,
                             int keyslot,
                             const char *cipher);

This command is the same as C<guestfs_luks_format> but it also allows you to
set the C<cipher> used.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section L</KEYS AND PASSPHRASES> for more
information.

(Додано у 1.5.2)

=head2 guestfs_luks_kill_slot

 int
 guestfs_luks_kill_slot (guestfs_h *g,
                         const char *device,
                         const char *key,
                         int keyslot);

This command deletes the key in key slot C<keyslot> from the encrypted LUKS
device C<device>.  C<key> must be one of the I<other> keys.

This function returns 0 on success or -1 on error.

This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section L</KEYS AND PASSPHRASES> for more
information.

(Додано у 1.5.2)

=head2 guestfs_luks_open

 int
 guestfs_luks_open (guestfs_h *g,
                    const char *device,
                    const char *key,
                    const char *mapname);

This command opens a block device which has been encrypted according to the
Linux Unified Key Setup (LUKS) standard.

C<device> is the encrypted block device or partition.

The caller must supply one of the keys associated with the LUKS block
device, in the C<key> parameter.

This creates a new block device called C</dev/mapper/mapname>.  Reads and
writes to this block device are decrypted from and encrypted to the
underlying C<device> respectively.

If this block device contains LVM volume groups, then calling
C<guestfs_vgscan> followed by C<guestfs_vg_activate_all> will make them
visible.

Use C<guestfs_list_dm_devices> to list all device mapper devices.

This function returns 0 on success or -1 on error.

This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section L</KEYS AND PASSPHRASES> for more
information.

(Додано у 1.5.1)

=head2 guestfs_luks_open_ro

 int
 guestfs_luks_open_ro (guestfs_h *g,
                       const char *device,
                       const char *key,
                       const char *mapname);

This is the same as C<guestfs_luks_open> except that a read-only mapping is
created.

This function returns 0 on success or -1 on error.

This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section L</KEYS AND PASSPHRASES> for more
information.

(Додано у 1.5.1)

=head2 guestfs_lvcreate

 int
 guestfs_lvcreate (guestfs_h *g,
                   const char *logvol,
                   const char *volgroup,
                   int mbytes);

This creates an LVM logical volume called C<logvol> on the volume group
C<volgroup>, with C<size> megabytes.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_lvm_canonical_lv_name

 char *
 guestfs_lvm_canonical_lv_name (guestfs_h *g,
                                const char *lvname);

This converts alternative naming schemes for LVs that you might find to the
canonical name.  For example, C</dev/mapper/VG-LV> is converted to
C</dev/VG/LV>.

This command returns an error if the C<lvname> parameter does not refer to a
logical volume.

See also C<guestfs_is_lv>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Додано у 1.5.24)

=head2 guestfs_lvm_clear_filter

 int
 guestfs_lvm_clear_filter (guestfs_h *g);

This undoes the effect of C<guestfs_lvm_set_filter>.  LVM will be able to
see every block device.

This command also clears the LVM cache and performs a volume group scan.

This function returns 0 on success or -1 on error.

(Додано у 1.5.1)

=head2 guestfs_lvm_remove_all

 int
 guestfs_lvm_remove_all (guestfs_h *g);

This command removes all LVM logical volumes, volume groups and physical
volumes.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

(Added in 0.8)

=head2 guestfs_lvm_set_filter

 int
 guestfs_lvm_set_filter (guestfs_h *g,
                         char *const *devices);

This sets the LVM device filter so that LVM will only be able to "see" the
block devices in the list C<devices>, and will ignore all other attached
block devices.

Where disk image(s) contain duplicate PVs or VGs, this command is useful to
get LVM to ignore the duplicates, otherwise LVM can get confused.  Note also
there are two types of duplication possible: either cloned PVs/VGs which
have identical UUIDs; or VGs that are not cloned but just happen to have the
same name.  In normal operation you cannot create this situation, but you
can do it outside LVM, eg.  by cloning disk images or by bit twiddling
inside the LVM metadata.

This command also clears the LVM cache and performs a volume group scan.

You can filter whole block devices or individual partitions.

You cannot use this if any VG is currently in use (eg.  contains a mounted
filesystem), even if you are not filtering out that VG.

This function returns 0 on success or -1 on error.

(Додано у 1.5.1)

=head2 guestfs_lvremove

 int
 guestfs_lvremove (guestfs_h *g,
                   const char *device);

Remove an LVM logical volume C<device>, where C<device> is the path to the
LV, such as C</dev/VG/LV>.

You can also remove all LVs in a volume group by specifying the VG name,
C</dev/VG>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.13)

=head2 guestfs_lvrename

 int
 guestfs_lvrename (guestfs_h *g,
                   const char *logvol,
                   const char *newlogvol);

Rename a logical volume C<logvol> with the new name C<newlogvol>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.83)

=head2 guestfs_lvresize

 int
 guestfs_lvresize (guestfs_h *g,
                   const char *device,
                   int mbytes);

This resizes (expands or shrinks) an existing LVM logical volume to
C<mbytes>.  When reducing, data in the reduced part is lost.

This function returns 0 on success or -1 on error.

(Added in 1.0.27)

=head2 guestfs_lvresize_free

 int
 guestfs_lvresize_free (guestfs_h *g,
                        const char *lv,
                        int percent);

This expands an existing logical volume C<lv> so that it fills C<pc>% of the
remaining free space in the volume group.  Commonly you would call this with
pc = 100 which expands the logical volume as much as possible, using all
remaining free space in the volume group.

This function returns 0 on success or -1 on error.

(Додано у 1.3.3)

=head2 guestfs_lvs

 char **
 guestfs_lvs (guestfs_h *g);

List all the logical volumes detected.  This is the equivalent of the
L<lvs(8)> command.

This returns a list of the logical volume device names
(eg. C</dev/VolGroup00/LogVol00>).

See also C<guestfs_lvs_full>, C<guestfs_list_filesystems>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.4)

=head2 guestfs_lvs_full

 struct guestfs_lvm_lv_list *
 guestfs_lvs_full (guestfs_h *g);

List all the logical volumes detected.  This is the equivalent of the
L<lvs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_lv_list *>, or NULL if there
was an error.  I<The caller must call C<guestfs_free_lvm_lv_list> after
use>.

(Added in 0.4)

=head2 guestfs_lvuuid

 char *
 guestfs_lvuuid (guestfs_h *g,
                 const char *device);

This command returns the UUID of the LVM LV C<device>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.87)

=head2 guestfs_lxattrlist

 struct guestfs_xattr_list *
 guestfs_lxattrlist (guestfs_h *g,
                     const char *path,
                     char *const *names);

This call allows you to get the extended attributes of multiple files, where
all files are in the directory C<path>.  C<names> is the list of files from
this directory.

On return you get a flat list of xattr structs which must be interpreted
sequentially.  The first xattr struct always has a zero-length C<attrname>.
C<attrval> in this struct is zero-length to indicate there was an error
doing C<lgetxattr> for this file, I<or> is a C string which is a decimal
number (the number of following attributes for this file, which could be
C<"0">).  Then after the first xattr struct are the zero or more attributes
for the first named file.  This repeats for the second and subsequent files.

This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also C<guestfs_lstatlist> for
a similarly efficient call for getting standard stats.  Very long directory
listings might cause the protocol message size to be exceeded, causing this
call to fail.  The caller must split up such requests into smaller groups of
names.

This function returns a C<struct guestfs_xattr_list *>, or NULL if there was
an error.  I<The caller must call C<guestfs_free_xattr_list> after use>.

(Added in 1.0.77)

=head2 guestfs_mkdir

 int
 guestfs_mkdir (guestfs_h *g,
                const char *path);

Create a directory named C<path>.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_mkdir_mode

 int
 guestfs_mkdir_mode (guestfs_h *g,
                     const char *path,
                     int mode);

This command creates a directory, setting the initial permissions of the
directory to C<mode>.

For common Linux filesystems, the actual mode which is set will be C<mode &
~umask & 01777>.  Non-native-Linux filesystems may interpret the mode in
other ways.

See also C<guestfs_mkdir>, C<guestfs_umask>

This function returns 0 on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_mkdir_p

 int
 guestfs_mkdir_p (guestfs_h *g,
                  const char *path);

Create a directory named C<path>, creating any parent directories as
necessary.  This is like the C<mkdir -p> shell command.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_mkdtemp

 char *
 guestfs_mkdtemp (guestfs_h *g,
                  const char *template);

This command creates a temporary directory.  The C<template> parameter
should be a full pathname for the temporary directory name with the final
six characters being "XXXXXX".

For example: "/tmp/myprogXXXXXX" or "/Temp/myprogXXXXXX", the second one
being suitable for Windows filesystems.

The name of the temporary directory that was created is returned.

The temporary directory is created with mode 0700 and is owned by root.

The caller is responsible for deleting the temporary directory and its
contents after use.

See also: L<mkdtemp(3)>

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.54)

=head2 guestfs_mke2fs_J

 int
 guestfs_mke2fs_J (guestfs_h *g,
                   const char *fstype,
                   int blocksize,
                   const char *device,
                   const char *journal);

This creates an ext2/3/4 filesystem on C<device> with an external journal on
C<journal>.  It is equivalent to the command:

 mke2fs -t fstype -b blocksize -J device=<журнал> <пристрій>

See also C<guestfs_mke2journal>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mke2fs_JL

 int
 guestfs_mke2fs_JL (guestfs_h *g,
                    const char *fstype,
                    int blocksize,
                    const char *device,
                    const char *label);

This creates an ext2/3/4 filesystem on C<device> with an external journal on
the journal labeled C<label>.

See also C<guestfs_mke2journal_L>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mke2fs_JU

 int
 guestfs_mke2fs_JU (guestfs_h *g,
                    const char *fstype,
                    int blocksize,
                    const char *device,
                    const char *uuid);

This creates an ext2/3/4 filesystem on C<device> with an external journal on
the journal with UUID C<uuid>.

See also C<guestfs_mke2journal_U>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mke2journal

 int
 guestfs_mke2journal (guestfs_h *g,
                      int blocksize,
                      const char *device);

This creates an ext2 external journal on C<device>.  It is equivalent to the
command:

 mke2fs -O journal_dev -b blocksize device

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mke2journal_L

 int
 guestfs_mke2journal_L (guestfs_h *g,
                        int blocksize,
                        const char *label,
                        const char *device);

This creates an ext2 external journal on C<device> with label C<label>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mke2journal_U

 int
 guestfs_mke2journal_U (guestfs_h *g,
                        int blocksize,
                        const char *uuid,
                        const char *device);

This creates an ext2 external journal on C<device> with UUID C<uuid>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mkfifo

 int
 guestfs_mkfifo (guestfs_h *g,
                 int mode,
                 const char *path);

This call creates a FIFO (named pipe) called C<path> with mode C<mode>.  It
is just a convenient wrapper around C<guestfs_mknod>.

The mode actually set is affected by the umask.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mkfs

 int
 guestfs_mkfs (guestfs_h *g,
               const char *fstype,
               const char *device);

This creates a filesystem on C<device> (usually a partition or LVM logical
volume).  The filesystem type is C<fstype>, for example C<ext3>.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_mkfs_b

 int
 guestfs_mkfs_b (guestfs_h *g,
                 const char *fstype,
                 int blocksize,
                 const char *device);

This call is similar to C<guestfs_mkfs>, but it allows you to control the
block size of the resulting filesystem.  Supported block sizes depend on the
filesystem type, but typically they are C<1024>, C<2048> or C<4096> only.

For VFAT and NTFS the C<blocksize> parameter is treated as the requested
cluster size.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the L</guestfs_mkfs_opts>
call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Додано у 1.0.68)

=head2 guestfs_mkfs_opts

 int
 guestfs_mkfs_opts (guestfs_h *g,
                    const char *fstype,
                    const char *device,
                    ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_MKFS_OPTS_BLOCKSIZE, int blocksize,
 GUESTFS_MKFS_OPTS_FEATURES, const char *features,
 GUESTFS_MKFS_OPTS_INODE, int inode,
 GUESTFS_MKFS_OPTS_SECTORSIZE, int sectorsize,

This function creates a filesystem on C<device>.  The filesystem type is
C<fstype>, for example C<ext3>.

The optional arguments are:

=over 4

=item C<blocksize>

The filesystem block size.  Supported block sizes depend on the filesystem
type, but typically they are C<1024>, C<2048> or C<4096> for Linux ext2/3
filesystems.

For VFAT and NTFS the C<blocksize> parameter is treated as the requested
cluster size.

For UFS block sizes, please see L<mkfs.ufs(8)>.

=item C<features>

This passes the I<-O> parameter to the external mkfs program.

For certain filesystem types, this allows extra filesystem features to be
selected.  See L<mke2fs(8)> and L<mkfs.ufs(8)> for more details.

You cannot use this optional parameter with the C<gfs> or C<gfs2> filesystem
type.

=item C<inode>

This passes the I<-I> parameter to the external L<mke2fs(8)> program which
sets the inode size (only for ext2/3/4 filesystems at present).

=item C<sectorsize>

This passes the I<-S> parameter to external L<mkfs.ufs(8)> program, which
sets sector size for ufs filesystem.

=back

This function returns 0 on success or -1 on error.

(Додано у 1.7.19)

=head2 guestfs_mkfs_opts_va

 int
 guestfs_mkfs_opts_va (guestfs_h *g,
                       const char *fstype,
                       const char *device,
                       va_list args);

This is the "va_list variant" of L</guestfs_mkfs_opts>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_mkfs_opts_argv

 int
 guestfs_mkfs_opts_argv (guestfs_h *g,
                         const char *fstype,
                         const char *device,
                         const struct guestfs_mkfs_opts_argv *optargs);

This is the "argv variant" of L</guestfs_mkfs_opts>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_mkmountpoint

 int
 guestfs_mkmountpoint (guestfs_h *g,
                       const char *exemptpath);

C<guestfs_mkmountpoint> and C<guestfs_rmmountpoint> are specialized calls
that can be used to create extra mountpoints before mounting the first
filesystem.

These calls are I<only> necessary in some very limited circumstances, mainly
the case where you want to mount a mix of unrelated and/or read-only
filesystems together.

For example, live CDs often contain a "Russian doll" nest of filesystems, an
ISO outer layer, with a squashfs image inside, with an ext2/3 image inside
that.  You can unpack this as follows in guestfish:

 add-ro Fedora-11-i686-Live.iso
 run
 mkmountpoint /cd
 mkmountpoint /sqsh
 mkmountpoint /ext3fs
 mount /dev/sda /cd
 mount-loop /cd/LiveOS/squashfs.img /sqsh
 mount-loop /sqsh/LiveOS/ext3fs.img /ext3fs

The inner filesystem is now unpacked under the /ext3fs mountpoint.

C<guestfs_mkmountpoint> is not compatible with C<guestfs_umount_all>.  You
may get unexpected errors if you try to mix these calls.  It is safest to
manually unmount filesystems and remove mountpoints after use.

C<guestfs_umount_all> unmounts filesystems by sorting the paths longest
first, so for this to work for manual mountpoints, you must ensure that the
innermost mountpoints have the longest pathnames, as in the example code
above.

For more details see L<https://bugzilla.redhat.com/show_bug.cgi?id=599503>

Autosync [see C<guestfs_set_autosync>, this is set by default on handles]
can cause C<guestfs_umount_all> to be called when the handle is closed which
can also trigger these issues.

This function returns 0 on success or -1 on error.

(Додано у 1.0.62)

=head2 guestfs_mknod

 int
 guestfs_mknod (guestfs_h *g,
                int mode,
                int devmajor,
                int devminor,
                const char *path);

This call creates block or character special devices, or named pipes
(FIFOs).

The C<mode> parameter should be the mode, using the standard constants.
C<devmajor> and C<devminor> are the device major and minor numbers, only
used when creating block and character special devices.

Note that, just like L<mknod(2)>, the mode must be bitwise OR'd with
S_IFBLK, S_IFCHR, S_IFIFO or S_IFSOCK (otherwise this call just creates a
regular file).  These constants are available in the standard Linux header
files, or you can use C<guestfs_mknod_b>, C<guestfs_mknod_c> or
C<guestfs_mkfifo> which are wrappers around this command which bitwise OR in
the appropriate constant for you.

The mode actually set is affected by the umask.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mknod_b

 int
 guestfs_mknod_b (guestfs_h *g,
                  int mode,
                  int devmajor,
                  int devminor,
                  const char *path);

This call creates a block device node called C<path> with mode C<mode> and
device major/minor C<devmajor> and C<devminor>.  It is just a convenient
wrapper around C<guestfs_mknod>.

The mode actually set is affected by the umask.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mknod_c

 int
 guestfs_mknod_c (guestfs_h *g,
                  int mode,
                  int devmajor,
                  int devminor,
                  const char *path);

This call creates a char device node called C<path> with mode C<mode> and
device major/minor C<devmajor> and C<devminor>.  It is just a convenient
wrapper around C<guestfs_mknod>.

The mode actually set is affected by the umask.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mkswap

 int
 guestfs_mkswap (guestfs_h *g,
                 const char *device);

Create a swap partition on C<device>.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mkswap_L

 int
 guestfs_mkswap_L (guestfs_h *g,
                   const char *label,
                   const char *device);

Create a swap partition on C<device> with label C<label>.

Note that you cannot attach a swap label to a block device
(eg. C</dev/sda>), just to a partition.  This appears to be a limitation of
the kernel or swap tools.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mkswap_U

 int
 guestfs_mkswap_U (guestfs_h *g,
                   const char *uuid,
                   const char *device);

Create a swap partition on C<device> with UUID C<uuid>.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_mkswap_file

 int
 guestfs_mkswap_file (guestfs_h *g,
                      const char *path);

Створити файл резервної пам’яті.

This command just writes a swap file signature to an existing file.  To
create the file itself, use something like C<guestfs_fallocate>.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_modprobe

 int
 guestfs_modprobe (guestfs_h *g,
                   const char *modulename);

This loads a kernel module in the appliance.

The kernel module must have been whitelisted when libguestfs was built (see
C<appliance/kmod.whitelist.in> in the source).

This function returns 0 on success or -1 on error.

(Додано у 1.0.68)

=head2 guestfs_mount

 int
 guestfs_mount (guestfs_h *g,
                const char *device,
                const char *mountpoint);

Mount a guest disk at a position in the filesystem.  Block devices are named
C</dev/sda>, C</dev/sdb> and so on, as they were added to the guest.  If
those block devices contain partitions, they will have the usual names
(eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style names can be used.

The rules are the same as for L<mount(2)>: A filesystem must first be
mounted on C</> before others can be mounted.  Other filesystems can only be
mounted on directories which already exist.

The mounted filesystem is writable, if we have sufficient permissions on the
underlying device.

B<Important note:> When you use this call, the filesystem options C<sync>
and C<noatime> are set implicitly.  This was originally done because we
thought it would improve reliability, but it turns out that I<-o sync> has a
very large negative performance impact and negligible effect on
reliability.  Therefore we recommend that you avoid using C<guestfs_mount>
in any code that needs performance, and instead use C<guestfs_mount_options>
(use an empty string for the first parameter if you don't want any options).

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the L</guestfs_mount_options>
call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 0.3)

=head2 guestfs_mount_9p

 int
 guestfs_mount_9p (guestfs_h *g,
                   const char *mounttag,
                   const char *mountpoint,
                   ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_MOUNT_9P_OPTIONS, const char *options,

Mount the virtio-9p filesystem with the tag C<mounttag> on the directory
C<mountpoint>.

If required, C<trans=virtio> will be automatically added to the options.
Any other options required can be passed in the optional C<options>
parameter.

This function returns 0 on success or -1 on error.

(Added in 1.11.12)

=head2 guestfs_mount_9p_va

 int
 guestfs_mount_9p_va (guestfs_h *g,
                      const char *mounttag,
                      const char *mountpoint,
                      va_list args);

This is the "va_list variant" of L</guestfs_mount_9p>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_mount_9p_argv

 int
 guestfs_mount_9p_argv (guestfs_h *g,
                        const char *mounttag,
                        const char *mountpoint,
                        const struct guestfs_mount_9p_argv *optargs);

This is the "argv variant" of L</guestfs_mount_9p>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_mount_loop

 int
 guestfs_mount_loop (guestfs_h *g,
                     const char *file,
                     const char *mountpoint);

This command lets you mount C<file> (a filesystem image in a file) on a
mount point.  It is entirely equivalent to the command C<mount -o loop file
mountpoint>.

This function returns 0 on success or -1 on error.

(Added in 1.0.54)

=head2 guestfs_mount_options

 int
 guestfs_mount_options (guestfs_h *g,
                        const char *options,
                        const char *device,
                        const char *mountpoint);

This is the same as the C<guestfs_mount> command, but it allows you to set
the mount options as for the L<mount(8)> I<-o> flag.

If the C<options> parameter is an empty string, then no options are passed
(all options default to whatever the filesystem uses).

This function returns 0 on success or -1 on error.

(Added in 1.0.10)

=head2 guestfs_mount_ro

 int
 guestfs_mount_ro (guestfs_h *g,
                   const char *device,
                   const char *mountpoint);

This is the same as the C<guestfs_mount> command, but it mounts the
filesystem with the read-only (I<-o ro>) flag.

This function returns 0 on success or -1 on error.

(Added in 1.0.10)

=head2 guestfs_mount_vfs

 int
 guestfs_mount_vfs (guestfs_h *g,
                    const char *options,
                    const char *vfstype,
                    const char *device,
                    const char *mountpoint);

This is the same as the C<guestfs_mount> command, but it allows you to set
both the mount options and the vfstype as for the L<mount(8)> I<-o> and
I<-t> flags.

This function returns 0 on success or -1 on error.

(Added in 1.0.10)

=head2 guestfs_mountpoints

 char **
 guestfs_mountpoints (guestfs_h *g);

This call is similar to C<guestfs_mounts>.  That call returns a list of
devices.  This one returns a hash table (map) of device name to directory
where the device is mounted.

This function returns a NULL-terminated array of strings, or NULL if there
was an error.  The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.  I<The
caller must free the strings and the array after use>.

(Додано у 1.0.62)

=head2 guestfs_mounts

 char **
 guestfs_mounts (guestfs_h *g);

This returns the list of currently mounted filesystems.  It returns the list
of devices (eg. C</dev/sda1>, C</dev/VG/LV>).

Some internal mounts are not shown.

See also: C<guestfs_mountpoints>

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.8)

=head2 guestfs_mv

 int
 guestfs_mv (guestfs_h *g,
             const char *src,
             const char *dest);

This moves a file from C<src> to C<dest> where C<dest> is either a
destination filename or destination directory.

This function returns 0 on success or -1 on error.

(Added in 1.0.18)

=head2 guestfs_ntfs_3g_probe

 int
 guestfs_ntfs_3g_probe (guestfs_h *g,
                        int rw,
                        const char *device);

This command runs the L<ntfs-3g.probe(8)> command which probes an NTFS
C<device> for mountability.  (Not all NTFS volumes can be mounted
read-write, and some cannot be mounted at all).

C<rw> is a boolean flag.  Set it to true if you want to test if the volume
can be mounted read-write.  Set it to false if you want to test if the
volume can be mounted read-only.

The return value is an integer which C<0> if the operation would succeed, or
some non-zero value documented in the L<ntfs-3g.probe(8)> manual page.

On error this function returns -1.

(Added in 1.0.43)

=head2 guestfs_ntfsresize

 int
 guestfs_ntfsresize (guestfs_h *g,
                     const char *device);

This command resizes an NTFS filesystem, expanding or shrinking it to the
size of the underlying device.

I<Note:> After the resize operation, the filesystem is marked as requiring a
consistency check (for safety).  You have to boot into Windows to perform
this check and clear this condition.  Furthermore, ntfsresize refuses to
resize filesystems which have been marked in this way.  So in effect it is
not possible to call ntfsresize multiple times on a single filesystem
without booting into Windows between each resize.

See also L<ntfsresize(8)>.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the
L</guestfs_ntfsresize_opts> call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.3.2)

=head2 guestfs_ntfsresize_opts

 int
 guestfs_ntfsresize_opts (guestfs_h *g,
                          const char *device,
                          ...);

You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with C<-1> on
its own.  See L</CALLS WITH OPTIONAL ARGUMENTS>.

 GUESTFS_NTFSRESIZE_OPTS_SIZE, int64_t size,
 GUESTFS_NTFSRESIZE_OPTS_FORCE, int force,

This command resizes an NTFS filesystem, expanding or shrinking it to the
size of the underlying device.

The optional parameters are:

=over 4

=item C<size>

The new size (in bytes) of the filesystem.  If omitted, the filesystem is
resized to fit the container (eg. partition).

=item C<force>

If this option is true, then force the resize of the filesystem even if the
filesystem is marked as requiring a consistency check.

After the resize operation, the filesystem is always marked as requiring a
consistency check (for safety).  You have to boot into Windows to perform
this check and clear this condition.  If you I<don't> set the C<force>
option then it is not possible to call C<guestfs_ntfsresize_opts> multiple
times on a single filesystem without booting into Windows between each
resize.

=back

See also L<ntfsresize(8)>.

This function returns 0 on success or -1 on error.

(Added in 1.11.15)

=head2 guestfs_ntfsresize_opts_va

 int
 guestfs_ntfsresize_opts_va (guestfs_h *g,
                             const char *device,
                             va_list args);

This is the "va_list variant" of L</guestfs_ntfsresize_opts>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_ntfsresize_opts_argv

 int
 guestfs_ntfsresize_opts_argv (guestfs_h *g,
                               const char *device,
                               const struct guestfs_ntfsresize_opts_argv *optargs);

This is the "argv variant" of L</guestfs_ntfsresize_opts>.

Див. L</CALLS WITH OPTIONAL ARGUMENTS>.

=head2 guestfs_ntfsresize_size

 int
 guestfs_ntfsresize_size (guestfs_h *g,
                          const char *device,
                          int64_t size);

This command is the same as C<guestfs_ntfsresize> except that it allows you
to specify the new size (in bytes) explicitly.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the
L</guestfs_ntfsresize_opts> call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.3.14)

=head2 guestfs_part_add

 int
 guestfs_part_add (guestfs_h *g,
                   const char *device,
                   const char *prlogex,
                   int64_t startsect,
                   int64_t endsect);

This command adds a partition to C<device>.  If there is no partition table
on the device, call C<guestfs_part_init> first.

The C<prlogex> parameter is the type of partition.  Normally you should pass
C<p> or C<primary> here, but MBR partition tables also support C<l> (or
C<logical>) and C<e> (or C<extended>) partition types.

C<startsect> and C<endsect> are the start and end of the partition in
I<sectors>.  C<endsect> may be negative, which means it counts backwards
from the end of the disk (C<-1> is the last sector).

Creating a partition which covers the whole disk is not so easy.  Use
C<guestfs_part_disk> to do that.

This function returns 0 on success or -1 on error.

(Added in 1.0.78)

=head2 guestfs_part_del

 int
 guestfs_part_del (guestfs_h *g,
                   const char *device,
                   int partnum);

This command deletes the partition numbered C<partnum> on C<device>.

Note that in the case of MBR partitioning, deleting an extended partition
also deletes any logical partitions it contains.

This function returns 0 on success or -1 on error.

(Added in 1.3.2)

=head2 guestfs_part_disk

 int
 guestfs_part_disk (guestfs_h *g,
                    const char *device,
                    const char *parttype);

This command is simply a combination of C<guestfs_part_init> followed by
C<guestfs_part_add> to create a single primary partition covering the whole
disk.

C<parttype> is the partition table type, usually C<mbr> or C<gpt>, but other
possible values are described in C<guestfs_part_init>.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

(Added in 1.0.78)

=head2 guestfs_part_get_bootable

 int
 guestfs_part_get_bootable (guestfs_h *g,
                            const char *device,
                            int partnum);

This command returns true if the partition C<partnum> on C<device> has the
bootable flag set.

See also C<guestfs_part_set_bootable>.

This function returns a C truth value on success or -1 on error.

(Added in 1.3.2)

=head2 guestfs_part_get_mbr_id

 int
 guestfs_part_get_mbr_id (guestfs_h *g,
                          const char *device,
                          int partnum);

Returns the MBR type byte (also known as the ID byte) from the numbered
partition C<partnum>.

Note that only MBR (old DOS-style) partitions have type bytes.  You will get
undefined results for other partition table types (see
C<guestfs_part_get_parttype>).

On error this function returns -1.

(Added in 1.3.2)

=head2 guestfs_part_get_parttype

 char *
 guestfs_part_get_parttype (guestfs_h *g,
                            const char *device);

This command examines the partition table on C<device> and returns the
partition table type (format) being used.

Common return values include: C<msdos> (a DOS/Windows style MBR partition
table), C<gpt> (a GPT/EFI-style partition table).  Other values are
possible, although unusual.  See C<guestfs_part_init> for a full list.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.78)

=head2 guestfs_part_init

 int
 guestfs_part_init (guestfs_h *g,
                    const char *device,
                    const char *parttype);

This creates an empty partition table on C<device> of one of the partition
types listed below.  Usually C<parttype> should be either C<msdos> or C<gpt>
(for large disks).

Initially there are no partitions.  Following this, you should call
C<guestfs_part_add> for each partition required.

Possible values for C<parttype> are:

=over 4

=item B<efi>

=item B<gpt>

Intel EFI / GPT partition table.

This is recommended for >= 2 TB partitions that will be accessed from Linux
and Intel-based Mac OS X.  It also has limited backwards compatibility with
the C<mbr> format.

=item B<mbr>

=item B<msdos>

The standard PC "Master Boot Record" (MBR) format used by MS-DOS and
Windows.  This partition type will B<only> work for device sizes up to 2
TB.  For large disks we recommend using C<gpt>.

=back

Other partition table types that may work but are not supported include:

=over 4

=item B<aix>

Мітки дисків AIX.

=item B<amiga>

=item B<rdb>

Формат "Rigid Disk Block" Amiga.

=item B<bsd>

Мітки дисків BSD.

=item B<dasd>

DASD, використовувалися у мейнфреймах IBM.

=item B<dvh>

Томи MIPS/SGI.

=item B<mac>

Старий формат розділів Mac. Сучасні системи Mac використовують C<gpt>.

=item B<pc98>

Формат NEC PC-98, поширений у Японії.

=item B<sun>

Мітки дисків Sun.

=back

This function returns 0 on success or -1 on error.

(Added in 1.0.78)

=head2 guestfs_part_list

 struct guestfs_partition_list *
 guestfs_part_list (guestfs_h *g,
                    const char *device);

This command parses the partition table on C<device> and returns the list of
partitions found.

The fields in the returned structure are:

=over 4

=item B<part_num>

Partition number, counting from 1.

=item B<part_start>

Start of the partition I<in bytes>.  To get sectors you have to divide by
the device's sector size, see C<guestfs_blockdev_getss>.

=item B<part_end>

End of the partition in bytes.

=item B<part_size>

Size of the partition in bytes.

=back

This function returns a C<struct guestfs_partition_list *>, or NULL if there
was an error.  I<The caller must call C<guestfs_free_partition_list> after
use>.

(Added in 1.0.78)

=head2 guestfs_part_set_bootable

 int
 guestfs_part_set_bootable (guestfs_h *g,
                            const char *device,
                            int partnum,
                            int bootable);

This sets the bootable flag on partition numbered C<partnum> on device
C<device>.  Note that partitions are numbered from 1.

The bootable flag is used by some operating systems (notably Windows) to
determine which partition to boot from.  It is by no means universally
recognized.

This function returns 0 on success or -1 on error.

(Added in 1.0.78)

=head2 guestfs_part_set_mbr_id

 int
 guestfs_part_set_mbr_id (guestfs_h *g,
                          const char *device,
                          int partnum,
                          int idbyte);

Sets the MBR type byte (also known as the ID byte) of the numbered partition
C<partnum> to C<idbyte>.  Note that the type bytes quoted in most
documentation are in fact hexadecimal numbers, but usually documented
without any leading "0x" which might be confusing.

Note that only MBR (old DOS-style) partitions have type bytes.  You will get
undefined results for other partition table types (see
C<guestfs_part_get_parttype>).

This function returns 0 on success or -1 on error.

(Added in 1.3.2)

=head2 guestfs_part_set_name

 int
 guestfs_part_set_name (guestfs_h *g,
                        const char *device,
                        int partnum,
                        const char *name);

This sets the partition name on partition numbered C<partnum> on device
C<device>.  Note that partitions are numbered from 1.

The partition name can only be set on certain types of partition table.
This works on C<gpt> but not on C<mbr> partitions.

This function returns 0 on success or -1 on error.

(Added in 1.0.78)

=head2 guestfs_part_to_dev

 char *
 guestfs_part_to_dev (guestfs_h *g,
                      const char *partition);

This function takes a partition name (eg. "/dev/sdb1") and removes the
partition number, returning the device name (eg. "/dev/sdb").

The named partition must exist, for example as a string returned from
C<guestfs_list_partitions>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.5.15)

=head2 guestfs_ping_daemon

 int
 guestfs_ping_daemon (guestfs_h *g);

This is a test probe into the guestfs daemon running inside the qemu
subprocess.  Calling this function checks that the daemon responds to the
ping message, without affecting the daemon or attached block device(s) in
any other way.

This function returns 0 on success or -1 on error.

(Added in 1.0.18)

=head2 guestfs_pread

 char *
 guestfs_pread (guestfs_h *g,
                const char *path,
                int count,
                int64_t offset,
                size_t *size_r);

This command lets you read part of a file.  It reads C<count> bytes of the
file, starting at C<offset>, from file C<path>.

This may read fewer bytes than requested.  For further details see the
L<pread(2)> system call.

See also C<guestfs_pwrite>, C<guestfs_pread_device>.

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.77)

=head2 guestfs_pread_device

 char *
 guestfs_pread_device (guestfs_h *g,
                       const char *device,
                       int count,
                       int64_t offset,
                       size_t *size_r);

This command lets you read part of a file.  It reads C<count> bytes of
C<device>, starting at C<offset>.

This may read fewer bytes than requested.  For further details see the
L<pread(2)> system call.

See also C<guestfs_pread>.

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.5.21)

=head2 guestfs_pvcreate

 int
 guestfs_pvcreate (guestfs_h *g,
                   const char *device);

This creates an LVM physical volume on the named C<device>, where C<device>
should usually be a partition name such as C</dev/sda1>.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_pvremove

 int
 guestfs_pvremove (guestfs_h *g,
                   const char *device);

This wipes a physical volume C<device> so that LVM will no longer recognise
it.

The implementation uses the C<pvremove> command which refuses to wipe
physical volumes that contain any volume groups, so you have to remove those
first.

This function returns 0 on success or -1 on error.

(Додано у 1.0.13)

=head2 guestfs_pvresize

 int
 guestfs_pvresize (guestfs_h *g,
                   const char *device);

This resizes (expands or shrinks) an existing LVM physical volume to match
the new size of the underlying device.

This function returns 0 on success or -1 on error.

(Added in 1.0.26)

=head2 guestfs_pvresize_size

 int
 guestfs_pvresize_size (guestfs_h *g,
                        const char *device,
                        int64_t size);

This command is the same as C<guestfs_pvresize> except that it allows you to
specify the new size (in bytes) explicitly.

This function returns 0 on success or -1 on error.

(Added in 1.3.14)

=head2 guestfs_pvs

 char **
 guestfs_pvs (guestfs_h *g);

List all the physical volumes detected.  This is the equivalent of the
L<pvs(8)> command.

This returns a list of just the device names that contain PVs
(eg. C</dev/sda2>).

See also C<guestfs_pvs_full>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.4)

=head2 guestfs_pvs_full

 struct guestfs_lvm_pv_list *
 guestfs_pvs_full (guestfs_h *g);

List all the physical volumes detected.  This is the equivalent of the
L<pvs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_pv_list *>, or NULL if there
was an error.  I<The caller must call C<guestfs_free_lvm_pv_list> after
use>.

(Added in 0.4)

=head2 guestfs_pvuuid

 char *
 guestfs_pvuuid (guestfs_h *g,
                 const char *device);

This command returns the UUID of the LVM PV C<device>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.87)

=head2 guestfs_pwrite

 int
 guestfs_pwrite (guestfs_h *g,
                 const char *path,
                 const char *content,
                 size_t content_size,
                 int64_t offset);

This command writes to part of a file.  It writes the data buffer C<content>
to the file C<path> starting at offset C<offset>.

This command implements the L<pwrite(2)> system call, and like that system
call it may not write the full data requested.  The return value is the
number of bytes that were actually written to the file.  This could even be
0, although short writes are unlikely for regular files in ordinary
circumstances.

See also C<guestfs_pread>, C<guestfs_pwrite_device>.

On error this function returns -1.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.3.14)

=head2 guestfs_pwrite_device

 int
 guestfs_pwrite_device (guestfs_h *g,
                        const char *device,
                        const char *content,
                        size_t content_size,
                        int64_t offset);

This command writes to part of a device.  It writes the data buffer
C<content> to C<device> starting at offset C<offset>.

This command implements the L<pwrite(2)> system call, and like that system
call it may not write the full data requested (although short writes to disk
devices and partitions are probably impossible with standard Linux kernels).

See also C<guestfs_pwrite>.

On error this function returns -1.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.5.20)

=head2 guestfs_read_file

 char *
 guestfs_read_file (guestfs_h *g,
                    const char *path,
                    size_t *size_r);

This calls returns the contents of the file C<path> as a buffer.

Unlike C<guestfs_cat>, this function can correctly handle files that contain
embedded ASCII NUL characters.  However unlike C<guestfs_download>, this
function is limited in the total size of file that can be handled.

This function returns a buffer, or NULL on error.  The size of the returned
buffer is written to C<*size_r>.  I<The caller must free the returned buffer
after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.63)

=head2 guestfs_read_lines

 char **
 guestfs_read_lines (guestfs_h *g,
                     const char *path);

Return the contents of the file named C<path>.

The file contents are returned as a list of lines.  Trailing C<LF> and
C<CRLF> character sequences are I<not> returned.

Note that this function cannot correctly handle binary files (specifically,
files containing C<\0> character which is treated as end of line).  For
those you need to use the C<guestfs_read_file> function which has a more
complex interface.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.7)

=head2 guestfs_readdir

 struct guestfs_dirent_list *
 guestfs_readdir (guestfs_h *g,
                  const char *dir);

This returns the list of directory entries in directory C<dir>.

All entries in the directory are returned, including C<.> and C<..>.  The
entries are I<not> sorted, but returned in the same order as the underlying
filesystem.

Also this call returns basic file type information about each file.  The
C<ftyp> field will contain one of the following characters:

=over 4

=item 'b'

Блоковий особливий

=item 'c'

Символьний особливий

=item 'd'

Каталог

=item 'f'

FIFO (іменований канал)

=item 'l'

Символічне посилання

=item 'r'

Звичайний файл

=item 's'

Сокет

=item 'u'

Невідомий тип файла

=item '?'

The L<readdir(3)> call returned a C<d_type> field with an unexpected value

=back

This function is primarily intended for use by programs.  To get a simple
list of names, use C<guestfs_ls>.  To get a printable directory for human
consumption, use C<guestfs_ll>.

This function returns a C<struct guestfs_dirent_list *>, or NULL if there
was an error.  I<The caller must call C<guestfs_free_dirent_list> after
use>.

(Added in 1.0.55)

=head2 guestfs_readlink

 char *
 guestfs_readlink (guestfs_h *g,
                   const char *path);

This command reads the target of a symbolic link.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.66)

=head2 guestfs_readlinklist

 char **
 guestfs_readlinklist (guestfs_h *g,
                       const char *path,
                       char *const *names);

This call allows you to do a C<readlink> operation on multiple files, where
all files are in the directory C<path>.  C<names> is the list of files from
this directory.

On return you get a list of strings, with a one-to-one correspondence to the
C<names> list.  Each string is the value of the symbolic link.

If the C<readlink(2)> operation fails on any name, then the corresponding
result string is the empty string C<"">.  However the whole operation is
completed even if there were C<readlink(2)> errors, and so you can call this
function with names where you don't know if they are symbolic links already
(albeit slightly less efficient).

This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  Very long directory listings
might cause the protocol message size to be exceeded, causing this call to
fail.  The caller must split up such requests into smaller groups of names.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.77)

=head2 guestfs_realpath

 char *
 guestfs_realpath (guestfs_h *g,
                   const char *path);

Return the canonicalized absolute pathname of C<path>.  The returned path
has no C<.>, C<..> or symbolic link path elements.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.66)

=head2 guestfs_removexattr

 int
 guestfs_removexattr (guestfs_h *g,
                      const char *xattr,
                      const char *path);

This call removes the extended attribute named C<xattr> of the file C<path>.

See also: C<guestfs_lremovexattr>, L<attr(5)>.

This function returns 0 on success or -1 on error.

(Added in 1.0.59)

=head2 guestfs_resize2fs

 int
 guestfs_resize2fs (guestfs_h *g,
                    const char *device);

This resizes an ext2, ext3 or ext4 filesystem to match the size of the
underlying device.

I<Note:> It is sometimes required that you run C<guestfs_e2fsck_f> on the
C<device> before calling this command.  For unknown reasons C<resize2fs>
sometimes gives an error about this and sometimes not.  In any case, it is
always safe to call C<guestfs_e2fsck_f> before calling this function.

This function returns 0 on success or -1 on error.

(Added in 1.0.27)

=head2 guestfs_resize2fs_M

 int
 guestfs_resize2fs_M (guestfs_h *g,
                      const char *device);

This command is the same as C<guestfs_resize2fs>, but the filesystem is
resized to its minimum size.  This works like the I<-M> option to the
C<resize2fs> command.

To get the resulting size of the filesystem you should call
C<guestfs_tune2fs_l> and read the C<Block size> and C<Block count> values.
These two numbers, multiplied together, give the resulting size of the
minimal filesystem in bytes.

This function returns 0 on success or -1 on error.

(Added in 1.9.4)

=head2 guestfs_resize2fs_size

 int
 guestfs_resize2fs_size (guestfs_h *g,
                         const char *device,
                         int64_t size);

This command is the same as C<guestfs_resize2fs> except that it allows you
to specify the new size (in bytes) explicitly.

This function returns 0 on success or -1 on error.

(Added in 1.3.14)

=head2 guestfs_rm

 int
 guestfs_rm (guestfs_h *g,
             const char *path);

Remove the single file C<path>.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_rm_rf

 int
 guestfs_rm_rf (guestfs_h *g,
                const char *path);

Remove the file or directory C<path>, recursively removing the contents if
its a directory.  This is like the C<rm -rf> shell command.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_rmdir

 int
 guestfs_rmdir (guestfs_h *g,
                const char *path);

Remove the single directory C<path>.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_rmmountpoint

 int
 guestfs_rmmountpoint (guestfs_h *g,
                       const char *exemptpath);

This calls removes a mountpoint that was previously created with
C<guestfs_mkmountpoint>.  See C<guestfs_mkmountpoint> for full details.

This function returns 0 on success or -1 on error.

(Додано у 1.0.62)

=head2 guestfs_scrub_device

 int
 guestfs_scrub_device (guestfs_h *g,
                       const char *device);

This command writes patterns over C<device> to make data retrieval more
difficult.

It is an interface to the L<scrub(1)> program.  See that manual page for
more details.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

(Added in 1.0.52)

=head2 guestfs_scrub_file

 int
 guestfs_scrub_file (guestfs_h *g,
                     const char *file);

This command writes patterns over a file to make data retrieval more
difficult.

The file is I<removed> after scrubbing.

It is an interface to the L<scrub(1)> program.  See that manual page for
more details.

This function returns 0 on success or -1 on error.

(Added in 1.0.52)

=head2 guestfs_scrub_freespace

 int
 guestfs_scrub_freespace (guestfs_h *g,
                          const char *dir);

This command creates the directory C<dir> and then fills it with files until
the filesystem is full, and scrubs the files as for C<guestfs_scrub_file>,
and deletes them.  The intention is to scrub any free space on the partition
containing C<dir>.

It is an interface to the L<scrub(1)> program.  See that manual page for
more details.

This function returns 0 on success or -1 on error.

(Added in 1.0.52)

=head2 guestfs_set_append

 int
 guestfs_set_append (guestfs_h *g,
                     const char *append);

This function is used to add additional options to the guest kernel command
line.

The default is C<NULL> unless overridden by setting C<LIBGUESTFS_APPEND>
environment variable.

Setting C<append> to C<NULL> means I<no> additional options are passed
(libguestfs always adds a few of its own).

This function returns 0 on success or -1 on error.

(Added in 1.0.26)

=head2 guestfs_set_attach_method

 int
 guestfs_set_attach_method (guestfs_h *g,
                            const char *attachmethod);

Set the method that libguestfs uses to connect to the back end guestfsd
daemon.  Possible methods are:

=over 4

=item C<appliance>

Launch an appliance and connect to it.  This is the ordinary method and the
default.

=item C<unix:I<шлях>>

Встановити з’єднання з сокетом домену Unix I<шлях>.

This method lets you connect to an existing daemon or (using virtio-serial)
to a live guest.  For more information, see L<guestfs(3)/ATTACHING TO
RUNNING DAEMONS>.

=back

This function returns 0 on success or -1 on error.

(Added in 1.9.8)

=head2 guestfs_set_autosync

 int
 guestfs_set_autosync (guestfs_h *g,
                       int autosync);

If C<autosync> is true, this enables autosync.  Libguestfs will make a best
effort attempt to make filesystems consistent and synchronized when the
handle is closed (also if the program exits without closing handles).

This is enabled by default (since libguestfs 1.5.24, previously it was
disabled by default).

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_set_direct

 int
 guestfs_set_direct (guestfs_h *g,
                     int direct);

If the direct appliance mode flag is enabled, then stdin and stdout are
passed directly through to the appliance once it is launched.

One consequence of this is that log messages aren't caught by the library
and handled by C<guestfs_set_log_message_callback>, but go straight to
stdout.

You probably don't want to use this unless you know what you are doing.

The default is disabled.

This function returns 0 on success or -1 on error.

(Added in 1.0.72)

=head2 guestfs_set_e2label

 int
 guestfs_set_e2label (guestfs_h *g,
                      const char *device,
                      const char *label);

This sets the ext2/3/4 filesystem label of the filesystem on C<device> to
C<label>.  Filesystem labels are limited to 16 characters.

You can use either C<guestfs_tune2fs_l> or C<guestfs_get_e2label> to return
the existing label on a filesystem.

This function returns 0 on success or -1 on error.

(Added in 1.0.15)

=head2 guestfs_set_e2uuid

 int
 guestfs_set_e2uuid (guestfs_h *g,
                     const char *device,
                     const char *uuid);

This sets the ext2/3/4 filesystem UUID of the filesystem on C<device> to
C<uuid>.  The format of the UUID and alternatives such as C<clear>,
C<random> and C<time> are described in the L<tune2fs(8)> manpage.

You can use either C<guestfs_tune2fs_l> or C<guestfs_get_e2uuid> to return
the existing UUID of a filesystem.

This function returns 0 on success or -1 on error.

(Added in 1.0.15)

=head2 guestfs_set_memsize

 int
 guestfs_set_memsize (guestfs_h *g,
                      int memsize);

This sets the memory size in megabytes allocated to the qemu subprocess.
This only has any effect if called before C<guestfs_launch>.

You can also change this by setting the environment variable
C<LIBGUESTFS_MEMSIZE> before the handle is created.

For more information on the architecture of libguestfs, see L<guestfs(3)>.

This function returns 0 on success or -1 on error.

(Added in 1.0.55)

=head2 guestfs_set_network

 int
 guestfs_set_network (guestfs_h *g,
                      int network);

If C<network> is true, then the network is enabled in the libguestfs
appliance.  The default is false.

This affects whether commands are able to access the network (see
L<guestfs(3)/RUNNING COMMANDS>).

You must call this before calling C<guestfs_launch>, otherwise it has no
effect.

This function returns 0 on success or -1 on error.

(Added in 1.5.4)

=head2 guestfs_set_path

 int
 guestfs_set_path (guestfs_h *g,
                   const char *searchpath);

Set the path that libguestfs searches for kernel and initrd.img.

The default is C<$libdir/guestfs> unless overridden by setting
C<LIBGUESTFS_PATH> environment variable.

Setting C<path> to C<NULL> restores the default path.

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_set_pgroup

 int
 guestfs_set_pgroup (guestfs_h *g,
                     int pgroup);

If C<pgroup> is true, child processes are placed into their own process
group.

The practical upshot of this is that signals like C<SIGINT> (from users
pressing C<^C>) won't be received by the child process.

The default for this flag is false, because usually you want C<^C> to kill
the subprocess.

This function returns 0 on success or -1 on error.

(Added in 1.11.18)

=head2 guestfs_set_qemu

 int
 guestfs_set_qemu (guestfs_h *g,
                   const char *qemu);

Set the qemu binary that we will use.

The default is chosen when the library was compiled by the configure script.

You can also override this by setting the C<LIBGUESTFS_QEMU> environment
variable.

Setting C<qemu> to C<NULL> restores the default qemu binary.

Note that you should call this function as early as possible after creating
the handle.  This is because some pre-launch operations depend on testing
qemu features (by running C<qemu -help>).  If the qemu binary changes, we
don't retest features, and so you might see inconsistent results.  Using the
environment variable C<LIBGUESTFS_QEMU> is safest of all since that picks
the qemu binary at the same time as the handle is created.

This function returns 0 on success or -1 on error.

(Added in 1.0.6)

=head2 guestfs_set_recovery_proc

 int
 guestfs_set_recovery_proc (guestfs_h *g,
                            int recoveryproc);

If this is called with the parameter C<false> then C<guestfs_launch> does
not create a recovery process.  The purpose of the recovery process is to
stop runaway qemu processes in the case where the main program aborts
abruptly.

This only has any effect if called before C<guestfs_launch>, and the default
is true.

About the only time when you would want to disable this is if the main
process will fork itself into the background ("daemonize" itself).  In this
case the recovery process thinks that the main program has disappeared and
so kills qemu, which is not very helpful.

This function returns 0 on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_set_selinux

 int
 guestfs_set_selinux (guestfs_h *g,
                      int selinux);

This sets the selinux flag that is passed to the appliance at boot time.
The default is C<selinux=0> (disabled).

Note that if SELinux is enabled, it is always in Permissive mode
(C<enforcing=0>).

For more information on the architecture of libguestfs, see L<guestfs(3)>.

This function returns 0 on success or -1 on error.

(Added in 1.0.67)

=head2 guestfs_set_trace

 int
 guestfs_set_trace (guestfs_h *g,
                    int trace);

If the command trace flag is set to 1, then libguestfs calls, parameters and
return values are traced.

If you want to trace C API calls into libguestfs (and other libraries) then
possibly a better way is to use the external ltrace(1) command.

Command traces are disabled unless the environment variable
C<LIBGUESTFS_TRACE> is defined and set to C<1>.

Trace messages are normally sent to C<stderr>, unless you register a
callback to send them somewhere else (see C<guestfs_set_event_callback>).

This function returns 0 on success or -1 on error.

(Added in 1.0.69)

=head2 guestfs_set_verbose

 int
 guestfs_set_verbose (guestfs_h *g,
                      int verbose);

If C<verbose> is true, this turns on verbose messages.

Verbose messages are disabled unless the environment variable
C<LIBGUESTFS_DEBUG> is defined and set to C<1>.

Verbose messages are normally sent to C<stderr>, unless you register a
callback to send them somewhere else (see C<guestfs_set_event_callback>).

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_setcon

 int
 guestfs_setcon (guestfs_h *g,
                 const char *context);

This sets the SELinux security context of the daemon to the string
C<context>.

See the documentation about SELINUX in L<guestfs(3)>.

This function returns 0 on success or -1 on error.

(Added in 1.0.67)

=head2 guestfs_setxattr

 int
 guestfs_setxattr (guestfs_h *g,
                   const char *xattr,
                   const char *val,
                   int vallen,
                   const char *path);

This call sets the extended attribute named C<xattr> of the file C<path> to
the value C<val> (of length C<vallen>).  The value is arbitrary 8 bit data.

See also: C<guestfs_lsetxattr>, L<attr(5)>.

This function returns 0 on success or -1 on error.

(Added in 1.0.59)

=head2 guestfs_sfdisk

 int
 guestfs_sfdisk (guestfs_h *g,
                 const char *device,
                 int cyls,
                 int heads,
                 int sectors,
                 char *const *lines);

This is a direct interface to the L<sfdisk(8)> program for creating
partitions on block devices.

C<device> should be a block device, for example C</dev/sda>.

C<cyls>, C<heads> and C<sectors> are the number of cylinders, heads and
sectors on the device, which are passed directly to sfdisk as the I<-C>,
I<-H> and I<-S> parameters.  If you pass C<0> for any of these, then the
corresponding parameter is omitted.  Usually for 'large' disks, you can just
pass C<0> for these, but for small (floppy-sized) disks, sfdisk (or rather,
the kernel) cannot work out the right geometry and you will need to tell it.

C<lines> is a list of lines that we feed to C<sfdisk>.  For more information
refer to the L<sfdisk(8)> manpage.

To create a single partition occupying the whole disk, you would pass
C<lines> as a single element list, when the single element being the string
C<,> (comma).

See also: C<guestfs_sfdisk_l>, C<guestfs_sfdisk_N>, C<guestfs_part_init>

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

This function is deprecated.  In new code, use the L</guestfs_part_add> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 0.8)

=head2 guestfs_sfdiskM

 int
 guestfs_sfdiskM (guestfs_h *g,
                  const char *device,
                  char *const *lines);

This is a simplified interface to the C<guestfs_sfdisk> command, where
partition sizes are specified in megabytes only (rounded to the nearest
cylinder) and you don't need to specify the cyls, heads and sectors
parameters which were rarely if ever used anyway.

See also: C<guestfs_sfdisk>, the L<sfdisk(8)> manpage and
C<guestfs_part_disk>

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

This function is deprecated.  In new code, use the L</guestfs_part_add> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.55)

=head2 guestfs_sfdisk_N

 int
 guestfs_sfdisk_N (guestfs_h *g,
                   const char *device,
                   int partnum,
                   int cyls,
                   int heads,
                   int sectors,
                   const char *line);

This runs L<sfdisk(8)> option to modify just the single partition C<n>
(note: C<n> counts from 1).

For other parameters, see C<guestfs_sfdisk>.  You should usually pass C<0>
for the cyls/heads/sectors parameters.

See also: C<guestfs_part_add>

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

This function is deprecated.  In new code, use the L</guestfs_part_add> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.26)

=head2 guestfs_sfdisk_disk_geometry

 char *
 guestfs_sfdisk_disk_geometry (guestfs_h *g,
                               const char *device);

This displays the disk geometry of C<device> read from the partition table.
Especially in the case where the underlying block device has been resized,
this can be different from the kernel's idea of the geometry (see
C<guestfs_sfdisk_kernel_geometry>).

The result is in human-readable format, and not designed to be parsed.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.26)

=head2 guestfs_sfdisk_kernel_geometry

 char *
 guestfs_sfdisk_kernel_geometry (guestfs_h *g,
                                 const char *device);

This displays the kernel's idea of the geometry of C<device>.

The result is in human-readable format, and not designed to be parsed.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.26)

=head2 guestfs_sfdisk_l

 char *
 guestfs_sfdisk_l (guestfs_h *g,
                   const char *device);

This displays the partition table on C<device>, in the human-readable output
of the L<sfdisk(8)> command.  It is not intended to be parsed.

See also: C<guestfs_part_list>

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

This function is deprecated.  In new code, use the L</guestfs_part_list>
call instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.26)

=head2 guestfs_sh

 char *
 guestfs_sh (guestfs_h *g,
             const char *command);

This call runs a command from the guest filesystem via the guest's
C</bin/sh>.

This is like C<guestfs_command>, but passes the command to:

 /bin/sh -c "command"

Depending on the guest's shell, this usually results in wildcards being
expanded, shell expressions being interpolated and so on.

All the provisos about C<guestfs_command> apply to this call.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.50)

=head2 guestfs_sh_lines

 char **
 guestfs_sh_lines (guestfs_h *g,
                   const char *command);

This is the same as C<guestfs_sh>, but splits the result into a list of
lines.

See also: C<guestfs_command_lines>

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.50)

=head2 guestfs_sleep

 int
 guestfs_sleep (guestfs_h *g,
                int secs);

Sleep for C<secs> seconds.

This function returns 0 on success or -1 on error.

(Added in 1.0.41)

=head2 guestfs_stat

 struct guestfs_stat *
 guestfs_stat (guestfs_h *g,
               const char *path);

Returns file information for the given C<path>.

This is the same as the C<stat(2)> system call.

This function returns a C<struct guestfs_stat *>, or NULL if there was an
error.  I<The caller must call C<guestfs_free_stat> after use>.

(Додано у 0.9.2)

=head2 guestfs_statvfs

 struct guestfs_statvfs *
 guestfs_statvfs (guestfs_h *g,
                  const char *path);

Returns file system statistics for any mounted file system.  C<path> should
be a file or directory in the mounted file system (typically it is the mount
point itself, but it doesn't need to be).

This is the same as the C<statvfs(2)> system call.

This function returns a C<struct guestfs_statvfs *>, or NULL if there was an
error.  I<The caller must call C<guestfs_free_statvfs> after use>.

(Додано у 0.9.2)

=head2 guestfs_strings

 char **
 guestfs_strings (guestfs_h *g,
                  const char *path);

This runs the L<strings(1)> command on a file and returns the list of
printable strings found.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.22)

=head2 guestfs_strings_e

 char **
 guestfs_strings_e (guestfs_h *g,
                    const char *encoding,
                    const char *path);

This is like the C<guestfs_strings> command, but allows you to specify the
encoding of strings that are looked for in the source file C<path>.

Можливими кодуваннями є:

=over 4

=item s

Single 7-bit-byte characters like ASCII and the ASCII-compatible parts of
ISO-8859-X (this is what C<guestfs_strings> uses).

=item S

Окремі 8-бітові-байтові символи.

=item b

16-bit big endian strings such as those encoded in UTF-16BE or UCS-2BE.

=item l (lower case letter L)

16-bit little endian such as UTF-16LE and UCS-2LE.  This is useful for
examining binaries in Windows guests.

=item B

32-bit big endian such as UCS-4BE.

=item L

32-bit little endian such as UCS-4LE.

=back

The returned strings are transcoded to UTF-8.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.22)

=head2 guestfs_swapoff_device

 int
 guestfs_swapoff_device (guestfs_h *g,
                         const char *device);

This command disables the libguestfs appliance swap device or partition
named C<device>.  See C<guestfs_swapon_device>.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapoff_file

 int
 guestfs_swapoff_file (guestfs_h *g,
                       const char *file);

This command disables the libguestfs appliance swap on file.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapoff_label

 int
 guestfs_swapoff_label (guestfs_h *g,
                        const char *label);

This command disables the libguestfs appliance swap on labeled swap
partition.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapoff_uuid

 int
 guestfs_swapoff_uuid (guestfs_h *g,
                       const char *uuid);

This command disables the libguestfs appliance swap partition with the given
UUID.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapon_device

 int
 guestfs_swapon_device (guestfs_h *g,
                        const char *device);

This command enables the libguestfs appliance to use the swap device or
partition named C<device>.  The increased memory is made available for all
commands, for example those run using C<guestfs_command> or C<guestfs_sh>.

Note that you should not swap to existing guest swap partitions unless you
know what you are doing.  They may contain hibernation information, or other
information that the guest doesn't want you to trash.  You also risk leaking
information about the host to the guest this way.  Instead, attach a new
host device to the guest and swap on that.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapon_file

 int
 guestfs_swapon_file (guestfs_h *g,
                      const char *file);

This command enables swap to a file.  See C<guestfs_swapon_device> for other
notes.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapon_label

 int
 guestfs_swapon_label (guestfs_h *g,
                       const char *label);

This command enables swap to a labeled swap partition.  See
C<guestfs_swapon_device> for other notes.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_swapon_uuid

 int
 guestfs_swapon_uuid (guestfs_h *g,
                      const char *uuid);

This command enables swap to a swap partition with the given UUID.  See
C<guestfs_swapon_device> for other notes.

This function returns 0 on success or -1 on error.

(Added in 1.0.66)

=head2 guestfs_sync

 int
 guestfs_sync (guestfs_h *g);

This syncs the disk, so that any writes are flushed through to the
underlying disk image.

You should always call this if you have modified a disk image, before
closing the handle.

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_tail

 char **
 guestfs_tail (guestfs_h *g,
               const char *path);

This command returns up to the last 10 lines of a file as a list of strings.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.54)

=head2 guestfs_tail_n

 char **
 guestfs_tail_n (guestfs_h *g,
                 int nrlines,
                 const char *path);

If the parameter C<nrlines> is a positive number, this returns the last
C<nrlines> lines of the file C<path>.

If the parameter C<nrlines> is a negative number, this returns lines from
the file C<path>, starting with the C<-nrlines>th line.

If the parameter C<nrlines> is zero, this returns an empty list.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.54)

=head2 guestfs_tar_in

 int
 guestfs_tar_in (guestfs_h *g,
                 const char *tarfile,
                 const char *directory);

This command uploads and unpacks local file C<tarfile> (an I<uncompressed>
tar file) into C<directory>.

To upload a compressed tarball, use C<guestfs_tgz_in> or C<guestfs_txz_in>.

This function returns 0 on success or -1 on error.

(Added in 1.0.3)

=head2 guestfs_tar_out

 int
 guestfs_tar_out (guestfs_h *g,
                  const char *directory,
                  const char *tarfile);

This command packs the contents of C<directory> and downloads it to local
file C<tarfile>.

To download a compressed tarball, use C<guestfs_tgz_out> or
C<guestfs_txz_out>.

This function returns 0 on success or -1 on error.

(Added in 1.0.3)

=head2 guestfs_tgz_in

 int
 guestfs_tgz_in (guestfs_h *g,
                 const char *tarball,
                 const char *directory);

This command uploads and unpacks local file C<tarball> (a I<gzip compressed>
tar file) into C<directory>.

To upload an uncompressed tarball, use C<guestfs_tar_in>.

This function returns 0 on success or -1 on error.

(Added in 1.0.3)

=head2 guestfs_tgz_out

 int
 guestfs_tgz_out (guestfs_h *g,
                  const char *directory,
                  const char *tarball);

This command packs the contents of C<directory> and downloads it to local
file C<tarball>.

To download an uncompressed tarball, use C<guestfs_tar_out>.

This function returns 0 on success or -1 on error.

(Added in 1.0.3)

=head2 guestfs_touch

 int
 guestfs_touch (guestfs_h *g,
                const char *path);

Touch acts like the L<touch(1)> command.  It can be used to update the
timestamps on a file, or, if the file does not exist, to create a new
zero-length file.

This command only works on regular files, and will fail on other file types
such as directories, symbolic links, block special etc.

This function returns 0 on success or -1 on error.

(Added in 0.3)

=head2 guestfs_truncate

 int
 guestfs_truncate (guestfs_h *g,
                   const char *path);

This command truncates C<path> to a zero-length file.  The file must exist
already.

This function returns 0 on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_truncate_size

 int
 guestfs_truncate_size (guestfs_h *g,
                        const char *path,
                        int64_t size);

This command truncates C<path> to size C<size> bytes.  The file must exist
already.

If the current file size is less than C<size> then the file is extended to
the required size with zero bytes.  This creates a sparse file (ie. disk
blocks are not allocated for the file until you write to it).  To create a
non-sparse file of zeroes, use C<guestfs_fallocate64> instead.

This function returns 0 on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_tune2fs_l

 char **
 guestfs_tune2fs_l (guestfs_h *g,
                    const char *device);

This returns the contents of the ext2, ext3 or ext4 filesystem superblock on
C<device>.

It is the same as running C<tune2fs -l device>.  See L<tune2fs(8)> manpage
for more details.  The list of fields returned isn't clearly defined, and
depends on both the version of C<tune2fs> that libguestfs was built against,
and the filesystem itself.

This function returns a NULL-terminated array of strings, or NULL if there
was an error.  The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.  I<The
caller must free the strings and the array after use>.

(Додано у 0.9.2)

=head2 guestfs_txz_in

 int
 guestfs_txz_in (guestfs_h *g,
                 const char *tarball,
                 const char *directory);

This command uploads and unpacks local file C<tarball> (an I<xz compressed>
tar file) into C<directory>.

This function returns 0 on success or -1 on error.

(Added in 1.3.2)

=head2 guestfs_txz_out

 int
 guestfs_txz_out (guestfs_h *g,
                  const char *directory,
                  const char *tarball);

This command packs the contents of C<directory> and downloads it to local
file C<tarball> (as an xz compressed tar archive).

This function returns 0 on success or -1 on error.

(Added in 1.3.2)

=head2 guestfs_umask

 int
 guestfs_umask (guestfs_h *g,
                int mask);

This function sets the mask used for creating new files and device nodes to
C<mask & 0777>.

Typical umask values would be C<022> which creates new files with
permissions like "-rw-r--r--" or "-rwxr-xr-x", and C<002> which creates new
files with permissions like "-rw-rw-r--" or "-rwxrwxr-x".

The default umask is C<022>.  This is important because it means that
directories and device nodes will be created with C<0644> or C<0755> mode
even if you specify C<0777>.

See also C<guestfs_get_umask>, L<umask(2)>, C<guestfs_mknod>,
C<guestfs_mkdir>.

This call returns the previous umask.

On error this function returns -1.

(Added in 1.0.55)

=head2 guestfs_umount

 int
 guestfs_umount (guestfs_h *g,
                 const char *pathordevice);

This unmounts the given filesystem.  The filesystem may be specified either
by its mountpoint (path) or the device which contains the filesystem.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_umount_all

 int
 guestfs_umount_all (guestfs_h *g);

This unmounts all mounted filesystems.

Some internal mounts are not unmounted by this call.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_upload

 int
 guestfs_upload (guestfs_h *g,
                 const char *filename,
                 const char *remotefilename);

Upload local file C<filename> to C<remotefilename> on the filesystem.

C<filename> can also be a named pipe.

See also C<guestfs_download>.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.0.2)

=head2 guestfs_upload_offset

 int
 guestfs_upload_offset (guestfs_h *g,
                        const char *filename,
                        const char *remotefilename,
                        int64_t offset);

Upload local file C<filename> to C<remotefilename> on the filesystem.

C<remotefilename> is overwritten starting at the byte C<offset> specified.
The intention is to overwrite parts of existing files or devices, although
if a non-existant file is specified then it is created with a "hole" before
C<offset>.  The size of the data written is implicit in the size of the
source C<filename>.

Note that there is no limit on the amount of data that can be uploaded with
this call, unlike with C<guestfs_pwrite>, and this call always writes the
full amount unless an error occurs.

See also C<guestfs_upload>, C<guestfs_pwrite>.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.5.17)

=head2 guestfs_utimens

 int
 guestfs_utimens (guestfs_h *g,
                  const char *path,
                  int64_t atsecs,
                  int64_t atnsecs,
                  int64_t mtsecs,
                  int64_t mtnsecs);

This command sets the timestamps of a file with nanosecond precision.

C<atsecs, atnsecs> are the last access time (atime) in secs and nanoseconds
from the epoch.

C<mtsecs, mtnsecs> are the last modification time (mtime) in secs and
nanoseconds from the epoch.

If the C<*nsecs> field contains the special value C<-1> then the
corresponding timestamp is set to the current time.  (The C<*secs> field is
ignored in this case).

If the C<*nsecs> field contains the special value C<-2> then the
corresponding timestamp is left unchanged.  (The C<*secs> field is ignored
in this case).

This function returns 0 on success or -1 on error.

(Added in 1.0.77)

=head2 guestfs_version

 struct guestfs_version *
 guestfs_version (guestfs_h *g);

Return the libguestfs version number that the program is linked against.

Note that because of dynamic linking this is not necessarily the version of
libguestfs that you compiled against.  You can compile the program, and then
at runtime dynamically link against a completely different C<libguestfs.so>
library.

This call was added in version C<1.0.58>.  In previous versions of
libguestfs there was no way to get the version number.  From C code you can
use dynamic linker functions to find out if this symbol exists (if it
doesn't, then it's an earlier version).

The call returns a structure with four elements.  The first three (C<major>,
C<minor> and C<release>) are numbers and correspond to the usual version
triplet.  The fourth element (C<extra>) is a string and is normally empty,
but may be used for distro-specific information.

To construct the original version string: C<$major.$minor.$release$extra>

See also: L<guestfs(3)/LIBGUESTFS VERSION NUMBERS>.

I<Note:> Don't use this call to test for availability of features.  In
enterprise distributions we backport features from later versions into
earlier versions, making this an unreliable way to test for features.  Use
C<guestfs_available> instead.

This function returns a C<struct guestfs_version *>, or NULL if there was an
error.  I<The caller must call C<guestfs_free_version> after use>.

(Added in 1.0.58)

=head2 guestfs_vfs_label

 char *
 guestfs_vfs_label (guestfs_h *g,
                    const char *device);

This returns the filesystem label of the filesystem on C<device>.

If the filesystem is unlabeled, this returns the empty string.

To find a filesystem from the label, use C<guestfs_findfs_label>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.3.18)

=head2 guestfs_vfs_type

 char *
 guestfs_vfs_type (guestfs_h *g,
                   const char *device);

This command gets the filesystem type corresponding to the filesystem on
C<device>.

For most filesystems, the result is the name of the Linux VFS module which
would be used to mount this filesystem if you mounted it without specifying
the filesystem type.  For example a string such as C<ext3> or C<ntfs>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.75)

=head2 guestfs_vfs_uuid

 char *
 guestfs_vfs_uuid (guestfs_h *g,
                   const char *device);

This returns the filesystem UUID of the filesystem on C<device>.

If the filesystem does not have a UUID, this returns the empty string.

To find a filesystem from the UUID, use C<guestfs_findfs_uuid>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.3.18)

=head2 guestfs_vg_activate

 int
 guestfs_vg_activate (guestfs_h *g,
                      int activate,
                      char *const *volgroups);

This command activates or (if C<activate> is false) deactivates all logical
volumes in the listed volume groups C<volgroups>.

This command is the same as running C<vgchange -a y|n volgroups...>

Note that if C<volgroups> is an empty list then B<all> volume groups are
activated or deactivated.

This function returns 0 on success or -1 on error.

(Added in 1.0.26)

=head2 guestfs_vg_activate_all

 int
 guestfs_vg_activate_all (guestfs_h *g,
                          int activate);

This command activates or (if C<activate> is false) deactivates all logical
volumes in all volume groups.

This command is the same as running C<vgchange -a y|n>

This function returns 0 on success or -1 on error.

(Added in 1.0.26)

=head2 guestfs_vgcreate

 int
 guestfs_vgcreate (guestfs_h *g,
                   const char *volgroup,
                   char *const *physvols);

This creates an LVM volume group called C<volgroup> from the non-empty list
of physical volumes C<physvols>.

This function returns 0 on success or -1 on error.

(Added in 0.8)

=head2 guestfs_vglvuuids

 char **
 guestfs_vglvuuids (guestfs_h *g,
                    const char *vgname);

Given a VG called C<vgname>, this returns the UUIDs of all the logical
volumes created in this volume group.

You can use this along with C<guestfs_lvs> and C<guestfs_lvuuid> calls to
associate logical volumes and volume groups.

See also C<guestfs_vgpvuuids>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.87)

=head2 guestfs_vgpvuuids

 char **
 guestfs_vgpvuuids (guestfs_h *g,
                    const char *vgname);

Given a VG called C<vgname>, this returns the UUIDs of all the physical
volumes that this volume group resides on.

You can use this along with C<guestfs_pvs> and C<guestfs_pvuuid> calls to
associate physical volumes and volume groups.

See also C<guestfs_vglvuuids>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 1.0.87)

=head2 guestfs_vgremove

 int
 guestfs_vgremove (guestfs_h *g,
                   const char *vgname);

Remove an LVM volume group C<vgname>, (for example C<VG>).

This also forcibly removes all logical volumes in the volume group (if any).

This function returns 0 on success or -1 on error.

(Додано у 1.0.13)

=head2 guestfs_vgrename

 int
 guestfs_vgrename (guestfs_h *g,
                   const char *volgroup,
                   const char *newvolgroup);

Rename a volume group C<volgroup> with the new name C<newvolgroup>.

This function returns 0 on success or -1 on error.

(Додано у 1.0.83)

=head2 guestfs_vgs

 char **
 guestfs_vgs (guestfs_h *g);

List all the volumes groups detected.  This is the equivalent of the
L<vgs(8)> command.

This returns a list of just the volume group names that were detected
(eg. C<VolGroup00>).

See also C<guestfs_vgs_full>.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

(Added in 0.4)

=head2 guestfs_vgs_full

 struct guestfs_lvm_vg_list *
 guestfs_vgs_full (guestfs_h *g);

List all the volumes groups detected.  This is the equivalent of the
L<vgs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_vg_list *>, or NULL if there
was an error.  I<The caller must call C<guestfs_free_lvm_vg_list> after
use>.

(Added in 0.4)

=head2 guestfs_vgscan

 int
 guestfs_vgscan (guestfs_h *g);

This rescans all block devices and rebuilds the list of LVM physical
volumes, volume groups and logical volumes.

This function returns 0 on success or -1 on error.

(Added in 1.3.2)

=head2 guestfs_vguuid

 char *
 guestfs_vguuid (guestfs_h *g,
                 const char *vgname);

This command returns the UUID of the LVM VG named C<vgname>.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

(Added in 1.0.87)

=head2 guestfs_wait_ready

 int
 guestfs_wait_ready (guestfs_h *g);

This function is a no op.

In versions of the API E<lt> 1.0.71 you had to call this function just after
calling C<guestfs_launch> to wait for the launch to complete.  However this
is no longer necessary because C<guestfs_launch> now does the waiting.

If you see any calls to this function in code then you can just remove them,
unless you want to retain compatibility with older versions of the API.

This function returns 0 on success or -1 on error.

This function is deprecated.  In new code, use the L</guestfs_launch> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 0.3)

=head2 guestfs_wc_c

 int
 guestfs_wc_c (guestfs_h *g,
               const char *path);

This command counts the characters in a file, using the C<wc -c> external
command.

On error this function returns -1.

(Added in 1.0.54)

=head2 guestfs_wc_l

 int
 guestfs_wc_l (guestfs_h *g,
               const char *path);

This command counts the lines in a file, using the C<wc -l> external
command.

On error this function returns -1.

(Added in 1.0.54)

=head2 guestfs_wc_w

 int
 guestfs_wc_w (guestfs_h *g,
               const char *path);

This command counts the words in a file, using the C<wc -w> external
command.

On error this function returns -1.

(Added in 1.0.54)

=head2 guestfs_write

 int
 guestfs_write (guestfs_h *g,
                const char *path,
                const char *content,
                size_t content_size);

This call creates a file called C<path>.  The content of the file is the
string C<content> (which can contain any 8 bit data).

See also C<guestfs_write_append>.

This function returns 0 on success or -1 on error.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.3.14)

=head2 guestfs_write_append

 int
 guestfs_write_append (guestfs_h *g,
                       const char *path,
                       const char *content,
                       size_t content_size);

This call appends C<content> to the end of file C<path>.  If C<path> does
not exist, then a new file is created.

See also C<guestfs_write>.

This function returns 0 on success or -1 on error.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.11.18)

=head2 guestfs_write_file

 int
 guestfs_write_file (guestfs_h *g,
                     const char *path,
                     const char *content,
                     int size);

This call creates a file called C<path>.  The contents of the file is the
string C<content> (which can contain any 8 bit data), with length C<size>.

As a special case, if C<size> is C<0> then the length is calculated using
C<strlen> (so in this case the content cannot contain embedded ASCII NULs).

I<NB.> Owing to a bug, writing content containing ASCII NUL characters does
I<not> work, even if the length is specified.

This function returns 0 on success or -1 on error.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

This function is deprecated.  In new code, use the L</guestfs_write> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 0.8)

=head2 guestfs_zegrep

 char **
 guestfs_zegrep (guestfs_h *g,
                 const char *regex,
                 const char *path);

This calls the external C<zegrep> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_zegrepi

 char **
 guestfs_zegrepi (guestfs_h *g,
                  const char *regex,
                  const char *path);

This calls the external C<zegrep -i> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_zero

 int
 guestfs_zero (guestfs_h *g,
               const char *device);

This command writes zeroes over the first few blocks of C<device>.

How many blocks are zeroed isn't specified (but it's I<not> enough to
securely wipe the device).  It should be sufficient to remove any partition
tables, filesystem superblocks and so on.

If blocks are already zero, then this command avoids writing zeroes.  This
prevents the underlying device from becoming non-sparse or growing
unnecessarily.

See also: C<guestfs_zero_device>, C<guestfs_scrub_device>,
C<guestfs_is_zero_device>

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

(Added in 1.0.16)

=head2 guestfs_zero_device

 int
 guestfs_zero_device (guestfs_h *g,
                      const char *device);

This command writes zeroes over the entire C<device>.  Compare with
C<guestfs_zero> which just zeroes the first few blocks of a device.

If blocks are already zero, then this command avoids writing zeroes.  This
prevents the underlying device from becoming non-sparse or growing
unnecessarily.

This function returns 0 on success or -1 on error.

This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
L<guestfs(3)/GUESTFS_EVENT_PROGRESS>.

B<This command is dangerous.  Without careful use you can easily destroy all
your data>.

(Додано у 1.3.1)

=head2 guestfs_zerofree

 int
 guestfs_zerofree (guestfs_h *g,
                   const char *device);

This runs the I<zerofree> program on C<device>.  This program claims to zero
unused inodes and disk blocks on an ext2/3 filesystem, thus making it
possible to compress the filesystem more effectively.

You should B<not> run this program if the filesystem is mounted.

It is possible that using this program can damage the filesystem or data on
the filesystem.

This function returns 0 on success or -1 on error.

(Added in 1.0.26)

=head2 guestfs_zfgrep

 char **
 guestfs_zfgrep (guestfs_h *g,
                 const char *pattern,
                 const char *path);

This calls the external C<zfgrep> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_zfgrepi

 char **
 guestfs_zfgrepi (guestfs_h *g,
                  const char *pattern,
                  const char *path);

This calls the external C<zfgrep -i> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_zfile

 char *
 guestfs_zfile (guestfs_h *g,
                const char *meth,
                const char *path);

This command runs C<file> after first decompressing C<path> using C<method>.

C<method> must be one of C<gzip>, C<compress> or C<bzip2>.

Since 1.0.63, use C<guestfs_file> instead which can now process compressed
files.

This function returns a string, or NULL on error.  I<The caller must free
the returned string after use>.

This function is deprecated.  In new code, use the L</guestfs_file> call
instead.

Deprecated functions will not be removed from the API, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.

(Added in 1.0.59)

=head2 guestfs_zgrep

 char **
 guestfs_zgrep (guestfs_h *g,
                const char *regex,
                const char *path);

This calls the external C<zgrep> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

=head2 guestfs_zgrepi

 char **
 guestfs_zgrepi (guestfs_h *g,
                 const char *regex,
                 const char *path);

This calls the external C<zgrep -i> program and returns the matching lines.

This function returns a NULL-terminated array of strings (like
L<environ(3)>), or NULL if there was an error.  I<The caller must free the
strings and the array after use>.

Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See L<guestfs(3)/PROTOCOL LIMITS>.

(Added in 1.0.66)

