
=head1 НАЗВА

guestfs-hacking — розширення можливостей і участь у розробці libguestfs

=head1 ОПИС

Цю сторінку підручника призначено для тих, хто хоче розширити можливості
libguestfs власноруч.

=head1 ПОЧАТКОВИЙ КОД

Код libguestfs зберігається у сховищі github
L<https://github.com/libguestfs/libguestfs>

Велика частина стереотипного коду у libguestfs (RPC, прив'язки,
документація) створюється автоматично. Це означає, що у звичайному клоні
сховища git не буде багатьох файлів, які є у архівах з початковим кодом. Вам
доведеться запустити генератор (C<./autogen.sh && make -C generator>), щоб
створити ці файли.

У libguestfs використовується система збирання на основі autotools,
основними файлами якої є F<configure.ac> і F<Makefile.am>. Див. L</СИСТЕМА
ЗБИРАННЯ>.

У підкаталозі F<generator> міститься генератор та файли із описом
програмного інтерфейсу. У підкаталозі F<lib> міститься початковий код
бібліотеки. У підкаталогах F<appliance> та F<daemon> зберігається початковий
код, який збирає базову систему, так код, який запускає базову систему,
відповідно. Інші каталоги описано у розділі L<ПІДКАТАЛОГИ ПОЧАТКОВОГО КОДУ>
нижче.

Окрім того факту, що усі вхідні точки програмного інтерфейсу перебувають у
певному створеному коді, сама бібліотека є простою. (Фактично, навіть
створений код читається так самою легко, як і звичайний код.) Деякі дії
виконуються суто у бібліотеці, їхній код написано мовою C, він зберігається
у підкаталозі F<lib>. Виконання інших дій переспрямовується до фонової
служби, де (після певного скерування RPC) їх реалізовано як функції мовою C
у файлах підкаталогу F<daemon>.

Настанови щодо збирання з початкового коду наведено у підручнику
L<guestfs-building(1)>.

=head2 ПІДКАТАЛОГИ ПОЧАТКОВОГО КОДУ

У ієрархії початкового коду багато підкаталогів! На яких слід зосередити
увагу передусім? На каталогах F<lib> та F<daemon>, у яких міститься
початковий код основи бібліотеки. F<generator> містить код генератора,
описаного вище, тому цей підкаталог також є важливим. Файл F<Makefile.am> у
кореневому каталозі містить цінні дані щодо порядку збирання коду у
підкаталогах. І нарешті, якщо ви шукаєте код певного інструмента (наприклад
F<v2v>) або прив'язки до мови (наприклад F<python>), зверніться
безпосередньо до відповідного підкаталогу, але пам'ятайте, що якщо ще не
було запущено генератор, вам може здатися, що у початковому коді не вистачає
багатьох файлів.

=over 4

=item F<align>

Програма L<virt-alignment-scan(1)> та документація до неї.

=item F<appliance>

Базова система libguestfs, скрипти збирання тощо.

=item F<bash>

Скрипти доповнення команд у відповідь на натискання клавіші Tab.

=item F<build-aux>

Різноманітні скрипти збирання, які використовуються autotools.

=item F<builder>

Програма L<virt-builder(1)> та документація до неї.

=item F<cat>

Код програм L<virt-cat(1)>, L<virt-filesystems(1)>, L<virt-log(1)>,
L<virt-ls(1)> and L<virt-tail(1)> та документація до них.

=item F<common>

У підкаталозі F<common> зберігаються різноманітні бібліотеки внутрішнього
коду:

=over 4

=item F<common/edit>

Загальний код для інтерактивного та неінтерактивного редагування файлів у
файловій системі libguestfs.

=item F<common/errnostring>

Протоколом обміну даними, який використовується між бібліотекою і фоновою
службою, запущеною у базовій системі, передбачено кодування номерів помилок
у рядки, які обробляються цією бібліотекою.

=item F<common/miniexpect>

Копія бібліотеки miniexpect з
L<http://git.annexia.org/?p=miniexpect.git;a=summary>. Використовується у
virt-p2v.

=item F<common/mlaugeas>

Прив'язки до бібліотеки Augeas. Їх запозичено з бібліотеки ocaml-augeas,
L<http://git.annexia.org/?p=ocaml-augeas.git>

=item F<common/mlgettext>

Невеличкий автоматично створений скрипт-обгортка, який надає змогу збирати
libguestfs з ocaml-gettext та без нього. Скрипт створюється за допомогою
F<./configure>.

=item F<common/mlpcre>

Невибагливі до ресурсів прив'язки до OCaml бібліотеки сумісних із Perl
формальних виразів (PCRE). Зауважте, що цей код ніяким чином не пов'язано із
бібліотекою ocaml-pcre, яку створив Markus Mottl.

=item F<common/mlprogress>

Прив'язки OCaml до функцій смужки поступу (див. F<common/progress>).

=item F<common/mlstdutils>

Бібліотека допоміжних функцій, які використовуються у багатьох місцях, суто
мовою OCaml.

=item F<common/mltools>

Допоміжні функції OCaml, які використовуються лише інструментами
віртуалізації мовою OCaml (зокрема C<virt-sysprep>, C<virt-v2v> тощо)

=item F<common/mlutils>

Прив'язки до OCaml для функцій C у C<common/utils> та деякі прив'язки POSIX,
яких немає у стандартній бібліотеці OCaml.

=item F<common/mlvisit>

Прив'язки до OCaml для функцій visit (див. F<common/visit>).

=item F<common/mlxml>

Прив'язки OCaml для бібліотеки libxml2.

=item F<common/options>

Загальна обробка параметрів для guestfish, guestmount та деяких інструментів
віртуалізації.

=item F<common/parallel>

Комплект бібліотек для паралельної обробки декількох доменів libvirt.

=item F<common/progress>

Загальний код для виведення смужок поступу.

=item F<common/protocol>

Тут визначається протокол обміну даними, заснований на XDR, який
використовується для спілкування між бібліотекою і фоновою службою у базовій
системі.

=item F<common/qemuopts>

Мінібібліотека для запису рядків команд qemu та файлів налаштувань qemu.

=item F<common/structs>

Загальний код для виведення та вивільнення структур libguestfs, який
використовується у бібліотеці та деяких інструментах.

=item F<common/utils>

Різноманітні допоміжні функції, які використовуються у бібліотеці та
інструментах.

=item F<common/visit>

Рекурсивний обхід ієрархії файлових систем guestfs.

=item F<common/windows>

Допоміжні функції для обробки літер дисків у Windows.

=back

=item F<contrib>

Зовнішні внески, експериментальні частини.

=item F<customize>

Програма L<virt-customize(1)> та документація до неї.

=item F<daemon>

Фонова служба, яка працює у базовій системі libguestfs і забезпечує
виконання дій.

=item F<df>

Програма L<virt-df(1)> та документація до неї.

=item F<dib>

Програма L<virt-dib(1)> та документація до неї.

=item F<diff>

Програма L<virt-diff(1)> та документація до неї.

=item F<docs>

Різноманітні сторінки підручника.

=item F<edit>

Програма L<virt-edit(1)> та документація до неї.

=item F<examples>

Код прикладів використання програмного інтерфейсу мовою C.

=item F<fish>

L<guestfish(1)> — оболонка командного рядка та різноманітні скрипти оболонки
на її основі, зокрема L<virt-copy-in(1)>, L<virt-copy-out(1)>,
L<virt-tar-in(1)>, L<virt-tar-out(1)>.

=item F<format>

Програма L<virt-format(1)> та документація до неї.

=item F<fuse>

L<guestmount(1)>, FUSE (файлова система у просторі користувача), яку зібрано
на основі libguestfs.

=item F<generator>

Критично важливий засіб створення коду, використовується для автоматичного
створення значного обсягу важливого коду мовою C, зокрема для RPC та
прив'язок.

=item F<get-kernel>

Програма L<virt-get-kernel(1)> та документація до неї.

=item F<gnulib>

Gnulib використовується як бібліотека забезпечення портованості. До цього
каталогу включено копію gnulib.

=item F<inspector>

L<virt-inspector(1)> — засіб інспектування образів віртуальних машин.

=item F<lib>

Початковий код бібліотеки мовою C.

=item F<logo>

Логотип, який використовується на сайті. До речі, ім'я рибки — Артур.

=item F<m4>

Макроси M4, які використовуються autoconf. Див. L</СИСТЕМА ЗБИРАННЯ>.

=item F<make-fs>

Програма L<virt-make-fs(1)> та документація до неї.

=item F<p2v>

Програма L<virt-p2v(1)>, документація та скрипти для збирання ISO або образу
диска virt-p2v.

=item F<po>

Переклади простих рядків gettext.

=item F<po-docs>

Інфраструктура збирання та файли PO перекладів сторінок підручника та файлів
POD. Колись ми об'єднаємо ці дані з каталогом F<po>, але цей процес є доволі
складним.

=item F<rescue>

Програма L<virt-rescue(1)> та документація до неї.

=item F<resize>

Програма L<virt-resize(1)> та документація до неї.

=item F<sparsify>

Програма L<virt-sparsify(1)> та документація до неї.

=item F<sysprep>

Програма L<virt-sysprep(1)> та документація до неї.

=item F<tests>

Тести.

=item F<test-data>

Файли та інші тестові дані, які використовуються при тестуванні.

=item F<test-tool>

Засіб тестування, який допоможе визначити кінцевим користувачам, чи
працюватиме їхня комбінація qemu/ядро з libguestfs.

=item F<tmp>

Використовується для тимчасових файлів під час тестування (замість F</tmp>
та подібних каталогів). Причиною створення є уможливлення запуску декількох
тестів libguestfs паралельно без ризику перезапису базової системи набором
тестів, який виконується паралельно із набором, за допомогою якого було
створено базову систему.

=item F<tools>

Засоби командного рядка, які написано мовою програмування Perl
(L<virt-win-reg(1)> та багато інших).

=item F<utils>

Різноманітні допоміжні програми, зокрема C<boot-benchmark>.

=item F<v2v>

Програма L<virt-v2v(1)> та документація до неї.

=item F<website>

Файли сайта L<http://libguestfs.org>.

=item F<csharp>

=item F<erlang>

=item F<gobject>

=item F<golang>

=item F<haskell>

=item F<java>

=item F<lua>

=item F<ocaml>

=item F<php>

=item F<perl>

=item F<python>

=item F<ruby>

Прив’язки до мов програмування.

=back

=head2 СИСТЕМА ЗБИРАННЯ

Libguestfs використовує систему збирання GNU autotools (autoconf, automake,
libtool).

Скрипт F<./configure> створюється на основі F<configure.ac> і
F<m4/guestfs-*.m4>. Більшу частину вмісту скрипту configure складають дані з
багатьох файлів макросів m4, поділених за розділами, наприклад,
F<m4/guestfs-daemon.m4> призначено для обробки залежностей фонової служби
(daemon).

Завданням файла F<Makefile.am> на верхньому рівні є визначення списку
підкаталогів (C<SUBDIRS>) у порядку їхнього збирання.

F<common-rules.mk> включається до усіх файлів F<Makefile.am> (верхнього
рівня та підкаталогів). F<subdir-rules.mk> включається лише до файлів
F<Makefile.am> у підкаталогах.

Цілей збирання багато. Скористайтеся цією командою, щоб побачити список:

 make help

=head1 РОЗШИРЕННЯ МОЖЛИВОСТЕЙ LIBGUESTFS

=head2 ДОДАВАННЯ НОВИХ ПРОГРАМНИХ ІНТЕРФЕЙСІВ

Оскільки більша частина стереотипного коду у libguestfs створюється у
автоматичному режимі, розширити програмний інтерфейс libguestfs доволі
просто.

Щоб додати нову дію програмного інтерфейсу, слід внести дві зміни:

=over 4

=item 1.

Вам слід додати опис виклику (назву, параметри, тип значення, яке
повертається, тести, документацію) до F<generator/actions_*.ml> і, можливо,
до F<generator/proc_nr.ml>.

Існує два різновиди дій програмного інтерфейсу. Тип залежить від того,
проходить виклик до базової системи через фонову службу, чи обслуговується
лише засобами бібліотеки
(див. L<guestfs-internals(1)/АРХІТЕКТУРА>). L<guestfs(3)/guestfs_sync> є
прикладом дій першого типу, оскільки синхронізація відбувається у базовій
системі. L<guestfs(3)/guestfs_set_trace> є прикладом дій другого типу,
оскільки прапорець трасування обслуговується у дескрипторі, а усе трасування
виконується на боці бібліотеки.

Більшість нових дій належить до першого типу, тому їхні записи додаються до
списку C<daemon_functions>. У кожної функції є унікальний номер процедури,
який використовується у протоколі RPC, який пов'язується із цією дією під
час оприлюднення версії libguestfs і який не можна використовувати
повторно. Знайдіть останній номер процедури і додайте до нього одиницю, щоб
отримати ваш номер.

Дії другого типу, які пов'язано лише з бібліотекою, слід додавати до списку
C<non_daemon_functions>. Оскільки ці функції обслуговуються бібліотекою і не
поширюються механізмом RPC до фонової служби, ці функції не потребують
номеру процедури; отже, для них встановлюється номер процедури C<-1>.

=item 2.

Реалізація дії (мовою C):

Для дій фонової служби слід реалізувати функцію C<do_E<lt>назваE<gt>> у
каталозі C<daemon/>.

Для дій бібліотеки слід реалізувати функцію C<guestfs_impl_E<lt>назваE<gt>>
у каталозі C<lib/>.

У обох випадках скористайтеся якоюсь іншою функцією як прикладом реалізації.

=item 3.

Альтернатива кроку 2: починаючи з версії libguestfs 1.38, дії фонової служби
може бути реалізовано мовою OCaml. Вам слід встановити прапорець C<impl =
OCaml ...> у генераторі. Прикладом може слугувати файл F<daemon/file.ml>.

=back

Після внесення цих змін скористайтеся командою C<make> для збирання.

Зауважте, що вам не потрібно реалізовувати RPC, прив'язки до мов, сторінки
підручника або щось інше. Усе це буде створено автоматично на основі опису
OCaml.

=head3 Додавання тестів для програмного інтерфейсу

До кожного виклику програмного інтерфейсу можна не додавати тести або
додавати будь-яку кількість тестів. Тести може бути додано або як частину
опису програмного інтерфейсу (F<generator/actions_*.ml>), або у деяких
рідкісних випадках, додати скрипт до C<tests/*/>. Зауважте, що додавання
скрипту до C<tests/*/> уповільнює тестування, тому, якщо можна, користуйтеся
першим зі способів.

Нижче описано тестове середовище, яке використовується при додавання тесту
програмного інтерфейсу до F<actions_*.ml>.

У середовищі тестування 4 блокових пристрої:

=over 4

=item F</dev/sda> 2 ГБ

Блоковий пристрій загального типу для тестування.

=item F</dev/sdb> 2 ГБ

F</dev/sdb1> — файлова система ext2, яка використовується для тестування дій
із запису до файлової системи.

=item F</dev/sdc> 10 МБ

Використовується для тестів, у яких потрібні два блокових пристрої.

=item F</dev/sdd>

ISO із фіксованим вмістом (див. F<images/test.iso>).

=back

Щоб мати змогу виконувати тестування у прийнятні строки, базову систему та
блокові пристрої libguestfs слід повторно використовувати у тестах. Отже, не
намагайтеся тестувати L<guestfs(3)/guestfs_kill_subprocess> :-x

Кожен тест запускає початковий сценарій, який вибирається за допомогою
одного з виразів C<Init*>, описаний у F<generator/types.ml>. Сценарій
ініціалізує диски, згадані вище, у спосіб, який задокументовано у
F<types.ml>. Ви не повинні робити у своєму коді жодних припущень щодо
попереднього вмісту інших дисків, які не ініціалізовано.

Ви можете додати інструкцію щодо попередніх вимог до будь-якого окремого
тесту. Це динамічна перевірка, яка, якщо її не буде пройдено, призведе до
пропускання тесту. Це корисно для тестування команди, яка може не працювати
у всіх різновидах збірок libguestfs. Тест, для якого попередньою вимогою є
C<Always>, запускається безумовно.

Крім того, пакувальники можуть пропускати окремі тести встановленням
відповідних змінних середовища до запуску C<make check>.

 SKIP_TEST_<CMD>_<NUM>=1

Приклад: C<SKIP_TEST_COMMAND_3=1> призведе до пропускання тесту 3 у
L<guestfs(3)/guestfs_command>.

або:

 SKIP_TEST_<CMD>=1

Приклад: C<SKIP_TEST_ZEROFREE=1> призводить до пропускання усіх тестів
L<guestfs(3)/guestfs_zerofree>.

Пакувальники можуть обмежити тестування певним набором тестів, встановлюючи,
наприклад, таке:

 TEST_ONLY="vfs_type zerofree"

Див. F<tests/c-api/tests.c>, щоб дізнатися більше про те, як працюють ці
змінні середовища.

=head3 Діагностика нових програмних інтерфейсів

Перевірте нові можливості, перш ніж записувати їх до сховища коду.

Для перевірки нових команд ви можете скористатися guestfish.

Діагностика фонової служби є проблематичною, оскільки вона виконується у
мінімалістичному середовищі. Втім, ви можете скористатися виведенням
повідомлень за допомогою fprintf у фоновій службі до stderr. Повідомлення
можна буде переглядати за допомогою C<guestfish -v>.

=head2 ДОДАВАННЯ НОВОЇ ПРИВ’ЯЗКИ ДО МОВИ

Усі прив'язки до мов має бути створено відповідним засобом (див. підкаталог
F<generator>).

Документації з цього питання ще не написано. Пропонуємо вам звернутися до
коду наявних прив'язок, наприклад F<generator/ocaml.ml> або
F<generator/perl.ml>.

=head3 Додавання тестів для прив'язок до мов

Прив'язки до мов мають постачатися із тестами. Раніше тестування прив'язок
до мов було суто ситуативним, але тепер ми намагаємося формалізувати набір
тестів, які має використовувати кожна прив'язка до мови.

У поточній версії повний набір тестів реалізовано лише для прив'язок до
OCaml і Perl. Канонічним набором є набір для OCaml, тому вам слід емулювати
тести саме для OCaml.

Ось схема нумерації, яка використовується у тестах:

 - 000+, базові перевірки:
 
   010  завантажити бібліотеку
   020  створення
   030  прапорці створення
   040  створення декількох дескрипторів
   050  налаштовування тестування та отримання властивостей налаштовування
   060  явне закриття
   065  неявне закриття (у мовах із збирачем сміття)
   070  аргументи параметрів
   080  версія
   090  повернуті значення
 
 - 100  запуск, створення розділів та логічних томів, а також файлових систем
 
 - події 400+:
 
   410  подія закриття
   420  повідомлення журналу
   430  повідомлення щодо поступу
 
 - 800+ тести на регресії (специфічні для мови)
 
 - 900+ будь-які інші нетипові тести для мови

Для заощадження часу під час виконання тестування дескриптор запускатимуть
лише 100, 430, 800+, 900+.

=head2 ФОРМАТУВАННЯ КОДУ

Наш початковий код мовою C загалом відповідає деяким базовим вимогам щодо
форматування коду. Наявна кодова база є повністю однорідною у цьому сенсі,
але ми б хотіли, щоб увесь новий код також було форматовано подібним
чином. Якщо коротко, користуйтеся пробілами, а не символами табуляції,
використовуйте додаткові 2 пробіли на кожному із рівнів відступів, у інших
аспектах форматування слідуйте стилю книги Кернігана та Річі.

If you use Emacs, add the following to one of your start-up files (e.g.,
~/.emacs), to help ensure that you get indentation right:

 ;;; In libguestfs, indent with spaces everywhere (not TABs).
 ;;; Exceptions: Makefile and ChangeLog modes.
 (add-hook 'find-file-hook
     '(lambda () (if (and buffer-file-name
                          (string-match "/libguestfs\\>"
                              (buffer-file-name))
                          (not (string-equal mode-name "Change Log"))
                          (not (string-equal mode-name "Makefile")))
                     (setq indent-tabs-mode nil))))
 
 ;;; Під час редагування початкового коду C у libguestfs користуйтеся цим стилем.
 (defun libguestfs-c-mode ()
   "C mode with adjusted defaults for use with libguestfs."
   (interactive)
   (c-set-style "K&R")
   (setq c-indent-level 2)
   (setq c-basic-offset 2))
 (add-hook 'c-mode-hook
           '(lambda () (if (string-match "/libguestfs\\>"
                               (buffer-file-name))
                           (libguestfs-c-mode))))

=head2 ТЕСТУВАННЯ ВНЕСЕНИХ ВАМИ ЗМІН

Перетворити попередження на повідомлення про помилки під час розробки, щоб
ці попередження не ігнорувалися:

 ./configure --enable-werror

Корисні цілі збирання:

=over 4

=item C<make check>

Запускає звичайний комплект перевірок.

Реалізовано за допомогою типової цілі automake C<TESTS>. Докладніше про цю
ціль можна дізнатися з документації до automake.

=item C<make check-valgrind>

Запускає підмножину комплекту тестування у valgrind.

Див. L</VALGRIND> нижче.

=item C<make check-valgrind-local-guests>

Запускає підмножину комплекту тестування у valgrind з використанням локально
встановлених гостьових систем libvirt (лише для читання).

=item C<make check-direct>

Виконує усі тести за допомогою типового модуля роботи із базовою
системою. Працює, лише якщо за допомогою C<./configure
--with-default-backend=...> було вибрано нетиповий модуль.

=item C<make check-valgrind-direct>

Запустити підмножину комплексу тестів під керуванням valgrind з
використанням типового модуля базової системи.

=item C<make check-uml>

Виконує усі тести з використанням модуля режиму користувача у Linux.

Оскільки немає стандартизованого місця для зберігання ядра Linux з режимом
користувача, вам I<слід> встановити значення C<LIBGUESTFS_HV> таким чином,
щоб воно вказувало на образ ядра. Приклад:

 make check-uml LIBGUESTFS_HV=~/d/linux-um/vmlinux

=item C<make check-valgrind-uml>

Виконує усі тести з використанням модуля режиму користувача Linux під
керуванням valgrind.

Як і вище, вам слід встановити значення C<LIBGUESTFS_HV> так, щоб воно
вказувало на ядро.

=item C<make check-with-upstream-qemu>

Виконує усі тести з використанням локального виконуваного файла qemu. Шукає
виконуваний файл qemu за допомогою змінної QEMUDIR (типове значення
F<$HOME/d/qemu>), але ви можете встановити інший каталог за допомогою рядка
команди. Приклад:

 make check-with-upstream-qemu QEMUDIR=/usr/src/qemu

=item C<make check-with-upstream-libvirt>

Виконує усі тести за допомогою локальної копії libvirt. Працює, лише якщо за
допомогою C<./configure --with-default-backend=libvirt> було вибрано модуль
libvirt.

Пошук libvirt виконуватиметься у каталозі LIBVIRTDIR (типово,
F<$HOME/d/libvirt>), але ви можете вказати інший каталог у рядку
команди. Приклад:

 make check-with-upstream-libvirt LIBVIRTDIR=/usr/src/libvirt

=item C<make check-slow>

Запускає повільні тести або тести, які виконуються довго. Такі тести типово
не запускаються.

Щоб позначити тест як повільний або такий, який виконується довго:

=over 4

=item *

Додайте це до списку C<TESTS> у F<Makefile.am>, подібно до звичайного тесту.

=item *

Змініть тест так, щоб у ньому перевірялася умова для змінної середовища
C<SLOW=1>, і якщо таке значення змінної I<не> встановлено, тест пропускався
(тобто повертав код виходу 77). Якщо використовується C<$TEST_FUNCTIONS>,
для цього ви можете викликати функцію C<slow_test>.

=item *

Додайте змінну C<SLOW_TESTS> до файла F<Makefile.am> зі значенням-списком
повільних тестів.

=item *

Додайте таке правило до F<Makefile.am>:

 check-slow:
   $(MAKE) check TESTS="$(SLOW_TESTS)" SLOW=1

=back

=item C<sudo make check-root>

Запускає деякі тести, які потребують прав доступу користувача root. Ці
тести, як ми припускаємо, безпечні, але вам слід вжити усіх додаткових
засобів захисту. Вам слід запускати цю команду від імені root (наприклад, за
допомогою явного використання L<sudo(8)>).

Щоб позначити тест як такий, що вимагає прав доступу користувача root:

=over 4

=item *

Додайте це до списку C<TESTS> у F<Makefile.am>, подібно до звичайного тесту.

=item *

Внесіть зміни до тесту так, щоб тест перевіряв, чи euid == 0, і якщо це
значення I<не> встановлено, тест пропускається (тобто повертає код виходу
77). Якщо використовується C<$TEST_FUNCTIONS>, ви можете викликати функцію
C<root_test> для цього.

=item *

Додайте змінну C<ROOT_TESTS> до файла F<Makefile.am> зі значенням-списком
тестів для root.

=item *

Додайте таке правило до F<Makefile.am>:

 check-root:
   $(MAKE) check TESTS="$(ROOT_TESTS)"

=back

=item C<make check-all>

Еквівалент запуску усіх правил C<make check*>, окрім C<check-root>.

=item C<make check-release>

Виконує підмножину правил C<make check*>, які слід передати до створення
архіву tar. У поточній версії це:

=over 4

=item *

check

=item *

check-valgrind

=item *

check-direct

=item *

check-valgrind-direct

=item *

check-slow

=back

=item C<make installcheck>

Запустити C<make check> для встановленої копії libguestfs.

Версії встановленої libguestfs, тестування якої виконується, та версія у
ієрархії початкового коду libguestfs мають збігатися.

Команди:

 ./autogen.sh
 make clean ||:
 make
 make installcheck

=back

=head2 VALGRIND

Коли ви віддаєте команду C<make check-valgrind>, відбувається пошук
будь-якого F<Makefile.am> у ієрархії коду, де є ціль C<check-valgrind:>, і
його запуск.

Правильно написати F<Makefile.am> і тести, щоб скористатися valgrind і
паралельним тестуванням automake, не так уже і просто.

Якщо ваш тести запускаються за допомогою скриптової обгортки для командної
оболонки, у обгортці слід скористатися таким кодом:

 $VG virt-foo

а у F<Makefile.am> слід вказати:

 check-valgrind:
     make VG="@VG@" check

Втім, якщо ваші виконувані файли запускаються безпосередньо з правила
C<TESTS>, до F<Makefile.am> слід внести такий рядок:

 LOG_COMPILER = $(VG)
 
 check-valgrind:
     make VG="@VG@" check

Який би з варіантів ви не реалізовували, слід перевіряти, чи ту програму ви
тестуєте, шляхом уважного вивчення файлів журналу F<tmp/valgrind*>.

=head2 НАДСИЛАННЯ ЛАТОК

Надсилайте латки до списку листування,
L<http://www.redhat.com/mailman/listinfo/libguestfs> і копію повідомлення до
L<rjones@redhat.com>.

Можете не підписуватися на список листування, якщо не хочете. Втім, для
непідписаних користувачів повідомлення з'являються у списку із затримкою,
потрібною на модерацію.

=head2 НЕТИПОВІ ЗАСОБИ ФОРМАТУВАННЯ PRINTF У ФОНОВІЙ СЛУЖБІ

У коді фонової служби напис створено нетипові форматувальники printf C<%Q> і
C<%R>, які використовуються для режиму встановлення лапок у командній
оболонці.

=over 4

=item %Q

Простий рядок командної оболонки із лапками. Автоматичне екранування
пробілів та інших керівних символів оболонки.

=item %R

Те саме, що і C<%Q>, але рядок вважатиметься шляхом із префіксом sysroot.

=back

Приклад:

 asprintf (&cmd, "cat %R", path);

дасть C<cat /sysroot/якийсь\ шлях\ із\ пробілами>

I<Зауваження:> I<не> використовуйте ці замінники, якщо передаєте параметри
функціям C<command{,r,v,rv}()>. У параметрах цих функцій НЕ потрібно нічого
міняти, оскільки вони не передаються крізь командну оболонку (а
безпосередньо передаються функції exec). Втім, ймовірно, варто
використовувати функцію C<sysroot_path()>.

=head2 ПІДТРИМКА ІНТЕРНАЦІОНАЛІЗАЦІЇ (I18N)

У нашій бібліотеці передбачено можливість інтернаціоналізації (засобами
gettext).

Втім, багато повідомлень надходять від фонової служби, і у поточній версії
ми їх не перекладаємо. Однією з причин цього є те, що, загалом, у базовій
системі немає файлів локалей, оскільки вони досить об'ємні. Тому для
реалізації можливості перекладу нам довелося б додати ці файли і скопіювати
наші файли PO до базової системи.

Діагностичні повідомлення не перекладаються, оскільки їх призначено для
програмістів.

=head1 ІНШІ ТЕМИ

=head2 ЯК КОМПІЛЮЮТЬСЯ І КОМПОНУЮТЬСЯ ПРОГРАМИ OCAML

Більша частина цього розділу присвячена питанню «як ми змусили automake і
ocamlopt працювати разом», оскільки самі програми OCaml зібрати легко.

У automake немає вбудованої підтримки програм OCaml, ocamlc та ocamlopt. Наш
підхід полягає у обробці програм OCaml як програм C, які можуть містити такі
«інші об'єкти» (C<"DEPENDENCIES"> у термінології automake), які можуть бути
об'єктами OCaml. Це працює, оскільки програми OCaml зазвичай містять файли C
для природних прив'язок до бібліотек тощо.

Отже, типова програма описується як список файлів з її кодом мовою C:

 virt_v2v_SOURCES = ... utils-c.c xml-c.c

Для програм, які не містять явних початкових текстів мовою C ми створюємо
порожній файл F<dummy.c> і додаємо його до списку замість справжніх файлів:

 virt_resize_SOURCES = dummy.c

Об'єкти OCaml, які містять більшу частину коду, потрапляють до списку як
залежності automake (інші залежності також можуть потрапляти до списку):

 virt_v2v_DEPENDENCIES = ... cmdline.cmx v2v.cmx

Окрім того, єдиною іншою річчю, яку нам слід зробити, є надання нетипової
команди компонування. Ця команда потрібна, оскільки інакше automake не зможе
зібрати команду ocamlopt, список об'єктів та бібліотеки C<-cclib> у
належному порядку.

 virt_v2v_LINK = \
     $(top_srcdir)/ocaml-link.sh -cclib '-lutils -lgnu' -- ...

Справжні правила, із якими ви можете ознайомитися у файлі F<v2v/Makefile.am>
є дещо складнішими за ці, оскільки у них ще треба обробити:

=over 4

=item *

Компіляцію у байткод або природний код системи.

=item *

Взірцеві правила, потрібні для збирання коду OCaml у об'єкти.

Ці правила тепер зберігаються у F<subdir-rules.mk> на верхньому рівні
ієрархії коду. Цей файл включається до усіх підкаталогів F<Makefile.am>.

=item *

Додавання файлів початкового коду OCaml до C<EXTRA_DIST>.

Automake не зможе визначити повний список початкових кодів для виконуваного
файла, тому програма не зможе додати відповідні файли автоматично.

=back

=head2 VIRT-V2V

Спочатку трохи історії. Протягом свого існування програма virt-v2v зазнала
принаймні двох повних переписувань, тому поточна версія є принаймні третьою
(ми не маємо планів переписувати її ще раз). Попередню версію було написано
мовою Perl. Її код і досі зберігається тут:
L<https://git.fedorahosted.org/git/virt-v2v.git>

Поточну версію було започатковано як майже порядково переписану з Perl на
OCaml + C, і вона все ще зберігає повністю подібну структуру. Тому, якщо ви
не розумієте якихось подробиць щодо коду (особливо подробиць щодо
перетворення гостьових систем), вам може допомогти читання коду мовою Perl.

Ось файли, з яких варто розпочати читання цього коду:

=over 4

=item *

F<types.mli>

=item *

F<v2v.ml>

=back

У F<types.mli> визначаються усі структури, які використовуються і
передаються під час обміну даними між різними частинами програми. У
F<v2v.ml> реалізовано керування роботою програми на різних етапах.

Після вивчення цих файлів ви можете перейти до вивчення модулів вхідних
даних (F<input_*>), модулів вихідних даних (F<output_*>) або модулів
перетворення (F<convert_*>). Модулі вхідних і вихідних даних визначають
перелік варіантів для параметрів I<-i> та I<-o> (див. підручник). Модулі
перетворення визначають, із якими типами гостьових систем ми можемо
працювати і які конкретно кроки слід виконати для їхнього перетворення.

Усі інші файли у цьому каталозі є певним чином супровідними модулями або
бібліотеками. Частину коду написано мовою C, особливо там, де ми хотіли
використати зовнішні бібліотеки C, зокрема libxml2.

=head2 VIRT-P2V

Virt-p2v є оболонкою над virt-v2v. Інакше кажучи, усе, що робить ця
програма, — це працює як оболонка із графічним інтерфейсом, для виконання
самого перетворення ця програма викликає virt-v2v. Тому, більша частина коду
мовою C у підкаталозі F<p2v/> є кодом Gtk (графічного інтерфейсу) або
супутнім кодом для обміну даними із віддаленим сервером перетворення. У
virt-v2v немає ніякого спеціальної підтримки фізичних машин. Дані фізичним
машин перетворюються у той самий спосіб, що і дані сторонніх віртуальних
машин.

=head3 Як запустити virt-p2v

Ви можете запустити виконуваний файл F<p2v/virt-p2v> безпосередньо, але
програма спробує перетворити справжній диск F</dev/sda> вашої системи, що
навряд чи дасть бажані результати. Втім, virt-p2v також має тестовий режим,
у якому ви можете вказати тестовий диск:

 make -C p2v run-virt-p2v-directly

Це обгортка до параметра I<--test-disk> L<virt-p2v(1)>. Ви можете керувати
диском «фізичної машини» встановленням значення C<PHYSICAL_MACHINE>, яке
вказує на образ диска.

Реалістичнішим тестом є запуск virt-p2v у віртуальній машині на локальній
машині. Для цього зробіть так:

 make -C p2v run-virt-p2v-in-a-vm

Ця команда також запускає qemu для диска «фізичної машини» (вказати яку
можна за допомогою встановлення значення змінної C<PHYSICAL_MACHINE>),
віртуального компакт-диска та різноманітних мережевих карток для
тестування. Ви можете змінити виконуваний файл qemu і додати параметри
команди qemu встановленням значень параметрів C<QEMU> і/або C<QEMU_OPTIONS>
у командному рядку make.

Запущена у третій спосіб програма virt-p2v досить точно імітує програму, що
отримується за допомогою PXE, а потім виконує автоматичне перетворення
початкової фізичної машини (спосіб без графічного інтерфейсу —
див. наступний розділ нижче):

 make -C p2v run-virt-p2v-non-gui-conversion

=head3 Як розібратися у коді virt-p2v

I<Див. також:> L<virt-p2v(1)/ЯК ПРАЦЮЄ VIRT-P2V>

Існує два шляхи крізь код, з графічним інтерфейсом або без графічного
інтерфейсу (обробка командного рядка ядра):

 main.c ──────┬─────▶ gui.c ──────┬─────▶ conversion.c
              │                   │
              │                   │
              └────▶ kernel.c ────┘

але обидва шляхи виконують зворотний виклик функції C<start_conversion> з
F<conversion.c> для запуску віддаленого virt-v2v.

Основним завданням F<gui.c>/F<kernel.c> є заповнення параметрів
налаштовування virt-v2v (F<config.c>).

Під час перетворення слід встановити з'єднання ssh, і це виконується за
допомогою двох бібліотек:

 conversion.c ──────▶ ssh.c ──────▶ miniexpect.c

де F<ssh.c> відповідає за керування з'єднаннями ssh взагалі, а
F<miniexpect.c> реалізує expect-подібні функціональні можливості для
інтерактивного обміну даними із віддаленим сервером перетворення virt-v2v.

(Зауважте, що miniexpect є окремою бібліотекою із власною основною гілкою
розробки, отже, якщо ви накладаєте латку на miniexpect.c, будь ласка,
переконайтеся, що зміни також надіслано до основної гілки розробки
miniexpect: F<http://git.annexia.org/?p=miniexpect.git;a=summary>)

=head1 ЗАВДАННЯ ІЗ СУПРОВОДУ

=head2 ЦІЛІ ДЛЯ СУПРОВІДНИКІВ У MAKEFILE

Ці цілі C<make>, ймовірно, не працюватимуть або не будуть корисними, якщо ви
не є супровідником пакунків libguestfs.

=head3 make maintainer-commit

Ця ціль вносить усі зміни із робочого каталогу до системи керування сховищем
коду із повідомленням щодо внеску C<Version $(VERSION).>. Вам слід спочатку
оновити F<configure.ac>, очистити ієрархію коду та виконати повторне
збирання.

=head3 make maintainer-tag

Ця команда створює мітку для поточного внеску у HEAD зі значенням мітки
C<v$(VERSION)> і одним із таких повідомлень:

 Version $(VERSION) stable

 Version $(VERSION) development

(Опис відмінностей між стабільним випуском і випуском, який перебуває у
розробці, наведено у розділі L<guestfs(3)/НУМЕРАЦІЯ ВЕРСІЙ LIBGUESTFS>.)

=head3 make maintainer-check-authors

Перевірити, чи усіх авторів (записи яких можна знайти у повідомленнях щодо
внесків до git) включено до файла F<generator/authors.ml>.

=head3 make maintainer-check-extra-dist

Це правило слід запускати після C<make dist> (щоб у робочому каталозі уже
був архів tar). Воно порівнює вміст архіву tar із даними у git з метою
переконатися, що не пропущено жодного файла із правил C<EXTRA_DIST> у
F<Makefile.am>.

=head3 make maintainer-upload-website

Це правило використовується програмним забезпеченням автоматизації випусків
libguestfs для копіювання сайта libguestfs до іншого сховища git до його
вивантаження на вебсервер.

=head2 СТВОРЕННЯ СТАБІЛЬНОГО ВИПУСКУ

Тут наведено документацію щодо створення стабільних випусків. Загальні
правила щодо створення стабільних випусків наведено у розділі
L<guestfs(3)/НУМЕРАЦІЯ ВЕРСІЙ LIBGUESTFS>.

=over 4

=item *

Перевірте, чи працює C<make && make check> принаймні у таких системах:

=over 4

=item Fedora (x86-64)

=item Debian (x86-64)

=item Ubuntu (x86-64)

=item Fedora (aarch64)

=item Fedora (ppc64)

=item Fedora (ppc64le)

=back

=item *

Перевірте, чи працює C<./configure --without-libvirt>.

=item *

Внесіть завершальні зміни до F<guestfs-release-notes.pod>

=item *

Надіслати і отримати дані з Zanata.

Віддайте команду:

 zanata push

щоб надіслати найсвіжіші файли POT на Zanata. Потім віддайте команду:

 ./zanata-pull.sh

яка є обгорткою для команд отримання найсвіжіших перекладених файлів
F<*.po>.

=item *

Оновіть gnulib до найсвіжішої версії основної гілки розробки.

=item *

Створіть каталоги стабільної версії і версії у розробці на
L<http://libguestfs.org/download>.

=item *

Внесіть зміни до F<website/index.html.in>.

=item *

Встановіть версію (у F<configure.ac>) у значення нової I<стабільної> версії,
тобто 1.XX.0, і запишіть версію:

 ./localconfigure
 make distclean -k
 ./localconfigure
 make && make dist
 make maintainer-commit
 make maintainer-tag

=item *

Створіть стабільну гілку у git:

 git branch stable-1.XX
 git push origin stable-1.XX

=item *

Виконайте повноцінний випуск стабільної гілки.

=item *

Встановіть значення номера наступної версії для розробки і запишіть його до
сховища. Можна також створити повноцінний випуск із гілки для розробки.

=back

=head1 ВНУТРІШНЯ ДОКУМЕНТАЦІЯ

У цьому розділі наведено документацію щодо внутрішніх функцій libguestfs та
різноманітних допоміжних програм. Вміст цього розділу буде цікавим лише для
розробників libguestfs.

Цей розділ створено автоматично на основі тих коментарів C</**> у файлах
початкового коду, які форматовано для використання у форматі POD.

B<Ці функції не експортуються відкрито (public). Їх може бути змінено або
вилучено у будь-якій новішій версії.>

__INTERNAL_DOCUMENTATION__

=head1 ТАКОЖ ПЕРЕГЛЯНЬТЕ

L<guestfs(3)>, L<guestfs-building(1)>, L<guestfs-examples(3)>,
L<guestfs-internals(1)>, L<guestfs-performance(1)>,
L<guestfs-release-notes(1)>, L<guestfs-testing(1)>,
L<libguestfs-test-tool(1)>, L<libguestfs-make-fixed-appliance(1)>,
L<http://libguestfs.org/>.

=head1 АВТОРИ

Richard W.M. Jones (C<rjones at redhat dot com>)

=head1 АВТОРСЬКІ ПРАВА

Copyright (C) 2009-2019 Red Hat Inc.

