.\" Automatically generated by Podwrapper::Man 1.40.2 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "guestfs-recipes 1"
.TH guestfs-recipes 1 "2019-02-07" "libguestfs-1.40.2" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
guestfs-recipes — рецепти для libguestfs, guestfish та інструментів
віртуалізації
.SH "ОПИС"
.IX Header "ОПИС"
На цій сторінці містяться рецепти і посилання на сторінки із описом дій, які
можна виконати за допомогою libguestfs, \fBguestfish\fR\|(1) та інших засобів
віртуалізації.
.SH "Доступ до віддаленого образу диска за допомогою guestfish"
.IX Header "Доступ до віддаленого образу диска за допомогою guestfish"
Якщо образ диска зберігається на віддаленому сервері, доступ до якого
здійснюється за допомогою \s-1SSH, HTTP, FTP, NBD,\s0 iSCSI або подібного
протоколу, ви можете відкрити його безпосередньо. Приклади наведено у
розділі \*(L"ДОДАВАННЯ ВІДДАЛЕНОГО СХОВИЩА\*(R" in \fBguestfish\fR\|(1). Цю можливість
реалізовано у libguestfs ≥ 1.22 та qemu ≥ 1.5.
.SH "Аудит віртуальної машини щодо файлів із setuid"
.IX Header "Аудит віртуальної машини щодо файлів із setuid"
See: \*(L"\s-1EXAMPLES\*(R"\s0 in \fBvirt\-ls\fR\|(1).
.SH "Аудит віртуальної машини щодо вразливостей і проблем захисту"
.IX Header "Аудит віртуальної машини щодо вразливостей і проблем захисту"
Див.
https://rwmj.wordpress.com/2013/05/16/scanning\-offline\-guests\-using\-openscap\-and\-guestmount/#content
.SH "Зміна зображення тла у віртуальній машині Windows XP"
.IX Header "Зміна зображення тла у віртуальній машині Windows XP"
За наведеними нижче посиланнями можна знайти опис використання
\&\fBguestfish\fR\|(1) для зміни зображення тла для користувача віртуальної машини
Windows \s-1XP.\s0 На жаль, у різних версіях Windows методика досягнення
аналогічного результату є різною.
.PP
https://lists.fedoraproject.org/pipermail/virt/2011\-May/002655.html
https://lists.fedoraproject.org/pipermail/virt/2011\-May/002658.html
.SH "Створення контрольної суми файла або пристрою всередині образу диска"
.IX Header "Створення контрольної суми файла або пристрою всередині образу диска"
Щоб створити контрольну суму усього пристрою, розділу, логічного тому
всередині образу диска, скористайтеся командою:
.PP
.Vb 1
\& guestfish \-\-ro \-a диск.img run : checksum\-device md5 /dev/sda1
.Ve
.PP
Замініть \f(CW\*(C`md5\*(C'\fR на тип потрібної вам контрольної суми. Список підтримуваних
типів можна знайти у розділі \*(L"guestfs_checksum_device\*(R" in \fBguestfs\fR\|(3).
.PP
\&\fI/dev/sda1\fR означає «перший розділ». Ви можете скористатися \fI/dev/sda\fR,
щоб обчислити контрольну суму всього образу диска, або вказати назву
логічного тому або пристрою \s-1RAID.\s0
.PP
Створення контрольної суми для окремого файла:
.PP
.Vb 1
\& guestfish \-\-ro \-a диск.img \-i checksum sha256 /etc/passwd
.Ve
.PP
або для гостьової системи Windows:
.PP
.Vb 2
\& guestfish \-\-ro \-a диск.img \-i \e
\&   checksum sha256 \*(Aqwin:\ewindows\esystem32\econfig\eSOFTWARE\*(Aq
.Ve
.SH "Клонування віртуальної машини"
.IX Header "Клонування віртуальної машини"
Скористайтеся комбінацією інструментів, подібних до \fBcp\fR\|(1), \fBdd\fR\|(1), та
інструментами віртуалізації, зокрема \fBvirt\-sysprep\fR\|(1), \fBvirt\-sparsify\fR\|(1)
та \fBvirt\-resize\fR\|(1).
.PP
Докладніший опис у розділі \*(L"КОПІЮВАННЯ І КЛОНУВАННЯ\*(R" in \fBvirt\-sysprep\fR\|(1).
.SH "Перетворення CD-ROM / DVD / ISO на архів tar"
.IX Header "Перетворення CD-ROM / DVD / ISO на архів tar"
Ця команда перетворює \fIcd.iso\fR на \fIcd.tar.gz\fR:
.PP
.Vb 1
\& guestfish \-\-ro \-a cd.iso \-m /dev/sda tgz\-out / cd.tar.gz
.Ve
.PP
Щоб експортувати підкаталог, наприклад \fI/files\fR, віддайте таку команду:
.PP
.Vb 1
\& guestfish \-\-ro \-a cd.iso \-m /dev/sda tgz\-out /files cd.tar.gz
.Ve
.SH "Перетворення з одного формату або однієї файлової системи у інший формат"
.IX Header "Перетворення з одного формату або однієї файлової системи у інший формат"
Якщо у вас є диск із даними у одному форматі, файловій системі, на розділі
або під керуванням засобу керування томами, за допомогою цієї методики ви
можете перетворити ці дані у інший формат.
.PP
У цьому прикладі ми розпочнемо з диска, на якому є один розділ із однією
файловою системою. Ми створимо інший диск, який міститиме ті самі файли, але
у файловій системі ext3, вбудованій у логічний том на диску у розрідженому
простому (raw) форматі.
.PP
Спочатку створіть форматований, але порожній диск призначення:
.PP
.Vb 2
\& truncate \-s 10G target.img
\& virt\-format \-a target.img \-\-partition=mbr \-\-lvm \-\-filesystem=ext3
.Ve
.PP
Тепер, з'єднаємо канали обробки двох екземплярів guestfish разом для
передавання старих даних на новий диск:
.PP
.Vb 2
\& guestfish \-\-ro \-a source.img \-m /dev/sda1  \-\- tar\-out / \- | \e
\& guestfish \-\-rw \-a target.img \-m /dev/VG/LV \-\- tar\-in \- /
.Ve
.PP
Для навігації створеним остаточним образом диска скористайтеся такою
командою:
.PP
.Vb 2
\& guestfish \-\-ro \-a target.img \-m /dev/VG/LV
\& ><fs> ll /
.Ve
.PP
Ця методика доволі потужна і надає вам змогу, наприклад, поділити початкові
каталоги між файловими системами призначення.
.PP
Зауважте, що це не працюватиме (принаймні безпосередньо) для
завантажувальних дисків віртуальних машин, оскільки не копіюється
завантажувач.
.SH "Перетворення DVD Windows на придатний до завантаження диск USB"
.IX Header "Перетворення DVD Windows на придатний до завантаження диск USB"
http://rwmj.wordpress.com/2013/05/09/tip\-convert\-a\-windows\-dvd\-iso\-to\-a\-bootable\-usb\-key\-using\-guestfish/#content
.SH "Перетворення образу без розділів у стилі Xen на образ диска із розділами"
.IX Header "Перетворення образу без розділів у стилі Xen на образ диска із розділами"
У образах дисків Xen часто немає розділів. Це означає, що файлова система
розпочинається безпосередньо на початку диска, без таблиці розділів. Ви,
фактично, можете користуватися такими образами безпосередньо у \s-1KVM\s0 (якщо
гостьовою системою не є Windows), але декому подобається перетворювати такі
образи у образи дисків зі звичайним розподілом на розділи. Такий розподіл є
обов'язковим для гостьових систем Windows. Ось як скористатися guestfish для
виконання цього завдання:
.PP
.Vb 12
\& guestfish
\& ><fs> add\-ro input.img
\& ><fs> sparse output.img 10G     # скоригувати розмір результату
\& ><fs> run
\& # Створити таблицю розділів на диску\-результаті:
\& ><fs> part\-init /dev/sdb mbr
\& ><fs> part\-add /dev/sdb p 2048 \-2048
\& # Скопіювати дані на розділ призначення:
\& ><fs> copy\-device\-to\-device /dev/sda /dev/sdb1 sparse:true
\& # Додатково змінити розмір файлової системи призначення.
\& # Скористайтеся ntfsresize для гостьових систем Windows:
\& ><fs> resize2fs /dev/sdb1
.Ve
.PP
Такий образ диска не можна буде безпосередньо завантажити. Ймовірно, для
його завантаження вам доведеться використовувати зовнішнє ядро та initramfs
(див. нижче). Ви також можете скористатися командами guestfish \f(CW\*(C`syslinux\*(C'\fR
та \f(CW\*(C`extlinux\*(C'\fR для встановлення завантажувача \s-1SYSLINUX.\s0
.SH "Створення порожніх образів дисків"
.IX Header "Створення порожніх образів дисків"
Програма \fBvirt\-format\fR\|(1) може робити це безпосередньо.
.PP
Скористайтеся \fBvirt\-make\-fs\fR\|(1) для створення образу диска з даними. Ця
програма здатна також створювати деякі стандартні образи дисків, зокрема
віртуальні пристрої для читання дискет (\s-1VFD\s0).
.PP
Ви також можете скористатися параметром \fI\-N\fR \fBguestfish\fR\|(1) для створення
порожніх образів дисків. Корисні настанови, наведені нижче, допоможуть вам
скористатися доступними варіантами.
.PP
https://rwmj.wordpress.com/2010/09/08/new\-guestfish\-n\-options\-in\-1\-5\-9/#content
.PP
\&\fBvirt\-builder\fR\|(1) може створювати мінімальні гостьові системи.
.SH "Вилучення файлів (або інші прості дії з файлами)"
.IX Header "Вилучення файлів (або інші прості дії з файлами)"
Скористайтеся guestfish. Вилучення файла:
.PP
.Vb 1
\& guestfish \-a диск.img \-i rm /файл/який/слід/вилучити
.Ve
.PP
Торкнутися файла (оновити його часову позначку або створити його):
.PP
.Vb 1
\& guestfish \-a диск.img \-i touch /файл/позначку/якого/слід/оновити
.Ve
.PP
Отримання статистичних даних щодо файла. Оскільки для цієї дії потрібне лише
читання, можна зробити її безпечнішою, додавши параметр \fI\-\-ro\fR.
.PP
.Vb 1
\& guestfish \-\-ro \-a диск.img \-i stat /файл/який/слід/обробити
.Ve
.PP
Таких команд десятки. Див. \fBguestfish\fR\|(1)  або дані, виведені командою
\&\f(CW\*(C`guestfish \-h\*(C'\fR
.SH "Порівняти дві гостьові системи; порівняти знімок із поточною версією"
.IX Header "Порівняти дві гостьові системи; порівняти знімок із поточною версією"
Починаючи з libguestfs ≥ 1.26, можна скористатися \fBvirt\-diff\fR\|(1) для
пошуку відмінностей між двома гостьовими системами (наприклад, якщо ці
системи у початковому стані були клонами тієї самої системи) або між двома
знімками однієї гостьової системи. У ранніх версіях libguestfs для цього
використовувалася програма \fBvirt\-ls\fR\|(1).
.SH "Вимикання служби systemd"
.IX Header "Вимикання служби systemd"
Наведена нижче команда є еквівалентом \f(CW\*(C`systemctl mask ...\*(C'\fR. Щоб вимкнути
службу \f(CW\*(C`cloud\-init\*(C'\fR так, щоб вона не запускалася під час наступного
завантаження, віддайте таку команду:
.PP
.Vb 2
\& guestfish \-a disk.img \-i \e
\&     ln\-sf /dev/null /etc/systemd/system/cloud\-init.service
.Ve
.PP
Щоб вимкнути tmp-on-tmpfs:
.PP
.Vb 2
\& guestfish \-a disk.img \-i \e
\&     ln\-sf /dev/null /etc/systemd/system/tmp.mount
.Ve
.PP
Однією з проблем наведених вище команд є те, що ви не отримаєте ніякого
відгуку від системи, якщо назву служби, яку ви хочете замаскувати, вказано
неправильно. Але ви можете скористатися \fBvirt\-ls\fR\|(1) для отримання списку
доступних служб systemd, ось так:
.PP
.Vb 1
\& virt\-ls \-a /tmp/fedora\-19.img \-R /lib/systemd/system
.Ve
.SH "Літери дисків у FUSE"
.IX Header "Літери дисків у FUSE"
Якщо ви маєте справу із гостьовою системою Windows і хочете відкрити її
літерні диски як точки монтування \s-1FUSE\s0 (\fI/C/...\fR, \fI/D/...\fR тощо), замість
\&\fBguestmount\fR\|(1) скористайтеся таким скриптом мовою Perl:
.PP
.Vb 10
\& #!/usr/bin/perl \-w
\& use strict;
\& use Sys::Guestfs;
\& $| = 1;
\& die "usage: $0 mountpoint disk.img" if @ARGV < 2;
\& my $mp = shift @ARGV;
\& my $g = new Sys::Guestfs;
\& $g\->add_drive_opts ($_) foreach @ARGV;
\& $g\->launch;
\& my @roots = $g\->inspect_os;
\& die "$0: no operating system found" if @roots != 1;
\& my $root = $roots[0];
\& die "$0: not Windows" if $g\->inspect_get_type ($root) ne "windows";
\& my %map = $g\->inspect_get_drive_mappings ($root);
\& foreach (keys %map) {
\&     $g\->mkmountpoint ("/$_");
\&     eval { $g\->mount ($map{$_}, "/$_") };
\&     warn "$@ (ignored)\en" if $@;
\& }
\& $g\->mount_local ($mp);
\& print "filesystem ready on $mp\en";
\& $g\->mount_local_run;
\& $g\->shutdown;
.Ve
.PP
Ви можете скористатися скриптом ось так:
.PP
.Vb 3
\& $ mkdir /tmp/mnt
\& $ ./drive\-letters.pl /tmp/mnt windows7.img
\& filesystem ready on /tmp/mnt
.Ve
.PP
У іншому вікні:
.PP
.Vb 12
\& $ cd /tmp/mnt
\& $ ls
\& C  D
\& $ cd C
\& $ ls
\& Documents and Settings
\& PerfLogs
\& ProgramData
\& Program Files
\& [etc]
\& $ cd ../..
\& $ guestunmount /tmp/mnt
.Ve
.SH "Створення дампів вмісту простої файлової системи у образі диска або ВМ"
.IX Header "Створення дампів вмісту простої файлової системи у образі диска або ВМ"
Ви можете скористатися командою \f(CW\*(C`download\*(C'\fR \fBguestfish\fR\|(1) для видобування
вмісту простої файлової системи з будь\-якої файлової системи на образі диску
або у віртуальній машині (навіть зашифрованої або захованої у логічному томі
або на пристрої \s-1RAID\s0):
.PP
.Vb 1
\& guestfish \-\-ro \-a disk.img run : download /dev/sda1 sda1.img
\&
\& guestfish \-\-ro \-d Guest run : download /dev/vg_guest/lv_root lv.img
.Ve
.PP
Щоб отримати дані до stdout, замініть назву файла символом \f(CW\*(C`\-\*(C'\fR:
.PP
.Vb 1
\& guestfish \-\-ro \-a disk.img run : download /dev/sda1 \- | gzip > sda1.gz
.Ve
.PP
Для отримання списку файлових систем на образі диска скористайтеся
\&\fBvirt\-filesystems\fR\|(1).
.PP
Див. також \*(L"Вивантаження даних на файлові системи без обробки\*(R".
.SH "Редагувати налаштування grub у віртуальній машині"
.IX Header "Редагувати налаштування grub у віртуальній машині"
Ви можете скористатися цим для того, щоб виконати такі завдання:
.IP "\(bu" 4
Виправити віртуальну машину, яка не завантажується.
.IP "\(bu" 4
Змінити ядро, яке використовується для завантаження віртуальної машини.
.IP "\(bu" 4
Змінити параметри командного рядка ядра.
.PP
Для редагування налаштувань grub скористайтеся \fBvirt\-edit\fR\|(1):
.PP
.Vb 1
\& virt\-edit \-d BrokenGuest /boot/grub2/grub.cfg
.Ve
.PP
або, для загального виправлення у непридатній до завантаження віртуальній
машині, скористайтеся \fBvirt\-rescue\fR\|(1) ось так:
.PP
.Vb 1
\& virt\-rescue \-d BrokenGuest
.Ve
.SH "Експортувати будь\-який каталог з віртуальної машини"
.IX Header "Експортувати будь-який каталог з віртуальної машини"
Щоб експортувати \fI/home\fR з віртуальної машини до локального каталогу,
скористайтеся \fBvirt\-copy\-out\fR\|(1):
.PP
.Vb 1
\& virt\-copy\-out \-d Guest /home .
.Ve
.PP
Нотатки:
.IP "\(bu" 4
Кінцева крапка у команді не є друкарською помилкою. Вона означає, що ми
хочемо скопіювати дані до поточного каталогу.
.IP "\(bu" 4
Ця команда створить каталог із назвою \f(CW\*(C`home\*(C'\fR у поточному каталозі.
.PP
Якщо гостьова система є операційною системою Windows, ви можете скористатися
літерами дисків та символами зворотної похилої риски, але вам слід додати до
шляху префікс \f(CW\*(C`win:\*(C'\fR і взяти його у лапки, щоб захистити від обробки
командною оболонкою, ось так:
.PP
.Vb 1
\& virt\-copy\-out \-d WinGuest \*(Aqwin:c:\ewindows\esystem32\econfig\*(Aq .
.Ve
.PP
Щоб отримати результат у форматі стисненого архіву tar, слід віддати таку
команду:
.PP
.Vb 1
\& virt\-tar\-out \-d Guest /home \- | gzip \-\-best > home.tar.gz
.Ve
.PP
Хоча виникає спокуса використання цієї команди для створення резервних копій
запущеної гостьової системи, не варто користуватися нею саме для
цього. Докладніше про це у розділі запитань та відповідей на них:
http://libguestfs.org/FAQ.html#backup
.SH "Експортування зовнішнього ядра та initramfs (initrd)"
.IX Header "Експортування зовнішнього ядра та initramfs (initrd)"
Якщо у гостьовій системі Linux немає завантажувача або завантажувач
пошкоджено, ви, зазвичай, можете завантажити цю систему за допомогою
зовнішнього ядра і initramfs. У такій конфігурації гіпервізор працює як
завантажувач, завантажуючи ядро з диска основної системи до пам'яті
гостьової системи і переходячи безпосередньо до ядра.
.PP
Втім, у вас може виникнути питання щодо того, як отримати правильне ядро,
яке відповідає образу диска, який у вас є. Починаючи з libguestfs ≥
1.24, \fBvirt\-builder\fR\|(1) може отримувати найсвіжіше ядро і відповідний файл
initramfs:
.PP
.Vb 3
\& mkdir outputdir
\& virt\-builder \-\-get\-kernel disk.img \-o outputdir
\& ls \-lh outputdir
.Ve
.SH "Визначення користувача, дані якого займають найбільше місця"
.IX Header "Визначення користувача, дані якого займають найбільше місця"
За допомогою цього простого скрипту ви можете визначити, який із
користувачів гостьової системи Linux використовує найбільше місця для даних
у своєму домашньому каталозі:
.PP
.Vb 1
\& #!/bin/sh \-
\& 
\& set \-e
\& 
\& vm="$1"
\& dir=/home
\& 
\& eval $(guestfish \-\-ro \-d "$vm" \-i \-\-listen)
\& 
\& for d in $(guestfish \-\-remote ls "$dir"); do
\&     echo \-n "$dir/$d"
\&     echo \-ne \*(Aq\et\*(Aq
\&     guestfish \-\-remote du "$dir/$d";
\& done | sort \-nr \-k 2
\& 
\& guestfish \-\-remote exit
.Ve
.SH "Отримання адреси DHCP з ВМ"
.IX Header "Отримання адреси DHCP з ВМ"
За наведеним нижче посиланням можна знайти різноманітні методики отримання
останньої призначеної адреси \s-1DHCP\s0 для віртуальної машини.
.PP
https://rwmj.wordpress.com/2011/03/31/tip\-code\-for\-getting\-dhcp\-address\-from\-a\-virtual\-machine\-disk\-image/#content
.PP
Каталозі із прикладами початкових кодів libguestfs є найсвіжіша версія
програми \fIvirt\-dhcp\-address.c\fR.
.SH "Отримання рядка назви продукту операційної системи"
.IX Header "Отримання рядка назви продукту операційної системи"
Збережіть наведений нижче скрипт до файла із назвою \fIproduct\-name.sh\fR:
.PP
.Vb 6
\& #!/bin/sh \-
\& set \-e
\& eval "$(guestfish \-\-ro \-d "$1" \-\-i \-\-listen)"
\& root="$(guestfish \-\-remote inspect\-get\-roots)"
\& guestfish \-\-remote inspect\-get\-product\-name "$root"
\& guestfish \-\-remote exit
.Ve
.PP
Зробіть скрипт придатним до виконання і запустіть його на іменованій
гостьовій системі:
.PP
.Vb 2
\& # product\-name.sh RHEL60x64
\& Red Hat Enterprise Linux Server release 6.0 (Santiago)
.Ve
.PP
Крім того, ви можете скористатися запитом XPath у \s-1XML\s0 \fBvirt\-inspector\fR\|(1)
за допомогою засобу командного рядка \f(CW\*(C`xpath\*(C'\fR або з вашої улюбленої мови
програмування:
.PP
.Vb 5
\& # virt\-inspector RHEL60x64 > xml
\& # xpath \*(Aq//product_name\*(Aq < xml
\& Found 1 nodes:
\& \-\- NODE \-\-
\& <product_name>Red Hat Enterprise Linux Server release 6.0 (Santiago)</product_name>
.Ve
.SH "Отримання типового ядра для завантаження для віртуальної машини Linux"
.IX Header "Отримання типового ядра для завантаження для віртуальної машини Linux"
За наведеним нижче посиланням можна знайти програму для виведення типового
ядра для завантаження у віртуальній машині Linux.
.PP
https://rwmj.wordpress.com/2010/10/30/tip\-use\-augeas\-to\-get\-the\-default\-boot\-kernel\-for\-a\-vm/#content
.PP
У ній використано Augeas та методику, якою можна скористатися для виконання
багатьох різних завдань, зокрема таких:
.IP "\(bu" 4
показ списку облікових записів користувачів у гостьовій системі
.IP "\(bu" 4
показ списку сховищ, які використовуються системою
.IP "\(bu" 4
показ списку серверів \s-1NTP,\s0 з якими з'єднано систему
.IP "\(bu" 4
показ списку повідомлень під час останнього сеансу завантаження системи
.IP "\(bu" 4
показ списку користувачів, які входили до системи нещодавно
.PP
http://augeas.net/
.SH "Повислі гостьові системи"
.IX Header "Повислі гостьові системи"
Існують різноманітні способи скористатися libguestfs для визначення причин,
чому гостьова система повисла або не відповідає на запити:
.IP "1." 4
Читання файлів журналу за допомогою virt-cat:
.Sp
.Vb 1
\& virt\-cat Guest /var/log/messages | less
.Ve
.IP "2." 4
Читання журналу подій Windows (лише Windows Vista або новіші версії):
.Sp
https://rwmj.wordpress.com/2011/04/17/decoding\-the\-windows\-event\-log\-using\-guestfish/#content
.IP "3." 4
Визначити файли, які було нещодавно оновлено у гостьовій системі:
.Sp
https://rwmj.wordpress.com/2012/02/27/using\-libguestfs\-to\-find\-out\-why\-a\-windows\-guest\-was\-hanging/#content
.Sp
Це може підказати вам, яка саме програма працює.
.SH "Створення шістнадцяткових дампів секторів диска з гостьової системи"
.IX Header "Створення шістнадцяткових дампів секторів диска з гостьової системи"
Створення шістнадцяткового дампу розділу завантаження (\s-1MBR /\s0 перший сектор):
.PP
.Vb 2
\& guestfish \-\-ro \-a диск.img run : pread\-device /dev/sda 0x200 0 |
\&   hexdump \-C
.Ve
.PP
(\f(CW0x200\fR = 512 байтів, тобто розмір традиційних секторів \s-1PC\s0)
.PP
Щоб створити шістнадцятковий дамп N\-го розділу, замініть \f(CW\*(C`N\*(C'\fR на відповідне
число у такій команду:
.PP
.Vb 3
\& guestfish \-\-ro \-a disk.img \e
\&     run : pread\-device /dev/sda 0x200 $((N*0x200)) |
\&   hexdump \-C
.Ve
.SH "Шістнадцяткове редагування секторів у гостьовій системі"
.IX Header "Шістнадцяткове редагування секторів у гостьовій системі"
Редагування шістнадцяткового дампу розділу завантаження (\s-1MBR /\s0 перший
сектор):
.PP
.Vb 1
\& guestfish \-\-rw \-a диск.img run : hexedit /dev/sda 0x200
.Ve
.SH "Встановлення пакунків (RPM, пакунки Debian) у гостьовій системі"
.IX Header "Встановлення пакунків (RPM, пакунки Debian) у гостьовій системі"
Починаючи з libguestfs 1.26, \fBvirt\-builder\fR\|(1), \fBvirt\-customize\fR\|(1) та
\&\fBvirt\-sysprep\fR\|(1) мають параметр \fI\-\-install\fR для встановлення пакунків у
гостьових системах Linux. (Скористайтеся virt-customize, якщо у вас уже є
наявна гостьова система, або virt-builder, якщо ви хочете створити гостьову
систему від початку).
.PP
Приклад:
.PP
.Vb 1
\& virt\-builder fedora\-20 \-\-install emacs
.Ve
.SH "Встановлення пакунків із альтернативного сховища"
.IX Header "Встановлення пакунків із альтернативного сховища"
Починаючи з libguestfs 1.26, ви можете скористатися параметром \fI\-\-edit\fR
\&\fBvirt\-builder\fR\|(1), \fBvirt\-customize\fR\|(1) або \fBvirt\-sysprep\fR\|(1)  для
редагування метаданих сховища до встановлення пакунків.
.PP
Наприклад, вказана нижче команда встановить пакунки зі сховища
updates-testing у Fedora:
.PP
.Vb 4
\& virt\-builder fedora\-20 \e
\&   \-\-edit \*(Aq/etc/yum.repos.d/fedora\-updates\-testing.repo:
\&             s/enabled=0/enabled=1/\*(Aq \e
\&   \-\-install emacs
.Ve
.SH "Встановлення завантажувача SYSLINUX у гостьовій системі"
.IX Header "Встановлення завантажувача SYSLINUX у гостьовій системі"
\&\s-1SYSLINUX\s0 — невеличкий, простий у налаштовуванні завантажувач для гостьових
систем Linux і Windows. Якщо ваша гостьова система не придатна до
завантаження, ви можете встановити завантажувач \s-1SYSLINUX\s0 за допомогою
команди guestfish \f(CW\*(C`syslinux\*(C'\fR (для заснованих на \s-1FAT\s0 гостьових систем) або
\&\f(CW\*(C`extlinux\*(C'\fR (для заснованих на ext2/3/4 або btrfs гостьових систем).
.PP
У цих настановах ми припускаємо, що маємо справу із гостьовою системою
Linux, де \fI/dev/sda1\fR змонтовано як \fI/boot\fR, \fI/boot/vmlinuz\fR є ядром
гостьової системи, а \fI/dev/sda3\fR є кореневим розділом. Для гостьової
системи Windows вам знадобиться завантажувальний розділ у форматі \s-1FAT\s0 і
використання команди \f(CW\*(C`syslinux\*(C'\fR замість вказаних нижче.
.PP
Створіть файл налаштувань \fIsyslinux.cfg\fR. Вам слід скористатися
документацією з \s-1SYSLINUX\s0 з сайта http://www.syslinux.org, але вміст
виглядатиме десь так:
.PP
.Vb 6
\& DEFAULT linux
\& LABEL linux
\&   SAY Booting the kernel
\&   KERNEL vmlinuz
\&   INITRD initrd
\&   APPEND ro root=/dev/sda3
.Ve
.PP
Знайдіть головний запис завантаження syslinux (файл, який називається якось
так: \fI/usr/share/syslinux/mbr.bin\fR).
.PP
.Vb 10
\& guestfish \-a диск.img \-i
\& # Вивантаження головного запису завантаження та файла налаштувань:
\& ><fs> upload ..../mbr.bin /boot/mbr.bin
\& ><fs> upload ..../syslinux.cfg /boot/syslinux.cfg
\& # Запис MBR до сектора завантаження:
\& ><fs> copy\-file\-to\-device /boot/mbr.bin /dev/sda size:440
\& # Встановлення syslinux на першому розділі:
\& ><fs> extlinux /boot
\& # Визначення першого розділу як завантажувального:
\& ><fs> part\-set\-bootable /dev/sda 1 true
.Ve
.PP
Див. також
http://rwmj.wordpress.com/2013/04/04/new\-in\-libguestfs\-use\-syslinux\-or\-extlinux\-to\-make\-bootable\-guests/#content
.SH "Показати список програм, встановлених у віртуальній машині"
.IX Header "Показати список програм, встановлених у віртуальній машині"
Збережіть такий текст до файла \fIlist\-apps.sh\fR:
.PP
.Vb 6
\& #!/bin/sh \-
\& set \-e
\& eval "$(guestfish \-\-ro \-d "$1" \-\-i \-\-listen)"
\& root="$(guestfish \-\-remote inspect\-get\-roots)"
\& guestfish \-\-remote inspect\-list\-applications "$root"
\& guestfish \-\-remote exit
.Ve
.PP
Зробіть цей файл придатним до виконання, а потім можете запустити його для
будь\-якої іменованої віртуальної машини:
.PP
.Vb 10
\& # list\-apps.sh WinGuest
\& [0] = {
\&   app_name: Mozilla Firefox (3.6.12)
\&   app_display_name: Mozilla Firefox (3.6.12)
\&   app_epoch: 0
\&   app_version: 3.6.12 (en\-GB)
\&   app_release:
\&   app_install_path: C:\eProgram Files\eMozilla Firefox
\&   app_trans_path:
\&   app_publisher: Mozilla
\&   app_url: http://www.mozilla.com/en\-GB/
\&   app_source_package:
\&   app_summary:
\&   app_description: Mozilla Firefox
\& }
\& [1] = {
\&   app_name: VLC media player
\&   app_display_name: VLC media player 1.1.5
\&   app_epoch: 0
\&   app_version: 1.1.5
\&   app_release:
\&   app_install_path: C:\eProgram Files\eVideoLAN\eVLC
\&   app_trans_path:
\&   app_publisher: VideoLAN
\&   app_url: http://www.videolan.org/
\&   app_source_package:
\&   app_summary:
\&   app_description:
\& }
.Ve
.PP
Якщо ви хочете запустити скрипт для образів дисків (замість віртуальних
машин libvirt), замініть \f(CW\*(C`\-d "$1"\*(C'\fR на \f(CW\*(C`\-a "$1"\*(C'\fR. Див. також
\&\fBvirt\-inspector\fR\|(1).
.SH "Показати список файлів і каталогів у віртуальній машині"
.IX Header "Показати список файлів і каталогів у віртуальній машині"
Скористайтеся \fBvirt\-ls\fR\|(1).
.SH "Показати список служб у віртуальній машині Windows"
.IX Header "Показати список служб у віртуальній машині Windows"
За наведеним нижче посиланням можна знайти скрипт, яким можна скористатися
для отримання списку служб з віртуальної машини Windows і визначення того,
запускаються ці служби під час завантаження чи завантажуються за потреби.
.PP
https://rwmj.wordpress.com/2010/12/10/tip\-list\-services\-in\-a\-windows\-guest/#content
.SH "Створення образу диска розрідженим"
.IX Header "Створення образу диска розрідженим"
Скористайтеся \fBvirt\-sparsify\fR\|(1).
.SH "Спостереження за зміною використання диска з часом"
.IX Header "Спостереження за зміною використання диска з часом"
Для спостереження за зміною вживання диска у ваших гостьових системах з
часом ви можете скористатися \fBvirt\-df\fR\|(1). Настанови можна знайти за
наведеним нижче посиланням.
.PP
http://web.archive.org/web/20130214073726/http://virt\-tools.org/learning/advanced\-virt\-df/
.SH "Читання журналу подій у Windows з версії Windows Vista"
.IX Header "Читання журналу подій у Windows з версії Windows Vista"
Для читання журналу подій Windows у будь\-якій віртуальній машині, де
запущено Windows Vista або новішу версію Windows, можна скористатися
\&\fBguestfish\fR\|(1) та іншими інструментами, як це описано за наведеним нижче
посиланням.
.PP
https://rwmj.wordpress.com/2011/04/17/decoding\-the\-windows\-event\-log\-using\-guestfish/#content
.SH "Вилучення пароля root (Linux)"
.IX Header "Вилучення пароля root (Linux)"
За допомогою параметра \fI\-e\fR \fBvirt\-edit\fR\|(1) ви можете виконувати прості
заміни у файлах. Одним із варіантів таких замін є вилучення пароля root з
гостьової системи Linux:
.PP
.Vb 1
\& virt\-edit \-d назва_домену /etc/passwd \-e \*(Aqs/^root:.*?:/root::/\*(Aq
\&
\& virt\-edit \-a диск.img /etc/passwd \-e \*(Aqs/^root:.*?:/root::/\*(Aq
.Ve
.SH "Вилучення пароля адміністратора (Windows)"
.IX Header "Вилучення пароля адміністратора (Windows)"
За наведеним нижче посиланням викладено одну методику вилучення пароля
адміністратора з віртуальної машини Windows \s-1VM\s0 або, якщо бути точнішим,
отримання доступу до командної оболонки під час наступного входу до системи,
звідки ви можете обійти будь\-який захист:
.PP
https://mdbooth.wordpress.com/2010/10/18/resetting\-a\-windows\-guests\-administrator\-password\-with\-guestfish/
.SH "Виконання sysprep для віртуальної машини (Windows)"
.IX Header "Виконання sysprep для віртуальної машини (Windows)"
«sysprep» можна виконати засобами лише libguestfs, хоча і не напряму.  У
поточній версії проекту Aeolus Oz є код, який робить це (за допомогою
libguestfs). Ймовірно, ми додамо цю можливість до \fBvirt\-sysprep\fR\|(1) у
майбутніх версіях.
.PP
https://github.com/clalancette/oz
https://www.redhat.com/archives/virt\-tools\-list/2011\-May/msg00019.html
.SH "Розпакування компакт\-диска з портативною системою"
.IX Header "Розпакування компакт-диска з портативною системою"
Образи портативних систем Linux для компакт\-дисків часто містять багато
шарів образів дисків, подібно до матрьошки. Ви можете скористатися
\&\fBguestfish\fR\|(1), щоб зазирнути всередину цих шарів, як це описано у
настановах за наведеним нижче посиланням.
.PP
https://rwmj.wordpress.com/2009/07/15/unpack\-the\-russian\-doll\-of\-a\-f11\-live\-cd/#content
.SH "Вивантаження і звантаження файлів"
.IX Header "Вивантаження і звантаження файлів"
За наведеним нижче посиланням містяться загальні підказки щодо вивантаження
(копіювання всередину) або отримання (копіювання назовні) файлів з
віртуальних машин.
.PP
https://rwmj.wordpress.com/2010/12/02/tip\-uploading\-and\-downloading/#content
.SH "Вивантаження даних на файлові системи без обробки"
.IX Header "Вивантаження даних на файлові системи без обробки"
Ви можете скористатися \fBguestfish\fR\|(1) для вивантаження цілих файлових
систем до віртуальної машини, навіть до файлової системи, яку зашифровано і
включено до логічного тому або пристрою \s-1RAID:\s0
.PP
.Vb 1
\& guestfish \-\-rw \-a disk.img run : upload sda1.img /dev/sda1
\&
\& guestfish \-\-rw \-d Guest run : upload lv.img /dev/vg_guest/lv_root
.Ve
.PP
Однією загальною проблемою є те, що розмір файлової системи є невідповідним
для цілі. Якщо місця надто багато, зробити щось за допомогою libguestfs
навряд чи вдасться — вам слід інакше готувати файлову систему. Але якщо
файлову систему слід розширити, ви можете скористатися guestfish для зміни
розміру на відповідний:
.PP
.Vb 3
\& guestfish \-\-rw \-d Guest run : \e
\&   upload lv.img /dev/vg_guest/lv_root : \e
\&   resize2fs /dev/vg_guest/lv_root
.Ve
.PP
(або скористайтеся \f(CW\*(C`ntfsresize\*(C'\fR, якщо файловою системою є \s-1NTFS\s0).
.SH "Користування засобами libguestfs для роботи із гостьовими системами VMware ESX"
.IX Header "Користування засобами libguestfs для роботи із гостьовими системами VMware ESX"
За наведеним нижче посиланням описано використання libguestfs,
\&\fBguestfish\fR\|(1) та засобів віртуалізації для будь\-яких гостьових систем
VMware \s-1ESX.\s0 Для цього слід спочатку оприлюднити VMware \s-1VMFS\s0 за допомогою
sshfs.
.PP
https://rwmj.wordpress.com/2011/05/10/tip\-use\-libguestfs\-on\-vmware\-esx\-guests/#content
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fBguestfs\fR\|(3), \fBguestfish\fR\|(1), \fBguestfs\-examples\fR\|(3),
\&\fBguestfs\-erlang\fR\|(3), \fBguestfs\-gobject\fR\|(3), \fBguestfs\-golang\fR\|(3),
\&\fBguestfs\-java\fR\|(3), \fBguestfs\-lua\fR\|(3), \fBguestfs\-ocaml\fR\|(3),
\&\fBguestfs\-perl\fR\|(3), \fBguestfs\-python\fR\|(3), \fBguestfs\-ruby\fR\|(3),
http://libguestfs.org/.
.SH "АВТОРИ"
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
Copyright (C) 2009\-2019 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fBlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
