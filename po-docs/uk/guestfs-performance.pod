
=head1 НАЗВА

guestfs-performance — керування libguestfs з метою отримання найкращої
швидкодії

=head1 ОПИС

Цю сторінку присвячено питанням отримання найліпшої швидкодії libguestfs,
особливо у випадках, коли ви хочете використовувати libguestfs для керування
тисячами віртуальних машин або образів дисків.

Наведені рекомендації стосуються трьох основних областей. Libguestfs
запускає базову систему (невеличкий дистрибутив Linux) у qemu/KVM. Першими
двома областями є мінімізація часу запуску базової системи та кількості
запусків базової системи. Третьою областю є скорочення часу, потрібного на
інспектування віртуальних машин.

=head1 БАЗОВІ ВИМІРИ

Перш ніж вносити зміни до способів використання libguestfs, виконайте базові
виміри.

=head2 База: запуск базової системи

На незавантаженій машині час, який потрібне для запуску базової системи:

 time guestfish -a /dev/null run

Віддайте цю команду декілька разів послідовно і відкиньте результати перших
декількох запусків, щоб виміряти типовий випадок із «гарячим кешем».

I<Примітка для розробників:> якщо ви збираєте libguestfs з початкових кодів,
у них можна знайти програму із назвою
F<utils/boot-benchmark/boot-benchmark>, яка виконує те саме, але виконує
декілька запусків і виводить математичне сподівання та стандартне
відхилення. Щоб запустити цю програму, віддайте таку команду:

 make
 ./run utils/boot-benchmark/boot-benchmark

Передбачено окрему сторінку підручника для
F<utils/boot-benchmark/boot-benchmark.1>

=head3 Пояснення

Наведена вище команда guestfish запускає базову систему libguestfs для
порожнього диска, а потім одразу вимикає її. Під час першого виконання
команди програма створить базову систему і виконає її кешування (зазвичай, у
F</var/tmp/.guestfs-*>). Під час наступних запусків програма просто повторно
використовуватиме кешовану базову систему.

=head3 Очікувані результати

Слід очікувати значень тривалості виконання дії, менших за 6 секунд. Якщо
для ненавантаженої машини ви спостерігаєте значення тривалості, яке є вищим
за вказане, вам слід ознайомитися із вмістом розділу L</БОРОТЬБА ІЗ
ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ>, наведеного нижче.

=head2 База: виконання інспектування гостьової системи

Для цього тесту вам потрібна буде ненавантажена машина і принаймні одна
справжня гостьова система або образ диска. Якщо ви плануєте використовувати
libguestfs лише для гостьових систем X (наприклад, X = Windows), тоді у
цьому тесті варто використати саме гостьову систему X. Якщо ж ви плануєте
використовувати libguestfs для різних гостьових систем, скористайтеся у
цьому тесті різними гостьовими системами.

Визначте тривалість інспектування і монтування дисків гостьової
системи. Скористайтеся першою з команд, якщо ви використовуватимете образи
дисків, і другою із команд, якщо ви використовуватимете libvirt.

 time guestfish --ro -a диск.img -i exit

 time guestfish --ro -d НазваГостьовоїСистеми -i exit

Віддайте цю команду декілька разів послідовно і відкиньте результати перших
декількох запусків, щоб виміряти типовий випадок із «гарячим кешем».

=head3 Пояснення

Ця команда запускає базову систему libguestfs для іменованого образу диска
або гостьової системи libvirt, виконує її інспектування за допомогою
libguestfs (див. L<guestfs(3)/ІНСПЕКТУВАННЯ>), монтує диски гостьової
системи, а потім відкидає усі ці результати і завершує роботу.

Під час першого виконання команди програма створить базову систему і виконає
її кешування (зазвичай, у F</var/tmp/.guestfs-*>). Під час наступних
запусків програма просто повторно використовуватиме кешовану базову систему.

=head3 Очікувані результати

Слід очікувати на тривалість виконання, яка на E<le> 5 секунд перевищує
виміряну у першому базовому тесті вище. (Наприклад, якщо перший базовий тест
було виконано за 5 секунд, цей тест має виконуватися за E<le> 10 секунд.)

=head1 ДОКЛАДНІШЕ ПРО БАЗОВУ СИСТЕМУ ТА ПРО ТЕ, КОЛИ ЇЇ ЗБИРАЮТЬ ТА КОЛИ ВОНА
ПОТРАПЛЯЄ ДО КЕШУ

Під час першої спроби скористатися libguestfs бібліотека збирає і надсилає
до кешу базову систему. Зазвичай, така базова система має адресу
F</var/tmp/.guestfs-*>, якщо вами не було встановлено значень для змінних
середовища C<$TMPDIR> або C<$LIBGUESTFS_CACHEDIR>. Якщо було встановлено
такі значення, базова система зберігатиметься у відповідному тимчасовому
каталозі.

Щоб дізнатися більше про побудову базової системи, див. L<supermin(1)/БАЗОВІ
СИСТЕМИ SUPERMIN>.

Під час кожного запуску libguestfs намагається визначити, чи не було змінено
якість файли основної системи, які використовуються базовою системою. Якщо
було змінено хоч один такий файл, базову систему буде перезібрано. Таке,
зазвичай, трапляється, якщо у основній системі встановлюється або
оновлюється якийсь пакунок (наприклад, за допомогою програм, подібних до
C<yum> або C<apt-get>). Причиною повторного збирання базової системи є
забезпечення захисту: нова програма, яку було встановлено, може містити
виправлення захисту, тому нам варто включити виправлену програму до базової
системи автоматично.

Ось речі, які пов'язано із швидкодією:

=over 4

=item *

Процес побудови (або повторної побудови) кешованої базової системи є
повільним. Ви можете уникнути його, якщо скористаєтеся фіксованою базовою
системою (див. нижче).

=item *

Якщо ви не користуєтеся фіксованою базовою системою, майте на увазі, що
оновлення програмного забезпечення основної системи призведе до одноразового
повторного збирання базової системи.

=item *

F</var/tmp> (або C<$TMPDIR>, C<$LIBGUESTFS_CACHEDIR>) має зберігатися на
швидкому диску і мати достатньо місця для базової системи.

=back

=head1 ВИКОРИСТАННЯ ФІКСОВАНОЇ БАЗОВОЇ СИСТЕМИ

Щоб мати повний контроль над тим, коли збирається базова система, ви можете
зібрати фіксовану базову систему. Ця базова система має зберігатися на
швидкому локальному диску.

Щоб зібрати образ системи для розгортання, віддайте таку команду:

 libguestfs-make-fixed-appliance <каталог>

замінивши рядок C<E<lt>каталогE<gt>> на назву каталогу, у якому
зберігатиметься базова система (зазвичай, вам слід вказати підкаталог,
наприклад: F</usr/local/lib/guestfs/appliance> або F</dev/shm/appliance>).

Далі, встановіть значення для C<$LIBGUESTFS_PATH> (і переконайтеся, що цю
змінну середовища встановлено у вашій програмі libguestfs) або внесіть зміни
до вашої програми так, щоб вона викликала C<guestfs_set_path>. Приклад:

 export LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance

Тепер ви можете запускати програми libguestfs, засоби віртуалізації,
guestfish тощо у звичний спосіб. Програми використовуватимуть вашу фіксовану
базову систему і ніколи не збиратимуть, не перезбиратимуть і не кешуватимуть
власну базову систему.

(Докладніші відомості з цієї теми можна знайти тут:
L<libguestfs-make-fixed-appliance(1)>).

=head2 Швидкодія фіксованої базової системи

Наші тестування показали, що використання фіксованої базової системи не дає
ніяких помітних переваг у швидкодії, навіть якщо розташувати базову систему
у оперативній пам'яті (тобто на пристрої F</dev/shm>). Втім, слід зважити
ось на що:

=over 4

=item 1.

Використання фіксованої базової системи запобігатиме спробам libguestfs
повторно зібрати базову систему, що означатиме, що тривалість запуску
libguestfs буде легше передбачити.

=item 2.

Базова система завантажується на вимогу. Простий тест, наприклад такий:

 time guestfish -a /dev/null run

не дуже навантажує базову систему. Справжня програма libguestfs, де
використовуватимуться складні виклики програмного інтерфейсу,
навантажуватиме базову систему набагато більше. Можливість зберігати базову
систему у вказаному місці робить швидкодію значно передбачуванішою.

=back

=head1 ЗМЕНШЕННЯ КІЛЬКОСТІ ЗАПУСКІВ БАЗОВОЇ СИСТЕМИ

Набагато ефективнішим, але не завжди найпростішим способом дістати добру
швидкодію є забезпечення якомога меншої кількості запусків базової
системи. Це, ймовірно, включає внесення змін до самої вашої програми
libguestfs.

Намагайтеся викликати C<guestfs_launch> не більше одного разу на одну
віртуальну машину або образ диска.

Замість використання окремого екземпляра L<guestfish(1)> для внесення змін
до тієї самої гостьової системи, скористайтеся єдиним екземпляром guestfish
і/або використовуйте параметр guestfish I<--listen>.

Спробуйте написати вашу програму у формі фонової служби, яка підтримує
зв'язок із гостьовою системою відкритим протягом усього сеансу внесення
послідовності змін. Крім того, можете скерувати усі дії, які ви хочете
виконати, до відкриття зв'язку із гостьовою системою.

Ви також можете спробувати додавати диски з декількох гостьових систем до
єдиної базової системи. Перш ніж намагатися це зробити, врахуйте ось що:

=over 4

=item 1.

Додавання декількох гостьових системи до однієї базової системи створює
проблему із захистом, оскільки може уможливити для однієї гостьової системи
втручання до дисків іншої гостьової системи. Робіть це, лише якщо ви
довіряєте усім гостьовим системам або якщо ви можете згрупувати гостьові
системи за рівнем довіри.

=item 2.

Існує жорстке обмеження для кількості дисків, які ви можете додати до однієї
базової системи. Щоб отримати максимальне можливе значення, скористайтеся
викликом L<guestfs(3)/guestfs_max_disks>. Докладнішу інформацію можна знайти
у розділі L<guestfs(3)/ОБМЕЖЕННЯ>.

=item 3.

Використання libguestfs у цей спосіб є ускладненим. Диски можуть взаємодіяти
у несподіваний спосіб: наприклад, якщо у двох гостьових системах
використовуються однакові UUID для файлової системи (оскільки ці системи
було клоновано) або існують групи томів із однаковими назвами (але
див. C<guestfs_lvm_set_filter>).

=back

L<virt-df(1)>, типово, додає одразу декілька дисків, тому код цієї програми
є чудовим прикладом для ваших власних розробок.

=head1 СКОРОЧЕННЯ ЧАСУ, ПОТРІБНОГО ДЛЯ ІНСПЕКТУВАННЯ ВІРТУАЛЬНИХ МАШИН

Основна порада очевидна: не виконуйте інспектування (це дуже витратна
операція), якщо вам не потрібні його результати.

Якщо гостьова система інспектується декілька разів, варто створити кеш
результатів першого інспектування і повторно скористатися ними для наступних
дій.

Деякі диски взагалі не потребують інспектування. Наприклад, якщо ви
створюєте образ диска, або якщо образ диска не є віртуальною машиною, або
якщо образ диска має заздалегідь відоме компонування.

Навіть якщо базове інспектування (C<guestfs_inspect_os>) є обов'язковим,
можна обійтися без допоміжних операцій з інспектування:

=over 4

=item *

Монтування дисків є необхідним, лише якщо потрібно отримати докладніші дані
щодо файлової системи.

=item *

Отримання списку програм (C<guestfs_inspect_list_applications>) є витратною
операцією для Linux, яка, втім, виконується дуже швидко для Windows.

=item *

Створення піктограми гостьової системи (C<guestfs_inspect_get_icon>)
виконується дуже швидко для Linux, але є витратною операцією для Windows.

=back

=head1 ПАРАЛЕЛЬНІ БАЗОВІ СИСТЕМИ

Базові системи libguestfs є здебільшого зв'язками введення-виведення даних,
отже ви можете паралельно запускати одразу декілька базових систем.  Якщо у
основній системі достатньо багато вільної оперативної пам'яті, між запуском
1 базової системи і паралельним запуском багатьох базових систем відмінність
є незначною.

На 2-ядерному (4 потоки обробки) ноутбуці із 16 ГБ оперативної пам'яті,
використання (не дуже реалістичного) тестового скрипту мовою Perl,
наведеного нижче, дало вказані нижче результати, які свідчать про чудову
масштабованість у запуску 1 базової системи і паралельному запуску 20
базових систем:

  12 ++---+----+----+----+-----+----+----+----+----+---++
     +    +    +    +    +     +    +    +    +    +    *
     |                                                  |
     |                                               *  |
  11 ++                                                ++
     |                                                  |
     |                                                  |
     |                                          *  *    |
  10 ++                                                ++
     |                                        *         |
     |                                                  |
 s   |                                                  |
   9 ++                                                ++
 e   |                                                  |
     |                                     *            |
 c   |                                                  |
   8 ++                                  *             ++
 o   |                                *                 |
     |                                                  |
 n 7 ++                                                ++
     |                              *                   |
 d   |                           *                      |
     |                                                  |
 s 6 ++                                                ++
     |                      *  *                        |
     |                   *                              |
     |                                                  |
   5 ++                                                ++
     |                                                  |
     |                 *                                |
     |            * *                                   |
   4 ++                                                ++
     |                                                  |
     |                                                  |
     +    *  * *    +    +     +    +    +    +    +    +
   3 ++-*-+----+----+----+-----+----+----+----+----+---++
     0    2    4    6    8     10   12   14   16   18   20
               кількість паралельних базових систем

Можна запустити і набагато більше за 20 базових систем паралельно, але вам
слід мати на увазі, що якщо ви використовуєте модуль обробки libvirt,
типово, libvirt обмежує кількість з'єднань із клієнтами двадцятьма.

Для отримання даних, наведених на рисунку вище, було використано простий
скрипт мовою Perl, наведений нижче. Втім, набагато більше відомостей з цього
питання, зокрема досконаліші скрипти для тестування та графіки, можна знайти
у наступних дописах у блогах:

L<http://rwmj.wordpress.com/2013/02/25/multiple-libguestfs-appliances-in-parallel-part-1/>
L<http://rwmj.wordpress.com/2013/02/25/multiple-libguestfs-appliances-in-parallel-part-2/>
L<http://rwmj.wordpress.com/2013/02/25/multiple-libguestfs-appliances-in-parallel-part-3/>
L<http://rwmj.wordpress.com/2013/02/25/multiple-libguestfs-appliances-in-parallel-part-4/>

 #!/usr/bin/env perl
 
 use strict;
 use threads;
 use warnings;
 use Sys::Guestfs;
 use Time::HiRes qw(time);
 
 sub test {
     my $g = Sys::Guestfs->new;
     $g->add_drive_ro ("/dev/null");
     $g->launch ();
     
     # Тут можна виконати якісь завдання за допомогою libguestfs.
     
     $g->close ();
 }
 
 # Отримати усе до кешу.
 test (); test (); test ();
 
 for my $nr_threads (1..20) {
     my $start_t = time ();
     my @threads;
     foreach (1..$nr_threads) {
         push @threads, threads->create (\&test)
     }
     foreach (@threads) {
         $_->join ();
         if (my $err = $_->error ()) {
             die "launch failed with $nr_threads threads: $err"
         }
     }
     my $end_t = time ();
     printf ("%d %.2f\n", $nr_threads, $end_t - $start_t);
 }

=head1 ВИКОРИСТАННЯ USER-MODE LINUX

Починаючи з libguestfs 1.24, стало можливим використання модуля обробки
User-Mode Linux (uml) замість KVM (див. L<guestfs(3)/МОДУЛЬ USER-MODE
LINUX>). У цьому розділі наведено деякі загальні зауваження щодо цього
модуля, але ми B<наполегливо рекомендуємо> вам виміряти навантаження з UML у
вашій системі, а не сліпо довірятися коментарям або інтуїції.

=over 4

=item *

UML, зазвичай, працює із тією самою швидкістю, що і KVM, або трохи
повільніше на типовій системі.

=item *

Втім, UML часто працює так само швидко в умовах віртуалізації, як і у
звичайному апаратному середовищі, тоді як KVM може працювати набагато
повільніше в умовах віртуалізації (оскільки там недоступне апаратне
прискорення віртуалізації).

=item *

Вивантаження і отримання даних у UML удесятеро повільніше за такі самі
операції у KVM. Libguestfs надсилає дані крізь емульований послідовний порт
UML, який є набагато менш ефективним за virtio-serial у KVM.

=item *

В UML недоступні деякі можливості (наприклад, підтримка qcow2), тому іноді
цей варіант взагалі не є придатним.

=back

Самі графіки можна знайти тут:
L<http://rwmj.wordpress.com/2013/08/14/performance-of-user-mode-linux-as-a-libguestfs-backend/#content>

=head1 БОРОТЬБА ІЗ ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ

=head2 Переконайтеся, що увімкнено апаратну віртуалізацію

Use F</proc/cpuinfo> to ensure that hardware virtualization is available.
Note that you may need to enable it in your BIOS.

Усередині віртуальних машин апаратна віртуалізація зазвичай недоступна,
тому, щоб ви не робили, у віртуальній машині libguestfs працюватиме
повільно. Наш досвід свідчить про те, що вкладена віртуалізація працює
погано, і, напевне, альтернативи запуску libguestfs у основній системі
немає.

=head2 Переконайтеся, що KVM є доступним

Переконайтеся, що KVM увімкнено і доступний користувачеві, який запускає
libguestfs. Безпечним є встановлення прав доступу 0666 для F</dev/kvm>, як
це робиться у більшості сучасних дистрибутивів.

=head2 Процесори, яких слід уникати

Не використовуйте процесори, у яких немає апаратної віртуалізації, та
процесорів, які просто дуже повільні (чудовим прикладом такого процесора є
AMD Geode).

=head2 Xen dom0

У Xen dom0 є віртуальною машиною, отже на ньому апаратна віртуалізація
недоступна.

=head2 Скористайтеся libguestfs E<ge> 1.34 і qemu E<ge> 2.7

Під час циклу розробки libguestfs 1.33 ми приділяли багато часу швидкодії,
зосередившись на швидкості завантаження, і додали декілька латок до
libguestfs, qemu та Linux, що у певних випадках зменшило час завантаження до
значень, менших за 1 секунду. Тому, ви можете спостерігати набагато швидшу
роботу версій libguestfs та qemu, згаданих у заголовку розділу.

=head1 ДОКЛАДНИЙ АНАЛІЗ

=head2 Аналіз завантаження

У каталозі з початковим кодом libguestfs за адресою F<utils/boot-analysis>
можна знайти програму, яка називається C<boot-analysis>. Ця програма може
виводити дуже докладні дані щодо кроків завантаження (наприклад, qemu, BIOS,
ядра, скрипту ініціалізації libguestfs) і вимірювати тривалість виконання
кожного з кроків.

Щоб запустити цю програму, віддайте таку команду:

 make
 ./run utils/boot-analysis/boot-analysis

Передбачено окрему сторінку підручника для
F<utils/boot-benchmark/boot-analysis.1>

=head2 Докладний таймінг з використанням ts

Скористайтеся програмою L<ts(1)> (з moreutils), щоб переглянути докладну
картину:

 $ guestfish -a /dev/null run -v |& ts -i '%.s'
 0.000022 libguestfs: launch: program=guestfish
 0.000134 libguestfs: launch: version=1.29.31fedora=23,release=2.fc23,libvirt
 0.000044 libguestfs: launch: backend registered: unix
 0.000035 libguestfs: launch: backend registered: uml
 0.000035 libguestfs: launch: backend registered: libvirt
 0.000032 libguestfs: launch: backend registered: direct
 0.000030 libguestfs: launch: backend=libvirt
 0.000031 libguestfs: launch: tmpdir=/tmp/libguestfsw18rBQ
 0.000029 libguestfs: launch: umask=0002
 0.000031 libguestfs: launch: euid=1000
 0.000030 libguestfs: libvirt version = 1002012 (1.2.12)
 [etc]

Часові позначки вказано у секундах (з нарощуванням щодо попереднього рядка).

=head2 Докладний таймінг з використанням SystemTap

Для отримання докладної інформації щодо часових параметрів обробки у
програмах libguestfs можете скористатися SystemTap (L<stap(1)>).

Збережіть такий скрипт із назвою F<time.stap>:

 global last;
 
 function display_time () {
       now = gettimeofday_us ();
       delta = 0;
       if (last > 0)
             delta = now - last;
       last = now;
 
       printf ("%d (+%d):", now, delta);
 }
 
 probe begin {
       last = 0;
       printf ("ready\n");
 }
 
 /* Показати усі виклики статичних маркерів. */
 probe process("/usr/lib*/libguestfs.so.0")
           .provider("guestfs").mark("*") ? {
       display_time();
       printf ("\t%s %s\n", $$name, $$parms);
 }
 
 /* Показати усі виклики функцій guestfs_*. */
 probe process("/usr/lib*/libguestfs.so.0")
           .function("guestfs_[a-z]*") ? {
       display_time();
       printf ("\t%s %s\n", probefunc(), $$parms);
 }

Запустіть його у одному вікні від імені користувача root:

 # stap time.stap
 ready

Скрипт виведе рядок «ready», коли SystemTap завантажить програму. Запустіть
вашу програму libguestfs, guestfish або програму засобів віртуалізації у
іншому вікні. Приклад:

 $ guestfish -a /dev/null run

У вікні stap ви побачити багато даних, зокрема, буде показано дані щодо
часу, потрібного на виконання кожного з кроків (у форматі кількості
мілісекунд у дужках). Приклад:

 xxxx (+0):	guestfs_create 
 xxxx (+29):	guestfs_set_pgroup g=0x17a9de0 pgroup=0x1
 xxxx (+9):	guestfs_add_drive_opts_argv g=0x17a9de0 [...]
 xxxx (+8):	guestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d
 xxxx (+19):	guestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38
 xxxx (+5):	guestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60
 xxxx (+10):	guestfs_launch g=0x17a9de0
 xxxx (+4):	launch_start 
 [etc]

Вам слід звернутися до початкового коду libguestfs або навіть трохи змінити
його, щоб повністю розібратися у виведених даних.

=head2 Докладна діагностика з використанням gdb

Ви можете керувати BIOS або ядром базової системи за допомогою gdb. Якщо ви
добре знаєтеся на процесі діагностики за допомогою gdb, це може бути
корисним інструментом для виявлення і усування регресій у процесі
завантаження.

По-перше, вам слід змінити qemu так, щоб програма запускалася із параметрами
C<-S> і C<-s>. Ці параметри наказують qemu призупинити процес завантаження і
уможливити долучення до нього засобу діагностики. Щоб дізнатися більше,
ознайомтеся із підручником щодо L<qemu(1)>. Libguestfs викликає qemu
декілька разів (для сканування допоміжних виведених даних тощо). Вам
потрібен лише кінцевий виклик qemu, тому скористайтеся скриптом-обгорткою,
подібним до такого:

 #!/bin/bash -
 
 # Встановіть значення, яке вказуватиме на справжній виконуваний файл qemu.
 qemu=/usr/bin/qemu-kvm
 
 if [ "$1" != "-global" ]; then
     # Scanning help output etc.
     exec $qemu "$@"
 else 
     # Really running qemu.
     exec $qemu -S -s "$@"
 fi

Далі, запустіть guestfish або інший інструмент libguestfs із обгорткою qemu
(див. L<guestfs(3)/ОБГОРТКИ QEMU>, щоб зрозуміти, які дії виконуються):

 LIBGUESTFS_HV=/шлях/до/qemu-wrapper guestfish -a /dev/null -v run

Виконання має призупинитися після запуску qemu. У іншому вікні з'єднайтеся
із qemu за допомогою gdb:

 $ gdb
 (gdb) set architecture i8086
 The target architecture is assumed to be i8086
 (gdb) target remote :1234
 Remote debugging using :1234
 0x0000fff0 in ?? ()
 (gdb) cont

Після цього ви можете використовувати стандартні методики gdb, наприклад,
натискати C<^C>, щоб перервати завантаження, або C<bt>, щоб отримати
трасування стека, встановлювати точки зупину тощо. Зауважте, що після
проходження BIOS і потрапляння до ядра Linux вам варто знову змінити
архітектуру на 32 або 64-бітову.

=head1 ПРОБЛЕМИ ЗІ ШВИДКОДІЄЮ У ІНШИХ ПРОГРАМАХ

Іноді регресії у швидкодії трапляються у інших програмах (наприклад, у qemu
або ядрі системи), що спричиняє проблеми і у libguestfs.

У початковому коді libguestfs є файл
F<utils/boot-benchmark/boot-benchmark-range.pl>. Це скрипт, яким можна
скористатися для вимірювання параметрів роботи libguestfs на діапазоні
внесків git у іншому проекті, щоб визначити внесок, який спричинив
уповільнення роботи (або її пришвидшення).

Щоб дізнатися більше про те, як користуватися цим скриптом, зверніться до
підручника:

 ./utils/boot-benchmark/boot-benchmark-range.pl --man

=head1 ТАКОЖ ПЕРЕГЛЯНЬТЕ

L<supermin(1)>, L<guestfish(1)>, L<guestfs(3)>, L<guestfs-examples(3)>,
L<guestfs-internals(1)>, L<libguestfs-make-fixed-appliance(1)>, L<stap(1)>,
L<qemu(1)>, L<gdb(1)>, L<http://libguestfs.org/>.

=head1 АВТОРИ

Richard W.M. Jones (C<rjones at redhat dot com>)

=head1 АВТОРСЬКІ ПРАВА

Copyright (C) 2012-2019 Red Hat Inc.

