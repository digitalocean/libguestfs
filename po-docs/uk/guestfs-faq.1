.\" Automatically generated by Podwrapper::Man 1.40.2 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "guestfs-faq 1"
.TH guestfs-faq 1 "2019-02-07" "libguestfs-1.40.2" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
guestfs-faq — поширені питання щодо libguestfs на відповіді на них (\s-1FAQ\s0)
.SH "ПРО LIBGUESTFS"
.IX Header "ПРО LIBGUESTFS"
.SS "Для чого призначено libguestfs?"
.IX Subsection "Для чого призначено libguestfs?"
libguestfs — засіб створення образів диска, доступу до образів диску та
внесення змін до образів диска. За її допомогою ви зможете бачити вміст
образів диска, вносити зміни до файлів, які у ньому містяться, створювати
образи, змінювати їхні розміри тощо. Це особливо корисно для керування
образами зі скриптів та програм, а також командного рядка.
.PP
libguestfs є бібліотекою мовою C (звідси «lib\-») і набором інструментів,
побудованих на основі цієї бібліотеки, а також прив'язок до багатьох типових
мов програмування.
.PP
Докладніший опис призначення і можливостей libguestfs наведено у вступній
частині домашньої сторінки (http://libguestfs.org).
.SS "Для чого призначено virt tools?"
.IX Subsection "Для чого призначено virt tools?"
Засоби віртуалізації (сайт: http://virt\-tools.org) — загальний набір
засобів для керування віртуалізацією, призначений для системних
адміністраторів. Деякі із засобів походять із libguestfs, деякі — з libvirt,
а багато інших — із інших проектів із відкритим кодом. Отже, засоби
віртуалізації — надбудова над libguestfs. Втім, багато важливих інструментів
є частиною саме libguestfs. Із повним списком можна ознайомитися тут:
http://libguestfs.org.
.SS "Чи потрібно встановлювати пакунки { libvirt / \s-1KVM /\s0 Red Hat / Fedora } для роботи з libguestfs?"
.IX Subsection "Чи потрібно встановлювати пакунки { libvirt / KVM / Red Hat / Fedora } для роботи з libguestfs?"
Ні!
.PP
libvirt не є обов’язковою частиною libguestfs.
.PP
libguestfs працює із будь\-яким образом диска, зокрема образами, створеним за
допомогою VMware, \s-1KVM,\s0 qemu, VirtualBox, Xen та багатьох інших гіпервізорів,
а також тими образами, які ви створили «з нуля».
.PP
Red Hat спонсорує (тобто оплачує) розробку libguestfs та величезної
кількості інших проектів із відкритим кодом. Втім, ви можете працювати із
libguestfs та засобами віртуалізації на багатьох інших дистрибутивах Linux
та у Mac \s-1OS X.\s0 Ми намагаємося якнайкраще підтримувати передусім усі
дистрибутиви Linux. Деякі із засобів віртуалізації портовано на Windows.
.SS "Що дає використання libguestfs порівняно з іншими інструментами?"
.IX Subsection "Що дає використання libguestfs порівняно з іншими інструментами?"
.IP "\fIпорівняно з kpartx\fR" 4
.IX Item "порівняно з kpartx"
У libguestfs використано інший підхід, порівняно із kpartx. Для роботи
kpartx потрібні права доступу адміністратора (root) та монтування файлових
систем на рівні ядра основної системи (що може бути небезпечним,
див. \fBguestfs\-security\fR\|(1)).  Libguestfs ізолює ядро основної системи від
гостьових систем, є гнучкішою, придатнішою для керування ззовні, підтримує
\&\s-1LVM,\s0 не потребує прав доступу root, ізольована від інших процесів та чистить
систему після себе. Libguestfs — це не лише доступ до файлів, оскільки
бібліотека здатна сама створювати образи «з нуля».
.IP "\fIпорівняно з vdfuse\fR" 4
.IX Item "порівняно з vdfuse"
vdfuse подібна до kpartx, але призначена для образів VirtualBox. Відповідно,
порівняння подібне до наведеного вище порівняння для kpartx. Ви можете
скористатися libguestfs для роботи із файлами розділів крізь vdfuse, але у
цьому немає потреби, оскільки libguestfs може отримувати доступ до образів
VirtualBox безпосередньо.
.IP "\fIпорівняно з qemu-nbd\fR" 4
.IX Item "порівняно з qemu-nbd"
\&\s-1NBD\s0 (Network Block Device) — протокол для експортування блокових пристроїв
мережею. qemu-nbd — сервер \s-1NBD,\s0 який може працювати із дисками будь\-якого
формату, якщо підтримку цього формату передбачено у qemu (зокрема з raw,
qcow2). Ви можете скористатися libguestfs у поєднанні із qemu-nbd або nbdkit
together для доступу до блокових пристроїв мережею. Приклад: \f(CW\*(C`guestfish \-a
nbd://віддалена_система\*(C'\fR
.IP "\fIпорівняно з монтуванням файлових систем у основній системі\fR" 4
.IX Item "порівняно з монтуванням файлових систем у основній системі"
Монтування файлових систем гостьової системи до основної системи не є
безпечним. Його слід завжди уникати для ненадійних гостьових
систем. Скористайтеся libguestfs для створення шару захисту від вразливостей
у засобах обробки файлових систем. Див. також \fBguestmount\fR\|(1).
.IP "\fIпорівняно з parted\fR" 4
.IX Item "порівняно з parted"
У libguestfs передбачено підтримку \s-1LVM.\s0 У libguestfs використовується
parted, бібліотека надає доступ до більшості можливостей parted за допомогою
програмного інтерфейсу libguestfs.
.SH "ОТРИМАННЯ ДОВІДКОВОЇ ІНФОРМАЦІЇ ТА ЗВІТУВАННЯ ПРО ВАДИ"
.IX Header "ОТРИМАННЯ ДОВІДКОВОЇ ІНФОРМАЦІЇ ТА ЗВІТУВАННЯ ПРО ВАДИ"
.SS "Як визначити версію програми, якою я користуюся?"
.IX Subsection "Як визначити версію програми, якою я користуюся?"
Найпростіший спосіб:
.PP
.Vb 1
\& guestfish \-\-version
.Ve
.PP
Розробка libguestfs відбувається у нестабільній гілці. Ми також періодично
створюємо стабільні гілки, до яких портуємо латки із виправленнями вад. Щоб
дізнатися більше, ознайомтеся із розділом \*(L"НУМЕРАЦІЯ ВЕРСІЙ
\&\s-1LIBGUESTFS\*(R"\s0 in \fBguestfs\fR\|(3).
.SS "Як допомогти проектові?"
.IX Subsection "Як допомогти проектові?"
.SS "Якими списками листування або кімнатами спілкування можна скористатися?"
.IX Subsection "Якими списками листування або кімнатами спілкування можна скористатися?"
Якщо ви є клієнтом Red Hat, який користується Red Hat Enterprise Linux,
будь ласка, зв'яжіться із Службою підтримки Red Hat:
http://redhat.com/support
.PP
Передбачено список листування, здебільшого, для тем, пов'язаних із
розробкою, але користувачі також можуть задавати питання щодо libguestfs та
засобів віртуалізації у цьому списку:
https://www.redhat.com/mailman/listinfo/libguestfs
.PP
Крім того, ви можете поспілкуватися із нами на каналі \s-1IRC\s0 \f(CW\*(C`#libguestfs\*(C'\fR
сервера FreeNode. Не всі розробники можуть увесь час перебувати на зв'язку,
отому, будь ласка, задавши питання на каналі, зачекайте хоч трохи, і хтось
обов'язково на нього відповість.
.PP
Щодо інших засобів віртуалізації (не тих, які є частиною libguestfs) існує
загальний список листування щодо засобів віртуалізації:
https://www.redhat.com/mailman/listinfo/virt\-tools\-list
.SS "Як повідомити про вади?"
.IX Subsection "Як повідомити про вади?"
Будь ласка, скористайтеся цим посиланням для створення записів звітів щодо
вад у Bugzilla:
.PP
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
Надайте якнайдокладніший опис і поради щодо способу відтворення проблеми.
.PP
Включіть до звіту усі дані, які було виведено \fBlibguestfs\-test\-tool\fR\|(1).
.SH "ТИПОВІ ПРОБЛЕМИ"
.IX Header "ТИПОВІ ПРОБЛЕМИ"
Приклади помилкового використання програмного інтерфейсу libguestfs також
наведено у розділі \*(L"ПРОБЛЕМНІ МІСЦЯ \s-1LIBGUESTFS\*(R"\s0 in \fBguestfs\fR\|(3).
.ie n .SS """Could not allocate dynamic translator buffer"""
.el .SS "``Could not allocate dynamic translator buffer''"
.IX Subsection "Could not allocate dynamic translator buffer"
Фактично, причиною цієї важковідстежуваної помилки є проблеми із
SELinux. Вам слід увімкнути такий булевий перемикач SELinux:
.PP
.Vb 1
\& setsebool \-P virt_use_execmem=on
.Ve
.PP
Докладніші відомості можна знайти за адресою
https://bugzilla.redhat.com/show_bug.cgi?id=806106.
.ie n .SS """child process died unexpectedly"""
.el .SS "``child process died unexpectedly''"
.IX Subsection "child process died unexpectedly"
[Це повідомлення у libguestfs 1.21.18 було замінено на змістовніше.]
.PP
Це повідомлення про помилку вказує на помилку у роботі qemu або неможливість
завантаження ядра основної системи. Для отримання подальшої інформації щодо
помилки вам слід віддати таку команду:
.PP
.Vb 1
\& libguestfs\-test\-tool
.Ve
.PP
Якщо навіть після використання цієї команди ви не зрозуміли причини помилки,
зверніться до розробників бібліотеки (див. попередній розділ).
.SS "libguestfs: помилка: не вдалося знайти відповідного supermin libguestfs, фіксованого розгортання або розгортання у застарілому стилі за адресою \s-1LIBGUESTFS_PATH\s0"
.IX Subsection "libguestfs: помилка: не вдалося знайти відповідного supermin libguestfs, фіксованого розгортання або розгортання у застарілому стилі за адресою LIBGUESTFS_PATH"
.SS "febootstrap-supermin-helper: ext2: не знайдено батьківського каталогу"
.IX Subsection "febootstrap-supermin-helper: ext2: не знайдено батьківського каталогу"
.SS "supermin-helper: ext2: не знайдено батьківського каталогу"
.IX Subsection "supermin-helper: ext2: не знайдено батьківського каталогу"
[Цю ваду було остаточно виправлено у libguestfs ≥ 1.26.]
.PP
Якщо ви бачите ці повідомлення про помилки у Debian/Ubuntu, вам слід віддати
таку команду:
.PP
.Vb 1
\& sudo update\-guestfs\-appliance
.Ve
.SS "«Заборонено доступ» («Permission denied») під час виконання libguestfs від імені root"
.IX Subsection "«Заборонено доступ» («Permission denied») під час виконання libguestfs від імені root"
Ви отримуєте повідомлення щодо заборони доступу під час відкриття образу
диска, незважаючи на те, що запускали libguestfs від імені адміністратора
системи (root).
.PP
Причиною є робота libvirt, отже, це трапляється лише при використанні модуля
обробки libvirt. Під час роботи від імені користувача root libvirt запускає
базову систему qemu від імені користувача \f(CW\*(C`qemu.qemu\*(C'\fR. На жаль, зазвичай,
це означає, що qemu не зможе відкривати образи дисків, особливо якщо
власником цих образів диска є користувач root або ці образи зберігаються у
каталогах, доступ до яких має лише користувач root.
.PP
Для виправлення цього відкрито звіт про ваду у libvirt:
https://bugzilla.redhat.com/show_bug.cgi?id=1045069
.PP
Обійти проблему можна у один з таких способів:
.IP "\(bu" 4
Перемкнутися на безпосередній модуль:
.Sp
.Vb 1
\& export LIBGUESTFS_BACKEND=direct
.Ve
.IP "\(bu" 4
Не запускати libguestfs від імені адміністратора (root).
.IP "\(bu" 4
Змініть режим доступу до образу диска та усіх каталогів, з яких складається
шлях до нього, таким чином, щоб користувач qemu мав до них доступ.
.IP "\(bu" 4
(Небезпечний спосіб) Відкрийте для редагування \fI/etc/libvirt/qemu.conf\fR і
змініть значення параметра \f(CW\*(C`user\*(C'\fR.
.SS "execl: /init: відмовлено у доступі"
.IX Subsection "execl: /init: відмовлено у доступі"
\&\fBЗауваження:\fR якщо ви бачите це повідомлення про помилку під час роботи із
дистрибутивним пакунком libguestfs (наприклад, пакунком Fedora, Debian),
повідомте про ваду розробникам дистрибутива. Звичайний користувач
дистрибутивного пакунка, приготованого належним чином, ніколи не повинен
бачити цього повідомлення про помилку.
.PP
Це повідомлення про помилку виникає під час стадії завантаження запуску
базової системи у supermin:
.PP
.Vb 5
\& supermin: mounting new root on /root
\& supermin: chroot
\& execl: /init: Permission denied
\& supermin: debug: listing directory /
\& [...далі багато інших діагностичних повідомлень...]
.Ve
.PP
Це складна вада, пов'язана із базовими системами \fBsupermin\fR\|(1). Базова
система будується шляхом копіювання файлів, подібних до \fI/bin/bash\fR, та
багатьох бібліотек із основної системи. Список файлів, які має бути
скопійовано з основної системи до базової, зберігається у файлі
\&\f(CW\*(C`hostfiles\*(C'\fR. Якщо якихось файлів немає у основній системі, їх буде
пропущено, але якщо такі файли потрібні (наприклад) для запуску
\&\fI/bin/bash\fR, ви побачите згодом саме таке повідомлення про помилку.
.PP
Виявити причину помилки можна вивчивши список бібліотек, потрібних для
роботи \fI/bin/bash\fR. Тобто, слід віддати таку команду:
.PP
.Vb 1
\& ldd /bin/bash
.Ve
.PP
і порівняти отриманий список зі списком із \f(CW\*(C`hostfiles\*(C'\fR, списком файлів, які
є у файловій системі основної системи та діагностичними повідомленнями із
повідомлення про помилку. Щойно буде виявлено файл, якого не вистачає, його
слід встановити за допомогою програми для керування пакунками, а потім
повторити спробу.
.PP
Також слід перевірити, чи є файли, подібні до \fI/init\fR та \fI/bin/bash\fR (у
базовій системі) виконуваними. У діагностичних даних мають бути відомості
щодо режимів файлів.
.SH "ОТРИМАННЯ, ВСТАНОВЛЕННЯ, ЗБИРАННЯ LIBGUESTFS"
.IX Header "ОТРИМАННЯ, ВСТАНОВЛЕННЯ, ЗБИРАННЯ LIBGUESTFS"
.SS "Де взяти найсвіжіші збірки для... ?"
.IX Subsection "Де взяти найсвіжіші збірки для... ?"
.IP "Fedora ≥ 11" 4
.IX Item "Fedora ≥ 11"
Скористайтеся командою:
.Sp
.Vb 1
\& yum install \*(Aq*guestf*\*(Aq
.Ve
.Sp
Найсвіжіші збірки можна знайти тут:
http://koji.fedoraproject.org/koji/packageinfo?packageID=8391
.IP "Red Hat Enterprise Linux" 4
.IX Item "Red Hat Enterprise Linux"
.RS 4
.PD 0
.IP "\s-1RHEL 5\s0" 4
.IX Item "RHEL 5"
.PD
Версія, що постачається разом з офіційним \s-1RHEL 5\s0 є дуже застарілою. Нею не
варто користуватися без сполучення з virt\-v2v. Скористайтеся пакунками
libguestfs 1.20 з \s-1EPEL 5:\s0 https://fedoraproject.org/wiki/EPEL
.IP "\s-1RHEL 6\s0" 4
.IX Item "RHEL 6"
.PD 0
.IP "\s-1RHEL 7\s0" 4
.IX Item "RHEL 7"
.PD
Є частиною типового набору для встановлення. У \s-1RHEL 6\s0 і 7 (і лише тут) вам
слід встановити \f(CW\*(C`libguestfs\-winsupport\*(C'\fR, щоб мати змогу працювати з
гостьовими системами Windows.
.RE
.RS 4
.RE
.IP "Debian і Ubuntu" 4
.IX Item "Debian і Ubuntu"
У libguestfs < 1.26 після встановлення libguestfs вам слід віддати такі
команди:
.Sp
.Vb 1
\& sudo update\-guestfs\-appliance
.Ve
.Sp
(Цей скрипт було вилучено у Debian/Ubuntu  у версіях libguestfs ≥ 1.26,
де замість цього базова система збирається на вимогу.)
.Sp
Лише в Ubuntu:
.Sp
.Vb 1
\& sudo chmod 0644 /boot/vmlinuz*
.Ve
.Sp
Вам, ймовірно, варто додати вашого користувача до групи \f(CW\*(C`kvm\*(C'\fR:
.Sp
.Vb 1
\& sudo usermod \-a \-G kvm ваш_обліковий_запис
.Ve
.RS 4
.IP "Debian Squeeze (6)" 4
.IX Item "Debian Squeeze (6)"
Hilko Bengen зібрано libguestfs для сховища пакунків зворотного портування
squeeze:
http://packages.debian.org/search?keywords=guestfs&searchon=names&section=all&suite=squeeze\-backports
.IP "Debian Wheezy та пізніші версії (7+)" 4
.IX Item "Debian Wheezy та пізніші версії (7+)"
Супровід libguestfs у Debian здійснює Hilko Bengen. Ви можете скористатися
офіційними пакунками Debian:
http://packages.debian.org/search?keywords=libguestfs
.IP "Ubuntu" 4
.IX Item "Ubuntu"
У нас немає повноцінного супровідника пакунків Ubuntu. Пакунки, що надаються
Canonical (і не контролюються нами) іноді виявляються непрацездатними.
.Sp
Компанією Canonical прийнято рішення щодо зміни прав доступу до ядра таким
чином, що його читання не може виконувати жоден з користувачів, окрім
root. Ми вважаємо таке рішення повністю невиправданим, але компанія
відмовляється його змінювати
(https://bugs.launchpad.net/ubuntu/+source/linux/+bug/759725). Тому
користувачам слід віддати таку команду:
.Sp
.Vb 1
\& sudo chmod 0644 /boot/vmlinuz*
.Ve
.RS 4
.IP "Ubuntu 12.04" 4
.IX Item "Ubuntu 12.04"
libguestfs у цій версії Ubuntu має працювати, але вам слід оновити пакунки
febootstrap та seabios до найсвіжіших версій.
.Sp
Вам знадобиться пакунок febootstrap ≥ 3.14\-2 з
http://packages.ubuntu.com/precise/febootstrap
.Sp
Після встановлення або оновлення febootstrap виконайте повторне збирання
базової системи:
.Sp
.Vb 1
\& sudo update\-guestfs\-appliance
.Ve
.Sp
Вам знадобиться пакунок seabios ≥ 0.6.2\-0ubuntu2.1 або ≥
0.6.2\-0ubuntu3 з http://packages.ubuntu.com/precise\-updates/seabios або
http://packages.ubuntu.com/quantal/seabios
.Sp
Крім того, вам слід виконати такі дії (див. вище):
.Sp
.Vb 1
\& sudo chmod 0644 /boot/vmlinuz*
.Ve
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Gentoo" 4
.IX Item "Gentoo"
Libguestfs було додано до Gentoo 2012\-07, автори —  Andreis Vinogradovs
(libguestfs) та Maxim Koltsov (в основному hivex). Віддайте команду:
.Sp
.Vb 1
\& emerge libguestfs
.Ve
.IP "SuSE" 4
.IX Item "SuSE"
Libguestfs було додано до сховищ пакунків SuSE у 2012 році, супровідник —
Olaf Hering.
.IP "ArchLinux" 4
.IX Item "ArchLinux"
Libguestfs було додано до \s-1AUR\s0 у 2010 році.
.IP "Інші дистрибутиви Linux" 4
.IX Item "Інші дистрибутиви Linux"
Можна зібрати з початкових кодів (наступний розділ).
.IP "Інші дистрибутиви не\-Linux" 4
.IX Item "Інші дистрибутиви не-Linux"
Вам слід зібрати бібліотеку з початкових кодів і портувати її.
.SS "Як зібрати і встановити libguestfs з початкових кодів?"
.IX Subsection "Як зібрати і встановити libguestfs з початкових кодів?"
Ви можете зібрати libguestfs з git або архіву tar із початковим кодом. Перш
ніж почнете це робити, ознайомтеся із вмістом файла \s-1README.\s0
.PP
Git: https://github.com/libguestfs/libguestfs Архіви з кодом:
http://libguestfs.org/download
.PP
Не використовуйте команду \f(CW\*(C`make install\*(C'\fR! Замість неї слід користуватися
скриптом \f(CW\*(C`./run\*(C'\fR (див. \s-1README\s0).
.SS "Як зібрати і встановити libguestfs, якщо у дистрибутиві немає достатньо нового qemu, supermin або ядра?"
.IX Subsection "Як зібрати і встановити libguestfs, якщо у дистрибутиві немає достатньо нового qemu, supermin або ядра?"
Для роботи libguestfs потрібен supermin 5. Якщо supermin 5 не портовано на
ваш дистрибутив, ознайомтеся із наведеною нижче відповіддю на наступне
питання.
.PP
Спочатку зберіть qemu, supermin і/або ядро із початкового коду. Вам \fIне
слід\fR віддавати команду \f(CW\*(C`make install\*(C'\fR для встановлення.
.PP
У каталозі із початковим кодом libguestfs створіть два файли. Файл
\&\f(CW\*(C`localconfigure\*(C'\fR має містити такий текст:
.PP
.Vb 3
\& source localenv
\& #export PATH=/tmp/qemu/x86_64\-softmmu:$PATH
\& ./autogen.sh \-\-prefix /usr "$@"
.Ve
.PP
Зробіть \f(CW\*(C`localconfigure\*(C'\fR виконуваним.
.PP
\&\f(CW\*(C`localenv\*(C'\fR має містити таке:
.PP
.Vb 5
\& #export SUPERMIN=/tmp/supermin/src/supermin
\& #export LIBGUESTFS_HV=/tmp/qemu/x86_64\-softmmu/qemu\-system\-x86_64
\& #export SUPERMIN_KERNEL=/tmp/linux/arch/x86/boot/bzImage
\& #export SUPERMIN_KERNEL_VERSION=4.XX.0
\& #export SUPERMIN_MODULES=/tmp/lib/modules/4.XX.0
.Ve
.PP
Розкоментуйте і скоригуйте рядки так, щоб вони відповідали зібраним вами
альтернативним варіантам програм.
.PP
Скористайтеся \f(CW\*(C`./localconfigure\*(C'\fR замість \f(CW\*(C`./configure\*(C'\fR додавши до скрипту
звичайні аргументи для збирання libguestfs.
.PP
Не використовуйте команду \f(CW\*(C`make install\*(C'\fR! Замість неї слід користуватися
скриптом \f(CW\*(C`./run\*(C'\fR (див. \s-1README\s0).
.SS "Як зібрати і встановити libguestfs без supermin?"
.IX Subsection "Як зібрати і встановити libguestfs без supermin?"
Якщо у supermin 5 передбачено підтримку вашого дистрибутива, але якось так
вийшло, що у вашій системі не встановлено достатньо нової версії supermin,
скористайтеся настановами із відповіді на попереднє питання.
.PP
Якщо у supermin 5 взагалі не передбачено підтримки вашого дистрибутива, вам
доведеться скористатися «методом фіксованої базової системи», згідно з яким
вам слід скористатися наперед зібраним двійковим образом базової
системи. Щоб зібрати libguestfs без підтримки supermin, вам слід передати
параметри \f(CW\*(C`\-\-disable\-appliance \-\-disable\-daemon\*(C'\fR \fI./autogen.sh\fR або
\&\fI./configure\fR (залежно від того, що ви збираєте, код з git або код з архіву
tar). Далі, під час використання libguestfs вам \fBслід\fR встановити для
змінної середовища \f(CW\*(C`LIBGUESTFS_PATH\*(C'\fR значення, яке збігається із адресою
каталогу, де зберігається попередньо зібрана базова система, як це описано у
розділі \*(L"ФІКСОВАНА БАЗОВА СИСТЕМА\*(R" in \fBguestfs\-internals\fR\|(1).
.PP
Крім того, попередньо зібрані базові системи можна знайти тут:
http://libguestfs.org/download/binaries/appliance/.
.PP
Ми будемо раді надісланим вами латкам для портування supermin на інші
дистрибутиви Linux.
.SS "Як додати підтримку для sVirt?"
.IX Subsection "Як додати підтримку для sVirt?"
\&\fBЗауваження для користувачів Fedora/RHEL:\fR ця конфігурація є типовою,
починаючи з Fedora 18 та \s-1RHEL 7.\s0  Якщо вами буде виявлено якісь
проблеми, будь ласка, повідомте розробникам або створіть звіт про ваду у
бібліотеці.
.PP
SVirt створює захищену базову
систему із використанням SELinux, роблячи дуже складною для створеного
зловмисниками образу диска «втечу» з контейнера libguestfs і ускладнюючи
спроби нашкодити основній системі (слід сказати, що навіть у стандартній
libguestfs зробити це складно, але sVirt створює додатковий шар захисту для
основної системи і, що важливіше, захищає віртуальні машини на одній
основній системі одна від одної).
.PP
У поточній версії для вмикання sVirt вам знадобиться libvirt ≥ 0.10.2
(бажано 1.0 або новіша версія), libguestfs ≥ 1.20, та правила SELinux зі
свіжої версії Fedora. Якщо ви працюєте не з Fedora 18+, вам доведеться
внести зміни до ваших правил SELinux — якщо потрібен конкретний список,
зв'яжіться із нами за допомогою списку листування.
.PP
Щойно усі вимоги буде задоволено, зробіть наступне:
.PP
.Vb 3
\& ./configure \-\-with\-default\-backend=libvirt       # libguestfs >= 1.22
\& ./configure \-\-with\-default\-attach\-method=libvirt # libguestfs <= 1.20
\& make
.Ve
.PP
Встановіть SELinux у примусовий (Enforcing) режим, і sVirt буде використано
автоматично.
.PP
З sVirt мають працювати усі або майже усі можливості libguestfs. Втім, є
один відомий недолік: \fBvirt\-rescue\fR\|(1) не використовуватиме libvirt (а
отже, і sVirt), а повернеться до безпосереднього запуску qemu. Тому, ви не
зможете скористатися перевагами захисту sVirt, якщо користуватиметеся
virt-rescue.
.PP
Перевірити, чи працює sVirt можна вмиканням журналу libvirtd
(див. \fI/etc/libvirt/libvirtd.log\fR). Далі слід завершити роботу libvirtd і
перезапустити цю службу, а потім пошукати у файлах журналу повідомлення
\&\*(L"Setting SELinux context on ...\*(R" (Встановлюємо контекст SELinux...»).
.PP
Теоретично, у sVirt має бути передбачено підтримку AppArmor, але ми цього не
перевіряли. Майже напевне, використання sVirt потребуватиме латання libvirt
і написання правил AppArmor.
.SS "Чому у Libguestfs такий великий список залежностей?"
.IX Subsection "Чому у Libguestfs такий великий список залежностей?"
Основа бібліотеки має доволі мало залежностей, але існує три причини, через
які список залежностей є доволі довгим:
.IP "1." 4
Libguestfs повинна мати змогу читати і редагувати дані у багатьох різних
форматах дисків. Наприклад, підтримка \s-1XFS\s0 потребує використання інструментів
для роботи з \s-1XFS.\s0
.IP "2." 4
До складу бібліотеки включено прив'язки до багатьох мов програмування, і для
усіх цих мов потрібні власні інструменти для розробки. Усі прив'язки до мов
(окрім C) є необов'язковими.
.IP "3." 4
До складу бібліотеки включено декілька додаткових можливостей, які можна
вимкнути.
.PP
Починаючи з libguestfs ≥ 1.26, можна відділити залежності базової
системи (пункт 1 у наведеному вище списку), створивши, наприклад, окремий
підпакунок \f(CW\*(C`libguestfs\-xfs\*(C'\fR для обробки образів дисків \s-1XFS.\s0 Ми радимо
пакувальникам для дистрибутивів почати ділити базовий пакунок libguestfs на
менші підпакунки.
.SS "Помилки під час запуску на Fedora ≥ 18, \s-1RHEL\s0 ≥ 7"
.IX Subsection "Помилки під час запуску на Fedora ≥ 18, RHEL ≥ 7"
У Fedora ≥ 18 та \s-1RHEL\s0 ≥ 7 libguestfs використовує libvirt для
керування базовою системою. Раніше (і у основній гілці розробки) libguestfs
запускає qemu безпосередньо:
.PP
.Vb 10
\& ┌──────────────────────────────────┐
\& │ libguestfs                       │
\& ├────────────────┬─────────────────┤
\& │ безп. модуль │ модуль libvirt │
\& └────────────────┴─────────────────┘
\&        ↓                  ↓
\&    ┌───────┐         ┌──────────┐
\&    │ qemu  │         │ libvirtd │
\&    └───────┘         └──────────┘
\&                           ↓
\&                       ┌───────┐
\&                       │ qemu  │
\&                       └───────┘
\& 
\&    upstream          Fedora 18+
\&    не\-Fedora         RHEL 7+
\&    не\-RHEL
.Ve
.PP
Модуль libvirt є складнішим, підтримує SELinux/sVirt (див. вище), «гаряче»
з'єднання образів тощо. Втім, через складність він є менш стійким.
.PP
Якщо виникають проблеми із правами доступу під час використання модуля
libvirt, ви можете перейти на модуль безпосереднього керування встановленням
такої змінної середовища:
.PP
.Vb 1
\& export LIBGUESTFS_BACKEND=direct
.Ve
.PP
до запуску будь\-яких інструментів libguestfs або virt.
.SS "Як перемкнути бібліотеку на фіксовану або попередньо зібрану базову систему?"
.IX Subsection "Як перемкнути бібліотеку на фіксовану або попередньо зібрану базову систему?"
Це може поліпшити стабільність та швидкодію libguestfs у Fedora і \s-1RHEL.\s0
.PP
Будь\-коли після встановлення libguestfs віддайте такі команди від імені
root:
.PP
.Vb 3
\& mkdir \-p /usr/local/lib/guestfs/appliance
\& libguestfs\-make\-fixed\-appliance /usr/local/lib/guestfs/appliance
\& ls \-l /usr/local/lib/guestfs/appliance
.Ve
.PP
Далі, встановіть значення для такої змінної середовища до використання
libguest або будь\-якого іншого засобу віртуалізації:
.PP
.Vb 1
\& export LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance
.Ve
.PP
Звичайно ж, ви можете змінити шлях на адресу будь\-якого каталогу. Ви можете
спільно використовувати базову систему на різних машинах із однаковою
архітектурою (наприклад, усіх машинах x86\-64), але слід пам'ятати, що
libvirt не дасть вам спільно використовувати базову систему за допомогою \s-1NFS\s0
через проблеми із правами доступу (отже, слід або перемкнутися на модуль
безпосередньої роботи, або не використовувати \s-1NFS\s0).
.SS "Як пришвидшити збирання libguestfs?"
.IX Subsection "Як пришвидшити збирання libguestfs?"
Найважливішим у пришвидшенні роботи може стати встановлення і належне
налаштовування Squid. Зауважте, що типові налаштування, з якими
встановлюється Squid не дадуть бажаних результатів, тому налаштовування у
цьому випадку є обов'язковим.
.PP
Чудові початкові поради щодо налаштовування Squid можна знайти тут:
https://fedoraproject.org/wiki/Extras/MockTricks#Using_Squid_to_Speed_Up_Mock_package_downloads
.PP
Переконайтеся, що Squid працює, і що змінні середовища \f(CW$http_proxy\fR та
\&\f(CW$ftp_proxy\fR вказують на нього.
.PP
Якщо Squid запущено і належним чином налаштовано, збирання базової системи
має стати справою декількох хвилин.
.PP
\fIЯк пришвидшити збирання libguestfs (Debian)?\fR
.IX Subsection "Як пришвидшити збирання libguestfs (Debian)?"
.PP
Hilko Bengen запропоновано використовувати «approx», архівний проксі\-сервер
Debian (http://packages.debian.org/approx).   Документацію до цієї
програми можна знайти на сторінці підручника щодо \fBapprox\fR\|(8).
.SH "ШВИДКІСТЬ, МІСЦЕ НА ДИСКУ, ЯКЕ ЗАЙНЯТО LIBGUESTFS"
.IX Header "ШВИДКІСТЬ, МІСЦЕ НА ДИСКУ, ЯКЕ ЗАЙНЯТО LIBGUESTFS"
\&\fBЗауваження:\fR більшу частину відомостей з цього розділу перенесено до
розділу \fBguestfs\-performance\fR\|(1).
.SS "Вивантаження або запис дуже повільні."
.IX Subsection "Вивантаження або запис дуже повільні."
Якщо базовий диск не повністю розподілено (наприклад, маєте справу із
розрідженим raw або qcow2), запис може бути повільним через те, що основна
операційна система має виконувати ресурсомісткі операції із отримання місця
на диску під час запису. Усунути проблему можна використанням формату із
повним розподілом, тобто raw без розрідження або qcow2 з параметром
\&\f(CW\*(C`preallocation=metadata\*(C'\fR.
.SS "Libguestfs займає надто багато місця на диску!"
.IX Subsection "Libguestfs займає надто багато місця на диску!"
libguestfs кешує найбільшу базову систему сюди:
.PP
.Vb 1
\& /var/tmp/.guestfs\-<UID>
.Ve
.PP
Якщо визначено змінну середовища \f(CW\*(C`TMPDIR\*(C'\fR, буде використано
\&\fI\f(CI$TMPDIR\fI/.guestfs\-<\s-1UID\s0>\fR.
.PP
Коли ви не використовуєте libguestfs, цей каталог можна безпечно вилучити.
.SS "Здається, virt-sparsify робить так, що розмір образу збільшується до повного розміру віртуального диска"
.IX Subsection "Здається, virt-sparsify робить так, що розмір образу збільшується до повного розміру віртуального диска"
Якщо результатом \fBvirt\-sparsify\fR\|(1) є образ raw, буде виведено розріджені
дані raw. Отже, вимірювати виведені дані слід за допомогою інструмента, який
обробляє розріджені дані, наприклад \f(CW\*(C`du \-sh\*(C'\fR. Використання такого
інструмента є дуже важливим:
.PP
.Vb 4
\& $ ls \-lh test1.img
\& \-rw\-rw\-r\-\-. 1 rjones rjones 100M Aug  8 08:08 test1.img
\& $ du \-sh test1.img
\& 3.6M   test1.img
.Ve
.PP
(Порівняйте видимий розмір у \fB100 МБ\fR зі справжнім розміром у \fB3,6 МБ\fR)
.PP
Якщо такі відмінності бентежать вас, скористайтеся форматом виведення без
розрідження, вказавши параметр \fI\-\-convert\fR. Приклад:
.PP
.Vb 1
\& virt\-sparsify \-\-convert qcow2 диск.raw диск.qcow2
.Ve
.SS "Чому virt-resize не працює із образами дисків «на місці»?"
.IX Subsection "Чому virt-resize не працює із образами дисків «на місці»?"
Зміна розміру образу диска є доволі непростою дією — особливо, з урахуванням
того, що слід зберегти усі дані і не пошкодити завантажувач. У поточній
версії, насправді, створюється новий образ диска, до якого копіюються дані і
завантажувач зі старого образу. Якщо щось піде не так, ви завжди можете
повернутися до початкового варіанта.
.PP
Якби нами було реалізовано роботу virt-resize «на місці», нам довелося б
також ввести декілька обмежень: наприклад, було б заборонено пересування
наявних розділів (оскільки пересування даних у межах одного диска,
найімовірніше, призвело б до пошкодження даних при раптовому вимиканні
живлення або аварійному завершенні роботи програми), а підтримка \s-1LVM\s0 стала б
дуже складною справою (через майже випадковий зв'язок між вмістом логічного
тому і підлеглих йому блоків на диску).
.PP
Ми розглядали і інший спосіб, який полягав у тому, щоб створювати
різницю\-знімок щодо початкового образу диска так, щоб початкові дані
лишалися незмінними, а до знімка записувалася лише різниця. Зробити це у
поточній версії можна за допомогою комбінації \f(CW\*(C`qemu\-img create\*(C'\fR +
\&\f(CW\*(C`virt\-resize\*(C'\fR. Втім, qemu у поточній версії недостатньо кмітлива, щоб
розпізнати ситуацію, коли блок, який записується до знімка вже існує у
резервній копію диска, отже, зрозуміло, цей спосіб не заощадить вам ні місця
на диску, ні часу.
.PP
Підсумовуючи, це складна проблема, у поточній версії усе працює майже як
слід, тому ми не дуже хочемо щось міняти.
.SS "Чому virt-sparcify не працює із образами дисків «на місці»?"
.IX Subsection "Чому virt-sparcify не працює із образами дисків «на місці»?"
У libguestfs ≥ 1.26 virt-sparsify може працювати над образами диска на
місці. Скористайтеся такою командою:
.PP
.Vb 1
\& virt\-sparsify \-\-in\-place disk.img
.Ve
.PP
Але спочатку вам слід ознайомитися із розділом
\&\*(L"РОЗРІДЖЕННЯ НА МІСЦІ\*(R" in \fBvirt\-sparsify\fR\|(1).
.SH "ПРОБЛЕМИ З ВІДКРИТТЯМ ОБРАЗІВ ДИСКІВ"
.IX Header "ПРОБЛЕМИ З ВІДКРИТТЯМ ОБРАЗІВ ДИСКІВ"
.SS "Неможливо відкрити віддалені гостьові системи libvirt."
.IX Subsection "Неможливо відкрити віддалені гостьові системи libvirt."
Підтримки відкриття віддалених гостьових систем libvirt у поточній версії не
передбачено. Наприклад, така команда не працюватиме:
.PP
.Vb 1
\& guestfish \-c qemu://remote/system \-d Guest
.Ve
.PP
Щоб відкрити віддалені диски, вам слід спочатку якось їх експортувати, а
потім з'єднатися із експортованими даними. Наприклад, якщо ви вирішили
скористатися \s-1NBD:\s0
.PP
.Vb 2
\& remote$ qemu\-nbd \-t \-p 10809 guest.img
\&  local$ guestfish \-a nbd://remote:10809 \-i
.Ve
.PP
Серед інших можливостей є використання ssh (якщо ви користуєтеся досить
свіжою версією qemu), \s-1NFS\s0 або iSCSI. Див. \*(L"ВІДДАЛЕНЕ СХОВИЩЕ\*(R" in \fBguestfs\fR\|(3).
.SS "Як відкрити якесь дивне дискове джерело?"
.IX Subsection "Як відкрити якесь дивне дискове джерело?"
Нехай у вас є образ диска, розташований у іншій системі, доступ до якої
потребує бібліотеки, \s-1HTTP, REST\s0 або пропрієтарного програмного інтерфейсу,
або такий образ, який стиснено або архівовано у певний спосіб. (Одним із
прикладів є віддалений доступ до образів glance OpenStack без початкового
отримання усіх даних таких образів.)
.PP
Ми створили дочірній проект із назвою nbdkit
(https://github.com/libguestfs/nbdkit). Цей проект надає вам змогу
перетворити будь\-яке дискове джерело у сервер \s-1NBD.\s0 Libguestfs може отримати
доступ до серверів \s-1NBD\s0 безпосередньо, приклад:
.PP
.Vb 1
\& guestfish \-a nbd://remote
.Ve
.PP
Умови ліцензування nbdkit є доволі ліберальними, тому ви можете компонувати
або включати цей програмний код до пропрієтарних бібліотек та програм. Крім
того, передбачено простий і стабільний програмний інтерфейс для
додатків. Отже, ви зможете без проблем писати додатки з цим програмним
інтерфейсом, які працюватимуть і з майбутніми версіями.
.SS "Повідомлення про помилку під час відкриття дисків \s-1VMDK:\s0 «uses a vmdk feature which is not supported by this qemu version: \s-1VMDK\s0 version 3»"
.IX Subsection "Повідомлення про помилку під час відкриття дисків VMDK: «uses a vmdk feature which is not supported by this qemu version: VMDK version 3»"
У qemu (а отже і у libguestfs) передбачено підтримку лише деяких образів
дисків \s-1VMDK.\s0 Інші не працюватимуть — буде показано лише це або подібне
повідомлення про помилку.
.PP
Було б чудово, якби хтось виправив qemu так, щоб було реалізовано найновіші
можливості \s-1VMDK,\s0 але, доки цього не сталося, у вас три варіанти дій:
.IP "1." 4
Якщо гостьова система працює на «живому», доступному сервері \s-1ESX,\s0 знайдіть і
отримайте образ диска із назвою
\&\fI\fIназва_гостьової_системи\fI\-flat.vmdk\fR. Незважаючи на назву, це образ диска
raw, який можна відкрити будь\-якою відповідною програмою.
.Sp
Якщо ви працюєте з доволі свіжою версією qemu і libguestfs, ви, ймовірно,
зможете отримати доступ до цього образу диска віддалено за допомогою \s-1HTTPS\s0
або ssh. Див. \*(L"ВІДДАЛЕНЕ СХОВИЩЕ\*(R" in \fBguestfs\fR\|(3).
.IP "2." 4
Скористайтеся пропрієтарним інструментом VMware vdiskmanager для
перетворення образу у формат raw.
.IP "3." 4
Скористайтеся nbdkit із пропрієтарним додатком \s-1VDDK\s0 для експортування
«вживу» образу диска як джерела \s-1NBD.\s0 Це дасть вам змогу прочитати дані файла
\&\s-1VMDK\s0 і записати до нього дані.
.SS "Не передбачено можливості відкриття дисків \s-1UFS\s0 (у форматі, що використовується \s-1BSD\s0)."
.IX Subsection "Не передбачено можливості відкриття дисків UFS (у форматі, що використовується BSD)."
У файлової системи \s-1UFS\s0 багато варіантів. Визначити варіант непросто. Ядру
Linux має бути повідомлено варіант \s-1UFS,\s0 який слід використати, а libguestfs
не зможе це зробити самостійно.
.PP
Під час монтування цих файлових систем слід передати правильне значення
параметра монтування \f(CW\*(C`ufstype\*(C'\fR.
.PP
Див. https://www.kernel.org/doc/Documentation/filesystems/ufs.txt
.SS "Windows ReFS"
.IX Subsection "Windows ReFS"
Windows ReFS є копією ZFS/Btrfs від Microsoft. Принципи роботи цієї файлової
системи ще не визначено шляхами зворотної інженерії і не реалізовано у ядрі
Linux, тому у libguestfs не передбачено її підтримки. На сьогодні, зустріти
цю файлову систему «наживо» доволі важко.
.SS "У файлових системах \s-1VFAT\s0 не видно символів поза \s-1ASCII.\s0"
.IX Subsection "У файлових системах VFAT не видно символів поза ASCII."
Типові симптоми проблеми:
.IP "\(bu" 4
Ви бачите повідомлення про помилку під час створення файла із назвою, яка
містить символи поза \s-1ASCII,\s0 зокрема не\-8\-бітові символи з азійських мов
(китайської, японської тощо). Файловою системою є \s-1VFAT.\s0
.IP "\(bu" 4
У каталогах файлової системи \s-1VFAT\s0 назви файлів показано знаками питання.
.PP
Це конструктивна проблема системи GNU/Linux.
.PP
\&\s-1VFAT\s0 зберігає довгі назви файлів у форматі набору символів \s-1UTF\-16.\s0 Коли
операційна система відкриває або повертає назви файлів, ядро Linux має
перетворити такий набір символів у певну форму рядка із 8\-бітових
символів. Очевидним вибором про цьому є \s-1UTF\-8,\s0 окрім тих випадків, коли
користувачі Linux примусово визначають локалі, відмінні від \s-1UTF\-8\s0 (локаль
користувача не є відомою ядру, оскільки її роботу забезпечує не ядро, а
libc).
.PP
Через це вам слід повідомити ядру, яке саме перетворення слід виконати під
час монтування файлової системи. Зробити це можна або за допомогою параметра
\&\f(CW\*(C`iocharset\*(C'\fR (у випадку із libguestfs цей спосіб не спрацює), або за
допомогою прапорця \f(CW\*(C`utf8\*(C'\fR.
.PP
Отже, щоб скористатися файловою системою \s-1VFAT,\s0 вам слід додати прапорець
\&\f(CW\*(C`utf8\*(C'\fR під час монтування. У guestfish скористайтеся таким кодом:
.PP
.Vb 1
\& ><fs> параметри_монтування utf8 /dev/sda1 /
.Ve
.PP
або у командному рядку guestfish:
.PP
.Vb 1
\& guestfish [...] \-m /dev/sda1:/:utf8
.Ve
.PP
або з програмного інтерфейсу:
.PP
.Vb 1
\& guestfs_mount_options (g, "utf8", "/dev/sda1", "/");
.Ve
.PP
Після цього ядро зможе належним чином перетворювати назви файлів у рядки
\&\s-1UTF\-8,\s0 і навпаки.
.PP
У нас були наміри додати цей параметр монтування у прозорий спосіб, але, на
жаль, з цим виникли певні проблеми:
.IP "\(bu" 4
У деяких системах Linux параметр монтування \f(CW\*(C`utf8\*(C'\fR не працює. Нам не відомі
точні критерії визначення таких систем та причини непрацездатності
параметра, але щодо цього є гідні довіри звіти від одного з наших
користувачів.
.IP "\(bu" 4
Це не дасть вам змоги скористатися параметром \f(CW\*(C`iocharset\*(C'\fR, оскільки він є
несумісним із \f(CW\*(C`utf8\*(C'\fR. Ймовірно, цим параметром не варто користуватися, але
ми не хочемо і забороняти його використання.
.SS "У файлових системах \s-1ISO9660\s0 символи, які не належать до символів \s-1ASCII,\s0 показуються як підкреслювання (_)."
.IX Subsection "У файлових системах ISO9660 символи, які не належать до символів ASCII, показуються як підкреслювання (_)."
Файлову систему не було належним чином приготовано за допомогою mkisofs або
genisoimage. Переконайтеся, що файлову систему було створено за допомогою
розширень Joliet і/або Rock Ridge. libguestfs не потрібні ніяких спеціальні
параметри монтування для роботи з файловою системою.
.SS "Не вдається відкрити гостьові системи Windows, у яких використовується \s-1NTFS.\s0"
.IX Subsection "Не вдається відкрити гостьові системи Windows, у яких використовується NTFS."
Ви бачите такі повідомлення про помилки:
.PP
.Vb 1
\& mount: unknown filesystem type \*(Aqntfs\*(Aq
.Ve
.PP
У Red Hat Enterprise Linux або CentOS < 7.2 вам слід встановити пакунок
libguestfs-winsupport.
У \s-1RHEL\s0 ≥ 7.2, \f(CW\*(C`libguestfs\-winsupport\*(C'\fR є частиною базового дистрибутива
\&\s-1RHEL,\s0 але є аспекти, описані у наступному питанні.
.SS "«mount: unsupported filesystem type» для \s-1NTFS\s0 у \s-1RHEL\s0 ≥ 7.2"
.IX Subsection "«mount: unsupported filesystem type» для NTFS у RHEL ≥ 7.2"
У \s-1RHEL 7.2\s0 нам вдалося додати \f(CW\*(C`libguestfs\-winsupport\*(C'\fR до базового
дистрибутива \s-1RHEL,\s0 але довелося вимкнути можливість використовувати програму
для відкриття та редагування файлових систем. Підтримку цих дій передбачено
лише у поєднанні із \fBvirt\-v2v\fR\|(1). Якщо ви спробуєте скористатися
\&\fBguestfish\fR\|(1),  \fBguestmount\fR\|(1) або деякими іншими програмами для
файлової системи \s-1NTFS,\s0 ви побачите таке повідомлення про помилку:
.PP
.Vb 1
\& mount: unsupported filesystem type
.Ve
.PP
Підтримки цієї конфігурації не передбачено, отже ніхто не працюватиме над
тим, щоб це запрацювало у \s-1RHEL.\s0 Вам не варто створювати повідомлень про
ваду, оскільки їх одразу буде закрито за критерієм \f(CW\*(C`CLOSED \-> WONTFIX\*(C'\fR.
.PP
Ви можете зібрати власну версію libguestfs без цього
обмеження,
але не очікуйте на схвалення або підтримку з боку Red Hat.
.SS "Не вдається відкрити або вивчити гостьові системи \s-1RHEL 7.\s0"
.IX Subsection "Не вдається відкрити або вивчити гостьові системи RHEL 7."
.SS "Не вдається відкрити гостьові системи Linux, де використовується \s-1XFS.\s0"
.IX Subsection "Не вдається відкрити гостьові системи Linux, де використовується XFS."
Гостьові системи \s-1RHEL 7\s0 та будь\-які інші гостьові системи, де
використовується \s-1XFS,\s0 можна відкрити у libguestfs, але вам слід встановити
пакунок \f(CW\*(C`libguestfs\-xfs\*(C'\fR.
.SH "ВИКОРИСТАННЯ LIBGUESTFS У ВАШИХ ВЛАСНИХ ПРОГРАМАХ"
.IX Header "ВИКОРИСТАННЯ LIBGUESTFS У ВАШИХ ВЛАСНИХ ПРОГРАМАХ"
.SS "У програмному інтерфейсі сотні методів, з чого почати?"
.IX Subsection "У програмному інтерфейсі сотні методів, з чого почати?"
Рекомендуємо вам розпочати з читання огляду програмного інтерфейсу:
\&\*(L"ОГЛЯД ПРОГРАМНОГО ІНТЕРФЕЙСУ\*(R" in \fBguestfs\fR\|(3).
.PP
Хоча огляд програмного інтерфейсу стосується програмного інтерфейсу мовою C,
все ж варто його прочитати, навіть якщо ви будете користуватися іншою мовою
програмування, оскільки програмний інтерфейс є тим самим, лише з простими
логічними змінами у назвах викликів:
.PP
.Vb 6
\&                  C  guestfs_ln_sf (g, target, linkname);
\&             Python  g.ln_sf (target, linkname);
\&              OCaml  g#ln_sf target linkname;
\&               Perl  $g\->ln_sf (target, linkname);
\&  Shell (guestfish)  ln\-sf target linkname
\&                PHP  guestfs_ln_sf ($g, $target, $linkname);
.Ve
.PP
Після ознайомлення із оглядом програмного інтерфейсу, вам слід вивчити ці
початкові настанови щодо прив'язки до інших мов програмування:
\&\*(L"ВИКОРИСТАННЯ \s-1LIBGUESTFS\s0 ЗА ДОПОМОГОЮ ІНШИХ МОВ ПРОГРАМУВАННЯ\*(R" in \fBguestfs\fR\|(3).
.SS "Чи можна використовувати libguestfs у пропрієтарній програмі, програмі із закритим кодом або комерційній програмі?"
.IX Subsection "Чи можна використовувати libguestfs у пропрієтарній програмі, програмі із закритим кодом або комерційній програмі?"
Загалом, так. Втім, ця порада не є порадою юриста. Ознайомтеся із умовами
ліцензування, які постачаються разом із libguestfs, і якщо у вас виникнуть
специфічні питання, зв'яжіться із правником.
.PP
У ієрархії початкового коду умови ліцензування викладено у файлах
\&\f(CW\*(C`COPYING.LIB\*(C'\fR (LGPLv2+ для бібліотеки і прив'язок) та \f(CW\*(C`COPYING\*(C'\fR (GPLv2+
для окремих програм).
.SH "ДІАГНОСТИКА LIBGUESTFS"
.IX Header "ДІАГНОСТИКА LIBGUESTFS"
.SS "Допоможіть, не працює!"
.IX Subsection "Допоможіть, не працює!"
Якщо не працює жодна із програм libguestfs, віддайте вказану нижче команду і
вставте виведений текст \fBповністю, без змін\fR до повідомлення на адресу
\&\f(CW\*(C`libguestfs\*(C'\fR @ \f(CW\*(C`redhat.com\*(C'\fR:
.PP
.Vb 1
\& libguestfs\-test\-tool
.Ve
.PP
Якщо не вдається виконати певну дію, надайте усі дані із наведеного нижче
списку у повідомлення на адресу \f(CW\*(C`libguestfs\*(C'\fR @ \f(CW\*(C`redhat.com\*(C'\fR:
.IP "1." 4
Що саме ви намагаєтеся зробити?
.IP "2." 4
Які саме команди було віддано вами?
.IP "3." 4
Як саме виглядало повідомлення про помилку або результат виконання ваших
команд?
.IP "4." 4
Увімкніть діагностику, віддайте команду ще раз і скопіюйте \fBусі\fR виведені
дані. \fBНе редагуйте виведені дані.\fR
.Sp
.Vb 2
\& export LIBGUESTFS_DEBUG=1
\& export LIBGUESTFS_TRACE=1
.Ve
.IP "5." 4
Вкажіть версію libguestfs, версію операційної системи та спосіб встановлення
libguestfs (наприклад, з початкового коду (from source), \f(CW\*(C`yum install\*(C'\fR
тощо)
.SS "Як виконати діагностику роботи програми або інструмента libguestfs (наприклад virt\-v2v або virt-df)?"
.IX Subsection "Як виконати діагностику роботи програми або інструмента libguestfs (наприклад virt-v2v або virt-df)?"
Передбачено дві змінні середовища \f(CW\*(C`LIBGUESTFS_*\*(C'\fR, якими ви можете
скористатися для отримання додаткових відомостей від libguestfs.
.ie n .IP """LIBGUESTFS_TRACE""" 4
.el .IP "\f(CWLIBGUESTFS_TRACE\fR" 4
.IX Item "LIBGUESTFS_TRACE"
Встановіть для цієї змінної значення 1, і libguestfs виводитиме кожну
команду і виклик програмного інтерфейсу у форматі, який подібний до команд
guestfish.
.ie n .IP """LIBGUESTFS_DEBUG""" 4
.el .IP "\f(CWLIBGUESTFS_DEBUG\fR" 4
.IX Item "LIBGUESTFS_DEBUG"
Встановіть для цієї змінної значення 1, щоб увімкнути значний масив
діагностичних повідомлень. Якщо ви вважаєте, що причина проблеми ховається у
базовій системі libguestfs, вам слід скористатися цим варіантом.
.PP
Щоб встановити ці змінні із командної оболонки, віддайте такі команди до
запуску програми:
.PP
.Vb 2
\& export LIBGUESTFS_TRACE=1
\& export LIBGUESTFS_DEBUG=1
.Ve
.PP
Для csh/tcsh еквівалентними командами будуть такі:
.PP
.Vb 2
\& setenv LIBGUESTFS_TRACE 1
\& setenv LIBGUESTFS_DEBUG 1
.Ve
.PP
Докладніші дані можна знайти на сторінці \*(L"ЗМІННІ СЕРЕДОВИЩА\*(R" in \fBguestfs\fR\|(3)
.SS "Як виконувати діагностику за допомогою guestfish?"
.IX Subsection "Як виконувати діагностику за допомогою guestfish?"
Можна скористатися описаними вище змінними середовища. Крім того, ви можете
скористатися параметрами guestfish \-x (для трасування команд) та \-v (для
отримання повної діагностичної інформації).
.PP
Докладніші дані можна знайти на сторінці \fBguestfish\fR\|(1).
.SS "Як виконувати діагностику за допомогою програмного інтерфейсу?"
.IX Subsection "Як виконувати діагностику за допомогою програмного інтерфейсу?"
Викличте \*(L"guestfs_set_trace\*(R" in \fBguestfs\fR\|(3), щоб увімкнути трасування команд
і/або \*(L"guestfs_set_verbose\*(R" in \fBguestfs\fR\|(3), щоб увімкнути діагностичні
повідомлення.
.PP
Щоб отримати якнайкращі результати, викликайте ці функції якомога раніше,
одразу після створення дескриптора guestfs, точно до виклику launch.
.SS "Як перехопити діагностичні повідомлення і спрямувати їх до системи ведення журналу?"
.IX Subsection "Як перехопити діагностичні повідомлення і спрямувати їх до системи ведення журналу?"
Скористайтеся програмним інтерфейсом подій. Приклади можна знайти у розділі
\&\*(L"ВСТАНОВЛЕННЯ ЗВОРОТНИХ ВИКЛИКІВ ДЛЯ ОБРОБКИ ПОДІЙ\*(R" in \fBguestfs\fR\|(3) та програмі
\&\fIexamples/debug\-logging.c\fR у початковому коді libguestfs.
.SS "Занурення глибше до процесу завантаження базової системи."
.IX Subsection "Занурення глибше до процесу завантаження базової системи."
Увімкніть діагностику, а потім ознайомтеся із цією документацією щодо
процесу завантаження базової системи: \fBguestfs\-internals\fR\|(1).
.SS "libguestfs повисає або повідомляє про помилку під час запуску."
.IX Subsection "libguestfs повисає або повідомляє про помилку під час запуску."
Увімкніть діагностику і ознайомтеся із повними виведеними даними. Якщо вам
не вдається визначити причину, повідомте про ваду, додавши виведені
\&\fBlibguestfs\-test\-tool\fR\|(1) дані \fIповністю\fR.
.SS "Діагностування libvirt"
.IX Subsection "Діагностування libvirt"
Якщо ви користуєтеся модулем libvirt, а libvirt не працює, ви можете
увімкнути діагностику редагуванням \fI/etc/libvirt/libvirtd.conf\fR.
.PP
Якщо ви запускаєте програму не від імені користувача root, вам слід внести
зміни до іншого файла. Створіть \fI~/.config/libvirt/libvirtd.conf\fR з таким
вмістом:
.PP
.Vb 2
\& log_level=1
\& log_outputs="1:file:/tmp/libvirtd.log"
.Ve
.PP
Припиніть роботу усіх libvirtd (запущених не від імені root) у сеансі, і під
час наступного виконання команди libguestfs ви маєте побачити багато
корисних діагностичних відомостей від libvirtd у \fI/tmp/libvirtd.log\fR
.SS "Помилки у ядрі або як спробувати інше ядро."
.IX Subsection "Помилки у ядрі або як спробувати інше ядро."
Ви можете вибрати інше ядро для базової системи встановленням певних
змінних середовища supermin:
.PP
.Vb 5
\& export SUPERMIN_KERNEL_VERSION=4.8.0\-1.fc25.x86_64
\& export SUPERMIN_KERNEL=/boot/vmlinuz\-$SUPERMIN_KERNEL_VERSION
\& export SUPERMIN_MODULES=/lib/modules/$SUPERMIN_KERNEL_VERSION
\& rm \-rf /var/tmp/.guestfs\-*
\& libguestfs\-test\-tool
.Ve
.SS "Помилки у qemu або як спробувати іншу qemu."
.IX Subsection "Помилки у qemu або як спробувати іншу qemu."
Ви можете вибрати іншу qemu встановленням змінної
середовища гіпервізору:
.PP
.Vb 2
\& export LIBGUESTFS_HV=/шлях/до/qemu\-system\-x86_64
\& libguestfs\-test\-tool
.Ve
.SH "ДИЗАЙН/ВНУТРІШНЯ БУДОВА LIBGUESTFS"
.IX Header "ДИЗАЙН/ВНУТРІШНЯ БУДОВА LIBGUESTFS"
Див. також \fBguestfs\-internals\fR\|(1).
.SS "Чому б не виконувати усі дії за допомогою інтерфейсу \s-1FUSE\s0 або файлової системи?"
.IX Subsection "Чому б не виконувати усі дії за допомогою інтерфейсу FUSE або файлової системи?"
Нами створено програму із назвою \fBguestmount\fR\|(1), за допомогою якої ви
можете монтувати файлові системи гостьових систем у основній
системі. Програму реалізовано як модуль \s-1FUSE.\s0 Чому ж ми не реалізували усю
libguestfs з використанням цього механізму, замість створення великого і
доволі складного програмного інтерфейсу?
.PP
Причини дві. По\-перше, libguestfs надає змогу виконувати запити до
програмного інтерфейсу з метою створення та вилучення розділів і логічних
томів, що не вкладається у просту модель файлової системи. Звичайно ж, можна
уявити це і як роботу із файловою системою. Наприклад, створення розділу
можна пов'язати із \f(CW\*(C`mkdir /fs/hda1\*(C'\fR, але тоді доведеться вказувати метод
вибору розміру розділу (наприклад, \f(CW\*(C`echo 100M > /fs/hda1/.size\*(C'\fR), типу
розділу, початкового і кінцевого секторів тощо. Але якщо усе це реалізувати
програмний інтерфейс на основі файлової системи стає складнішим за
програмний інтерфейс на основі викликів, який зараз має бібліотека.
.PP
Другою причиною є ефективність. Сама \s-1FUSE\s0 є доволі ефективною, але вона
виконує багато незначних незалежних викликів модуля \s-1FUSE.\s0 У guestmount ці
виклики доводиться переводити у повідомлення для базової системи libguestfs
і втрачати на цьому багато часу (у сенсі навантаження на систему і циклів
обробки). Наприклад, читання 64\-кілобайтових фрагментів файла є
неефективним, оскільки кожен фрагмент дає власний цикл обробки.  У
програмному інтерфейсі libguestfs набагато ефективнішим є отримання усього
файла або каталогу за допомогою одного з потокових викликів, подібних до
\&\f(CW\*(C`guestfs_download\*(C'\fR або \f(CW\*(C`guestfs_tar_out\*(C'\fR.
.SS "Чому б не виконувати усі дії за допомогою \s-1GVFS\s0?"
.IX Subsection "Чому б не виконувати усі дії за допомогою GVFS?"
Проблеми такого варіанта подібні до проблем із \s-1FUSE.\s0
.PP
\&\s-1GVFS\s0 є кращою абстракцією за \s-1POSIX/FUSE.\s0 Існує модуль \s-1FTP\s0 для \s-1GVFS,\s0 що має
надихати, оскільки \s-1FTP\s0 концептуально подібна до програмного інтерфейсу
libguestfs. Втім, модуль \s-1FTP GVFS\s0 для підтримання інтерактивності встановлює
одразу декілька одночасних з'єднань, що непросто реалізувати у libguestfs.
.SS "Чому у мене лишається можливість запису на диск, навіть якщо його позначено як придатний лише для читання?"
.IX Subsection "Чому у мене лишається можливість запису на диск, навіть якщо його позначено як придатний лише для читання?"
.ie n .SS "Чому використання ""\-\-ro"" не дає бажаних наслідків?"
.el .SS "Чому використання \f(CW\-\-ro\fP не дає бажаних наслідків?"
.IX Subsection "Чому використання --ro не дає бажаних наслідків?"
Коли ви додаєте диск як придатний лише для читання, libguestfs розташовує на
основі підлеглого диска придатну для запису накладку. Записувані дані
потрапляють до цієї накладки і відкидаються, коли закривається дескриптор
(або завершує роботу програма \f(CW\*(C`guestfish\*(C'\fR або подібна).
.PP
Причин у такому стилі роботи є дві: по\-перше, у багатьох випадках створення
дисків, які придатні лише для читання, неможливе (наприклад, у \s-1IDE\s0 взагалі
не передбачено підтримки таких дисків, отже, ви не можете створити придатний
лише для читання диск із емуляцією \s-1IDE,\s0 хоча створення таких дисків і не є
типовим у встановлених екземплярах libguestfs).
.PP
По\-друге, і важливіше, навіть якщо створення придатних лише для читання
дисків можливе, вам вони просто не знадобляться. Монтування будь\-якої
файлової системи із журналом, навіть за допомогою команди \f(CW\*(C`mount \-o ro\*(C'\fR,
призводить до запису до файлової системи, оскільки має бути відтворено
журнал і оновлено метадані. Якщо б диск був насправді захищеним від запису,
ви б не змогли змонтувати файлову систему у стані незавершеного запису.
.PP
Щоб такими файловими системами можна було користуватися, ми створили
накладку, як місце для запису даних, які згодом буде відкинуто. Це
забезпечує недоторканність підлеглого диска.
.PP
Слід зауважити, що для цього передбачено особливий тест на регресії під час
збирання libguestfs (у \f(CW\*(C`tests/qemu\*(C'\fR). Це одна з причин, з яких ми
рекомендуємо пакувальникам вмикати комплекс перевірок під час збирання
пакунків.
.ie n .SS "Чи робить ""\-\-ro"" усі диски придатними лише для читання?"
.el .SS "Чи робить \f(CW\-\-ro\fP усі диски придатними лише для читання?"
.IX Subsection "Чи робить --ro усі диски придатними лише для читання?"
\&\fIНі!\fR Параметр \f(CW\*(C`\-\-ro\*(C'\fR стосується лише дисків, які додано за допомогою
командного рядка, тобто за допомогою параметрів \f(CW\*(C`\-a\*(C'\fR та \f(CW\*(C`\-d\*(C'\fR.
.PP
У guestfish, якщо ви використовуєте команду \f(CW\*(C`add\*(C'\fR, диск додається у режимі
читання і запису (якщо ви не вкажете прапорець \f(CW\*(C`readonly:true\*(C'\fR явним чином
у команді).
.ie n .SS "Чи можна скористатися ""guestfish \-\-ro"" для резервного копіювання моїх віртуальних машин?"
.el .SS "Чи можна скористатися \f(CWguestfish \-\-ro\fP для резервного копіювання моїх віртуальних машин?"
.IX Subsection "Чи можна скористатися guestfish --ro для резервного копіювання моїх віртуальних машин?"
Зазвичай, \fIне варто\fR цього роботи. Докладнішу відповідь на це питання можна
знайти у цьому повідомленні зі списку листування:
https://www.redhat.com/archives/libguestfs/2010\-August/msg00024.html
.PP
Див. також наступне питання.
.ie n .SS "Чому не можна запускати fsck для робочої файлової системи, де використано ""guestfish \-\-ro""?"
.el .SS "Чому не можна запускати fsck для робочої файлової системи, де використано \f(CWguestfish \-\-ro\fP?"
.IX Subsection "Чому не можна запускати fsck для робочої файлової системи, де використано guestfish --ro?"
Така команда, зазвичай, \fIне працює\fR:
.PP
.Vb 1
\& guestfish \-\-ro \-a /dev/vg/my_root_fs run : fsck /dev/sda
.Ve
.PP
Причиною є те, що qemu створює знімок початкової файлової системи, але не
створює цей знімок із точною прив'язкою до часу. Блоки даних підлеглої
файлової системи читаються qemu у різні моменти часу під час обробки
файлової системи за допомогою fsck, а основна система у цей час може
записувати дані. У результаті fsck виявить значні пошкодження (уявні, не
справжні!) у файловій системі і завершить роботу із повідомленням про
помилку.
.PP
Щоб досягти бажаного результату, вам слід створити прив'язаний до часу
знімок. Якщо маєте справу із логічним томом, скористайтеся знімком
\&\s-1LVM2.\s0 Якщо файлову систему розташовано у чомусь подібному до файла
btrfs/ZFS, скористайтеся знімком btrfs/ZFS, а потім запустіть fsck для
перевірки знімка. На практиці, для виконання цього завдання libguestfs не
потрібна — просто скористайтеся \fI/sbin/fsck\fR безпосередньо.
.PP
Створення прив'язаних до часу знімків пристроїв і файлів основної системи не
виконується засобами libguestfs, хоча libguestfs може працювати із такими
знімками, коли їх буде створено.
.SS "Чим відрізняються guestfish і virt-rescue?"
.IX Subsection "Чим відрізняються guestfish і virt-rescue?"
Для багато кого є незрозумілим включення нами двох з першого погляду
подібних інструментів до бібліотеки:
.PP
.Vb 3
\& $ guestfish \-\-ro \-a guest.img
\& ><fs> run
\& ><fs> fsck /dev/sda1
\&
\& $ virt\-rescue \-\-ro guest.img
\& ><rescue> /sbin/fsck /dev/sda1
.Ve
.PP
А ще одним пов'язаним питанням, яке тоді виникає, є питання того, чому у
guestfish не можна вводити команди оболонки повністю з усіма параметрами з
мінусами (але це можна робити у \fBvirt\-rescue\fR\|(1)).
.PP
\&\fBguestfish\fR\|(1) — програма, яка надає структурований доступ до програмного
інтерфейсу \fBguestfs\fR\|(3). Також це непогана інтерактивна командна оболонка,
але основним її призначенням є структурований доступ до скриптів командної
оболонки. Її можна вважати скоріше прив'язкою до мов програмування, зокрема
Python, та інших прив'язок, але для оболонки. Ключовим фактором
диференціювання guestfish (і програмного інтерфейсу libguestfs загалом) є
можливість автоматизації змін.
.PP
\&\fBvirt\-rescue\fR\|(1) — гнучкий спосіб завантажити базову систему libguestfs і
внести довільні зміни до вашої віртуальної машини. Його не структуровано, ви
не можете автоматизувати його використання, але для швидкого ситуаційного
внесення виправлень до ваших гостьових систем ця програма може бути дуже
зручною.
.PP
Але у libguestfs також є і «чорний вхід» до базової системи, який надає вам
змогу надсилати довільні команди до командної оболонки. Він не є настільки
гнучким як virt-rescue, оскільки ви не можете взаємодіяти із командами
оболонки. Втім, ось він:
.PP
.Vb 1
\& ><fs> debug sh "команда аргумент1 аргумент2 ..."
.Ve
.PP
Зауважте, що на цей спосіб \fBне слід\fR покладатися. Відповідні засоби може
бути вилучено або змінено у майбутньому. Якщо у вашій програмі потрібна
певна операція, будь ласка, додайте її до програмного інтерфейсу libguestfs.
.ie n .SS "Для чого призначено ""guestfish \-i""?"
.el .SS "Для чого призначено \f(CWguestfish \-i\fP?"
.IX Subsection "Для чого призначено guestfish -i?"
.SS "Чому virt-cat працює лише для справжнього образу віртуальної машини, а virt-df працює для будь\-якого образу диска?"
.IX Subsection "Чому virt-cat працює лише для справжнього образу віртуальної машини, а virt-df працює для будь-якого образу диска?"
.SS "Що означає повідомлення «у цьому образі операційної системи не знайдено кореневого пристрою»?"
.IX Subsection "Що означає повідомлення «у цьому образі операційної системи не знайдено кореневого пристрою»?"
Усі ці питання пов'язано на базовому рівні, хоча це спочатку здається
неочевидним.
.PP
На рівні програмного інтерфейсу \fBguestfs\fR\|(3) «образ диска» це просто купа
розділів і файлових систем.
.PP
У протилежність, коли завантажується віртуальна машина, вона монтує файлові
системи у послідовну ієрархію, ось так:
.PP
.Vb 9
\& /          (/dev/sda2)
\& │
\& ├── /boot  (/dev/sda1)
\& │
\& ├── /home  (/dev/vg_external/Homes)
\& │
\& ├── /usr   (/dev/vg_os/lv_usr)
\& │
\& └── /var   (/dev/vg_os/lv_var)
.Ve
.PP
(або літери дисків у Windows).
.PP
Перш за все, програмний інтерфейс бачить образ диска на рівні «купи файлових
систем». Але у програмному інтерфейсі також передбачено способи
інспектування образу диска для визначення, чи міститься на ньому операційна
система, та того, як монтуються диски, коли завантажується операційна
система: \*(L"ІНСПЕКЦІЯ\*(R" in \fBguestfs\fR\|(3).
.PP
Користувачі очікують працездатності деяких інструментів (зокрема
\&\fBvirt\-cat\fR\|(1)) для шляхів у ВМ:
.PP
.Vb 1
\& virt\-cat fedora.img /var/log/messages
.Ve
.PP
Як virt-cat дізнається про те, що \fI/var\fR є окремим розділом? Справа полягає
у тому, що virt-cat виконує інспекцію образу диска і використовує отримані
дані для правильної трансляції шляху.
.PP
Деякі з інструментів (зокрема \fBvirt\-cat\fR\|(1), \fBvirt\-edit\fR\|(1),
\&\fBvirt\-ls\fR\|(1)) використовують інспекцію для визначення шляхів у віртуальній
машині. Інші інструменти, зокрема \fBvirt\-df\fR\|(1) і \fBvirt\-filesystems\fR\|(1),
працюють лише на рівні необробленої «великої купи файлових систем»
програмного інтерфейсу libguestfs і не використовують інспекцію.
.PP
\&\fBguestfish\fR\|(1) є цікавим проміжним варіантом. Якщо ви використовуєте
параметри командного рядка \fI\-a\fR та \fI\-m\fR, вам доведеться повідомити
guestfish точно, як додавати образи дисків і куди слід монтувати розділи. Це
рівень програмного інтерфейсу без додаткової обробки.
.PP
Якщо ви використовуєте параметр \fI\-i\fR, libguestfs виконує інспектування та
монтує файлові системи.
.PP
Повідомлення про помилку \f(CW\*(C`у цьому образі операційної системи не знайдено
кореневого пристрою\*(C'\fR пов'язано із цим. Воно означає, що під час інспекції не
удалося виявити операційну систему на вказаному образі диска. Ви можете
побачити таке повідомлення від програм, подібних до virt-cat, якщо ви
скористаєтеся ними для дослідження образу диска, який не є образом диска
віртуальної машини.
.ie n .SS "Яке завдання виконують функції ""debug*"" і ""internal\-*""?"
.el .SS "Яке завдання виконують функції \f(CWdebug*\fP і \f(CWinternal\-*\fP?"
.IX Subsection "Яке завдання виконують функції debug* і internal-*?"
У бібліотеці існує декілька функцій, які використовуються для діагностування
та внутрішньої обробки даних. Ці функції \fIне\fR є частиною стабільного
програмного інтерфейсу.
.PP
Функції \f(CW\*(C`debug*\*(C'\fR (або \f(CW\*(C`guestfs_debug*\*(C'\fR), головним чином
\&\*(L"guestfs_debug\*(R" in \fBguestfs\fR\|(3) та декілька інших, використовуються для
діагностики помилок у libguestfs. Хоча вони і не є частиною стабільного
програмного інтерфейсу, а отже, їх може бути будь\-коли вилучено, їх можна
використовувати у програмах, доки певні можливості буде додано до
libguestfs.
.PP
Функції \f(CW\*(C`internal\-*\*(C'\fR (або \f(CW\*(C`guestfs_internal_*\*(C'\fR) призначено для
використання лише у libguestfs. Немає сенсу викликати ці функції з програм,
їх також не слід використовувати у програмах. Зрідка, використання цих
функцій може призвести до небажаних наслідків, окрім того, вони не є
частиною документованого стабільного програмного інтерфейсу.
.SH "РОЗРОБНИКАМ"
.IX Header "РОЗРОБНИКАМ"
.SS "Куди слід надсилати латки?"
.IX Subsection "Куди слід надсилати латки?"
Будь ласка, надсилайте латки до списку листування libguestfs,
https://www.redhat.com/mailman/listinfo/libguestfs. Підписуватися на
список не обов'язково, але для непідписаних користувачів розповсюдження
відбувається лише після підтвердження повідомлення вручну кимось із
адміністраторів.
.PP
\&\fBБудь ласка, не використовуйте запити щодо об'єднання на github — ці запити
буде проігноровано\fR. Причинами цього є: (а) ми хочемо обговорювати і
розбирати латки у списку листування, і (б) запити щодо об'єднання github
перетворюються у внески із об'єднанням, а ми хочемо зберігати у сховищі
лінійну історію.
.SS "Як запропонувати нову можливість?"
.IX Subsection "Як запропонувати нову можливість?"
Значні нові можливості, розробку яких ви маєте намір здійснити, має бути
спочатку обговорено у списку листування
(https://www.redhat.com/mailman/listinfo/libguestfs). Так ви можете
уникнути прикростей і заощадити час, якщо раптом виявиться, що інші
розробники вважають можливість такою, яка не відповідає меті проекту
libguestfs.
.PP
Якщо ви хочете запропонувати корисну можливість, але не хочете писати код
для її реалізації, ви можете створити повідомлення про ваду
(див. \*(L"ОТРИМАННЯ ДОВІДКОВОЇ ІНФОРМАЦІЇ ТА ЗВІТУВАННЯ ПРО ВАДИ\*(R") із
додаванням \f(CW"RFE: "\fR на початку рядка резюме (Summary).
.SS "Хто має право записувати внески до git libguestfs?"
.IX Subsection "Хто має право записувати внески до git libguestfs?"
Доступ на запис до сховища на github має близько 5 осіб. Латки має бути
спочатку надіслано до списку листування і схвалено учасниками. Правила
схвалення та запису латок окреслено нижче:
.PP
https://www.redhat.com/archives/libguestfs/2012\-January/msg00023.html
.SS "Можна мені створити відгалуження libguestfs?"
.IX Subsection "Можна мені створити відгалуження libguestfs?"
Звичайно ж, ви можете. Git спрощує створення відгалужень libguestfs. Github
робить цю процедуру ще простішою. Було б добре також оголосити про
відгалуження у списку листування та повідомити про причини його створення.
.SH "ІНШІ ПИТАННЯ"
.IX Header "ІНШІ ПИТАННЯ"
.SS "Чи можна інтерактивно стежити за роботою диска у віртуальній машині за допомогою libguestfs?"
.IX Subsection "Чи можна інтерактивно стежити за роботою диска у віртуальній машині за допомогою libguestfs?"
Типовим запитом є реалізація у libguestfs можливості інтерактивного стеження
за діями з диском у гостьовій системі, наприклад, отримання сповіщення
кожного разу, коли у гостьовій системі створюється файл. Libguestfs \fIне
працює\fR так, як дехто собі уявляє. Це можна бачити на наведеній нижче
діаграмі:
.PP
.Vb 10
\&            ┌─────────────────────────────────────┐
\&            │ програма для спостереження за допомогою libguestfs │
\&            └─────────────────────────────────────┘
\&                             ↓
\& ┌───────────┐    ┌──────────────────────┐
\& │ жива ВМ   │    │ базова система libguestfs │
\& ├───────────┤    ├──────────────────────┤
\& │ ядро (1)│    │ ядро базової системи (2) │
\& └───────────┘    └──────────────────────┘
\&      ↓                      ↓ (з\*(Aqєднання для читання)
\&      ┌──────────────────────┐
\&      |      образ диска      |
\&      └──────────────────────┘
.Ve
.PP
Цей сценарій є безпечним (якщо під час додавання диска було встановлено
прапорець \f(CW\*(C`лише читання\*(C'\fR). Втім, тоді ядро базової системи libguestfs (2)
не бачитиме усі зміни, які відбулися у образі диска, з двох причин:
.IP "i." 4
.IX Item "i."
Ядро віртуальної машини (1) може кешувати дані у пам'яті, щоб кеш не
записувався на образ диска.
.IP "ii." 4
.IX Item "ii."
Ядро базової системи libguestfs (2) не очікує на зміни у образі диска, тому
його власний кеш не буде магічним чином оновлено, навіть коли ядро
віртуальної машини (1) оновлює образ диска.
.PP
Єдиним підтримуваним рішенням є перезапуск усієї базової системи libguestfs
кожного разу, коли вам потрібно переглянути зміни у образі диска. На рівні
програмного інтерфейсу це відповідає виклику \f(CW\*(C`guestfs_shutdown\*(C'\fR з наступним
викликом \f(CW\*(C`guestfs_launch\*(C'\fR, що є доволі вартісною операцією (див. також
\&\fBguestfs\-performance\fR\|(3)).
.PP
Існує декілька «брудних» прийомів, якими ви можете скористатися, якщо
перезапуск базової системи є дійсно дуже вартісною справою:
.IP "\(bu" 4
Виклик \f(CW\*(C`guestfs_drop_caches (g, 3)\*(C'\fR. Такий виклик призводить до того, що
усі кешовані дані ядра базової системи libguestfs (2) буде відкинуто, отже
йому доведеться користуватися образом диска.
.Sp
Втім, лише цього недостатньо, оскільки qemu також кешує деякі дані. Вам
також доведеться латати libguestfs, щоб увімкнути режим
\&\f(CW\*(C`cache=none\*(C'\fR.
Див.
https://rwmj.wordpress.com/2013/09/02/new\-in\-libguestfs\-allow\-cache\-mode\-to\-be\-selected/
.IP "\(bu" 4
Замість цього, вам варто скористатися інструментами, подібними до
virt-bmap.
.IP "\(bu" 4
Запуск агента у гостьовій системі.
.PP
Нічого не поможе, якщо у гостьовій системі виконуються фундаментальніші
зміни (наприклад, вилучаються файлові системи). Для фіксації таких змін вам
доведеться перезапускати базову систему.
.PP
(Зауважте, що існує і третя проблема: вам доведеться користуватися
послідовними знімками для справжнього вивчення образів дисків, але це
загальна проблема використання libguestfs для роботи з будь\-яким «живим»
образом диска.)
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fBguestfish\fR\|(1), \fBguestfs\fR\|(3), http://libguestfs.org/.
.SH "АВТОРИ"
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
Copyright (C) 2012\-2019 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fBlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
