.\" Automatically generated by Podwrapper::Man 1.40.2 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "guestfs 3"
.TH guestfs 3 "2019-02-07" "libguestfs-1.40.2" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
guestfs — бібліотека для доступу та внесення змін до образів віртуальних
машин
.SH "КОРОТКИЙ ОПИС"
.IX Header "КОРОТКИЙ ОПИС"
.Vb 1
\& #include <guestfs.h>
\& 
\& guestfs_h *g = guestfs_create ();
\& guestfs_add_drive (g, "guest.img");
\& guestfs_launch (g);
\& guestfs_mount (g, "/dev/sda1", "/");
\& guestfs_touch (g, "/hello");
\& guestfs_umount (g, "/");
\& guestfs_shutdown (g);
\& guestfs_close (g);
\&
\& cc prog.c \-o prog \-lguestfs
\&або:
\& cc prog.c \-o prog \`pkg\-config libguestfs \-\-cflags \-\-libs\`
.Ve
.SH "ОПИС"
.IX Header "ОПИС"
Libguestfs є бібліотекою для доступу до образів дисків та віртуальних машин
і внесення зміни до них.
.PP
Цю сторінку підручника присвячено документації щодо програмного інтерфейсу
мовою програмування C.
.PP
Якщо вам потрібна якась вступна інформація щодо libguestfs, зверніться до
цього сайта: http://libguestfs.org/
.PP
У кожного інструмента віртуалізації є власна сторінка підручника (повний
список наведено у розділі \*(L"ДИВ. ТАКОЖ\*(R" наприкінці цього файла).
.PP
Інші сторінки підручника, які присвячено libguestfs:
.IP "\fBguestfs\-faq\fR\|(1)" 4
.IX Item "guestfs-faq"
Поширені питання (ЧаП).
.IP "\fBguestfs\-examples\fR\|(3)" 4
.IX Item "guestfs-examples"
Приклади використання програмного інтерфейсу з C. Приклади іншими мовами
програмування можна знайти у розділі \*(L"ВИКОРИСТАННЯ \s-1LIBGUESTFS\s0 ЗА ДОПОМОГОЮ
ІНШИХ МОВ ПРОГРАМУВАННЯ\*(R" нижче.
.IP "\fBguestfs\-recipes\fR\|(1)" 4
.IX Item "guestfs-recipes"
Підказки і рецепти.
.IP "\fBguestfs\-performance\fR\|(1)" 4
.IX Item "guestfs-performance"
Настанови та рішення, які пов’язано із швидкодією.
.IP "\fBlibguestfs\-test\-tool\fR\|(1)" 4
.IX Item "libguestfs-test-tool"
.PD 0
.IP "\fBguestfs\-testing\fR\|(1)" 4
.IX Item "guestfs-testing"
.PD
Допомога у тестуванні libguestfs.
.IP "\fBguestfs\-building\fR\|(1)" 4
.IX Item "guestfs-building"
Настанови щодо збирання libguestfs з початкових кодів.
.IP "\fBguestfs\-hacking\fR\|(1)" 4
.IX Item "guestfs-hacking"
Надсилання коду до libguestfs.
.IP "\fBguestfs\-internals\fR\|(1)" 4
.IX Item "guestfs-internals"
Опис принципів роботи libguestfs.
.IP "\fBguestfs\-security\fR\|(1)" 4
.IX Item "guestfs-security"
Дані щодо безпеки, зокрема список \s-1CVE,\s0 пов’язаних із libguestfs.
.SH "ОГЛЯД API"
.IX Header "ОГЛЯД API"
У цьому розділі наведено поверхневий огляд програмного інтерфейсу
libguestfs. Ми також намагалися згрупувати виклики програмного інтерфейсу,
де це не очевидно з матеріалів щодо окремих викликів у основному розділі
цього підручника.
.SS "ОБРОБНИКИ"
.IX Subsection "ОБРОБНИКИ"
Перш ніж ви зможете скористатися викликами libguestfs, вам слід створити
дескриптор. Далі, вам слід додати до дескриптора принаймні один образ диска,
потім запустити дескриптор, далі виконати потрібні вам дії і, нарешті,
закрити дескриптор. За угодою щодо синтаксису ми використовуємо одну літеру
\&\f(CW\*(C`g\*(C'\fR для іменування змінної дескриптора, хоча, звичайно ж, ви можете вибрати
будь\-яку іншу назву.
.PP
Загальна структуру усіх програм, де використовується libguestfs, є подібною
до такої:
.PP
.Vb 1
\& guestfs_h *g = guestfs_create ();
\& 
\& /* Викликаємо guestfs_add_drive додаткові рази, якщо
\&  * образів дисків декілька.
\&  */
\& guestfs_add_drive (g, "guest.img");
\& 
\& /* Більшість викликів з обробки не працюватимуть, доки ви
\&  * не запустите дескриптор «g». Вам слід зробити це _після_ додавання
\&  * дисків і _до_ інших команд.
\&  */
\& guestfs_launch (g);
\& 
\& /* Або визначити розділи, логічні томи тощо, які є доступними: */
\& char **partitions = guestfs_list_partitions (g);
\& char **logvols = guestfs_lvs (g);
\& 
\& /* Або наказати libguestfs знайти для вас файлові системи: */
\& char **filesystems = guestfs_list_filesystems (g);
\& 
\& /* Або скористатися інспекцією (див. розділ щодо інспекції нижче). */
\& 
\& /* Щоб отримати доступ до файлової системи у образі, вам слід її змонтувати. */
\& guestfs_mount (g, "/dev/sda1", "/");
\& 
\& /* Тепер ви можете виконувати дії з файловою системою на
\&  * образі диска операційної системи.
\&  */
\& guestfs_touch (g, "/hello");
\& 
\& /* Синхронізуємо диск. Це дія, протилежна до guestfs_launch. */
\& guestfs_shutdown (g);
\& 
\& /* Закрити і звільнити дескриптор «g». */
\& guestfs_close (g);
.Ve
.PP
До наведеного вище коду не включено обробник помилок. У справжньому коді
слід ретельно перевіряти повернуті значення на помилки. Загалом, усі
функції, які повертають цілі числа, повертають \f(CW\*(C`\-1\*(C'\fR, якщо станеться
помилка, а усі функції, які повертають вказівники, якщо станеться помилка,
повертають \f(CW\*(C`NULL\*(C'\fR. Див. розділ \*(L"ОБРОБКА ПОМИЛОК\*(R" нижче, щоб дізнатися про
те, як обробляти помилки. Також ознайомтеся із документацією щодо кожного
виклику функції, щоб дізнатися більше про те, як функції повідомляють про
помилки.
.PP
У наведеному вище коді не виконується \fBfree\fR\|(3) для рядків та масивів, які
повертаються функціями. Зверніться до документації з відповідної функції,
щоб дізнатися більше про те, як звільнити повернуте значення.
.PP
Повноцінні робочі приклади можна знайти у підручнику \fBguestfs\-examples\fR\|(3).
.SS "ОБРАЗИ ДИСКІВ"
.IX Subsection "ОБРАЗИ ДИСКІВ"
Назва файла образу (\f(CW"guest.img"\fR у наведеному вище прикладі) може бути
назвою образу диска з віртуальної машини, створеної за допомогою \fBdd\fR\|(1)
копії фізичного диска, справжнього блокового пристрою або просто назвою
порожнього файла, заповненого нулями, який можна створити за допомогою
\&\fBposix_fallocate\fR\|(3). Libguestfs надає вам змогу виконувати корисні
операції із усіма такими образами.
.PP
Викликом, яким вам слід користуватися у сучасному коді для додавання дисків,
є \*(L"guestfs_add_drive_opts\*(R". Щоб додати образ диска з можливістю запису і
вказати його формат (raw), скористайтеся таким кодом:
.PP
.Vb 3
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         \-1);
.Ve
.PP
Ви можете додати диск у режимі лише читання:
.PP
.Vb 4
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
\&                         \-1);
.Ve
.PP
або скористатися викликом старішої функції \*(L"guestfs_add_drive_ro\*(R". Якщо ви
використовуєте прапорець лише читання, libguestfs не зможе вносити зміни до
файла. (Див. також \*(L"ФОРМАТИ ОБРАЗІВ ДИСКІВ\*(R" нижче).
.PP
Будьте дуже обережні із дисками, які використовуються, наприклад,
віртуальною машиною. Додавання таких дисків у режимі читання\-запису майже
напевне призведе до пошкодження вмісту, але додавання у режимі лише читання
є безпечним.
.PP
Слід обов'язково додати принаймні один образ диска. Якщо потрібно, можна
додати декілька образів. Якщо додається декілька образів дисків, вони,
зазвичай, мають бути «пов'язані», тобто походити із однієї гостьової
системи. У програмному інтерфейсі на образи дисків, зазвичай, посилаються у
форматі \fI/dev/sda\fR (для першого доданого диска), \fI/dev/sdb\fR (для другого
доданого диска) тощо.
.PP
Після виклику \*(L"guestfs_launch\*(R" додавати нові образи вже не можна. Ви
можете викликати \*(L"guestfs_list_devices\*(R", щоб отримати список назв
пристроїв у порядку, за яким їх було додано. Див. також \*(L"ІМЕНУВАННЯ
БЛОКОВИХ ПРИСТРОЇВ\*(R" нижче.
.PP
Правила з'єднання дисків у «гарячому» режимі (у libguestfs ≥ 1.20) є
дещо іншими. Див. \*(L"З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ\*(R" нижче.
.SS "МОНТУВАННЯ"
.IX Subsection "МОНТУВАННЯ"
Перш ніж ви зможете читати або записувати файли, створювати каталоги та
виконувати інші дії на образі диска, який містить файлові системи, вам слід
змонтувати ці файлові системи за допомогою \*(L"guestfs_mount\*(R" або
\&\*(L"guestfs_mount_ro\*(R". Якщо ви вже знаєте, що на образі диска (наприклад)
міститься один розділ із файловою системою, ви можете змонтувати її
безпосередньо:
.PP
.Vb 1
\& guestfs_mount (g, "/dev/sda1", "/");
.Ve
.PP
де \fI/dev/sda1\fR означає буквально «перший розділ (\f(CW1\fR) першого образу
диска, який було додано (\fI/dev/sda\fR)».
 Якщо на диску містяться логічні томи \s-1LVM2\s0 Linux, ви можете посилатися на
них (наприклад, \fI/dev/VG/LV\fR). Зауважте, що вказані пристрої є віртуальними
пристроями libguestfs, які не мають нічого спільного із пристроями основної
системи.
.PP
Якщо у вас є образ диска, і ви не знаєте, що саме на ньому міститься, вам
доведеться спочатку все це з'ясувати. Libguestfs теж може це робити:
скористайтеся \*(L"guestfs_list_partitions\*(R" або \*(L"guestfs_lvs\*(R" для отримання
списку можливих розділів і логічних томів, а потім або спробуйте змонтувати
кожен з них, щоб визначити, які з них придатні до монтування, або у якийсь
інший спосіб вивчіть їх за допомогою \*(L"guestfs_vfs_type\*(R" або
\&\*(L"guestfs_file\*(R". Щоб просто отримати список файлових систем, скористайтеся
\&\*(L"guestfs_list_filesystems\*(R".
.PP
Крім того, у libguestfs передбачено набір програмних інтерфейсів для
інспектування невідомих образів дисків (див. \*(L"ІНСПЕКТУВАННЯ\*(R" нижче). Ви
також можете скористатися високорівневими програмами, побудованими на основі
libguestfs, зокрема \fBvirt\-inspector\fR\|(1).
.PP
Щоб змонтувати файлову систему у режимі лише читання, скористайтеся
\&\*(L"guestfs_mount_ro\*(R". Передбачено декілька інших варіантів викликів
\&\f(CW\*(C`guestfs_mount_*\*(C'\fR.
.SS "ДОСТУП ТА ВНЕСЕННЯ ЗМІН ДО ФАЙЛОВИХ СИСТЕМ"
.IX Subsection "ДОСТУП ТА ВНЕСЕННЯ ЗМІН ДО ФАЙЛОВИХ СИСТЕМ"
Більша частина програмного інтерфейсу libguestfs складається із
низькорівневих викликів для доступу до файлів та внесення змін до файлів,
каталогів, символічних посилань тощо на змонтованих файлових
системах. Передбачено понад сотню таких викликів, список яких із докладним
описом наведено нижче на цій сторінці підручника. Ми навіть не
намагатимемося повністю описати їх у цьому короткому огляді.
.PP
Вказуйте адреси і назви файлів повністю, починаючи з \f(CW"/"\fR, разом з точкою
монтування.
.PP
Наприклад, якщо вами змонтовано файлову систему до \f(CW"/"\fR, і ви бажаєте
виконати читання файла з назвою \f(CW"etc/passwd"\fR, ви можете скористатися
таким кодом:
.PP
.Vb 1
\& char *data = guestfs_cat (g, "/etc/passwd");
.Ve
.PP
Ця функція повертає дані \f(CW\*(C`data\*(C'\fR як новорозміщений буфер, що містить усі
дані з файла (із певними умовами; див. також \*(L"ОТРИМАННЯ\*(R" нижче) або
\&\f(CW\*(C`NULL\*(C'\fR, якщо сталася помилка.
.PP
Ще один приклад: для створення каталогу верхнього рівня із назвою \f(CW"var"\fR
на цій файловій системі можна скористатися такою командою:
.PP
.Vb 1
\& guestfs_mkdir (g, "/var");
.Ve
.PP
Щоб створити символічне посилання, ви можете скористатися таким кодом:
.PP
.Vb 2
\& guestfs_ln_s (g, "/etc/init.d/portmap",
\&               "/etc/rc3.d/S30portmap");
.Ve
.PP
Libguestfs відкидатиме спроби скористатися відносними шляхами. Крім того, не
передбачено поняття поточного робочого каталогу.
.PP
Libguestfs може повертати помилки у багатьох випадках: наприклад, якщо
файлова система не придатна до запису або якщо потрібного вам файла або
каталогу не існує. Якщо ви користуєтеся програмним інтерфейсом C
(документовано тут), вам слід перевіряти умову наявності помилки після
кожного виклику. (У інших прив'язках до мов програмування ці помилки
перетворюються на виключення.)
.PP
Запис до файлів визначається окремою для кожного дескриптора umask, як
встановлюється викликом \*(L"guestfs_umask\*(R" і має типове значення
022. Див. \*(L"\s-1UMASK\*(R"\s0.
.PP
Починаючи з версії libguestfs 1.18, можна монтувати файлову систему
libguestfs до локального каталогу із деякими обмеженнями. Див. \*(L"ЛОКАЛЬНЕ
МОНТУВАННЯ\*(R" нижче.
.SS "ПОДІЛ НА РОЗДІЛИ"
.IX Subsection "ПОДІЛ НА РОЗДІЛИ"
У libguestfs передбачено виклики програмного інтерфейсу для читання,
створення та внесення змін до таблиць розділів на образах дисків.
.PP
У типовому випадку, коли вам потрібно створити єдиний розділ на увесь диск,
вам слід скористатися викликом \*(L"guestfs_part_disk\*(R":
.PP
.Vb 4
\& const char *parttype = "mbr";
\& if (disk_is_larger_than_2TB)
\&   parttype = "gpt";
\& guestfs_part_disk (g, "/dev/sda", parttype);
.Ve
.PP
Очевидно, цей виклик призведе до витирання усіх даних, які раніше
зберігалися на цьому образі диска.
.SS "\s-1LVM2\s0"
.IX Subsection "LVM2"
Libguestfs надає доступ до великої частини програмного інтерфейсу \s-1LVM2,\s0
зокрема \*(L"guestfs_lvcreate\*(R" і \*(L"guestfs_vgremove\*(R". Але цей доступ не
матиме великого сенсу, якщо ви не ознайомитеся докладно із поняттями
фізичних томів, груп томів та логічних томів.
.PP
Автор цього підручника наполегливо рекомендує ознайомитися із настановами
щодо \s-1LVM HOWTO,\s0 які наведено у інтернеті:
http://tldp.org/HOWTO/LVM\-HOWTO/.
.SS "ОТРИМАННЯ ДАНИХ"
.IX Subsection "ОТРИМАННЯ ДАНИХ"
Для отримання невеличких текстових файлів скористайтеся \*(L"guestfs_cat\*(R". Цей
виклик не може обробляти файли, які містять символи \s-1ASCII NUL\s0 (\f(CW\*(C`\e0\*(C'\fR). Втім,
програмний інтерфейс цього виклику є дуже простим у використанні.
.PP
\&\*(L"guestfs_read_file\*(R" можна скористатися для читання файлів, які містять
довільні 8\-бітові дані, оскільки цей виклик повертає пару (вказівник,
розмір).
.PP
\&\*(L"guestfs_download\*(R" можна скористатися для отримання будь\-якого файла без
обмежень на вміст або розмір.
.PP
Для отримання одразу декількох файлів скористайтеся \*(L"guestfs_tar_out\*(R" і
\&\*(L"guestfs_tgz_out\*(R".
.SS "ВИВАНТАЖЕННЯ"
.IX Subsection "ВИВАНТАЖЕННЯ"
Для запису невеличкого файла із фіксованим вмістом скористайтеся
\&\*(L"guestfs_write\*(R". Для створення файла, який заповнено нулями, скористайтеся
\&\*(L"guestfs_truncate_size\*(R" (розріджений файл) або \*(L"guestfs_fallocate64\*(R"
(файл, для якого розподілено усі блоки на диску). Передбачено багато інших
функцій для створення тестових файлів, наприклад \*(L"guestfs_fill\*(R" і
\&\*(L"guestfs_fill_pattern\*(R".
.PP
Для вивантаження окремого файла скористайтеся \*(L"guestfs_upload\*(R". У цього
виклику немає обмежень на вміст і розмір файла.
.PP
Для вивантаження одразу декількох файлів скористайтеся \*(L"guestfs_tar_in\*(R" і
\&\*(L"guestfs_tgz_in\*(R".
.PP
Втім, найшвидшим способом вивантаження \fIвеликої кількості довільних файлів\fR
є перетворення їх на squashfs або \s-1ISO\s0 компакт\-диска (див. \fBmksquashfs\fR\|(8) і
\&\fBmkisofs\fR\|(8)) і долучення до системи за допомогою
\&\*(L"guestfs_add_drive_ro\*(R". Якщо ви додасте диск у передбачуваний спосіб
(наприклад, додасте його після усіх інших дисків), назву пристрою можна буде
отримати з \*(L"guestfs_list_devices\*(R", а диск можна буде безпосередньо
змонтувати за допомогою \*(L"guestfs_mount_ro\*(R". Зауважте, що для образів
squashfs іноді порушується сумісність із ядрами системи, у них не
передбачено підтримки міток та \s-1UUID.\s0 Якщо ви хочете попередньо зібрати образ
або хочете змонтувати його із міткою або \s-1UUID,\s0 вам слід скористатися
форматом образу \s-1ISO.\s0
.SS "КОПІЮВАННЯ"
.IX Subsection "КОПІЮВАННЯ"
Передбачено різноманітні команди для копіювання файлів і пристроїв до
гостьової операційної системи і з гостьової операційної системи. Резюме щодо
цих команд наведено у таблиці, розташованій нижче.
.IP "\fBфайл\fR у \fBфайл\fR" 4
.IX Item "файл у файл"
Скористайтеся \*(L"guestfs_cp\*(R" для копіювання окремого файла або
\&\*(L"guestfs_cp_a\*(R" для рекурсивного копіювання каталогів.
.Sp
Для копіювання частини файла (з визначенням відступу та розміру даних)
скористайтеся \*(L"guestfs_copy_file_to_file\*(R".
.IP "\fBфайл\fR на \fBпристрій\fR" 4
.IX Item "файл на пристрій"
.PD 0
.IP "\fBпристрій\fR до \fBфайла\fR" 4
.IX Item "пристрій до файла"
.IP "\fBпристрій\fR на \fBпристрій\fR" 4
.IX Item "пристрій на пристрій"
.PD
Скористайтеся \*(L"guestfs_copy_file_to_device\*(R",
\&\*(L"guestfs_copy_device_to_file\*(R" або \*(L"guestfs_copy_device_to_device\*(R".
.Sp
Приклад: дублювання вмісту логічного тому:
.Sp
.Vb 4
\& guestfs_copy_device_to_device (g,
\&         "/dev/VG/Original", "/dev/VG/Copy",
\&         /* \-1 позначає завершення списку необов\*(Aqязкових параметрів */
\&         \-1);
.Ve
.Sp
Призначення (\fI/dev/VG/Copy\fR) має бути не меншого розміру за джерело
(\fI/dev/VG/Original\fR). Для копіювання обсягу даних, який є меншим за увесь
пристрій джерела, скористайтеся додатковим параметром \f(CW\*(C`size\*(C'\fR:
.Sp
.Vb 4
\& guestfs_copy_device_to_device (g,
\&         "/dev/VG/Original", "/dev/VG/Copy",
\&         GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, 10000,
\&         \-1);
.Ve
.IP "\fBфайл на вузлі\fR на \fBфайл або пристрій\fR" 4
.IX Item "файл на вузлі на файл або пристрій"
Скористайтеся \*(L"guestfs_upload\*(R". Див. \*(L"ВИВАНТАЖЕННЯ\*(R" вище.
.IP "\fBфайл або пристрій\fR у \fBфайл на вузлі\fR" 4
.IX Item "файл або пристрій у файл на вузлі"
Скористайтеся \*(L"guestfs_download\*(R". Див. \*(L"ОТРИМАННЯ\*(R" вище.
.SS "ВИВАНТАЖЕННЯ І ОТРИМАННЯ ДАНИХ З КАНАЛІВ ТА ДЕСКРИПТОРІВ ФАЙЛІВ"
.IX Subsection "ВИВАНТАЖЕННЯ І ОТРИМАННЯ ДАНИХ З КАНАЛІВ ТА ДЕСКРИПТОРІВ ФАЙЛІВ"
Виклики, подібні до \*(L"guestfs_upload\*(R", \*(L"guestfs_download\*(R",
\&\*(L"guestfs_tar_in\*(R", \*(L"guestfs_tar_out\*(R" тощо, як може здатися, приймають як
аргументи лише назви файлів, тому, як може здатися, ви можете вивантажувати
дані лише до файлів і отримувати дані лише з файлів. Втім, у багатьох
Un*x\-подібних основних системах можна використовувати спеціальні файли
пристроїв \fI/dev/stdin\fR, \fI/dev/stdout\fR, \fI/dev/stderr\fR і \fI/dev/fd/N\fR для
читання і записування даних з stdin, stdout, stderr та файла з довільним
дескриптором N.
.PP
Наприклад, \fBvirt\-cat\fR\|(1) можна змусити записувати виведені дані до stdout у
такий спосіб:
.PP
.Vb 1
\& guestfs_download (g, filename, "/dev/stdout");
.Ve
.PP
а виведений архів tar можна записати до файла із вказаним дескриптором \f(CW\*(C`fd\*(C'\fR
ось так:
.PP
.Vb 3
\& char devfd[64];
\& snprintf (devfd, sizeof devfd, "/dev/fd/%d", fd);
\& guestfs_tar_out (g, "/", devfd);
.Ve
.SS "СПИСКИ ФАЙЛІВ"
.IX Subsection "СПИСКИ ФАЙЛІВ"
\&\*(L"guestfs_ll\*(R" призначено лише для створення зручних для читання даних (в
основному, якщо використано еквівалент \f(CW\*(C`ll\*(C'\fR у \fBguestfish\fR\|(1)).
.PP
\&\*(L"guestfs_ls\*(R" — швидкий спосіб отримати список файлів у каталозі від
програм у форматі простого списку рядків.
.PP
\&\*(L"guestfs_readdir\*(R" — програмний спосіб отримання списку файлів у каталозі
разом із додатковою інформацією щодо кожного з файлів. Це дуже схоже на
використання виклику \fBreaddir\fR\|(3) у локальних файлових системах.
.PP
\&\*(L"guestfs_find\*(R" і \*(L"guestfs_find0\*(R" можна скористатися для рекурсивної
побудови списку файлів.
.SS "ВИКОНАННЯ КОМАНД"
.IX Subsection "ВИКОНАННЯ КОМАНД"
Хоча програмний інтерфейс libguestfs в основному призначено для керування
файлами всередині образів гостьових операційних систем, у ньому передбачено
і обмежені можливості для запуску команд у гостьових операційних системах.
.PP
Існує багато обмежень щодо цього:
.IP "\(bu" 4
Версія ядра системи відрізнятиметься від тієї, на яку може покладатися код
програми.
.IP "\(bu" 4
Якщо програмі потрібно буде обмінятися даними із фоновими службами,
найімовірніше, ці фонові служби не працюватимуть.
.IP "\(bu" 4
Програму буде запущено з обмеженим обсягом доступної пам'яті.
.IP "\(bu" 4
Мережа буде недоступною, якщо ви її не увімкнете
(див. \*(L"guestfs_set_network\*(R").
.IP "\(bu" 4
Передбачено підтримку лише гостьових систем Linux (не Windows, \s-1BSD\s0 тощо).
.IP "\(bu" 4
Обмеження щодо архітектури (наприклад, не працює для гостьової системи \s-1PPC\s0
на основній системі X86).
.IP "\(bu" 4
У гостьових системах із SELinux може виникнути потреба у повторному
створенні міток після створення файлів. Див.  розділ \*(L"\s-1SELINUX\*(R"\s0 нижче.
.IP "\(bu" 4
\&\fIБезпека:\fR запускати програми із гостьових систем із невідомим походженням,
гостьових систем, які може бути створено зловмисниками, небезпечно. Програми
з таких систем можуть намагатися скористатися вразливостями у вашій
програмі, надсилаючи їй спеціально сформовані дані. Також ці програми можуть
намагатися скористатися вразливостями у ядрі Linux або qemu, які надаються
базовою системою libguestfs. Програми можуть скористатися доступом до
мережі, який надається базовою системою libguestfs для виходу за межі
звичайних мережевих розділів та брандмауерів. Програми можуть намагатися
розширити права доступу або змінити контекст SELinux вашої програми для
виконання задумів зловмисників.
.Sp
Безпечною альтернативою є використання libguestfs для встановлення скрипту
«firstboot» (скрипту, який запускається, коли гостьова система
завантажується у звичайному режимі) таким чином, що цей скрипт запускав
потрібні вам команди, у звичайному контексті запущеної гостьової системи, зі
звичайним захистом мережі тощо. Щоб дізнатися більше про проблеми, пов'язані
із захистом, ознайомтеся зі сторінкою підручника щодо
\&\fBguestfs\-security\fR\|(1).
.PP
Двома основними програмними інтерфейсами для запуску програм є
\&\*(L"guestfs_command\*(R" і \*(L"guestfs_sh\*(R" (передбачено також певні варіанти цих
інтерфейсів).
.PP
Відмінність двох інтерфейсів полягає у тому, що \*(L"guestfs_sh\*(R" виконує
команди за допомогою командної оболонки, отже, працюють усі
символи\-замінники, переспрямовування тощо.
.SS "ФАЙЛИ НАЛАШТУВАННЯ"
.IX Subsection "ФАЙЛИ НАЛАШТУВАННЯ"
Для читання і запису файлів налаштувань у файлових системах гостьових
операційних систем Linux ми наполегливо рекомендуємо скористатися
Augeas. Наприклад, Augeas знає, як читати і записувати, скажімо, файл
паролів Linux shadow або файл налаштувань X.org, отже, вам не доведеться
писати для цього додатковий код.
.PP
Основні виклики Augeas виконуються за допомогою програмних інтерфейсів
\&\f(CW\*(C`guestfs_aug_*\*(C'\fR. Тут ми не наводимо документації щодо самої Augeas,
оскільки існує чудова документація, викладена на сайті
http://augeas.net/.
.PP
Якщо ви не хочете користуватися Augeas (ну який же ви неслухняний!),
спробуйте викликати \*(L"guestfs_read_lines\*(R" для отримання файла у форматі
списку рядків, які ви ітеративно зможете обробити у коді програми.
.SS "ФАЙЛИ ЖУРНАЛУ \s-1SYSTEMD\s0"
.IX Subsection "ФАЙЛИ ЖУРНАЛУ SYSTEMD"
Для читання журналу systemd з гостьової системи Linux скористайтеся
програмними інтерфейсами \f(CW\*(C`guestfs_journal_*\*(C'\fR, починаючи з
\&\*(L"guestfs_journal_open\*(R".
.PP
Із документацією щодо журналу можна ознайомитися за допомогою таких сторінок
підручника: \fBsd\-journal\fR\|(3), \fBsd_journal_open\fR\|(3).
.SS "\s-1SELINUX\s0"
.IX Subsection "SELINUX"
Ми передбачили підтримку гостьових систем із SELinux. Втім, неможливо
завантажити правила SELinux гостьової системи до ядра базової системи. Тому
стратегія роботи з гостьовими системами із SELinux є повторне встановлення у
них міток після внесення змін.
.PP
У libguestfs ≥ 1.34 передбачено новий програмний інтерфейс,
\&\*(L"guestfs_setfiles\*(R", яким можна скористатися для виконання цього
завдання. Щоб належним чином скористатися цим програмним інтерфейсом, вам
слід обробити налаштування SELinux гостьової системи. Див. модульe
\&\fBvirt\-customize\fR\|(1) \fIcustomize/SELinux_relabel.ml\fR, щоб дізнатися більше
про це.
.PP
Простішою, але повільнішою альтернативою є виконання touch \fI/.autorelabel\fR
у гостьовій системі, що означатиме, що гостьовій системі доведеться повторно
встановити усі мітки під час наступного завантаження.
.PP
У libguestfs ≤ 1.32 було передбачено програмні інтерфейси
\&\f(CW\*(C`guestfs_set_selinux\*(C'\fR, \f(CW\*(C`guestfs_get_selinux\*(C'\fR, \f(CW\*(C`guestfs_setcon\*(C'\fR and
\&\f(CW\*(C`guestfs_getcon\*(C'\fR. Ці програмні інтерфейси не працювали як слід, вони
вважаються застарілими. Не використовуйте їх у новому коді.
.SS "\s-1UMASK\s0"
.IX Subsection "UMASK"
На деякі виклики впливає маска режиму створення поточного файла
(«umask»). Це, зокрема, виклики, які створюють файли або каталоги, наприклад
\&\*(L"guestfs_touch\*(R", \*(L"guestfs_mknod\*(R" і \*(L"guestfs_mkdir\*(R". Маска впливає або
на типовий режим створення файла, або змінює режим доступу, який ви
встановлюєте.
.PP
Типовим значенням umask є \f(CW022\fR. Отже, файли створюватимуться із правами
доступу, які подібні до \f(CW0644\fR, а каталоги — \f(CW0755\fR.
.PP
Існує два способи уникнути впливу umask. Можна або встановити для umask
значення 0 (викликати \f(CW\*(C`guestfs_umask (g, 0)\*(C'\fR одразу після запуску), або
викликати \*(L"guestfs_chmod\*(R" після створення кожного файла або каталогу.
.PP
Докладніший опис umask можна знайти на сторінці підручника щодо \fBumask\fR\|(2).
.SS "МІТКИ І \s-1UUID\s0"
.IX Subsection "МІТКИ І UUID"
У багатьох файлових системах, на пристроях або логічних томах передбачено
підтримку міток (коротких рядків, подібних до «BOOT», які можуть
повторюватися) і/або \s-1UUID\s0 (унікальних на загальному рівні ідентифікаторів).
.PP
Для файлових систем користуйтеся \*(L"guestfs_vfs_label\*(R" або
\&\*(L"guestfs_vfs_uuid\*(R" для читання мітки або \s-1UUID.\s0 У деяких файлових системах
можна викликати \*(L"guestfs_set_label\*(R" або \*(L"guestfs_set_uuid\*(R" для зміни
мітки або \s-1UUID.\s0
.PP
Ви можете знайти файлову систему за міткою або \s-1UUID\s0 за допомогою виклику
\&\*(L"guestfs_findfs_label\*(R" або \*(L"guestfs_findfs_uuid\*(R".
.PP
Для \s-1LVM2\s0 (де передбачено підтримку лише \s-1UUID\s0) передбачено широкий спектр
інструментів програмного інтерфейсу для отримання \s-1UUID,\s0 отримання \s-1UUID\s0
об'єктів контейнерів і зміни \s-1UUID.\s0 Див. \*(L"guestfs_lvuuid\*(R",
\&\*(L"guestfs_vguuid\*(R", \*(L"guestfs_pvuuid\*(R", \*(L"guestfs_vglvuuids\*(R",
\&\*(L"guestfs_vgpvuuids\*(R", \*(L"guestfs_vgchange_uuid\*(R",
\&\*(L"guestfs_vgchange_uuid_all\*(R", \*(L"guestfs_pvchange_uuid\*(R",
\&\*(L"guestfs_pvchange_uuid_all\*(R".
.PP
Зауважте, що при клонуванні файлової системи, пристрою або усієї гостьової
операційної системи варто встановити нові випадково створені \s-1UUID\s0 для копії.
.SS "ЗАШИФРОВАНІ ДИСКИ"
.IX Subsection "ЗАШИФРОВАНІ ДИСКИ"
Libguestfs надає вам змогу отримувати доступ до гостьових операційних систем
Linux, де використовується повне шифрування диска відповідно до стандарту
Linux Unified Key Setup (\s-1LUKS\s0), що включає майже усі системи шифрування
усього диска, які використовуються сучасними гостьовими системами Linux.
.PP
Скористайтеся \*(L"guestfs_vfs_type\*(R" для виявлення зашифрованих за допомогою
\&\s-1LUKS\s0 блокових пристроїв (функція повертає для таких пристроїв рядок
\&\f(CW\*(C`crypto_LUKS\*(C'\fR).
.PP
Далі, відкрийте ці пристрої, викликавши \*(L"guestfs_luks_open\*(R". Очевидно, для
відкриття вам знадобиться пароль!
.PP
Відкриття пристрою \s-1LUKS\s0 призводить до створення пристрою\-прив'язки із назвою
\&\fI/dev/mapper/назва_прив'язки\fR (де \f(CW\*(C`назва_прив\*(Aqязки\*(C'\fR — рядок, який ви
передаєте \*(L"guestfs_luks_open\*(R"). Дані, які читаються і записуються на цей
пристрій\-прив'язку, розшифровуються і шифруються на базовий блоковий
пристрій, відповідно.
.PP
Групи томів \s-1LVM\s0 на пристрої можна зробити видимими викликом
\&\*(L"guestfs_vgscan\*(R", за яким слід викликати
\&\*(L"guestfs_vg_activate_all\*(R". Після цього логічні томи можна змонтувати у
звичний спосіб.
.PP
Скористайтеся зворотною процедурою для закриття пристрою \s-1LUKS.\s0 Демонтуйте
усі логічні томи на ньому, деактивуйте групи томів викликом
\&\f(CW\*(C`guestfs_vg_activate (g, 0, ["/dev/VG"])\*(C'\fR. Далі, закрийте
пристрій\-прив'язку викликом \*(L"guestfs_luks_close\*(R" для пристрою
\&\fI/dev/mapper/назва_прив'язки\fR (а \fIне\fR для базового блокового пристрою).
.SS "ЛОКАЛЬНЕ МОНТУВАННЯ"
.IX Subsection "ЛОКАЛЬНЕ МОНТУВАННЯ"
Починаючи з версії libguestfs 1.18, можна монтувати файлову систему
libguestfs до локального каталогу і отримувати доступ до неї за допомогою
звичайних викликів і програм \s-1POSIX.\s0
.PP
Доступність цього може бути обмежено декількома факторами: у системі має
бути встановлено \s-1FUSE\s0 (Filesystem in USErspace), а заголовкові файли libfuse
мають бути доступними під час збирання libguestfs. \s-1FUSE\s0 може потребувати
завантаження модуля ядра. Крім того, можливо, потрібно додати поточного
користувача до спеціальної групи \f(CW\*(C`fuse\*(C'\fR. Докладніші відомості можна знайти
у документації до вашого дистрибутива та на http://fuse.sf.net.
.PP
Виклик монтування файлової системи libguestfs до локального каталогу є
послідовним викликом \*(L"guestfs_mount_local\*(R" з наступним
\&\*(L"guestfs_mount_local_run\*(R". Другий з цих викликів не повертає керування, аж
доки ви не демонтуєте файлову систему. Причиною цього є те, що виклик
входить до основного циклу обробки \s-1FUSE\s0 і обробляє запити ядра, перетворюючи
їх на виклики libguestfs. Альтернативний підхід міг би полягати у створенні
фонового потоку обробки для виконання цього завдання, але у libguestfs
pthreads не є обов'язковою залежністю. Крім того, наш підхід є гнучкішим:
наприклад, користувач може створити ще один потік обробки для
\&\*(L"guestfs_mount_local_run\*(R".
.PP
\&\*(L"guestfs_mount_local\*(R" потребує певного часу на налаштовування точки
монтування. Точка монтування лишатиметься недоступною, доки цей виклик не
поверне керування. До цього моменту спроби доступу до файлової системи
блокуватиметься, аж доки не буде здійснено вхід до основного циклу обробки
(тобто передано керування до \*(L"guestfs_mount_local_run\*(R"). Отже, якщо вам
потрібно запустити процес для доступу до файлової системи, додайте
розгалуження між \*(L"guestfs_mount_local\*(R" і \*(L"guestfs_mount_local_run\*(R".
.PP
\fIСУМІСНІСТЬ ЛОКАЛЬНОГО МОНТУВАННЯ\fR
.IX Subsection "СУМІСНІСТЬ ЛОКАЛЬНОГО МОНТУВАННЯ"
.PP
Оскільки можливість локального монтування було додано лише після версії
libguestfs 1.18, і ця можливість може бути недоступною навіть у пізніших
версіях через особливості збирання, код варто писати так, щоб у ньому не
було жорсткої залежності від цієї можливості і щоб було передбачено резервну
можливість повернутися до використання викликів, пов'язаних із файловою
системою у libguestfs.
.PP
Якщо libguestfs було зібрано без підтримки \*(L"guestfs_mount_local\*(R", виклик
цієї функції призводитиме до помилки із errno, встановленим у значення
\&\f(CW\*(C`ENOTSUP\*(C'\fR (див. \*(L"guestfs_last_errno\*(R").
.PP
\fIШВИДКОДІЯ ПРИ ЛОКАЛЬНОМУ МОНТУВАННІ\fR
.IX Subsection "ШВИДКОДІЯ ПРИ ЛОКАЛЬНОМУ МОНТУВАННІ"
.PP
Обгортка libguestfs навколо \s-1FUSE\s0 має доволі низький рівень швидкодії. Якщо
вам потрібен найшвидший доступ, не використовуйте її. Замість неї
користуйтеся звичайними викликами libguestfs, пов'язаними з обробкою
файлових систем: вивантаженням і отриманням даних тощо.
.SS "З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ"
.IX Subsection "З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ"
У libguestfs ≥ 1.20 ви можете додавати і вилучати диски після виклику
\&\*(L"guestfs_launch\*(R". Втім, є декілька обмежень, опис яких наведено
нижче. Таку можливість будемо називати \fIз'єднанням у «гарячому» режимі\fR.
.PP
Підтримку з'єднання у «гарячому» режимі передбачено лише у деяких модулях
обробки даних (у поточній версії таку підтримку передбачено лише у модулі
libvirt). Крім того, потрібні версії libvirt ≥ 0.10.3 та qemu ≥ 1.2.
.PP
Для додавання диска у «гарячому» режимі просто скористайтеся викликом
\&\*(L"guestfs_add_drive_opts\*(R" після \*(L"guestfs_launch\*(R". Має бути обов'язково
вказано параметр \f(CW\*(C`label\*(C'\fR, щоб новий доданий диск мав передбачувану
назву. Приклад:
.PP
.Vb 2
\& if (guestfs_launch (g) == \-1)
\&   error ("launch failed");
\& 
\& if (guestfs_add_drive_opts (g, filename,
\&                             GUESTFS_ADD_DRIVE_OPTS_LABEL, "newdisk",
\&                             \-1) == \-1)
\&   error ("hot\-add of disk failed");
\& 
\& if (guestfs_part_disk ("/dev/disk/guestfs/newdisk", "mbr") == \-1)
\&   error ("partitioning of hot\-added disk failed");
.Ve
.PP
Для вилучення диска у «гарячому» режимі скористайтеся викликом
\&\*(L"guestfs_remove_drive\*(R". Цей виклик можна використовувати до або після
\&\*(L"guestfs_launch\*(R". Вилучати диски у такий спосіб можна, лише якщо їх раніше
було додано із міткою.
.PP
У модулях обробки, де передбачено підтримку з'єднання у «гарячому» режимі не
обов'язково додавати один або більше дисків до виклику launch. Якщо
передбачено підтримку з'єднання у «гарячому» режимі, ви можете взагалі не
додавати жодних дисків.
.SS "ВІДДАЛЕНЕ СХОВИЩЕ ДАНИХ"
.IX Subsection "ВІДДАЛЕНЕ СХОВИЩЕ ДАНИХ"
\fI\s-1CEPH\s0\fR
.IX Subsection "CEPH"
.PP
Libguestfs може отримувати доступ до дисків Ceph (librbd/RBD).
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR і \f(CW\*(C`server\*(C'\fR у
виклику \*(L"guestfs_add_drive_opts\*(R", ось так:
.PP
.Vb 8
\& char **servers = { "ceph1.example.org:3000", /* ... */, NULL };
\& guestfs_add_drive_opts (g, "pool/image",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "rbd",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         GUESTFS_ADD_DRIVE_OPTS_USERNAME, "rbduser",
\&                         GUESTFS_ADD_DRIVE_OPTS_SECRET, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
\&                         \-1);
.Ve
.PP
\&\f(CW\*(C`servers\*(C'\fR (параметр \f(CW\*(C`server\*(C'\fR) — список з одного або декількох серверів
Ceph. Документацію щодо рядка server наведено у описі
\&\*(L"guestfs_add_drive_opts\*(R". Параметри \f(CW\*(C`username\*(C'\fR та \f(CW\*(C`secret\*(C'\fR є
необов'язковими. Якщо їх не вказано, розпізнавання не виконуватиметься.
.PP
\fI\s-1FTP, HTTP\s0 ТА \s-1TFTP\s0\fR
.IX Subsection "FTP, HTTP ТА TFTP"
.PP
Libguestfs може отримувати доступ до віддалених дисків за допомогою
протоколів \s-1FTP, FTPS, HTTP, HTTPS\s0 та \s-1TFTP.\s0
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR і \f(CW\*(C`server\*(C'\fR у
виклику \*(L"guestfs_add_drive_opts\*(R", ось так:
.PP
.Vb 6
\& char **servers = { "www.example.org", NULL };
\& guestfs_add_drive_opts (g, "/disk.img",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "http",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         \-1);
.Ve
.PP
Значенням параметра \f(CW\*(C`protocol\*(C'\fR може бути один з таких рядків: \f(CW"ftp"\fR,
\&\f(CW"ftps"\fR, \f(CW"http"\fR, \f(CW"https"\fR або \f(CW"tftp"\fR.
.PP
\&\f(CW\*(C`servers\*(C'\fR (параметр \f(CW\*(C`server\*(C'\fR) — список, який має складатися з одного
запису. Цей єдиний запис є рядком, який визначає вебсервер або сервер \s-1FTP\s0 чи
\&\s-1TFTP.\s0 Документацію щодо рядка server наведено у описі
\&\*(L"guestfs_add_drive_opts\*(R".
.PP
\fI\s-1GLUSTER\s0\fR
.IX Subsection "GLUSTER"
.PP
Libguestfs може отримувати доступ до дисків Gluster.
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR і \f(CW\*(C`server\*(C'\fR у
виклику \*(L"guestfs_add_drive_opts\*(R", ось так:
.PP
.Vb 6
\& char **servers = { "gluster.example.org:24007", NULL };
\& guestfs_add_drive_opts (g, "volname/image",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "gluster",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         \-1);
.Ve
.PP
\&\f(CW\*(C`servers\*(C'\fR (параметр \f(CW\*(C`server\*(C'\fR) — список, який має складатися з одного
запису. Цей єдиний запис є рядком, який визначає сервер
Gluster. Документацію щодо рядка server наведено у описі
\&\*(L"guestfs_add_drive_opts\*(R".
.PP
Зауважте, що, зазвичай, gluster потребує запуску клієнтського процесу (тобто
libguestfs) від імені користувача \fBroot\fR і повідомляє про незрозумілі
помилки, якщо процес запущено від звичайного користувача (наприклад, «No
data available» або «Дані недоступні»).
.PP
\fI\s-1ISCSI\s0\fR
.IX Subsection "ISCSI"
.PP
Libguestfs може отримувати віддалений доступ до дисків iSCSI.
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR і \f(CW\*(C`server\*(C'\fR у
виклику ось так:
.PP
.Vb 6
\& char **server = { "iscsi.example.org:3000", NULL };
\& guestfs_add_drive_opts (g, "target\-iqn\-name/lun",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "iscsi",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
\&                         \-1);
.Ve
.PP
\&\f(CW\*(C`servers\*(C'\fR (параметр \f(CW\*(C`server\*(C'\fR) — список, який має складатися з одного
запису. Цей єдиний запис є рядком, який визначає сервер iSCSI. Документацію
щодо рядка server наведено у описі \*(L"guestfs_add_drive_opts\*(R".
.PP
\fI\s-1NETWORK BLOCK DEVICE\s0\fR
.IX Subsection "NETWORK BLOCK DEVICE"
.PP
Libguestfs може отримувати віддалений доступ до дисків Network Block Device
(\s-1NBD\s0).
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR і \f(CW\*(C`server\*(C'\fR у
виклику \*(L"guestfs_add_drive_opts\*(R", ось так:
.PP
.Vb 6
\& char **server = { "nbd.example.org:3000", NULL };
\& guestfs_add_drive_opts (g, "" /* export name \- see below */,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "nbd",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
\&                         \-1);
.Ve
.PP
Нотатки:
.IP "\(bu" 4
\&\f(CW\*(C`сервер\*(C'\fR фактично є списком серверів. Для доступу до \s-1NBD\s0 вам слід завжди
вказувати список як єдиний елемент. (Для інших віддалених протоколів можна
не вказувати сервер або вказувати декілька серверів, тому цей параметр і є
списком.)
.IP "\(bu" 4
Документацію щодо рядка \f(CW\*(C`сервер\*(C'\fR можна знайти у розділі
\&\*(L"guestfs_add_drive_opts\*(R". Що встановити з'єднання із локальним екземпляром
qemu-nbd за допомогою сокета домену \s-1UNIX,\s0 скористайтеся записом
\&\f(CW"unix:/шлях/до/сокета"\fR.
.IP "\(bu" 4
Значенням параметра \f(CW\*(C`filename\*(C'\fR має бути назва експортування \s-1NBD.\s0
Скористайтеся порожнім рядком, якщо слід використовувати типове
експортування. У багатьох реалізаціях серверів \s-1NBD,\s0 зокрема qemu-nbd, не
передбачено підтримки назв експортування.
.IP "\(bu" 4
Якщо ви використовуєте як сервер qemu-nbd, вам слід завжди передавати
параметр \f(CW\*(C`\-t\*(C'\fR. Причина полягає у тому, що libguestfs може відкривати одразу
декілька з'єднань із сервером.
.IP "\(bu" 4
При користуванні модулем обробки libvirt обов'язково слід точно вказати
параметр \f(CW\*(C`format\*(C'\fR \*(L"guestfs_add_drive_opts\*(R", якщо ви використовуєте
придатні до запису диски \s-1NBD.\s0
.IP "\(bu" 4
У модулі обробки libvirt є вада, яка заважає з'єднанням із сокетом домену
\&\s-1UNIX\s0 працювати: https://bugzilla.redhat.com/show_bug.cgi?id=922888
.IP "\(bu" 4
У модулі безпосередньої обробки не передбачено підтримки з'єднань лише для
читання даних через ваду у qemu:
https://bugs.launchpad.net/qemu/+bug/1155677
.PP
\fI\s-1SHEEPDOG\s0\fR
.IX Subsection "SHEEPDOG"
.PP
Libguestfs може отримувати доступ до дисків Sheepdog.
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR і \f(CW\*(C`server\*(C'\fR у
виклику \*(L"guestfs_add_drive_opts\*(R", ось так:
.PP
.Vb 6
\& char **servers = { /* optional servers ... */ NULL };
\& guestfs_add_drive_opts (g, "volume",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "sheepdog",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         \-1);
.Ve
.PP
Необов'язковий список \f(CW\*(C`servers\*(C'\fR має складатися із нуля або якоїсь кількості
адрес серверів (\f(CW"назва_вузла:порт"\fR). Формат рядків server описано у
документації з \*(L"guestfs_add_drive_opts\*(R".
.PP
\fI\s-1SSH\s0\fR
.IX Subsection "SSH"
.PP
Libguestfs може отримувати доступ до дисків за допомогою з'єднань Secure
Shell (\s-1SSH\s0).
.PP
Для цього встановіть необов'язкові параметри \f(CW\*(C`protocol\*(C'\fR, \f(CW\*(C`server\*(C'\fR та
(необов'язково) \f(CW\*(C`username\*(C'\fR у виклику \*(L"guestfs_add_drive_opts\*(R", ось так:
.PP
.Vb 7
\& char **server = { "remote.example.com", NULL };
\& guestfs_add_drive_opts (g, "/path/to/disk.img",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "ssh",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
\&                         GUESTFS_ADD_DRIVE_OPTS_USERNAME, "remoteuser",
\&                         \-1);
.Ve
.PP
Формат рядка сервера документовано у розділі щодо
\&\*(L"guestfs_add_drive_opts\*(R".
.SS "ПЕРЕВІРКА"
.IX Subsection "ПЕРЕВІРКА"
У libguestfs передбачено програмні інтерфейси для інспектування невідомих
образів дисків для визначення, чи міститься у образі операційна система,
дані для встановлення з компакт\-диска або портативна система.
.PP
Додайте усі диски, що належать до невідомої віртуальної машини і викличте
\&\*(L"guestfs_launch\*(R" у звичний спосіб.
.PP
Далі, викличте \*(L"guestfs_inspect_os\*(R". Ця функція використовує інші виклики
libguestfs та певну евристику і повертає список знайдених операційних
систем. Якщо список виявиться порожнім, значить операційних систем не
знайдено. Окремий запис списку визначатиме кореневу файлову систему
операційної системи. Для гостьових операційних систем із варіантами
завантаження може бути повернуто декілька кореневих записів, кожен з яких
відповідає окремій операційній системі. (Віртуальні машини із варіантами
завантаження є дуже рідкісними у світі віртуалізації, але оскільки такий
сценарій можливий, нам довелося реалізувати його у libguestfs.)
.PP
Для кожної кореневої файлової системи ви можете скористатися різноманітними
функціями \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR для отримання додаткових відомостей щодо
операційної системи. Наприклад, викличте \*(L"guestfs_inspect_get_type\*(R", щоб
отримати рядок \f(CW\*(C`windows\*(C'\fR або \f(CW\*(C`linux\*(C'\fR для Windows та заснованих на Linux
операційних системах, відповідно.
.PP
Un*x\-подібні та засновані на Linux операційні системи зазвичай складаються з
декількох файлових систем, які монтуються під час завантаження (наприклад,
окремого розділу для завантаження, який змонтовано до \fI/boot\fR). Правила
інспектування уможливлюють визначення, як саме файлові системи пов'язано із
точками монтування. Викличте \f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, щоб
отримати дані щодо цієї прив'язки. У відповідь може бути повернуто
хеш\-таблицю, подібну до такої:
.PP
.Vb 3
\& /boot => /dev/sda1
\& /     => /dev/vg_guest/lv_root
\& /usr  => /dev/vg_guest/lv_usr
.Ve
.PP
Далі, можна викликати \*(L"guestfs_mount\*(R" для відповідного монтування файлових
систем.
.PP
Файлові системи слід монтувати у належному порядку (наприклад, \fI/\fR має бути
змонтовано перед \fI/usr\fR). Для визначення порядку можна упорядкувати
хеш\-записи за довжиною так, щоб першими у списку були найкоротші.
.PP
Засіб інспектування у поточній версії може працювати лише з декількома
поширеними операційними системами. Будемо раді вашим латкам, які
реалізуватимуть підтримку інших операційних систем, які ще не може бути
визначено програмно.
.PP
Шифровані диски слід відкривати до інспектування. Докладніше про це можна
дізнатися з розділу \*(L"ЗАШИФРОВАНІ ДИСКИ\*(R". Функція \*(L"guestfs_inspect_os\*(R"
просто ігноруватиме усі знайдені зашифровані пристрої.
.PP
Зауваження щодо реалізації: виклик \*(L"guestfs_inspect_os\*(R" виконує
інспектування та кешує результати у дескрипторі гостьової системи. Наступні
виклики \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR повертатимуть кешовані відомості, але \fIне
виконуватимуть\fR повторного читання дисків. Якщо ви зміните вміст дисків
гостьової системи, ви можете змусити програму повторно виконати
інспектування, викликавши \*(L"guestfs_inspect_os\*(R" ще
раз. (\*(L"guestfs_inspect_list_applications2\*(R" працює дещо інакше, якщо
порівнювати з іншими викликами, і виконує читання дисків. Див. документацію
з цієї функції, щоб дізнатися більше).
.PP
\fIВИВЧЕННЯ ДИСКІВ ДЛЯ ВСТАНОВЛЕННЯ\fR
.IX Subsection "ВИВЧЕННЯ ДИСКІВ ДЛЯ ВСТАНОВЛЕННЯ"
.PP
Libguestfs (з версії 1.9.4) може виявляти деякі диски для встановлення,
компакт\-диски для встановлення, компакт\-диски із портативними системами
тощо.
.PP
Докладну інформацію щодо операційних систем на дисках для встановлення можна
отримати за допомогою звичайних програмних інтерфейсів вивчення, зокрема
\&\*(L"guestfs_inspect_get_product_name\*(R", \*(L"guestfs_inspect_get_major_version\*(R"
тощо.
.SS "ДОДАТКОВІ ЗАУВАЖЕННЯ ЩОДО ГОСТЬОВИХ СИСТЕМ \s-1WINDOWS\s0"
.IX Subsection "ДОДАТКОВІ ЗАУВАЖЕННЯ ЩОДО ГОСТЬОВИХ СИСТЕМ WINDOWS"
Libguestfs може монтувати розділи \s-1NTFS.\s0 Це завдання виконується за допомогою
драйвера http://www.ntfs\-3g.org/.
.PP
\fIЛІТЕРИ ДИСКІВ ТА ШЛЯХИ\fR
.IX Subsection "ЛІТЕРИ ДИСКІВ ТА ШЛЯХИ"
.PP
У \s-1DOS\s0 та Windows для позначення дисків усе ще використовуються літери, а
назви у файлових системах самою Windows обробляються як незалежні від
регістру символів, тому можлива ситуація, коли файл налаштувань Windows
посилається на каталог із назвою подібною до \f(CW\*(C`c:\ewindows\esystem32\*(C'\fR. Коли ж
файлову систему змонтовано у libguestfs, той самий каталог може мати назву
\&\fI/WINDOWS/System32\fR.
.PP
Визначити прив'язку дисків до літер можна за допомогою засобу інспектування
(див. \*(L"ІНСПЕКТУВАННЯ\*(R" та \*(L"guestfs_inspect_get_drive_mappings\*(R")
.PP
Обробка символів\-роздільників у шляхах (символів зворотної чи прямої похилої
риски) не виконується самою libguestfs, але, зазвичай, для цього можна
просто скористатися автоматичною заміною символів на відповідні.
.PP
Щоб усунути проблему із неврахуванням регістру літер у шляхах, скористайтеся
викликом \*(L"guestfs_case_sensitive_path\*(R".
.PP
\fIДОВГІ НАЗВИ ФАЙЛІВ У \s-1NTFS\s0\fR
.IX Subsection "ДОВГІ НАЗВИ ФАЙЛІВ У NTFS"
.PP
У \s-1NTFS\s0 назви файлів обмежено довжиною у 255 символів. «Символ» означає
2\-байтову позицію у таблиці \s-1UTF\-16,\s0 яка містить більшість типових символів
Unicode.
.PP
У більшості файлових систем Linux передбачено підтримку назв файлів довжиною
до 255 \fIбайтів\fR. Це означає, що ви можете отримати повідомлення про
помилку:
.PP
.Vb 1
\& File name too long
.Ve
.PP
коли копіюватимете файл з \s-1NTFS\s0 на файлову систему Linux, якщо назва, коли її
буде перекодовано у \s-1UTF\-8,\s0 перевищить за довжиною 255 байтів.
.PP
Найчастіше таке трапляється, коли використовуються довші за ~127 символів
назви із символами, які не належать до \s-1ASCII,\s0 (наприклад, назви кирилицею
або грецькою) або використовуються довші за ~85 символів назви азійськими
мовами із ієрогліфічним записом.
.PP
Обійти проблему можна, намагаючись не зберігати файли із такими довгими
назвами у файлових системах Linux. Оскільки у форматі \fBtar\fR\|(1) передбачено
можливість зберігання назв файлів без будь\-яких обмежень, такі файли можна
зберігати у архівах tar.
.PP
\fIДОСТУП ДО РЕГІСТРУ \s-1WINDOWS\s0\fR
.IX Subsection "ДОСТУП ДО РЕГІСТРУ WINDOWS"
.PP
У libguestfs також передбачено допоміжні можливості із декодування файлів
реєстрів Windows, «hive», на основі окремої бібліотеки мовою C, яка
називається \fBhivex\fR\|(3).
.PP
До версії libguestfs 1.19.35 вам потрібно було отримати файл рою (hive),
обробити його локально за допомогою hivex і вивантажити його
назад. Починаючи з вказаної версії, нами було включено основні програмні
інтерфейси hivex безпосередньо до програмного інтерфейсу libguestfs
(див. \*(L"guestfs_hivex_open\*(R"). Це означає, що якщо ви відкрили гостьову
систему Windows, ви можете читати і записувати реєстр безпосередньо.
.PP
Див. також \fBvirt\-win\-reg\fR\|(1).
.PP
\fIСИМВОЛІЧНІ ПОСИЛАННЯ У ФАЙЛОВИХ СИСТЕМАХ \s-1NTFS\-3G\s0\fR
.IX Subsection "СИМВОЛІЧНІ ПОСИЛАННЯ У ФАЙЛОВИХ СИСТЕМАХ NTFS-3G"
.PP
Ntfs\-3g намагається переписати «точки з'єднання» та «символічні посилання»
\&\s-1NTFS\s0 для створення чогось схожого на символічне посилання Linux. Спосіб, у
який виконується переписування, описано тут:
.PP
http://www.tuxera.com/community/ntfs\-3g\-advanced/junction\-points\-and\-symbolic\-links/
.PP
Основною проблемою є те, що ntfs\-3g просто немає достатньо відомостей для
того, щоб виконати роботу правильно. Посилання \s-1NTFS\s0 можуть містити літери
дисків і посилання на \s-1GUID\s0 зовнішніх пристроїв, які не може бути оброблено у
ntfs\-3g. У цьому випадку, майже завжди, функції, які викликають libguestfs,
мають ігнорувати дії ntfs\-3g (тобто не використовувати \*(L"guestfs_readlink\*(R"
на томах \s-1NTFS\s0).
.PP
Замість цього, якщо у файловій системі ntfs\-3g трапиться символічне
посилання, слід скористатися \*(L"guestfs_lgetxattr\*(R" для читання розширеного
атрибута \f(CW\*(C`system.ntfs_reparse_data\*(C'\fR і прочитати дані повторної обробки з
нього (формат документовано у багатьох місцях в інтернеті).
.PP
\fIРОЗШИРЕНІ АТРИБУТИ НА ФАЙЛОВИХ СИСТЕМАХ \s-1NTFS\-3G\s0\fR
.IX Subsection "РОЗШИРЕНІ АТРИБУТИ НА ФАЙЛОВИХ СИСТЕМАХ NTFS-3G"
.PP
Існують інші корисні атрибути, які можна читати з файлових систем ntfs\-3g
(за допомогою \*(L"guestfs_getxattr\*(R"). Див.:
.PP
http://www.tuxera.com/community/ntfs\-3g\-advanced/extended\-attributes/
.PP
\fIПРИСИПЛЯННЯ \s-1WINDOWS\s0  ТА ШВИДКИЙ ЗАПУСК \s-1WINDOWS 8\s0\fR
.IX Subsection "ПРИСИПЛЯННЯ WINDOWS ТА ШВИДКИЙ ЗАПУСК WINDOWS 8"
.PP
Гостьові системи Windows, які було приспано (замість повного вимикання) не
можна монтувати. Це обмеження ntfs\-3g. Ви побачите ось таке повідомлення про
помилку:
.PP
.Vb 7
\& The disk contains an unclean file system (0, 0).
\& Metadata kept in Windows cache, refused to mount.
\& Failed to mount \*(Aq/dev/sda2\*(Aq: Operation not permitted
\& The NTFS partition is in an unsafe state. Please resume
\& and shutdown Windows fully (no hibernation or fast
\& restarting), or mount the volume read\-only with the
\& \*(Aqro\*(Aq mount option.
.Ve
.PP
У Windows 8 кнопка вимикання не вимикає гостьову систему. Замість цього, ця
кнопка присипляє гостьову систему. Ця можливість відома як «швидкий запуск».
.PP
Ось пропоновані шляхи обійти проблему:
.IP "\(bu" 4
Монтування у режимі лише читання (наприклад, \*(L"guestfs_mount_ro\*(R").
.IP "\(bu" 4
У Windows 8 вимкніть швидкий запуск. Відповідним пунктом є такий: Панель
керування → Живлення → Виберіть дію для кнопки живлення → Змінити параметри,
які зараз недоступні → Увімкнути швидкий запуск.
.IP "\(bu" 4
У Windows 7 та попередніх версіях вимкніть гостьову систему належним чином
замість присипляння системи.
.SS "ПОМИЛКИ \s-1RESIZE2FS\s0"
.IX Subsection "ПОМИЛКИ RESIZE2FS"
Для зміни розмірів файлових систем ext2/3/4 використовуються виклики
\&\*(L"guestfs_resize2fs\*(R", \*(L"guestfs_resize2fs_size\*(R" і \*(L"guestfs_resize2fs_M\*(R".
.PP
Базова програма (\fBresize2fs\fR\|(8)) потребує, щоб файлова система не мала
прапорця змін і була нещодавно перевірена fsck, перш ніж ви зможете змінити
її розмір. Крім того, якщо дія зі зміни розміру завершується помилкою з
якоїсь причини, вам слід викликати fsck для файлової системи, щоб виправити
її.
.PP
У libguestfs \f(CW\*(C`lt\*(C'\fR 1.17.14 вам, зазвичай, потрібно було викликати
\&\*(L"guestfs_e2fsck_f\*(R" до зміни розміру. Втім, у \f(CW\*(C`ge\*(C'\fR 1.17.14 \fBe2fsck\fR\|(8)
викликається автоматично до зміни розміру, отже потреби у явному виклику вже
немає.
.PP
Робота програми \fBresize2fs\fR\|(8) все ще може завершитися помилкою. У цьому
випадку програма виводить повідомлення про помилку, подібне до такого:
.PP
.Vb 2
\& Будь ласка, запустіть «e2fsck \-fy <пристрій>», щоб виправити файлову систему
\& після переривання дії зі зміни розмірів.
.Ve
.PP
Ви можете зробити це, викликавши \*(L"guestfs_e2fsck\*(R" з параметром
\&\f(CW\*(C`forceall\*(C'\fR. Втім, у контексті образів дисків, зазвичай, краще уникати таких
ситуацій, наприклад, поверненням до попереднього знімка або копіюванням і
зміною розміру і поверненням до початкового стану, якщо станеться помилка.
.SS "ВИКОРИСТАННЯ \s-1LIBGUESTFS\s0 ЗА ДОПОМОГОЮ ІНШИХ МОВ ПРОГРАМУВАННЯ"
.IX Subsection "ВИКОРИСТАННЯ LIBGUESTFS ЗА ДОПОМОГОЮ ІНШИХ МОВ ПРОГРАМУВАННЯ"
Хоча у нас немає намірів забороняти вам використовувати програмний інтерфейс
C, тут ми будемо нагадувати, що той самий програмний інтерфейс також
доступний іншими мовами програмування.
.PP
Загалом, програмний інтерфейс усіма підтримуваними мовами є ідентичним. Це
означає, що виклик мовою C \f(CW\*(C`guestfs_add_drive_ro(g,file)\*(C'\fR ідентичний до
\&\f(CW\*(C`$g\->add_drive_ro($file)\*(C'\fR у Perl, \f(CW\*(C`g.add_drive_ro(file)\*(C'\fR у Python, і
\&\f(CW\*(C`g#add_drive_ro file\*(C'\fR в OCaml. Іншими словами, існує прямий, передбачуваний
ізоморфізм між усіма мовами.
.PP
Повідомлення про помилки буде автоматично перетворено на виключення, якщо
підтримку таких передбачено у відповідній мові програмування.
.PP
Ми не намагаємося виконати «об'єктне орієнтування» частин програмного
інтерфейсу у об'єктно орієнтованих мовах програмування, хоча ми будемо раді,
якщо учасники розробки, якщо це потрібно, зможуть написати високорівневі
програмні інтерфейси до вказаних вище програмних інтерфейсів, які ми
надаємо, їхніми улюбленими мовами програмування.
.IP "\fB\*(C+\fR" 4
.IX Item ""
Ви можете скористатися файлом заголовків \fIguestfs.h\fR з програм
\&\*(C+. Програмний інтерфейс \*(C+ є ідентичним до програмного інтерфейсу
C. Класи і виключення \*(C+ не використовуються.
.IP "\fBC#\fR" 4
.IX Item "C#"
Прив'язки до C# є досить експериментальними. Будь ласка, ознайомтеся із
попередженнями на початку файла \fIcsharp/Libguestfs.cs\fR.
.IP "\fBErlang\fR" 4
.IX Item "Erlang"
Див. \fBguestfs\-erlang\fR\|(3).
.IP "\fBGObject\fR" 4
.IX Item "GObject"
Доступні експериментальні прив'язки GObject (з підтримкою інтроспекції
GObject).
.Sp
Див. \fBguestfs\-gobject\fR\|(3)
.IP "\fBGo\fR" 4
.IX Item "Go"
Див. \fBguestfs\-golang\fR\|(3)
.IP "\fBHaskell\fR" 4
.IX Item "Haskell"
Ця прив’язка до мови працює, але є неповною:
.RS 4
.IP "\(bu" 4
Функції із необов'язковими аргументами не включено до прив'язок. Реалізація
необов'язкових параметрів у Haskell, здається, є доволі складною справою.
.IP "\(bu" 4
Події не обмежено.
.IP "\(bu" 4
Не передбачено прив'язок для функцій із такими повернутими типами:
.RS 4
.IP "\(bu" 4
Будь\-яка функція повертає структуру.
.IP "\(bu" 4
Будь\-яка функція повертає список структур.
.IP "\(bu" 4
Декілька функцій, які повертають буфери фіксованої довжини (зокрема ті, які
оголошено як \f(CW\*(C`RBufferOut\*(C'\fR у генераторі).
.IP "\(bu" 4
Незначна кількість прихованих функцій, які повертають сталі рядки (зокрема
функцій, оголошених як \f(CW\*(C`RConstOptString\*(C'\fR у генераторі).
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\fBJava\fR" 4
.IX Item "Java"
Повна документація міститься у Javadoc, який поширюється разом із
libguestfs. Приклади наведено на сторінці \fBguestfs\-java\fR\|(3).
.IP "\fBLua\fR" 4
.IX Item "Lua"
Див. \fBguestfs\-lua\fR\|(3).
.IP "\fBOCaml\fR" 4
.IX Item "OCaml"
Див. \fBguestfs\-ocaml\fR\|(3).
.IP "\fBPerl\fR" 4
.IX Item "Perl"
Див. \fBguestfs\-perl\fR\|(3) та \fBSys::Guestfs\fR\|(3).
.IP "\fB\s-1PHP\s0\fR" 4
.IX Item "PHP"
Документацію наведено у файлі \f(CW\*(C`README\-PHP\*(C'\fR, який постачається разом із
початковим кодом libguestfs або у пакунку php-libguestfs для вашого
дистрибутива.
.Sp
Прив'язки до \s-1PHP\s0 працюють належним чином лише у 64\-бітових операційних
системах.
.IP "\fBPython\fR" 4
.IX Item "Python"
Див. \fBguestfs\-python\fR\|(3).
.IP "\fBRuby\fR" 4
.IX Item "Ruby"
Див. \fBguestfs\-ruby\fR\|(3).
.Sp
Щоб скористатися JRuby, використовуйте прив'язки до Java.
.IP "\fBскрипти оболонки\fR" 4
.IX Item "скрипти оболонки"
Див. \fBguestfish\fR\|(1).
.SS "ПРОБЛЕМНІ МІСЦЯ \s-1LIBGUESTFS\s0"
.IX Subsection "ПРОБЛЕМНІ МІСЦЯ LIBGUESTFS"
http://en.wikipedia.org/wiki/Gotcha_(programming): «Можливість системи
[...], яка працює у документований спосіб, але не є інтуїтивно зрозумілою і
неначебто запрошує до помилок.»
.PP
З часу створення libguestfs та пов'язаних інструментів існує декілька речей,
які зараз ми б зробили інакше, але мусимо дотримуватися зворотної сумісності
або не можемо їх змінити з інших причин. Якщо колись відбудеться випуск
libguestfs 2.0, ми можемо змінити ці речі. Майте це на увазі.
.IP "Типовим режимом має бути «лише читання»." 4
.IX Item "Типовим режимом має бути «лише читання»."
У \fBguestfish\fR\|(3) параметр \fI\-\-ro\fR має бути типовим. Вам слід вказувати
параметр \fI\-\-rw\fR явним чином, якщо ви хочете внести зміни до образу.
.Sp
Це має зменшити ризик потенційного пошкодження образів віртуальних машин.
.Sp
Зауважте, що до багатьох файлових систем зміни вносяться простим монтуванням
із наступним демонтуванням, навіть якщо до файлової системи нічого не
записується. Вам слід використовувати \*(L"guestfs_add_drive_ro\*(R", щоб
гарантувати, що диск не буде змінено.
.IP "Командним рядком guestfish важко користуватися." 4
.IX Item "Командним рядком guestfish важко користуватися."
Команда \fIguestfish образ.диска\fR не виконує тих дій, на які сподіваються
користувачі (відкриття образу \fIобраз.диска\fR для вивчення). Ця команда
намагається виконати команду guestfish \fIобраз.диска\fR, якої не існує, отже,
виводиться повідомлення про помилку. У ранніх версіях guestfish це
повідомлення було незрозумілим, але з того часу його було
виправлено. Подібно до bash, варто було б використовувати команду
\&\f(CW\*(C`guestfish \-c команда\*(C'\fR для виконання команд.
.IP "Модифікатори вимірювання у мегабайтах guestfish не працюють як слід для усіх команд" 4
.IX Item "Модифікатори вимірювання у мегабайтах guestfish не працюють як слід для усіх команд"
У свіжих версіях guestfish ви можете скористатися записом \f(CW\*(C`1M\*(C'\fR на
позначення 1 мегабайта (та подібних одиниць виміру пам'яті). Насправді,
guestfish просто множить числову частину запису на частину модифікатора і
передає результат програмному інтерфейсу C. Втім, це не працює для декількох
програмних інтерфейсів, яким передаються не значення у байтах, а значення у
якихось інших одиницях (наприклад, у мегабайтах).
.Sp
Найпоширенішим прикладом є \*(L"guestfs_lvcreate\*(R". Ось така команда guestfish:
.Sp
.Vb 1
\& lvcreate LV VG 100M
.Ve
.Sp
не виконує тих дій, на які слід було б сподіватися. Замість цього, оскільки
\&\*(L"guestfs_lvcreate\*(R" вже передаються розміри у мегабайтах, виконується
спроба створити логічний том у 100 \fIтерабайтів\fR (100 мегабайтів *
мегабайтів). Повідомлення про помилку, яке ви побачите у відповідь на цю
команду, теж дещо незрозуміле.
.Sp
Цю ваду можна було б виправити у генераторі спеціальним позначенням
параметрів і поверненням значень у байтах чи інших одиницях.
.IP "Двозначність між пристроями і шляхами" 4
.IX Item "Двозначність між пристроями і шляхами"
У програмному інтерфейсі є певна неоднозначність між назвою пристрою
(наприклад \fI/dev/sdb2\fR) і подібною до неї назвою шляху. Файл у каталозі
\&\fI/dev\fR також можна викликати за допомогою \f(CW\*(C`sdb2\*(C'\fR (якщо розглядати якийсь
образ віртуальної машини, відмінної від Unix).
.Sp
У поточному програмному інтерфейсі ми, зазвичай, усуваємо цю неоднозначність
використанням двох окремих викликів, наприклад \*(L"guestfs_checksum\*(R" і
\&\*(L"guestfs_checksum_device\*(R". Деякі з викликів програмного інтерфейсу є
неоднозначними і вирішують (неправильно) проблему, визначаючи, чи наданий
шлях починається з \fI/dev/\fR.
.Sp
Щоб уникнути неоднозначностей та потреби у дублюванні викликів, можна
перетворити шляхи/пристрої на структуровані назви. Одним зі способів досягти
цього є використання позначень у стилі (\f(CW\*(C`hd(0,0)\*(C'\fR), хоча мало кому
подобається цей аспект роботи grub. Іншим способом, яким можна було б
скористатися, є використання структурованого типу, еквівалентного до такого
типу OCaml:
.Sp
.Vb 1
\& type path = Path of string | Device of int | Partition of int * int
.Ve
.Sp
що надало б вам змогу передавати аргументи ось так:
.Sp
.Vb 4
\& Path "/foo/bar"
\& Device 1            (* /dev/sdb або, можливо, /dev/sda *)
\& Partition (1, 2)    (* /dev/sdb2 (або /dev/sda2, або /dev/sdb3?) *)
\& Path "/dev/sdb2"    (* не є пристроєм *)
.Ve
.Sp
Як бачите, у визначенні шляхів є проблема навіть у такому
представленні. Також можете поміркувати над тим, як це може працювати у
guestfish.
.SS "КЛЮЧІ І ПАРОЛІ"
.IX Subsection "КЛЮЧІ І ПАРОЛІ"
Деяким викликам libguestfs передаються параметри, які містять конфіденційні
дані ключів у форматі звичайного рядка C.
.PP
У майбутньому ми сподіваємося змінити реалізацію у libguestfs так, щоб ключі
оброблялися \fBmlock\fR\|(2) у фізичній пам'яті системи і тому ніколи не
опинялися у файлі резервної пам'яті на диску. Втім, дотепер цього \fIне\fR
зроблено через складність такої реалізації.
.PP
Тому вам слід мати на увазі, що будь\-який параметр ключа, який ви передали
libguestfs, може бути записано на розділ резервної пам'яті. Якщо ви цим дуже
занепокоєні, витирайте файл резервної пам'яті або не використовуйте
libguestfs на зашифрованих пристроях.
.SS "ОБРОБКА У ДЕКІЛЬКА ДЕСКРПИТОРІВ І ПОТОКІВ"
.IX Subsection "ОБРОБКА У ДЕКІЛЬКА ДЕСКРПИТОРІВ І ПОТОКІВ"
Усі операції високого рівня у libguestfs синхронізуються. Якщо ви хочете
використовувати libguestfs у асинхронний спосіб, вам слід створити потік
обробки.
.PP
\fIПотоки у libguestfs ≥ 1.38\fR
.IX Subsection "Потоки у libguestfs ≥ 1.38"
.PP
У libguestfs ≥ 1.38 кожен дескриптор (\f(CW\*(C`guestfs_h\*(C'\fR) містить блокування,
яке встановлюється автоматично, коли ви викликаєте функцію
libguestfs. Практичним наслідком цього є те, що ви можете викликати функції
libguestfs для одного дескриптора з різних потоків обробки без потреби у
блокуванні.
.PP
Крім того, починаючи з версії libguestfs ≥ 1.38, остання помилка у
обробці дескриптора (\*(L"guestfs_last_error\*(R", \*(L"guestfs_last_errno\*(R")
зберігається у локальному сховищі даних потоку, тому написання такого ось
коду є безпечним:
.PP
.Vb 2
\& if (guestfs_add_drive_ro (g, drive) == \-1)
\&   fprintf (stderr, "error was: %s\en", guestfs_last_error (g));
.Ve
.PP
навіть коли інші потоки обробки можуть конкурувати за використання одного
дескриптора \f(CW\*(C`g\*(C'\fR.
.PP
\fIПотоки у libguestfs < 1.38\fR
.IX Subsection "Потоки у libguestfs < 1.38"
.PP
У libguestfs < 1.38 вам слід використовувати дескриптор лише у одному
потоці обробки. Або використовуйте дескриптор виключно з одного потоку, або
впровадьте власний семафор так, щоб два потоки не могли видавати виклики для
одного дескриптора одночасно. Навіть доволі невинні функції, подібні до
\&\*(L"guestfs_get_trace\*(R" \fIне можна\fR безпечно викликати без семафора з
декількох потоків обробки одночасно, якщо ви користуєтеся libguestfs <
1.38.
.PP
Скористайтеся \*(L"guestfs_set_identifier\*(R" для спрощення ідентифікації потоків
у даних, виведених засобом трасування.
.SS "ШЛЯХ"
.IX Subsection "ШЛЯХ"
Libguestfs потрібна базова система supermin, яку бібліотека шукає за
внутрішнім шляхом.
.PP
Типово, пошук відбувається у каталозі \f(CW\*(C`$libdir/guestfs\*(C'\fR (наприклад
\&\fI/usr/local/lib/guestfs\fR або \fI/usr/lib64/guestfs\fR).
.PP
Скористайтеся \*(L"guestfs_set_path\*(R" або встановіть значення змінної
середовища \*(L"\s-1LIBGUESTFS_PATH\*(R"\s0, щоб змінити каталоги, у який вестиме пошук
libguestfs. Значенням має бути список шляхів, відокремлених
двокрапками. Пошук у поточному каталозі \fIне\fR виконуватиметься, якщо у
записі шляхів не буде порожнього елемента або елемента \f(CW\*(C`.\*(C'\fR. Наприклад,
\&\f(CW\*(C`LIBGUESTFS_PATH=:/usr/lib/guestfs\*(C'\fR означає, що пошук виконуватиметься
спочатку у поточному каталозі, а потім у каталозі \fI/usr/lib/guestfs\fR.
.SS "ОБГОРТКИ \s-1QEMU\s0"
.IX Subsection "ОБГОРТКИ QEMU"
Якщо ви хочете зібрати власну версію qemu, запускати qemu із нестандартного
каталогу або передавати qemu додаткові аргументи, ви можете написати
скрипт\-обгортку для командної оболонки для запуску qemu.
.PP
Існує одне важливе правило, про яке слід пам'ятати: вам \fIслід виконати
\&\f(CI\*(C`exec qemu\*(C'\fI\fR як останню команду у скрипті оболонки (отже, qemu заміняє
командну оболонку і стає безпосереднім дочірнім процесом програми, яка
використовує libguestfs). Якщо ви цього не зробите, процес qemu не буде
належним чином очищено.
.PP
Ось приклад обгортки, де використано зібрану власну копію qemu:
.PP
.Vb 3
\& #!/bin/sh \-
\& qemudir=/home/rjones/d/qemu
\& exec $qemudir/x86_64\-softmmu/qemu\-system\-x86_64 \-L $qemudir/pc\-bios "$@"
.Ve
.PP
Збережіть цей скрипт як \fI/tmp/qemu.wrapper\fR (або під якоюсь іншою назвою),
\&\f(CW\*(C`chmod +x\*(C'\fR, а далі скористайтеся ним для встановлення значення змінної
середовища \s-1LIBGUESTFS_HV.\s0 Приклад:
.PP
.Vb 1
\& LIBGUESTFS_HV=/tmp/qemu.wrapper guestfish
.Ve
.PP
Зауважте, що libguestfs також викликає qemu із параметрами \-help і \-version
з метою визначення переліку можливостей програми.
.PP
Обгортками також можна скористатися для редагування параметрів, які
передаються qemu. У наведеному нижче прикладі параметр \f(CW\*(C`\-machine ...\*(C'\fR
(параметр \f(CW\*(C`\-machine\*(C'\fR і наступний за ним аргумент) вилучається з рядка
команди і замінюється на \f(CW\*(C`\-machine pc,accel=tcg\*(C'\fR. Цикл while виконує
ітерацію параметрами, аж доки не буде знайдено належний параметр для
вилучення, розташовуючи решту параметрів у масиві \f(CW\*(C`args\*(C'\fR.
.PP
.Vb 1
\& #!/bin/bash \-
\& 
\& i=0
\& while [ $# \-gt 0 ]; do
\&     case "$1" in
\&     \-machine)
\&         shift 2;;
\&     *)
\&         args[i]="$1"
\&         (( i++ ))
\&         shift ;;
\&     esac
\& done
\& 
\& exec qemu\-kvm \-machine pc,accel=tcg "${args[@]}"
.Ve
.SS "МОДУЛЬ"
.IX Subsection "МОДУЛЬ"
Модуль обробки (раніше ми його називали «метод долучення») керує тим, як
libguestfs створює і/або з'єднується із фоновою службою модуля обробки,
наприклад, запускаючи qemu безпосередньо або використовуючи libvirt для
керування базовою системою, запускаючи User-Mode Linux або з'єднуючись із
вже запущеною фоновою службою.
.PP
Встановити цей модуль можна викликом \*(L"guestfs_set_backend\*(R" або
встановленням значення змінної середовища \f(CW\*(C`LIBGUESTFS_BACKEND\*(C'\fR.
.PP
Можливі модуля описано нижче:
.ie n .IP """direct""" 4
.el .IP "\f(CWdirect\fR" 4
.IX Item "direct"
.PD 0
.ie n .IP """appliance""" 4
.el .IP "\f(CWappliance\fR" 4
.IX Item "appliance"
.PD
Запустити qemu безпосередньо для запуску базової системи.
.Sp
\&\f(CW\*(C`direct\*(C'\fR і \f(CW\*(C`appliance\*(C'\fR є синонімами.
.Sp
Це звичайний метод і за звичних умов цей метод є типовим, але зверніть увагу
на наведену нижче нотатку.
.ie n .IP """libvirt""" 4
.el .IP "\f(CWlibvirt\fR" 4
.IX Item "libvirt"
.PD 0
.ie n .IP """libvirt:null""" 4
.el .IP "\f(CWlibvirt:null\fR" 4
.IX Item "libvirt:null"
.ie n .IP """libvirt:\fIадреса\fP""" 4
.el .IP "\f(CWlibvirt:\f(CIадреса\f(CW\fR" 4
.IX Item "libvirt:адреса"
.PD
Скористатися libvirt для запуску і керування базовою системою.
.Sp
\&\f(CW\*(C`libvirt\*(C'\fR спричиняє вибір libguestfs відповідної адреси для створення
гостьових операційних систем сеансу. Якщо використовується модуль обробки
libvirt, вам майже завжди слід це використовувати.
.Sp
\&\f(CW\*(C`libvirt:null\*(C'\fR спричиняє вибір libguestfs використання \f(CW\*(C`NULL\*(C'\fR як адреси
з'єднання, що призводить до того, що libvirt намагається вгадати наміри
користувача. Ймовірно, вам не слід використовувати таку адресу.
.Sp
\&\f(CW\*(C`libvirt:\f(CIадреса\f(CW\*(C'\fR спричиняє використання адреси \fIадреса\fR як адреси
з'єднання libvirt (див. http://libvirt.org/uri.html). Типовим модулем
libvirt із вказаною адресою буде \f(CW\*(C`libvirt:qemu:///session\*(C'\fR
.Sp
У модулі обробки libvirt передбачено більше можливостей, зокрема можливість
з'єднання у «гарячому» режимі (див. \*(L"З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ\*(R") та
sVirt.
.ie n .IP """uml""" 4
.el .IP "\f(CWuml\fR" 4
.IX Item "uml"
Запустити ядро User-Mode Linux. Розташування ядра встановлюється за
допомогою \f(CW$LIBGUESTFS_HV\fR або за допомогою програмного інтерфейсу
\&\*(L"guestfs_set_qemu\*(R" (зауважте, що qemu не задіяно, ми просто повторно
використовуємо ту саму змінну середовища у дескрипторі для зручності).
.Sp
User-Mode Linux може бути набагато швидшим, простішим і невибагливішим до
ресурсів за повноцінну віртуальну машину, але у нього є певні
недоліки. Див. \*(L"МОДУЛЬ USER-MODE \s-1LINUX\*(R"\s0 нижче.
.ie n .IP """unix:\fIшлях\fP""" 4
.el .IP "\f(CWunix:\f(CIшлях\f(CW\fR" 4
.IX Item "unix:шлях"
Встановити з’єднання з сокетом домену Unix \fIшлях\fR.
.Sp
Цей метод надає вам змогу з'єднуватися із наявною фоновою службою або (за
допомогою virtio-serial) із запущеною гостьовою системою. Щоб дізнатися
більше, див. \*(L"ДОЛУЧЕННЯ ДО ЗАПУЩЕНИХ ФОНОВИХ СЛУЖБ\*(R".
.PP
\&\f(CW\*(C`direct\*(C'\fR, зазвичай є типовим модулем обробки. Втім, починаючи з версії
libguestfs ≥ 1.19.24, libguestfs можна зібрати із іншим типовим модулем
за допомогою такого параметра скрипту налаштовування збирання:
.PP
.Vb 1
\& ./configure \-\-with\-default\-backend=...
.Ve
.PP
Щоб визначити, чи було libguestfs зібрано із іншим типовим модулем обробки,
віддайте такі команди:
.PP
.Vb 2
\& unset LIBGUESTFS_BACKEND
\& guestfish get\-backend
.Ve
.SS "ПАРАМЕТРИ МОДУЛІВ"
.IX Subsection "ПАРАМЕТРИ МОДУЛІВ"
Кожен модуль обробки можна налаштувати передаванням списку рядків. Ви можете
або викликати \*(L"guestfs_set_backend_settings\*(R" зі списком рядків, або
встановити для змінної середовища \f(CW\*(C`LIBGUESTFS_BACKEND_SETTINGS\*(C'\fR значення,
яке є списком рядків, які відокремлено двокрапками (до створення
дескриптора).
.PP
\fIforce_tcg\fR
.IX Subsection "force_tcg"
.PP
Використовується:
.PP
.Vb 1
\& export LIBGUESTFS_BACKEND_SETTINGS=force_tcg
.Ve
.PP
примусово визначить для модулів обробки direct та libvirt використання \s-1TCG\s0
(програмної емуляції) замість \s-1KVM\s0 (апаратно прискореної віртуалізації).
.PP
\fIgdb\fR
.IX Subsection "gdb"
.PP
У модулі direct передбачено підтримку:
.PP
.Vb 1
\& export LIBGUESTFS_BACKEND_SETTINGS=gdb
.Ve
.PP
Якщо встановлено таке значення змінної середовища, qemu не розпочинатиме
негайний запуск базової системи. Програма очікуватиме, доки ви з'єднаєтеся
із нею за допомогою gdb:
.PP
.Vb 4
\& $ gdb
\& (gdb) symbol\-file /path/to/vmlinux
\& (gdb) target remote tcp::1234
\& (gdb) cont
.Ve
.PP
Далі, ви можете виконувати діагностику ядра базової системи, чим можна
скористатися для дослідження проблем із завантаженням (особливо таких
проблем, за яких не виводиться діагностичних повідомлень — підказка: шукайте
у \f(CW\*(C`log_buf\*(C'\fR ядра).
.PP
У Fedora встановіть \f(CW\*(C`kernel\-debuginfo\*(C'\fR для файла \f(CW\*(C`vmlinux\*(C'\fR (який містить
символи). Переконайтеся, що символи точно відповідають використаному ядру.
.SS "ДОЛУЧЕННЯ ДО ЗАПУЩЕНИХ ФОНОВИХ СЛУЖБ"
.IX Subsection "ДОЛУЧЕННЯ ДО ЗАПУЩЕНИХ ФОНОВИХ СЛУЖБ"
\&\fIЗауваження (1):\fR це \fBдуже експериментальна\fR можливість, яка може
призводити до пошкодження даних. Будьте обережні.
.PP
\&\fIНотатка (2):\fR у цьому розділі наведено відомості щодо долучення до
запущеної фонової служби з низькорівневою перспективою. Для більшості
користувачів просте використання засобів віртуалізації, зокрема
\&\fBguestfish\fR\|(1), з параметром \fI\-\-live\fR має «просто працювати».
.PP
\fIВикористання guestfs_set_backend\fR
.IX Subsection "Використання guestfs_set_backend"
.PP
За допомогою виклику \*(L"guestfs_set_backend\*(R" ви можете змінити спосіб
з'єднання бібліотеки з фоновою службою \f(CW\*(C`guestfsd\*(C'\fR у \*(L"guestfs_launch\*(R"
(ознайомтеся із розділом \*(L"АРХІТЕКТУРА\*(R" in \fBguestfs\-internals\fR\|(1), щоб дізнатися
більше про основи).
.PP
Звичайним модулем обробки є \f(CW\*(C`direct\*(C'\fR, де створюється мала базова система,
яка містить фонову службу, з якою згодом з'єднується бібліотека. \f(CW\*(C`libvirt\*(C'\fR
або \f(CW\*(C`libvirt:\f(CIадреса\f(CW\*(C'\fR є альтернативами, які використовують libvirt для
запуску базової системи.
.PP
Встановлення для модуля обробки значення \f(CW\*(C`unix:\f(CIшлях\f(CW\*(C'\fR (де \fIшлях\fR — це
шлях до сокета домену Unix) призводить до того, що \*(L"guestfs_launch\*(R"
з'єднується із наявною фоновою службою за допомогою сокета домену Unix.
.PP
Звичним використанням цього є встановлення з'єднання з запущеною віртуальною
машиною, які містить фонову службу \f(CW\*(C`guestfsd\*(C'\fR, і надсилання команд, щоб
можна було читати і записувати файли у запущеній віртуальній машині.
.PP
\fIЗа допомогою guestfs_add_domain з прапорцем live\fR
.IX Subsection "За допомогою guestfs_add_domain з прапорцем live"
.PP
\&\*(L"guestfs_add_domain\*(R" надає певну допомогу у отриманні відповідного модуля
обробки. Якщо ви передаєте параметр \f(CW\*(C`live\*(C'\fR цій функції, тоді (якщо
віртуальну машину запущено) вона вивчить \s-1XML\s0 libvirt, шукаючи канал
virtio-serial для з'єднання:
.PP
.Vb 11
\& <domain>
\&   ...
\&   <devices>
\&     ...
\&     <channel type=\*(Aqunix\*(Aq>
\&       <source mode=\*(Aqbind\*(Aq path=\*(Aq/path/to/socket\*(Aq/>
\&       <target type=\*(Aqvirtio\*(Aq name=\*(Aqorg.libguestfs.channel.0\*(Aq/>
\&     </channel>
\&     ...
\&   </devices>
\& </domain>
.Ve
.PP
\&\*(L"guestfs_add_domain\*(R" видобуває \fI/шлях/до/сокета\fR і встановлює для модуля
обробки шлях \f(CW\*(C`unix:/шлях/до/сокета\*(C'\fR.
.PP
У деяких із засобів libguestfs (зокрема guestfish) передбачено підтримку
параметра \fI\-\-live\fR, який передається до \*(L"guestfs_add_domain\*(R", таким чином
надаючи вам змогу з'єднуватися і змінювати запущені віртуальні машини.
.PP
Віртуальну машину слід попередньо налаштувати так, щоб у ній був канал
virtio-serial і у ній було запущено guestfsd.
.SS "МОДУЛЬ USER-MODE \s-1LINUX\s0"
.IX Subsection "МОДУЛЬ USER-MODE LINUX"
Встановлення вказаних нижче змінних середовища (або використання відповідних
програмних інтерфейсів) вибирає модуль обробки User-Mode Linux:
.PP
.Vb 2
\& export LIBGUESTFS_BACKEND=uml
\& export LIBGUESTFS_HV=/шлях/до/vmlinux
.Ve
.PP
\&\f(CW\*(C`vmlinux\*(C'\fR (іншою назвою може бути \f(CW\*(C`linux\*(C'\fR) — виконуваний файл Linux,
зібраний для запуску як процес у просторі користувача. Зауважте, що ми
повторно використали змінну qemu у дескрипторі для зручності; qemu вона не
стосується.
.PP
Використання User-Mode Linux може пришвидшити роботу і зменшити вибагливість
до ресурсів системи, порівняно із запуском повноцінної віртуальної машини
для модуля обробки (особливо, якщо ви вже запустили libguestfs у віртуальній
машині або у екземплярі системи в обчислювальній «хмарі»), але цей спосіб
також має певні недоліки, якщо порівнювати його зі звичайним модулем обробки
на основі qemu або \s-1KVM.\s0
.PP
\fIЗБИРАННЯ USER-MODE \s-1LINUX\s0 З ПОЧАТКОВИХ КОДІВ\fR
.IX Subsection "ЗБИРАННЯ USER-MODE LINUX З ПОЧАТКОВИХ КОДІВ"
.PP
У вашому дистрибутиві Linux можуть бути готові пакунки \s-1UML.\s0 Якщо це так,
можете пропустити цей розділ.
.PP
Інструкції запозичено з
http://user\-mode\-linux.sourceforge.net/source.html
.IP "1. Отримати початкові коди Linux" 4
.IX Item "1. Отримати початкові коди Linux"
Клонуйте сховище коду git Linux або отримайте архів tar із початковим кодом
Linux.
.IP "2. Налаштувати збирання ядра" 4
.IX Item "2. Налаштувати збирання ядра"
\&\fBЗауваження:\fR до усіх команд «make» слід додавати \f(CW\*(C`ARCH=um\*(C'\fR.
.Sp
.Vb 1
\& make menuconfig ARCH=um
.Ve
.Sp
Переконайтеся, що усі потрібні вам драйвери файлових систем вкомпільовано до
ядра.
.Sp
\&\fBУ поточній версії потрібні значні додаткові зусилля, щоб змусити працювати
модулі\fR. Рекомендуємо вам вимкнути підтримку модулів у налаштуваннях
ядра. Вимикання підтримки призведе до того, що усі можливості буде зібрано у
одному образі ядра.
.IP "3. Зібрати ядро" 4
.IX Item "3. Зібрати ядро"
.Vb 1
\& make ARCH=um
.Ve
.Sp
Ви отримаєте файл із назвою \f(CW\*(C`linux\*(C'\fR або \f(CW\*(C`vmlinux\*(C'\fR у каталозі верхнього
рівня. Цей файл і є ядром \s-1UML.\s0 Вам слід встановити значення
\&\f(CW\*(C`LIBGUESTFS_HV\*(C'\fR, яке вказуватиме на цей файл.
.PP
\fIВІДМІННОСТІ USER-MODE \s-1LINUX\s0 ВІД \s-1KVM\s0\fR
.IX Subsection "ВІДМІННОСТІ USER-MODE LINUX ВІД KVM"
.IP "У \s-1UML\s0 передбачено підтримку лише образів у форматі raw" 4
.IX Item "У UML передбачено підтримку лише образів у форматі raw"
Працюватимуть лише прості образи у форматі raw. Не можна користуватися ні
qcow2, ні файлами резервних копій.
.IP "У \s-1UML\s0 не передбачено підтримки будь\-яких віддалених дисків" 4
.IX Item "У UML не передбачено підтримки будь-яких віддалених дисків"
Не можна користуватися \s-1NBD\s0 тощо.
.IP "\s-1UML\s0 працює лише на ix86 та x86\-64" 4
.IX Item "UML працює лише на ix86 та x86-64"
.PD 0
.IP "\s-1UML\s0 є експериментальною можливістю" 4
.IX Item "UML є експериментальною можливістю"
.PD
Зокрема, підтримка \s-1UML\s0 у libguestfs залежить від підтримки \s-1UML\s0 у основній
гілці розробки ядра. Якщо \s-1UML\s0 буде вилучено із основного коду ядра Linux,
ймовірно, нам доведеться вилучити його підтримку і з libguestfs.
.SS "ГАРАНТІЯ ЩОДО \s-1ABI\s0"
.IX Subsection "ГАРАНТІЯ ЩОДО ABI"
Ми гарантуємо незмінність \s-1ABI\s0 (двійкового інтерфейсу) libguestfs для
загальних (public) високорівневих дій, як це описано у цьому розділі. Хоча
ми вважаємо деякі з дій застарілими, наприклад, якщо їх замінено новішими
викликами, ми зберігаємо ці дії у двійковому інтерфейсі. Це надає змогу
розробникам програм бути певними у незмінності програмного інтерфейсу
libguestfs.
.SS "ІМЕНУВАННЯ БЛОКОВИХ ПРИСТРОЇВ"
.IX Subsection "ІМЕНУВАННЯ БЛОКОВИХ ПРИСТРОЇВ"
Libguestfs визначає \fI/dev/sd*\fR як \fIстандартну схему іменування\fR для
пристроїв, які передаються викликам програмного інтерфейсу. Отже,
\&\fI/dev/sda\fR означає «перший пристрій, який додано за допомогою
\&\*(L"guestfs_add_drive_opts\*(R"», а \fI/dev/sdb3\fR означає «третій розділ на
другому пристрої».
.PP
На внутрішньому рівні іноді виконується трансляція назв пристроїв, але ця
трансляція лишається невидимою з рівня програмного інтерфейсу.
.PP
\fIМІТКИ ДИСКІВ\fR
.IX Subsection "МІТКИ ДИСКІВ"
.PP
Починаючи з libguestfs ≥ 1.20, ви можете надати диску мітку під час
додавання за допомогою необов'язкового параметра \f(CW\*(C`label\*(C'\fR функції
\&\*(L"guestfs_add_drive_opts\*(R".  (Зауважте, що мітки дисків є самостійними
об'єктами і можуть відрізнятися від міток файлової системи.)
.PP
Підтримку встановлення міток дисків передбачено не в усіх версіях
libguestfs. Якщо підтримку передбачено, то мітку обмежено 20 символами \s-1ASCII\s0
\&\f(CW\*(C`[a\-zA\-Z]\*(C'\fR.
.PP
Після додавання мітки до диска ви можете використовувати як його адресу або
\&\fI/dev/sd*\fR, або \fI/dev/disk/guestfs/\fIмітка\fI\fR. Вказувати на розділи диска
можна за допомогою адреси \fI/dev/disk/guestfs/\fIмітка\fI\fIномер_розділу\fI\fR.
.PP
Команди виведення списку пристроїв (\*(L"guestfs_list_devices\*(R") та розділів
(\*(L"guestfs_list_partitions\*(R") повертають назви блокових пристроїв. Втім, ви
можете скористатися \*(L"guestfs_list_disk_labels\*(R" для прив'язування міток
дисків до назв блокових пристроїв і розділів.
.SS "НУЛЬОВІ ДИСКИ"
.IX Subsection "НУЛЬОВІ ДИСКИ"
При додавання диска за допомогою, наприклад, \*(L"guestfs_add_drive\*(R", ви
можете встановити для назви файла значення \f(CW"/dev/null"\fR. Цей рядок у
libguestfs обробляється особливо, спричиняючи додавання «нуль\-диска».
.PP
Нуль\-диск має такі властивості:
.IP "\(bu" 4
Нуль\-диск буде показано як звичайний пристрій, наприклад, у викликах
\&\*(L"guestfs_list_devices\*(R".
.IP "\(bu" 4
Ви можете додавати пристрій \f(CW"/dev/null"\fR декілька разів.
.IP "\(bu" 4
Вам не слід намагатися отримати доступ до нуль\-диска у будь\-який
спосіб. Наприклад, не варто намагатися прочитати з нього дані або змонтувати
його.
.PP
Передбачено три основних призначення нульових дисків:
.IP "1." 4
Тестування швидкодії libguestfs (див. \fBguestfs\-performance\fR\|(1)).
.IP "2." 4
Вбудований комплекс для перевірки.
.IP "3." 4
Якщо ви хочете скористатися програмними інтерфейсами libguestfs, які не
посилаються на диски, оскільки libguestfs вимагає додавання принаймні одного
диска, вам слід додати нуль\-диск.
.Sp
Наприклад, щоб перевірити, чи доступна певна можливість, скористайтеся
кодом, подібним до такого:
.Sp
.Vb 2
\& guestfs_h *g;
\& char **groups = [ "btrfs", NULL ];
\& 
\& g = guestfs_create ();
\& guestfs_add_drive (g, "/dev/null");
\& guestfs_launch (g);
\& if (guestfs_available (g, groups) == 0) {
\&   // group(s) are available
\& } else {
\&   // group(s) are not available
\& }
\& guestfs_close (g);
.Ve
.SS "ФОРМАТИ ОБРАЗІВ ДИСКІВ"
.IX Subsection "ФОРМАТИ ОБРАЗІВ ДИСКІВ"
Віртуальні диски зберігаються у декількох форматах. Нижче наведено список
найпоширеніших форматів.
.PP
Зауважте, що за роботу із форматами дисків сама libguestfs не відповідає:
усю роботу виконує \fBqemu\fR\|(1). Якщо не передбачено підтримки якогось формату
або у підтримці формату буде виявлено вади, виправляти це слід у qemu.
.PP
\fIТИПОВІ ФОРМАТИ ОБРАЗІВ ВІРТУАЛЬНИХ ДИСКІВ\fR
.IX Subsection "ТИПОВІ ФОРМАТИ ОБРАЗІВ ВІРТУАЛЬНИХ ДИСКІВ"
.IP "\fIraw\fR" 4
.IX Item "raw"
Простий формат (raw) — це просто дамп послідовних байтів віртуального
диска. У ньому немає заголовка, контейнера, стискання, він не є результатом
будь\-якої обробки цього набору байтів.
.Sp
Оскільки для читання або запису даних простий формат не потребує ніякої
проміжної обробки, робота з ним дуже швидка, а підтримка його у qemu та усіх
інших гіпервізорах є дуже доброю. Цей формат можна вважати універсальним,
доступ до даних у якому зможе отримати будь\-який гіпервізор.
.Sp
Дані у простому форматі (raw) не стискаються, отже займають на диску рівно
стільки місця, скільки займає початковий образ диска, навіть якщо на ньому
зовсім немає даних. У різновиді цього формату (принаймні у Linux/Unix)
усунено потребу у зберіганні діапазонів нульових байтів шляхом використання
так званих розріджених файлів. Цей варіант формату іноді називають «простим
розрідженим» (\fIraw sparse\fR). Багато інструментів, зокрема
\&\fBvirt\-sparsify\fR\|(1), можуть перетворювати прості образи дисків у розріджені.
.IP "\fIqcow2\fR" 4
.IX Item "qcow2"
Qcow2 — природний формат образів дисків, який використовується у qemu. На
внутрішньому рівні використовується дворівнева структура каталогів, отже, у
файлі зберігаються лише блоки, які містять дані. Також передбачено багато
інших можливостей, зокрема стискання даних, знімки та резервне копіювання
файлів.
.Sp
Існує принаймні два різних варіанти цього формату. Втім, qemu (а отже,
libguestfs) обробляє обидва формати прозоро для користувача.
.IP "\fIvmdk\fR" 4
.IX Item "vmdk"
\&\s-1VMDK\s0 — природний формат образів дисків VMware. Існує багато варіацій. У
сучасних версіях qemu (а отже, і у libguestfs) передбачено підтримку
більшості варіацій, але вам слід мати на увазі те, що у застарілих версіях
qemu у цьому аспекті є серйозні вади, які можуть призводити до пошкодження
даних.
.Sp
Зауважте, що \s-1ESX\s0 VMware надає файли із назвою \fIguest\-flat.vmdk\fR.  Це не
файли у форматі \s-1VMDK.\s0 Це дані у простому форматі (raw), які просто записано
до файла із суфіксом назви \f(CW\*(C`.vmdk\*(C'\fR.
.IP "\fIvdi\fR" 4
.IX Item "vdi"
\&\s-1VDI\s0 — є природним форматом образів дисків VirtualBox. У qemu (а отже і у
libguestfs) передбачено загалом непогану підтримку даних у цьому форматі.
.IP "\fIvpc\fR" 4
.IX Item "vpc"
.PD 0
.IP "\fIvhd\fR" 4
.IX Item "vhd"
.PD
\&\s-1VPC\s0 (застарілий) та \s-1VHD\s0 (сучасний) — формати образів дисків, які розроблено
Microsoft (а перед тим, Connectix) для Virtual \s-1PC\s0 та Hyper-V.
.IP "Застарілі формати" 4
.IX Item "Застарілі формати"
Наведені далі формати є застарілими. Вам не слід ними користуватися: \fIqcow\fR
(або \fIqcow1\fR), \fIcow\fR, \fIbochs\fR.
.PP
\fIВИЗНАЧЕННЯ ФОРМАТУ ОБРАЗУ ДИСКА\fR
.IX Subsection "ВИЗНАЧЕННЯ ФОРМАТУ ОБРАЗУ ДИСКА"
.PP
По\-перше, зверніть увагу на прогалину у захисті, пов'язану із автоматичним
визначенням формату образу диска.  Вона може стосуватися вашого процесу
використання. Див. розділ \*(L"\s-1CVE\-2010\-3851\*(R"\s0 нижче.
.PP
Libguestfs offers an \s-1API\s0 to get the format of a disk image
(\*(L"guestfs_disk_format\*(R"), and it is safest to use this.
.PP
\&\fIНе\fR захоплюйтесь спробами обробки тексту або виведених для зручного
читання даних \f(CW\*(C`qemu\-img\*(C'\fR, оскільки ці дані не можна обробити надійним і
безпечним чином. Не використовуйте команду \f(CW\*(C`file\*(C'\fR, оскільки виведені нею
дані є різними для різних версій бібліотеки.
.SH "КЕРУВАННЯ З’ЄДНАННЯМ"
.IX Header "КЕРУВАННЯ З’ЄДНАННЯМ"
.SS "guestfs_h *"
.IX Subsection "guestfs_h *"
\&\f(CW\*(C`guestfs_h\*(C'\fR є непрозорим типом, який представляє дескриптор
з'єднання. Створіть дескриптор викликом \*(L"guestfs_create\*(R" або
\&\*(L"guestfs_create_flags\*(R".  Викличте \*(L"guestfs_close\*(R", щоб звільнити
дескриптор і усі використані ним ресурси.
.PP
Щоб дізнатися більше про обробку у декілька дескрипторів і у декілька
потоків, ознайомтеся із розділом \*(L"ОБРОБКА У ДЕКІЛЬКА ДЕСКРПИТОРІВ І
ПОТОКІВ\*(R" вище.
.SS "guestfs_create"
.IX Subsection "guestfs_create"
.Vb 1
\& guestfs_h *guestfs_create (void);
.Ve
.PP
Створити дескриптор з’єднання.
.PP
Якщо виконано успішно, повертає непорожній вказівник на дескриптор. Якщо
станеться помилка, повертає \s-1NULL.\s0
.PP
Після створення дескриптор слід «налаштувати». Для цього слід викликати
\&\*(L"guestfs_add_drive_opts\*(R" (або одну з інших еквівалентних функцій) для
дескриптора принаймні один раз.
.PP
Після налаштовування дескриптора вам слід викликати \*(L"guestfs_launch\*(R".
.PP
Ви також можете налаштувати обробку помилок для дескриптора. Див. розділ
\&\*(L"ОБРОБКА ПОМИЛОК\*(R" нижче.
.SS "guestfs_create_flags"
.IX Subsection "guestfs_create_flags"
.Vb 1
\& guestfs_h *guestfs_create_flags (unsigned flags [, ...]);
.Ve
.PP
Створює дескриптор з'єднання, надаючи додаткові прапорці та аргументи для
керування створенням дескриптора.
.PP
Якщо виконано успішно, повертає непорожній вказівник на дескриптор. Якщо
станеться помилка, повертає \s-1NULL.\s0
.PP
\&\*(L"guestfs_create\*(R" еквівалентна виклику \f(CWguestfs_create_flags(0)\fR.
.PP
Наведені нижче прапорці може бути поєднано за допомогою логічного АБО (у
поточній версії додаткові аргументи не використовуються).
.ie n .IP """GUESTFS_CREATE_NO_ENVIRONMENT""" 4
.el .IP "\f(CWGUESTFS_CREATE_NO_ENVIRONMENT\fR" 4
.IX Item "GUESTFS_CREATE_NO_ENVIRONMENT"
Не обробляти змінні середовища (зокрема \f(CW\*(C`LIBGUESTFS_DEBUG\*(C'\fR).
.Sp
Згодом ви можете викликати \*(L"guestfs_parse_environment\*(R" або
\&\*(L"guestfs_parse_environment_list\*(R" для обробки змінних середовища. Крім
того, можна \fIне\fR викликати ці функції, якщо ви не хочете, щоб на роботу
дескриптора впливали змінні середовища. Див. наведений нижче приклад.
.Sp
Типовою поведінкою (якщо цей прапорець не встановлено явно) є неявний виклик
\&\*(L"guestfs_parse_environment\*(R".
.ie n .IP """GUESTFS_CREATE_NO_CLOSE_ON_EXIT""" 4
.el .IP "\f(CWGUESTFS_CREATE_NO_CLOSE_ON_EXIT\fR" 4
.IX Item "GUESTFS_CREATE_NO_CLOSE_ON_EXIT"
Не намагатися закрити дескриптор у обробнику \fBatexit\fR\|(3), якщо програма
завершує роботу без закриття дескриптора явним чином.
.Sp
Типовою поведінкою (якщо цей прапорець не встановлено явно) є встановлення
також обробника atexit.
.PP
\fIВИКОРИСТАННЯ \f(CI\*(C`GUESTFS_CREATE_NO_ENVIRONMENT\*(C'\fI\fR
.IX Subsection "ВИКОРИСТАННЯ GUESTFS_CREATE_NO_ENVIRONMENT"
.PP
Ви можете скористатися \f(CW\*(C`GUESTFS_CREATE_NO_ENVIRONMENT\*(C'\fR і явним викликом
\&\*(L"guestfs_parse_environment\*(R" ось так:
.PP
.Vb 2
\& guestfs_h *g;
\& int r;
\& 
\& g = guestfs_create_flags (GUESTFS_CREATE_NO_ENVIRONMENT);
\& if (!g) {
\&   perror ("guestfs_create_flags");
\&   exit (EXIT_FAILURE);
\& }
\& r = guestfs_parse_environment (g);
\& if (r == \-1)
\&   exit (EXIT_FAILURE);
.Ve
.PP
Крім того, для створення дескриптора, на який не впливатимуть змінні
середовища, усуньте виклики \f(CW\*(C`guestfs_parse_environment\*(C'\fR з наведеного вище
коду.
.PP
У наведеного вище коду є ще одна перевага: усі помилки під час обробки
середовища передаються обробнику помилок, тоді як \f(CW\*(C`guestfs_create\*(C'\fR виводить
повідомлення про помилки до stderr і ігнорує помилки.
.SS "guestfs_close"
.IX Subsection "guestfs_close"
.Vb 1
\& void guestfs_close (guestfs_h *g);
.Ve
.PP
Закриває дескриптор з'єднання і звільняє усі використані ресурси. Якщо для
дескриптора було встановлено зворотний виклик закриття, його буде виконано.
.PP
Правильний спосіб закриття дескриптора ось такий:
.PP
.Vb 4
\& if (guestfs_shutdown (g) == \-1) {
\&   /* тут обробляємо помилки запису */
\& }
\& guestfs_close (g);
.Ve
.PP
Потреба у \*(L"guestfs_shutdown\*(R" виникає, лише якщо виконуються \fBусі\fR з
наведених нижче умов:
.IP "1." 4
у режимі читання\-запису було додано один або декілька дисків \fIі\fR
.IP "2." 4
було викликано guestfs_launch, \fIі\fR
.IP "3." 4
вами було внесено якісь зміни, \fIі\fR
.IP "4." 4
ви можете обробляти помилки запису (наприклад, завершенням виконання із
кодом помилки або звітуванням про помилку користувачеві).
.SH "ОБРОБКА ПОМИЛОК"
.IX Header "ОБРОБКА ПОМИЛОК"
Функції програмного інтерфейсу можуть повертати помилки. Наприклад, майже
усі функції, які повертають \f(CW\*(C`int\*(C'\fR, повертатимуть \f(CW\*(C`\-1\*(C'\fR для позначення
помилки.
.PP
Для помилок надається додаткова інформація: рядок повідомлення про помилку
і, необов'язково, номер помилки (errno), якщо помилку було пов'язано із
загальносистемним викликом.
.PP
Ви можете отримати додаткову інформацію щодо останньої помилки для
дескриптора за допомогою виклику \*(L"guestfs_last_error\*(R",
\&\*(L"guestfs_last_errno\*(R" і/або встановлення обробника помилок за допомогою
\&\*(L"guestfs_set_error_handler\*(R".
.PP
Під час створення дескриптора встановлюється типовий обробник помилок, який
виводить рядок повідомлення про помилку до \f(CW\*(C`stderr\*(C'\fR. Для невеличких
програм, які виконуються швидко і керуються з командного рядка, достатньо
зробити ось що:
.PP
.Vb 2
\& if (guestfs_launch (g) == \-1)
\&   exit (EXIT_FAILURE);
.Ve
.PP
оскільки типовий обробник помилок забезпечить виведення повідомлення про
помилку до \f(CW\*(C`stderr\*(C'\fR до завершення роботи програми.
.PP
Для інших програм, майже напевно, слід встановити альтернативний обробник
помилок або обробляти помилки всередині, як у наведеному нижче прикладі. У
прив'язках до мов програмування, відмінних від C, усюди встановлюються
NULL\-обробники помилок, а помилки перетворюються на виключення за допомогою
коду, подібного до такого:
.PP
.Vb 2
\& const char *msg;
\& int errnum;
\& 
\& /* Це вимикає типову поведінку при виведенні помилок
\&    до stderr. */
\& guestfs_set_error_handler (g, NULL, NULL);
\& 
\& if (guestfs_launch (g) == \-1) {
\&   /* Вивчаємо повідомлення про помилку і виводимо його, надсилаємо його
\&      тощо. */
\&   msg = guestfs_last_error (g);
\&   errnum = guestfs_last_errno (g);
\& 
\&   fprintf (stderr, "%s", msg);
\&   if (errnum != 0)
\&     fprintf (stderr, ": %s", strerror (errnum));
\&   fprintf (stderr, "\en");
\& 
\&   /* ... */
\& }
.Ve
.PP
\&\*(L"guestfs_create\*(R" повертає \f(CW\*(C`NULL\*(C'\fR, якщо дескриптор неможливо створити, а
оскільки, якщо таке трапиться, дескриптора не буде, неможливо буде отримати
додаткові відомості щодо помилки. Починаючи з libguestfs ≥ 1.20, ви
можете скористатися \*(L"guestfs_create_flags\*(R" для належної обробки помилок
під час створення дескрипторів, хоча у переважній частині програм можна
продовжувати користуватися \*(L"guestfs_create\*(R" і не перейматися особливо цим
випадком.
.PP
Помилки, пов'язані із нестачею пам'яті, обробляються інакше. Типовою дією є
виклик \fBabort\fR\|(3). Якщо такий виклик є небажаним, ви можете встановити
обробник за допомогою функції \*(L"guestfs_set_out_of_memory_handler\*(R".
.SS "guestfs_last_error"
.IX Subsection "guestfs_last_error"
.Vb 1
\& const char *guestfs_last_error (guestfs_h *g);
.Ve
.PP
Повертає повідомлення про останню помилку, яка трапилася для \f(CW\*(C`g\*(C'\fR. Якщо з
часу створення дескриптора помилок не траплялося, повертає \f(CW\*(C`NULL\*(C'\fR.
.PP
Зауважте, що у повернутому рядку \fIне\fR буде символу нового рядка
наприкінці. Більшість повідомлень про помилки є однорядковими. Деякі
поділено на декілька рядків, вони містять символи \f(CW\*(C`\en\*(C'\fR усередині рядка, але
не наприкінці.
.PP
Повернутий рядок лишається актуальним, аж доки не станеться наступна помилка
для того самого дескриптора або не буде викликано \*(L"guestfs_close\*(R". Якщо
цей рядок потрібен вам на довший термін, скопіюйте його.
.SS "guestfs_last_errno"
.IX Subsection "guestfs_last_errno"
.Vb 1
\& int guestfs_last_errno (guestfs_h *g);
.Ve
.PP
Повертає номер останньої помилки (errno), яка сталася для \f(CW\*(C`g\*(C'\fR.
.PP
Якщо виконано успішно, буде повернуто ненульове ціле число errno.
.PP
У багатьох випадках повертається спеціальне значення errno \f(CW\*(C`ENOTSUP\*(C'\fR, якщо
ви намагаєтеся викликати функцію або скористатися можливістю, підтримки якої
не передбачено.
.PP
Якщо номер помилки недоступний, функція повертає 0. Виклик може повертати 0
у трьох випадках:
.IP "1." 4
Для дескриптора не було зафіксовано жодних помилок.
.IP "2." 4
Сталася помилка, але отримання errno не має сенсу. Таке трапляється у
випадках, коли повідомлення про помилку надійшло не від загальносистемного
виклику, отже причина помилки була якоюсь іншою.
.IP "3." 4
Сталася помилка у загальносистемному виклику, але з якоїсь причини errno не
було перехоплено і повернуто. Це, зазвичай, пов'язано із вадою у libguestfs.
.PP
Libguestfs намагається перетворити errno із внутрішнього для базової системи
у відповідне значення errno для функції виклику (це завдання не є простим: у
базовій системі може бути запущено зовсім іншу операційну систему з
бібліотеки, а номери помилок у Un*x не стандартизовано). Якщо перетворення є
неможливим, повідомлення про помилку перетворюється до \f(CW\*(C`EINVAL\*(C'\fR. На
практиці такі випадки є дуже рідкісними.
.SS "guestfs_set_error_handler"
.IX Subsection "guestfs_set_error_handler"
.Vb 6
\& typedef void (*guestfs_error_handler_cb) (guestfs_h *g,
\&                                           void *opaque,
\&                                           const char *msg);
\& void guestfs_set_error_handler (guestfs_h *g,
\&                                 guestfs_error_handler_cb cb,
\&                                 void *opaque);
.Ve
.PP
Якщо станеться помилка, буде викликано зворотний виклик \f(CW\*(C`cb\*(C'\fR. Параметрами,
які передаються зворотному виклику, є непрозорий вказівник на дані і рядок
повідомлення про помилку.
.PP
\&\f(CW\*(C`errno\*(C'\fR зворотному виклику не передається. Щоб отримати це значення у
зворотному виклику, вам слід викликати \*(L"guestfs_last_errno\*(R".
.PP
Зауважте, що рядок повідомлення \f(CW\*(C`msg\*(C'\fR звільняється, щойно повертається
керування з функції зворотного виклику, отже, якщо ви хочете його десь
зберегти, вам слід зробити його копію.
.PP
Типовий обробник виводить повідомлення до \f(CW\*(C`stderr\*(C'\fR.
.PP
Якщо ви встановите для \f(CW\*(C`cb\*(C'\fR значення \f(CW\*(C`NULL\*(C'\fR, обробник \fIне\fR
викликатиметься.
.SS "guestfs_get_error_handler"
.IX Subsection "guestfs_get_error_handler"
.Vb 2
\& guestfs_error_handler_cb guestfs_get_error_handler (guestfs_h *g,
\&                                                     void **opaque_rtn);
.Ve
.PP
Повертає зворотний виклик поточного обробника помилок.
.SS "guestfs_push_error_handler"
.IX Subsection "guestfs_push_error_handler"
.Vb 3
\& void guestfs_push_error_handler (guestfs_h *g,
\&                                  guestfs_error_handler_cb cb,
\&                                  void *opaque);
.Ve
.PP
Ця функція виконує ті самі дії, що і \*(L"guestfs_set_error_handler\*(R", але
застарілий обробник помилок додається до стеку у самому дескрипторі. Ви
можете відновити попередній обробник помилок за допомогою виклику
\&\*(L"guestfs_pop_error_handler\*(R".
.PP
Скористайтеся таким кодом, щоб тимчасово вимкнути помилки навколо функції:
.PP
.Vb 3
\& guestfs_push_error_handler (g, NULL, NULL);
\& guestfs_mkdir (g, "/foo"); /* Нам все одно, якщо спроба буде невдалою. */
\& guestfs_pop_error_handler (g);
.Ve
.SS "guestfs_pop_error_handler"
.IX Subsection "guestfs_pop_error_handler"
.Vb 1
\& void guestfs_pop_error_handler (guestfs_h *g);
.Ve
.PP
Відновити попередній обробник помилок (див. \*(L"guestfs_push_error_handler\*(R").
.PP
Якщо ви виштовхуватимете обробники зі стосу достатню кількість разів, буде
відновлено типовий обробник помилок.
.SS "guestfs_set_out_of_memory_handler"
.IX Subsection "guestfs_set_out_of_memory_handler"
.Vb 3
\& typedef void (*guestfs_abort_cb) (void);
\& void guestfs_set_out_of_memory_handler (guestfs_h *g,
\&                                         guestfs_abort_cb);
.Ve
.PP
Зворотний виклик \f(CW\*(C`cb\*(C'\fR буде викликано, якщо станеться нестача
пам'яті. \fIЗауважте, що цей зворотний виклик не повинен повертати
керування\fR.
.PP
Типовим є виклик \fBabort\fR\|(3).
.PP
Не можна встановлювати для \f(CW\*(C`cb\*(C'\fR значення \f(CW\*(C`NULL\*(C'\fR. Ви не можете ігнорувати
випадки, коли не вистачає пам'яті.
.SS "guestfs_get_out_of_memory_handler"
.IX Subsection "guestfs_get_out_of_memory_handler"
.Vb 1
\& guestfs_abort_fn guestfs_get_out_of_memory_handler (guestfs_h *g);
.Ve
.PP
Повертає поточний обробник випадків нестачі пам'яті.
.SH "ВИКЛИКИ API"
.IX Header "ВИКЛИКИ API"
.SS "guestfs_acl_delete_def_file"
.IX Subsection "guestfs_acl_delete_def_file"
.Vb 3
\& int
\& guestfs_acl_delete_def_file (guestfs_h *g,
\&                              const char *dir);
.Ve
.PP
Ця функція вилучає типовий список керування доступом \s-1POSIX\s0 (\s-1ACL\s0), який
пов'язано із каталогом \f(CW\*(C`dir\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`acl\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.63)
.SS "guestfs_acl_get_file"
.IX Subsection "guestfs_acl_get_file"
.Vb 4
\& char *
\& guestfs_acl_get_file (guestfs_h *g,
\&                       const char *path,
\&                       const char *acltype);
.Ve
.PP
Ця функція повертає список керування доступом \s-1POSIX\s0 (\s-1ACL\s0), пов'язаний із
\&\f(CW\*(C`path\*(C'\fR. \s-1ACL\s0 буде повернуто у «довгій тестовій формі» (див. \fBacl\fR\|(5)).
.PP
Можливі значення параметра \f(CW\*(C`acltype\*(C'\fR:
.ie n .IP """access""" 4
.el .IP "\f(CWaccess\fR" 4
.IX Item "access"
Повертає звичайний (на доступ) \s-1ACL\s0 для будь\-якого файла, каталогу або іншого
об'єкта файлової системи.
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
Повертає типовий \s-1ACL.\s0 Зазвичай, це має сенс лише, якщо \f(CW\*(C`шлях\*(C'\fR — це каталог.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`acl\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.63)
.SS "guestfs_acl_set_file"
.IX Subsection "guestfs_acl_set_file"
.Vb 5
\& int
\& guestfs_acl_set_file (guestfs_h *g,
\&                       const char *path,
\&                       const char *acltype,
\&                       const char *acl);
.Ve
.PP
Ця функція встановлює список керування доступом \s-1POSIX\s0 (\s-1ACL\s0), пов'язаний із
шляхом \f(CW\*(C`path\*(C'\fR.
.PP
Можливі значення параметра \f(CW\*(C`acltype\*(C'\fR:
.ie n .IP """access""" 4
.el .IP "\f(CWaccess\fR" 4
.IX Item "access"
Встановлює звичайний (на доступ) \s-1ACL\s0 для будь\-якого файла, каталогу або
іншого об'єкта файлової системи.
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
Встановлює типовий \s-1ACL.\s0 Зазвичай, це має сенс лише, якщо \f(CW\*(C`шлях\*(C'\fR — це
каталог.
.PP
Значенням параметра \f(CW\*(C`acl\*(C'\fR є новий \s-1ACL\s0 у «довгій текстовий формі» або
«скороченій текстовій формі» (див. \fBacl\fR\|(5)). Новий \s-1ACL\s0 повністю заміняє
будь\-який попередній \s-1ACL\s0 файла. \s-1ACL\s0 має містити повні права доступу Unix
(наприклад, \f(CW\*(C`u::rwx,g::rx,o::rx\*(C'\fR).
.PP
Якщо ви вказуєте окремих користувачів або групи, слід вказувати і поле маски
(наприклад, \f(CW\*(C`m::rwx\*(C'\fR), за яким слід вказувати  поля
\&\f(CW\*(C`u:\f(CIідентифікатор\f(CW:...\*(C'\fR і/або \f(CW\*(C`g:\f(CIідентифікатор\f(CW:...\*(C'\fR. Отже, повний
рядок \s-1ACL\s0 може виглядати ось так:
.PP
.Vb 2
\& u::rwx,g::rwx,o::rwx,m::rwx,u:500:rwx,g:500:rwx
\& \e      Права Unix        / \eмаска/ \e      ACL        /
.Ve
.PP
Вам слід використовувати числові значення \s-1UID\s0 і \s-1GID.\s0 Щоб пов'язати імена
користувачів та назви груп із правильними значенням ідентифікаторів у
контексті гостьової системи, скористайтеся функціями Augeas
(див. \f(CW\*(C`guestfs_aug_init\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`acl\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.63)
.SS "guestfs_add_cdrom"
.IX Subsection "guestfs_add_cdrom"
.Vb 3
\& int
\& guestfs_add_cdrom (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_add_drive_ro\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця функція додає віртуальний образ компакт\-диска до гостьової системи.
.PP
Образ додається як придатний лише для читання диск, отже ця функція
еквівалентна до \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_add_domain"
.IX Subsection "guestfs_add_domain"
.Vb 4
\& int
\& guestfs_add_domain (guestfs_h *g,
\&                     const char *dom,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 9
\& GUESTFS_ADD_DOMAIN_LIBVIRTURI, const char *libvirturi,
\& GUESTFS_ADD_DOMAIN_READONLY, int readonly,
\& GUESTFS_ADD_DOMAIN_IFACE, const char *iface,
\& GUESTFS_ADD_DOMAIN_LIVE, int live,
\& GUESTFS_ADD_DOMAIN_ALLOWUUID, int allowuuid,
\& GUESTFS_ADD_DOMAIN_READONLYDISK, const char *readonlydisk,
\& GUESTFS_ADD_DOMAIN_CACHEMODE, const char *cachemode,
\& GUESTFS_ADD_DOMAIN_DISCARD, const char *discard,
\& GUESTFS_ADD_DOMAIN_COPYONREAD, int copyonread,
.Ve
.PP
Ця функція додає диски, долучені до вказаного за назвою домену libvirt
\&\f(CW\*(C`dom\*(C'\fR. Вона працює шляхом з'єднання із libvirt,
 надсилання запиту щодо домену і \s-1XML\s0 домену до libvirt, обробки отриманих
даних для дисків і виклику \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR для кожного з дисків.
.PP
Буде повернуто значення кількості доданих дисків. Ця операція є атомарною:
якщо буде повернуто помилку, жодного диска не додано.
.PP
Ця функція виконує деякі мінімальні перевірки, щоб переконатися, що домен
libvirt не запущено (якщо \f(CW\*(C`readonly\*(C'\fR не дорівнює true). У майбутніх версіях
ми спробуємо реалізувати блокування libvirt для кожного диска.
.PP
Диски мають бути доступними. Це часто означає, що додавання дисків з
віддаленого з'єднання libvirt (див. http://libvirt.org/remote.html)
завершиться помилкою, якщо ці диски не є доступними за тією самою адресою
пристрою і локально.
.PP
Необов'язковий параметр \f(CW\*(C`libvirturi\*(C'\fR встановлює адресу libvirt
(див. http://libvirt.org/uri.html). Якщо його не встановлено, ми
з'єднуємося із типовою адресою libvirt (або адресою, встановленою за
допомогою змінної середовища, див. документацію до libvirt, щоб ознайомитися
із подробицями).
.PP
Необов'язковий прапорець \f(CW\*(C`live\*(C'\fR керує тим, чи буде цей виклик намагатися
з'єднатися із запущеним процесом \f(CW\*(C`guestfsd\*(C'\fR віртуальної машини, якщо буде
виявлено відповідний елемент <channel> у визначення \s-1XML\s0
libvirt. Типовою поведінкою (якщо прапорець не встановлено) є поведінка, за
якої спроби робитися не буде. Див. \*(L"ДОЛУЧЕННЯ ДО ЗАПУЩЕНИХ
ФОНОВИХ СЛУЖБ\*(R", щоб дізнатися більше.
.PP
Якщо прапорець \f(CW\*(C`allowuuid\*(C'\fR має значення true (типовим значенням є false),
тоді \fIможе\fR бути передано \s-1UUID\s0 замість назви домену. Рядок \f(CW\*(C`dom\*(C'\fR
обробляється спочатку як \s-1UUID\s0 і виконується пошук. Якщо нічого не вдасться
знайти, \f(CW\*(C`dom\*(C'\fR обробляється як назва, як завжди.
.PP
Необов'язковий параметр \f(CW\*(C`readonlydisk\*(C'\fR керує тим, що ми робимо із дисками,
які позначено як <readonly/> у \s-1XML\s0 libvirt. Можливі значення:
.ie n .IP "readonlydisk = ""error""" 4
.el .IP "readonlydisk = ``error''" 4
.IX Item "readonlydisk = error"
Якщо \f(CW\*(C`readonly\*(C'\fR має значення false:
.Sp
Увесь виклик буде перервано із повідомленням про помилку, якщо буде виявлено
хоча б один диск із прапорцем <readonly/>.
.Sp
Якщо \f(CW\*(C`readonly\*(C'\fR має значення true:
.Sp
Диски із прапорцем <readonly/> додано лише для читання.
.ie n .IP "readonlydisk = ""read""" 4
.el .IP "readonlydisk = ``read''" 4
.IX Item "readonlydisk = read"
Якщо \f(CW\*(C`readonly\*(C'\fR має значення false:
.Sp
Диски із прапорцем <readonly/> додано лише для читання. Інші диски
додано для читання і запису.
.Sp
Якщо \f(CW\*(C`readonly\*(C'\fR має значення true:
.Sp
Диски із прапорцем <readonly/> додано лише для читання.
.ie n .IP "readonlydisk = ""write"" (типово)" 4
.el .IP "readonlydisk = ``write'' (типово)" 4
.IX Item "readonlydisk = write (типово)"
Якщо \f(CW\*(C`readonly\*(C'\fR має значення false:
.Sp
Диски із прапорцем <readonly/> додано для читання і запису.
.Sp
Якщо \f(CW\*(C`readonly\*(C'\fR має значення true:
.Sp
Диски із прапорцем <readonly/> додано лише для читання.
.ie n .IP "readonlydisk = ""ignore""" 4
.el .IP "readonlydisk = ``ignore''" 4
.IX Item "readonlydisk = ignore"
Якщо \f(CW\*(C`readonly\*(C'\fR має значення true або false:
.Sp
Диски з прапорцем <readonly/> буде пропущено.
.PP
Інші необов'язкові параметри передаються безпосередньо до
\&\f(CW\*(C`guestfs_add_drive_opts\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.7.4)
.SS "guestfs_add_domain_va"
.IX Subsection "guestfs_add_domain_va"
.Vb 4
\& int
\& guestfs_add_domain_va (guestfs_h *g,
\&                        const char *dom,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_add_domain\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_domain_argv"
.IX Subsection "guestfs_add_domain_argv"
.Vb 4
\& int
\& guestfs_add_domain_argv (guestfs_h *g,
\&                          const char *dom,
\&                          const struct guestfs_add_domain_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_add_domain\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_drive"
.IX Subsection "guestfs_add_drive"
.Vb 3
\& int
\& guestfs_add_drive (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_add_drive_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 0.3)
.SS "guestfs_add_drive_opts"
.IX Subsection "guestfs_add_drive_opts"
.Vb 4
\& int
\& guestfs_add_drive_opts (guestfs_h *g,
\&                         const char *filename,
\&                         ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 12
\& GUESTFS_ADD_DRIVE_OPTS_READONLY, int readonly,
\& GUESTFS_ADD_DRIVE_OPTS_FORMAT, const char *format,
\& GUESTFS_ADD_DRIVE_OPTS_IFACE, const char *iface,
\& GUESTFS_ADD_DRIVE_OPTS_NAME, const char *name,
\& GUESTFS_ADD_DRIVE_OPTS_LABEL, const char *label,
\& GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, const char *protocol,
\& GUESTFS_ADD_DRIVE_OPTS_SERVER, char *const *server,
\& GUESTFS_ADD_DRIVE_OPTS_USERNAME, const char *username,
\& GUESTFS_ADD_DRIVE_OPTS_SECRET, const char *secret,
\& GUESTFS_ADD_DRIVE_OPTS_CACHEMODE, const char *cachemode,
\& GUESTFS_ADD_DRIVE_OPTS_DISCARD, const char *discard,
\& GUESTFS_ADD_DRIVE_OPTS_COPYONREAD, int copyonread,
.Ve
.PP
Ця функція додає образ диска, який має назву \fIfilename\fR, до
дескриптора. \fIfilename\fR може бути звичайним файлом основної системи або
пристроєм основної системи.
.PP
Якщо цю функцію викликають до \f(CW\*(C`guestfs_launch\*(C'\fR (типовий випадок), тоді,
коли ви вперше викликаєте цю функцію, диск з'являється у програмному
інтерфейсі як \fI/dev/sda\fR, другого разу — \fI/dev/sdb\fR, тощо.
.PP
У libguestfs ≥ 1.20 ви можете викликати цю функцію і після запуску (з
певними обмеженнями). Це називається «з'єднання у «гарячому» режимі». При
такому з'єднанні вам слід вказати мітку (\f(CW\*(C`label\*(C'\fR), щоб новий диск отримав
передбачувану назву. Докладніший опис наведено у розділі
\&\*(L"З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ\*(R".
.PP
Вам не обов'язково мати права адміністратора (root), коли ви використовуєте
libguestfs. Втім, вам, очевидно, знадобляться достатні права доступу до
файла, щоб виконувати відповідні дії із файлом (тобто доступ до читання,
якщо ви хочете читати дані з образу, або доступ до запису, якщо ви хочете
вносити зміни до образу).
.PP
Цей виклик перевіряє, чи існує \fIfilename\fR.
.PP
\&\fIfilename\fR може бути спеціальним рядком
\&\f(CW"/dev/null"\fR. Див. \*(L"НУЛЬОВІ ДИСКИ\*(R".
.PP
Необов'язковими аргументами є:
.ie n .IP """readonly""" 4
.el .IP "\f(CWreadonly\fR" 4
.IX Item "readonly"
Якщо має значення true, образ вважатиметься придатним лише для
читання. Запис буде дозволено, але дані зберігатимуться у тимчасовому
знімку\-накладці, який наприкінці сеансу роботи буде відкинуто. Зміни до
диска, який ви додаєте, внесено не буде.
.ie n .IP """format""" 4
.el .IP "\f(CWformat\fR" 4
.IX Item "format"
Примусово встановлює формат образу. Якщо ви не вкажете його (або
скористаєтеся \f(CW\*(C`guestfs_add_drive\*(C'\fR чи \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR), формат
визначатиметься автоматично. Серед можливих форматів \f(CW\*(C`raw\*(C'\fR і \f(CW\*(C`qcow2\*(C'\fR.
.Sp
Автоматичне визначення формату є потенційною вадою захисту, якщо ви маєте
справу з образами у форматі raw із ненадійних джерел. Див. \s-1CVE\-2010\-3851\s0 і
RHBZ#642934. Вказування формату явним чином закриває цю дірку у захисті.
.ie n .IP """iface""" 4
.el .IP "\f(CWiface\fR" 4
.IX Item "iface"
Цей рідкісний параметр надає вам змогу емулювати поведінку застарілого
виклику \f(CW\*(C`guestfs_add_drive_with_if\*(C'\fR (q.v.)
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
Назва, яку диск має у початковій гостьовій системі, наприклад,
\&\fI/dev/sdb\fR. Використовується як підказка для процесу інспектування
гостьової системи, якщо така назва наявна.
.ie n .IP """label""" 4
.el .IP "\f(CWlabel\fR" 4
.IX Item "label"
Надати диску мітку. Мітка має бути унікальним коротким рядком, у якому
використано \fIлише\fR символи \s-1ASCII\s0 \f(CW\*(C`[a\-zA\-Z]\*(C'\fR. Окрім звичайної назви у
програмному інтерфейсі (наприклад \fI/dev/sda\fR), диск також можна буде
називати \fI/dev/disk/guestfs/\fIмітка\fI\fR.
.Sp
Див. \*(L"МІТКИ ДИСКІВ\*(R".
.ie n .IP """protocol""" 4
.el .IP "\f(CWprotocol\fR" 4
.IX Item "protocol"
Необов'язковим аргументом протоколу можна скористатися для вибору
альтернативного протоколу джерела.
.Sp
Див. також \*(L"\s-1REMOTE STORAGE\*(R"\s0.
.RS 4
.ie n .IP """protocol = ""file""""" 4
.el .IP "\f(CWprotocol = ``file''\fR" 4
.IX Item "protocol = ""file"""
\&\fIfilename\fR вважатиметься локальним файлом або пристроєм. Це типова
поведінка програми, якщо не вказано додатковий параметр протоколу.
.ie n .IP """protocol = ""ftp""|""ftps""|""http""|""https""|""tftp""""" 4
.el .IP "\f(CWprotocol = ``ftp''|``ftps''|``http''|``https''|``tftp''\fR" 4
.IX Item "protocol = ""ftp""|""ftps""|""http""|""https""|""tftp"""
З'єднатися із віддаленим сервером \s-1FTP, HTTP\s0 або \s-1TFTP.\s0 Також має бути надано
параметр \f(CW\*(C`server\*(C'\fR, див. нижче.
.Sp
Див. також \*(L"\s-1FTP, HTTP AND TFTP\*(R"\s0
.ie n .IP """protocol = ""gluster""""" 4
.el .IP "\f(CWprotocol = ``gluster''\fR" 4
.IX Item "protocol = ""gluster"""
З'єднатися із сервером GlusterFS. Також має бути надано параметр \f(CW\*(C`server\*(C'\fR,
див. нижче.
.Sp
Див. також \*(L"\s-1GLUSTER\*(R"\s0.
.ie n .IP """protocol = ""iscsi""""" 4
.el .IP "\f(CWprotocol = ``iscsi''\fR" 4
.IX Item "protocol = ""iscsi"""
З'єднатися із сервером iSCSI. Також має бути надано параметр \f(CW\*(C`server\*(C'\fR,
див. нижче. Має бути надано параметр \f(CW\*(C`username\*(C'\fR, див. нижче. Має бути
надано параметр \f(CW\*(C`secret\*(C'\fR, див. нижче.
.Sp
Див. також \*(L"\s-1ISCSI\*(R"\s0.
.ie n .IP """protocol = ""nbd""""" 4
.el .IP "\f(CWprotocol = ``nbd''\fR" 4
.IX Item "protocol = ""nbd"""
З'єднатися із сервером Network Block Device. Також має бути надано параметр
\&\f(CW\*(C`server\*(C'\fR, див. нижче.
.Sp
Див. також \*(L"\s-1NETWORK BLOCK DEVICE\*(R"\s0.
.ie n .IP """protocol = ""rbd""""" 4
.el .IP "\f(CWprotocol = ``rbd''\fR" 4
.IX Item "protocol = ""rbd"""
З'єднатися із сервером Ceph (librbd/RBD). Також має бути надано параметр
\&\f(CW\*(C`server\*(C'\fR, див. нижче. Має бути надано параметр \f(CW\*(C`username\*(C'\fR, див. нижче. Має
бути надано параметр \f(CW\*(C`secret\*(C'\fR, див. нижче.
.Sp
Див. також \*(L"\s-1CEPH\*(R"\s0.
.ie n .IP """protocol = ""sheepdog""""" 4
.el .IP "\f(CWprotocol = ``sheepdog''\fR" 4
.IX Item "protocol = ""sheepdog"""
З'єднатися із сервером Sheepdog. Також може бути надано параметр \f(CW\*(C`server\*(C'\fR,
див. нижче.
.Sp
Див. також \*(L"\s-1SHEEPDOG\*(R"\s0.
.ie n .IP """protocol = ""ssh""""" 4
.el .IP "\f(CWprotocol = ``ssh''\fR" 4
.IX Item "protocol = ""ssh"""
Встановити з’єднання з сервером Secure Shell (ssh).
.Sp
Має бути надано параметр \f(CW\*(C`server\*(C'\fR. Може бути надано параметр \f(CW\*(C`username\*(C'\fR,
див. нижче.
.Sp
Див. також \*(L"\s-1SSH\*(R"\s0.
.RE
.RS 4
.RE
.ie n .IP """server""" 4
.el .IP "\f(CWserver\fR" 4
.IX Item "server"
Для протоколів, які потребують доступу до віддаленого сервера, це список
серверів.
.Sp
.Vb 10
\& Протокол       Кількість потрібних серверів
\& \-\-\-\-\-\-\-\-       \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& file           Список має бути порожнім або не слід користуватися параметром взагалі
\& ftp|ftps|http|https|tftp  Точно один
\& gluster        Точно один
\& iscsi          Точно один
\& nbd            Точно один
\& rbd            Нуль або більше
\& sheepdog       Нуль або більше
\& ssh            Точно один
.Ve
.Sp
Кожен елемент у списку є рядком, який вказує на сервер. Рядок має бути
записано у одному з таких форматів:
.Sp
.Vb 5
\& назва_вузла
\& назва_вузла:порт
\& tcp:назва_вузла
\& tcp:назва_вузла:порт
\& unix:/шлях/до/сокета
.Ve
.Sp
Якщо номер порту не вказано, буде використано стандартний для протоколу
номер (див. \fI/etc/services\fR).
.ie n .IP """username""" 4
.el .IP "\f(CWusername\fR" 4
.IX Item "username"
Для протоколів \f(CW\*(C`ftp\*(C'\fR, \f(CW\*(C`ftps\*(C'\fR, \f(CW\*(C`http\*(C'\fR, \f(CW\*(C`https\*(C'\fR, \f(CW\*(C`iscsi\*(C'\fR, \f(CW\*(C`rbd\*(C'\fR, \f(CW\*(C`ssh\*(C'\fR
та \f(CW\*(C`tftp\*(C'\fR визначає ім’я користувача віддаленої системи.
.Sp
Якщо не вказано, для \f(CW\*(C`ssh\*(C'\fR буде використано ім'я локального користувача, а
для ceph спроба пройти розпізнавання не виконуватиметься. Втім, зауважте, що
іноді це може призводити до неочікуваних результатів, наприклад, якщо
використовується модуль обробки libvirt, і модуль обробки libvirt
налаштовано на запуск базової системи qemu від імені спеціального
користувача, зокрема \f(CW\*(C`qemu.qemu\*(C'\fR. Якщо сумніваєтеся, вкажіть потрібне вам
ім'я користувача віддаленої системи.
.ie n .IP """secret""" 4
.el .IP "\f(CWsecret\fR" 4
.IX Item "secret"
Лише для протоколу \f(CW\*(C`rbd\*(C'\fR це визначає «ключ», яким слід скористатися для
з'єднання із віддаленим пристроєм. Дані має бути вказано у кодуванні base64.
.Sp
Якщо не вказано, буде виконано пошук ключа, який відповідає вказаному імені
користувача у типовому сховищі ключів. Якщо імені користувача не вказано,
спроба пройти розпізнавання не виконуватиметься.
.ie n .IP """cachemode""" 4
.el .IP "\f(CWcachemode\fR" 4
.IX Item "cachemode"
Вкажіть, має libguestfs зважати на дії з синхронізації (безпечно, але
повільно) чи ні (небезпечно, але швидко). Можливими значеннями цього рядка
можуть бути:
.RS 4
.ie n .IP """cachemode = ""writeback""""" 4
.el .IP "\f(CWcachemode = ``writeback''\fR" 4
.IX Item "cachemode = ""writeback"""
Типове значення.
.Sp
Дії із запису у програмному інтерфейсі не повертають керування, аж доки не
буде завершено виклик \fBwrite\fR\|(2) у основній системі [втім, слід зауважити,
що це не означає, що щось буде записано на диск].
.Sp
Дії із синхронізації у програмному інтерфейсі, зокрема неявні синхронізації,
спричинені журналюванням файлової системи, не повертатимуть керування, аж
доки не буде завершено виклик \fBfdatasync\fR\|(2) у основній системі, що
означатиме, що дані було надіслано на диск.
.ie n .IP """cachemode = ""unsafe""""" 4
.el .IP "\f(CWcachemode = ``unsafe''\fR" 4
.IX Item "cachemode = ""unsafe"""
У цьому режимі надійність не гарантовано. Libguestfs може кешувати дані і
ігнорувати запити щодо синхронізації. Пасує лише тестовим та тимчасовим
дискам.
.RE
.RS 4
.RE
.ie n .IP """discard""" 4
.el .IP "\f(CWdiscard\fR" 4
.IX Item "discard"
Увімкнути або вимкнути підтримку відкидання (або обрізання чи скасовування
прив'язки) для цього диска. Якщо увімкнено, дії, подібні до
\&\f(CW\*(C`guestfs_fstrim\*(C'\fR зможуть відкидати / утоншувати / пробивати дірки у
підлеглому файлі або пристрої основної системи.
.Sp
Можливі варіанти параметрів відкидання:
.RS 4
.ie n .IP """discard = ""disable""""" 4
.el .IP "\f(CWdiscard = ``disable''\fR" 4
.IX Item "discard = ""disable"""
Вимкнути підтримку відкидання. Типова поведінка.
.ie n .IP """discard = ""enable""""" 4
.el .IP "\f(CWdiscard = ``enable''\fR" 4
.IX Item "discard = ""enable"""
Увімкнути підтримку відкидання. Завершується помилкою, якщо відкидання
неможливе.
.ie n .IP """discard = ""besteffort""""" 4
.el .IP "\f(CWdiscard = ``besteffort''\fR" 4
.IX Item "discard = ""besteffort"""
Увімкнути, якщо можна, підтримку відкидання, але не завершувати роботу із
повідомленням щодо помилки, якщо такої підтримки не передбачено.
.Sp
Оскільки підтримку відкидання передбачено не для усіх модулів обробки і не
для усіх підлеглих систем, це непоганий варіант, якщо ви хочете скористатися
відкиданням, якщо воно можливе, але не маєте нічого проти того, щоб воно не
працювало.
.RE
.RS 4
.RE
.ie n .IP """copyonread""" 4
.el .IP "\f(CWcopyonread\fR" 4
.IX Item "copyonread"
Булевий параметр \f(CW\*(C`copyonread\*(C'\fR вмикає підтримку копіювання під час
читання. Це стосується лише форматів дисків, які мають резервні файли, і
спричиняє до того, що дані читання зберігатимуться у накладному шарі, що
пришвидшуватиме повторні читання тих сами даних з диска.
.Sp
Типовим є значення false.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_add_drive_opts_va"
.IX Subsection "guestfs_add_drive_opts_va"
.Vb 4
\& int
\& guestfs_add_drive_opts_va (guestfs_h *g,
\&                            const char *filename,
\&                            va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_add_drive_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_drive_opts_argv"
.IX Subsection "guestfs_add_drive_opts_argv"
.Vb 4
\& int
\& guestfs_add_drive_opts_argv (guestfs_h *g,
\&                              const char *filename,
\&                              const struct guestfs_add_drive_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_add_drive_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_drive_ro"
.IX Subsection "guestfs_add_drive_ro"
.Vb 3
\& int
\& guestfs_add_drive_ro (guestfs_h *g,
\&                       const char *filename);
.Ve
.PP
Ця функція є еквівалентом виклику \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR із додатковим
параметром \f(CW\*(C`GUESTFS_ADD_DRIVE_OPTS_READONLY\*(C'\fR, який встановлено у значення
1, отже диск додається лише для читання, а формат визначається автоматично.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.38)
.SS "guestfs_add_drive_ro_with_if"
.IX Subsection "guestfs_add_drive_ro_with_if"
.Vb 4
\& int
\& guestfs_add_drive_ro_with_if (guestfs_h *g,
\&                               const char *filename,
\&                               const char *iface);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_add_drive\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Те саме, що і \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR, але надає вам змогу вказати емуляцію
інтерфейсу \s-1QEMU,\s0 яку буде використано під час роботи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.84)
.SS "guestfs_add_drive_scratch"
.IX Subsection "guestfs_add_drive_scratch"
.Vb 4
\& int
\& guestfs_add_drive_scratch (guestfs_h *g,
\&                            int64_t size,
\&                            ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_ADD_DRIVE_SCRATCH_NAME, const char *name,
\& GUESTFS_ADD_DRIVE_SCRATCH_LABEL, const char *label,
.Ve
.PP
Ця команда додає тимчасовий робочий диск до дескриптора. Параметр \f(CW\*(C`size\*(C'\fR
визначає його віртуальний розмір (у байтах). Робочий диск є початково
порожнім (усі спроби читання повертатимуть лише нулі, аж доки ви не почнете
записувати на нього дані). Диск вилучається після закриття дескриптора.
.PP
Додаткові аргументи \f(CW\*(C`name\*(C'\fR і \f(CW\*(C`label\*(C'\fR передаються до \f(CW\*(C`guestfs_add_drive\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.23.10)
.SS "guestfs_add_drive_scratch_va"
.IX Subsection "guestfs_add_drive_scratch_va"
.Vb 4
\& int
\& guestfs_add_drive_scratch_va (guestfs_h *g,
\&                               int64_t size,
\&                               va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_add_drive_scratch\*(R"
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_drive_scratch_argv"
.IX Subsection "guestfs_add_drive_scratch_argv"
.Vb 4
\& int
\& guestfs_add_drive_scratch_argv (guestfs_h *g,
\&                                 int64_t size,
\&                                 const struct guestfs_add_drive_scratch_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_add_drive_scratch\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_drive_with_if"
.IX Subsection "guestfs_add_drive_with_if"
.Vb 4
\& int
\& guestfs_add_drive_with_if (guestfs_h *g,
\&                            const char *filename,
\&                            const char *iface);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_add_drive\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Те саме, що і \f(CW\*(C`guestfs_add_drive\*(C'\fR, але надає вам змогу вказати емуляцію
інтерфейсу \s-1QEMU,\s0 яку буде використано під час роботи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.84)
.SS "guestfs_add_libvirt_dom"
.IX Subsection "guestfs_add_libvirt_dom"
.Vb 4
\& int
\& guestfs_add_libvirt_dom (guestfs_h *g,
\&                          void * /* really virDomainPtr */ dom,
\&                          ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 7
\& GUESTFS_ADD_LIBVIRT_DOM_READONLY, int readonly,
\& GUESTFS_ADD_LIBVIRT_DOM_IFACE, const char *iface,
\& GUESTFS_ADD_LIBVIRT_DOM_LIVE, int live,
\& GUESTFS_ADD_LIBVIRT_DOM_READONLYDISK, const char *readonlydisk,
\& GUESTFS_ADD_LIBVIRT_DOM_CACHEMODE, const char *cachemode,
\& GUESTFS_ADD_LIBVIRT_DOM_DISCARD, const char *discard,
\& GUESTFS_ADD_LIBVIRT_DOM_COPYONREAD, int copyonread,
.Ve
.PP
Ця функція додає диски, долучені до вказаного за назвою домену libvirt
\&\f(CW\*(C`dom\*(C'\fR. Вона працює шляхом з'єднання із libvirt,
 надсилання запиту щодо домену і \s-1XML\s0 домену до libvirt, обробки отриманих
даних для дисків і виклику \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR для кожного з дисків.
.PP
У програмному інтерфейсі мовою C ми оголошуємо \f(CW\*(C`void *dom\*(C'\fR, але насправді
типом змінної є \f(CW\*(C`virDomainPtr dom\*(C'\fR. Так зроблено, щоб нам не потрібна була
<libvirt.h>.
.PP
Буде повернуто значення кількості доданих дисків. Ця операція є атомарною:
якщо буде повернуто помилку, жодного диска не додано.
.PP
Ця функція виконує деякі мінімальні перевірки, щоб переконатися, що домен
libvirt не запущено (якщо \f(CW\*(C`readonly\*(C'\fR не дорівнює true). У майбутніх версіях
ми спробуємо реалізувати блокування libvirt для кожного диска.
.PP
Диски мають бути доступними. Це часто означає, що додавання дисків з
віддаленого з'єднання libvirt (див. http://libvirt.org/remote.html)
завершиться помилкою, якщо ці диски не є доступними за тією самою адресою
пристрою і локально.
.PP
Необов'язковий прапорець \f(CW\*(C`live\*(C'\fR керує тим, чи буде цей виклик намагатися
з'єднатися із запущеним процесом \f(CW\*(C`guestfsd\*(C'\fR віртуальної машини, якщо буде
виявлено відповідний елемент <channel> у визначення \s-1XML\s0
libvirt. Типовою поведінкою (якщо прапорець не встановлено) є поведінка, за
якої спроби робитися не буде. Див. \*(L"ДОЛУЧЕННЯ ДО ЗАПУЩЕНИХ
ФОНОВИХ СЛУЖБ\*(R", щоб дізнатися більше.
.PP
Необов'язковий параметр \f(CW\*(C`readonlydisk\*(C'\fR керує тим, що ми робимо із дисками,
які позначено як <readonly/> у \s-1XML\s0 libvirt. Можливі значення описано
у довідці щодо \f(CW\*(C`guestfs_add_domain\*(C'\fR.
.PP
Інші необов'язкові параметри передаються безпосередньо до
\&\f(CW\*(C`guestfs_add_drive_opts\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.29.14)
.SS "guestfs_add_libvirt_dom_va"
.IX Subsection "guestfs_add_libvirt_dom_va"
.Vb 4
\& int
\& guestfs_add_libvirt_dom_va (guestfs_h *g,
\&                             void * /* really virDomainPtr */ dom,
\&                             va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_add_libvirt_dom\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_add_libvirt_dom_argv"
.IX Subsection "guestfs_add_libvirt_dom_argv"
.Vb 4
\& int
\& guestfs_add_libvirt_dom_argv (guestfs_h *g,
\&                               void * /* really virDomainPtr */ dom,
\&                               const struct guestfs_add_libvirt_dom_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_add_libvirt_dom\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_aug_clear"
.IX Subsection "guestfs_aug_clear"
.Vb 3
\& int
\& guestfs_aug_clear (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Встановлює значення, пов'язане \f(CW\*(C`path\*(C'\fR у \f(CW\*(C`NULL\*(C'\fR. Те саме, що і команда
\&\fBaugtool\fR\|(1) \f(CW\*(C`clear\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.4)
.SS "guestfs_aug_close"
.IX Subsection "guestfs_aug_close"
.Vb 2
\& int
\& guestfs_aug_close (guestfs_h *g);
.Ve
.PP
Закрити поточний дескриптор Augeas і вивільнити усі ресурси, які ним
використовуються. Після виклику слід викликати \f(CW\*(C`guestfs_aug_init\*(C'\fR ще раз,
перш ніж ви зможете скористатися будь\-якими іншими функціями Augeas.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_defnode"
.IX Subsection "guestfs_aug_defnode"
.Vb 5
\& struct guestfs_int_bool *
\& guestfs_aug_defnode (guestfs_h *g,
\&                      const char *name,
\&                      const char *expr,
\&                      const char *val);
.Ve
.PP
Визначає змінну \f(CW\*(C`назва\*(C'\fR, чиїм значенням є результат обчислення виразу
\&\f(CW\*(C`вираз\*(C'\fR.
.PP
Якщо використання виразу \f(CW\*(C`вираз\*(C'\fR дає порожній набір вузлів, створюється
вузол. Еквівалент виклику \f(CW\*(C`guestfs_aug_set\*(C'\fR \f(CW\*(C`вираз\*(C'\fR, \f(CW\*(C`значення\*(C'\fR. \f(CW\*(C`назва\*(C'\fR
буде мати значення набору вузлів, який містить єдиний створений вузол.
.PP
Якщо виконано успішно, повертає пару значень — кількість вузлів у наборі
вузлів та булевий прапорець, якщо було створено вузол.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_int_bool *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_int_bool\*(C'\fI\fR.
.PP
(Додано у 0.7)
.SS "guestfs_aug_defvar"
.IX Subsection "guestfs_aug_defvar"
.Vb 4
\& int
\& guestfs_aug_defvar (guestfs_h *g,
\&                     const char *name,
\&                     const char *expr);
.Ve
.PP
Визначає змінну Augeas \f(CW\*(C`назва\*(C'\fR, чиїм значенням є результат обчислення
виразу \f(CW\*(C`вираз\*(C'\fR. Якщо значенням \f(CW\*(C`вираз\*(C'\fR є \s-1NULL,\s0 \f(CW\*(C`назва\*(C'\fR є невизначеною.
.PP
Якщо виконано успішно, повертає кількість вузлів у виразі \f(CW\*(C`вираз\*(C'\fR або \f(CW0\fR,
якщо обробка виразу \f(CW\*(C`вираз\*(C'\fR дає щось, що не є набором вузлів.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 0.7)
.SS "guestfs_aug_get"
.IX Subsection "guestfs_aug_get"
.Vb 3
\& char *
\& guestfs_aug_get (guestfs_h *g,
\&                  const char *augpath);
.Ve
.PP
Виконати пошук значення, пов'язаного із шляхом \f(CW\*(C`шлях\*(C'\fR. Якщо \f(CW\*(C`шлях\*(C'\fR
визначає точно один вузол, буде повернуто \f(CW\*(C`значення\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 0.7)
.SS "guestfs_aug_init"
.IX Subsection "guestfs_aug_init"
.Vb 4
\& int
\& guestfs_aug_init (guestfs_h *g,
\&                   const char *root,
\&                   int flags);
.Ve
.PP
Створити дескриптор Augeas для редагування файлів налаштувань. Якщо із цим
сеансом guestfs вже було пов'язано дескриптор Augeas, його буде закрито.
.PP
Вам слід викликати цю команду до використання будь\-яких інших команд
\&\f(CW\*(C`guestfs_aug_*\*(C'\fR.
.PP
\&\f(CW\*(C`корінь\*(C'\fR — коренева тека файлової системи. Значенням \f(CW\*(C`корінь\*(C'\fR не повинен
бути \s-1NULL.\s0 Замість значення \s-1NULL\s0 слід використовувати \fI/\fR.
.PP
Прапорці є тими самими, що і прапорці, визначені у <augeas.h>,
застосування логічного \fIАБО\fR до таких цілих значень:
.ie n .IP """AUG_SAVE_BACKUP"" = 1" 4
.el .IP "\f(CWAUG_SAVE_BACKUP\fR = 1" 4
.IX Item "AUG_SAVE_BACKUP = 1"
Зберігати початковий файл із додаванням до назви суфікса \f(CW\*(C`.augsave\*(C'\fR.
.ie n .IP """AUG_SAVE_NEWFILE"" = 2" 4
.el .IP "\f(CWAUG_SAVE_NEWFILE\fR = 2" 4
.IX Item "AUG_SAVE_NEWFILE = 2"
Зберігати зміни до файла із суфіксом назви \f(CW\*(C`.augnew\*(C'\fR і не перезаписувати
початковий файл. Має вищий пріоритет за \f(CW\*(C`AUG_SAVE_BACKUP\*(C'\fR.
.ie n .IP """AUG_TYPE_CHECK"" = 4" 4
.el .IP "\f(CWAUG_TYPE_CHECK\fR = 4" 4
.IX Item "AUG_TYPE_CHECK = 4"
Лінзи перевірки типів.
.Sp
Цей параметр буде корисним, лише якщо ви виконуєте діагностику лінз
Augeas. Використання цього параметра може потребувати додаткової пам'яті для
базової системи libguestfs. Ймовірно, вам варто встановити відповідне
значення для змінної середовища \f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR або викликати
\&\f(CW\*(C`guestfs_set_memsize\*(C'\fR.
.ie n .IP """AUG_NO_STDINC"" = 8" 4
.el .IP "\f(CWAUG_NO_STDINC\fR = 8" 4
.IX Item "AUG_NO_STDINC = 8"
Не використовувати стандартний шлях для завантаження модулів.
.ie n .IP """AUG_SAVE_NOOP"" = 16" 4
.el .IP "\f(CWAUG_SAVE_NOOP\fR = 16" 4
.IX Item "AUG_SAVE_NOOP = 16"
Вимкнути дію зі збереження, просто записати, що могло б бути змінено.
.ie n .IP """AUG_NO_LOAD"" = 32" 4
.el .IP "\f(CWAUG_NO_LOAD\fR = 32" 4
.IX Item "AUG_NO_LOAD = 32"
Не завантажувати ієрархію у \f(CW\*(C`guestfs_aug_init\*(C'\fR.
.PP
Щоб закрити дескриптор, ви можете викликати \f(CW\*(C`guestfs_aug_close\*(C'\fR.
.PP
Щоб дізнатися більше про Augeas, зверніться до http://augeas.net/.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_insert"
.IX Subsection "guestfs_aug_insert"
.Vb 5
\& int
\& guestfs_aug_insert (guestfs_h *g,
\&                     const char *augpath,
\&                     const char *label,
\&                     int before);
.Ve
.PP
Створити мітку\-близнюка \f(CW\*(C`мітка\*(C'\fR для шляху \f(CW\*(C`шлях\*(C'\fR, вставивши її до ієрархії
перед або після записом шляху \f(CW\*(C`шлях\*(C'\fR (залежно від додаткового булевого
прапорця \f(CW\*(C`до\*(C'\fR).
.PP
\&\f(CW\*(C`шлях\*(C'\fR має збігатися із точно одним наявним вузлом у ієрархії, а \f(CW\*(C`мітка\*(C'\fR
має бути міткою, тобто не містити \fI/\fR, \f(CW\*(C`*\*(C'\fR, або завершуватися індексом у
дужках, \f(CW\*(C`[N]\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_label"
.IX Subsection "guestfs_aug_label"
.Vb 3
\& char *
\& guestfs_aug_label (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Повертає мітку (назву останнього елемента) для виразу шляху Augeas
\&\f(CW\*(C`шлях\*(C'\fR. \f(CW\*(C`шлях\*(C'\fR має відповідати точно одному вузлу, інакше функцією буде
повернуто повідомлення про помилку.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.23.14)
.SS "guestfs_aug_load"
.IX Subsection "guestfs_aug_load"
.Vb 2
\& int
\& guestfs_aug_load (guestfs_h *g);
.Ve
.PP
Завантажити файли до ієрархії.
.PP
Див. документацію Augeas щодо \f(CW\*(C`aug_load\*(C'\fR, якщо хочете докладнішого опису.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_ls"
.IX Subsection "guestfs_aug_ls"
.Vb 3
\& char **
\& guestfs_aug_ls (guestfs_h *g,
\&                 const char *augpath);
.Ve
.PP
Скорочена форма запису для побудови списку \f(CW\*(C`guestfs_aug_match\*(C'\fR \f(CW\*(C`шлях/*\*(C'\fR і
упорядковування вузлів\-результатів за абеткою.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.8)
.SS "guestfs_aug_match"
.IX Subsection "guestfs_aug_match"
.Vb 3
\& char **
\& guestfs_aug_match (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Повертає список шляхів, які відповідають виразу шляху \f(CW\*(C`шлях\*(C'\fR. Повернуті
записи шляхів є достатньо визначеними, щоб відповідати точно одному запису
вузла у поточній ієрархії.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.7)
.SS "guestfs_aug_mv"
.IX Subsection "guestfs_aug_mv"
.Vb 4
\& int
\& guestfs_aug_mv (guestfs_h *g,
\&                 const char *src,
\&                 const char *dest);
.Ve
.PP
Пересуває вузол \f(CW\*(C`джерело\*(C'\fR до \f(CW\*(C`призначення\*(C'\fR. \f(CW\*(C`джерело\*(C'\fR має відповідати
точно одному вузлу. \f(CW\*(C`призначення\*(C'\fR буде перезаписано, якщо воно вже існує.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_rm"
.IX Subsection "guestfs_aug_rm"
.Vb 3
\& int
\& guestfs_aug_rm (guestfs_h *g,
\&                 const char *augpath);
.Ve
.PP
Вилучити \f(CW\*(C`шлях\*(C'\fR і усі його підлеглі об'єкти.
.PP
Якщо виконано успішно, повертає кількість вилучених записів.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 0.7)
.SS "guestfs_aug_save"
.IX Subsection "guestfs_aug_save"
.Vb 2
\& int
\& guestfs_aug_save (guestfs_h *g);
.Ve
.PP
Записує зміни з черги на диск.
.PP
Прапорці, які передаються \f(CW\*(C`guestfs_aug_init\*(C'\fR впливають на те, як саме буде
збережено файли.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_set"
.IX Subsection "guestfs_aug_set"
.Vb 4
\& int
\& guestfs_aug_set (guestfs_h *g,
\&                  const char *augpath,
\&                  const char *val);
.Ve
.PP
Встановлює для шляху \f(CW\*(C`шлях\*(C'\fR пов'язане значення \f(CW\*(C`значення\*(C'\fR.
.PP
У програмному інтерфейсі Augeas можна спорожняти вузол наданням йому
значення \s-1NULL.\s0 Через недогляд у програмному інтерфейсі libguestfs ви не
зможете цього робити за допомогою цього виклику. Замість цього, доведеться
викликати \f(CW\*(C`guestfs_aug_clear\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.7)
.SS "guestfs_aug_setm"
.IX Subsection "guestfs_aug_setm"
.Vb 5
\& int
\& guestfs_aug_setm (guestfs_h *g,
\&                   const char *base,
\&                   const char *sub,
\&                   const char *val);
.Ve
.PP
Змінити декілька вузлів Augeas однією командою. \f(CW\*(C`основа\*(C'\fR — вираз, що
відповідає декільком вузлам. \f(CW\*(C`підлеглий\*(C'\fR — вираз шляху відносно шляху
\&\f(CW\*(C`основа\*(C'\fR. Буде знайдено усі вузли, які відповідають запису \f(CW\*(C`основа\*(C'\fR, а
потім для кожного вузла значення \f(CW\*(C`підлеглий\*(C'\fR буде змінено на
\&\f(CW\*(C`значення\*(C'\fR. Значенням \f(CW\*(C`підлеглий\*(C'\fR може бути \f(CW\*(C`NULL\*(C'\fR, щоб призведе до
внесення змін до вузлів \f(CW\*(C`основа\*(C'\fR.
.PP
Повертає кількість модифікованих вузлів.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.23.14)
.SS "guestfs_aug_transform"
.IX Subsection "guestfs_aug_transform"
.Vb 5
\& int
\& guestfs_aug_transform (guestfs_h *g,
\&                        const char *lens,
\&                        const char *file,
\&                        ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_AUG_TRANSFORM_REMOVE, int remove,
.Ve
.PP
Додати перетворення Augeas до вказаної лінзи \f(CW\*(C`лінза\*(C'\fR так, щоб вона могла
обробляти \f(CW\*(C`файл\*(C'\fR.
.PP
Якщо значенням прапорця \f(CW\*(C`вилучення\*(C'\fR є true (типово його значенням є
\&\f(CW\*(C`false\*(C'\fR), перетворення буде вилучено.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.35.2)
.SS "guestfs_aug_transform_va"
.IX Subsection "guestfs_aug_transform_va"
.Vb 5
\& int
\& guestfs_aug_transform_va (guestfs_h *g,
\&                           const char *lens,
\&                           const char *file,
\&                           va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_aug_transform\*(R"
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_aug_transform_argv"
.IX Subsection "guestfs_aug_transform_argv"
.Vb 5
\& int
\& guestfs_aug_transform_argv (guestfs_h *g,
\&                             const char *lens,
\&                             const char *file,
\&                             const struct guestfs_aug_transform_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_aug_transform\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_available"
.IX Subsection "guestfs_available"
.Vb 3
\& int
\& guestfs_available (guestfs_h *g,
\&                    char *const *groups);
.Ve
.PP
Ця команда використовується для перевірки доступності певних груп
функціональних можливостей у базовій системі, роботу яких можуть забезпечити
не усі збірки базової системи libguestfs.
.PP
Список груп libguestfs та функцій, яким відповідають ці групи, наведено у
розділі \*(L"ДОСТУПНІСТЬ\*(R". Ви також можете отримати цей список у
робочому режимі викликом \f(CW\*(C`guestfs_available_all_groups\*(C'\fR.
.PP
Аргумент \f(CW\*(C`групи\*(C'\fR є списком назв груп. Приклад: \f(CW\*(C`["inotify", "augeas"]\*(C'\fR має
перевірити доступність функцій inotify Linux та функцій Augeas (редагування
файла налаштувань).
.PP
Ця команда не повертає повідомлення про помилку, якщо доступними є \fIусі\fR
вказані групи.
.PP
Команда завершується повідомленням про помилку, якщо одна або декілька
запитаних груп є недоступною у базовій системі.
.PP
Якщо до списку груп буде включено групу із невідомою назвою, команда завжди
повертатиме повідомлення про помилку.
.PP
\&\fIНотатки:\fR
.IP "\(bu" 4
\&\f(CW\*(C`guestfs_feature_available\*(C'\fR є тим самим, що і цей виклик, але із дещо
простішим у користуванні програмним інтерфейсом: цей виклик повертає булеве
true/false замість надсилання повідомлення про помилку.
.IP "\(bu" 4
Вам слід викликати \f(CW\*(C`guestfs_launch\*(C'\fR до виклику цієї функції.
.Sp
Причиною є те, що ми не знаємо, підтримку яких груп передбачено у базовій
системі або фоновій службі, доки її не буде запущено, і вона не зможе
відповідати на запити.
.IP "\(bu" 4
Якщо група функцій доступна, це не обов'язково означає, що функції
працюватимуть. Вам все одно слід перевірити, чи не виникають помилки під час
викликів окремих програмних інтерфейсів, навіть якщо вони доступні.
.IP "\(bu" 4
Зазвичай, збирання базової системи libguestfs із якомога ширшими
функціональними можливостями є завданням пакувальників
дистрибутивів. libguestfs із основної гілки коду, якщо програми зібрано із
початкового коду із усіма залежностями, підтримуватиме роботу із усіма
можливостями.
.IP "\(bu" 4
Цей виклик було додано у версії \f(CW1.0.80\fR. У попередніх версіях libguestfs
усе, що ви могли зробити, це спробувати виконати команду, щоб визначити, чи
реалізовано її у фоновій службі. Див. також \f(CW\*(C`guestfs_version\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_filesystem_available\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.80)
.SS "guestfs_available_all_groups"
.IX Subsection "guestfs_available_all_groups"
.Vb 2
\& char **
\& guestfs_available_all_groups (guestfs_h *g);
.Ve
.PP
Ця команда повертає список усіх додаткових груп, про які знає ця фонова
служба. Зауважте, що буде повернуто список підтримуваних і непідтримуваних
груп. Щоб визначити групи, підтримку яких передбачено у фоновій службі, вам
слід викликати \f(CW\*(C`guestfs_available\*(C'\fR / \f(CW\*(C`guestfs_feature_available\*(C'\fR для
кожного запису із повернутого списку.
.PP
Див. також \f(CW\*(C`guestfs_available\*(C'\fR, \f(CW\*(C`guestfs_feature_available\*(C'\fR і
\&\*(L"\s-1AVAILABILITY\*(R"\s0.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.3.15)
.SS "guestfs_base64_in"
.IX Subsection "guestfs_base64_in"
.Vb 4
\& int
\& guestfs_base64_in (guestfs_h *g,
\&                    const char *base64file,
\&                    const char *filename);
.Ve
.PP
Ця команда вивантажує закодовані у base64 дані з файла \f(CW\*(C`файл_base64\*(C'\fR до
файла \fIназва_файла\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.5)
.SS "guestfs_base64_out"
.IX Subsection "guestfs_base64_out"
.Vb 4
\& int
\& guestfs_base64_out (guestfs_h *g,
\&                     const char *filename,
\&                     const char *base64file);
.Ve
.PP
Ця команда отримує вміст файла \fIназва_файла\fR і записує його до локального
файла \f(CW\*(C`файл_base64\*(C'\fR у кодуванні base64.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.5)
.SS "guestfs_blkdiscard"
.IX Subsection "guestfs_blkdiscard"
.Vb 3
\& int
\& guestfs_blkdiscard (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
Ця команда відкидає усі блоки на блоковому пристрої \f(CW\*(C`пристрій\*(C'\fR, вивільняючи
місце і передаючи його основній системі.
.PP
Ця операція потребує підтримки у libguestfs, файловій системі основної
системи, qemu та ядрі основної системи. Якщо цієї підтримки немає, операція
призведе до помилки або навіть виконуватиметься, але без усіляких
наслідків. Вам слід встановити атрибут \f(CW\*(C`discard\*(C'\fR на підлеглому диску
(див. \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`blkdiscard\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.25.44)
.SS "guestfs_blkdiscardzeroes"
.IX Subsection "guestfs_blkdiscardzeroes"
.Vb 3
\& int
\& guestfs_blkdiscardzeroes (guestfs_h *g,
\&                           const char *device);
.Ve
.PP
Цей виклик повертає true, якщо блоки на пристрої \f(CW\*(C`пристрій\*(C'\fR, які було
відкинуто викликом \f(CW\*(C`guestfs_blkdiscard\*(C'\fR, повернуто як блоки у нуль байтів
під час наступного читання.
.PP
Якщо повертає false, може так статися, що відкинуті блоки читаються як
застарілі або випадкові дані.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`blkdiscardzeroes\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.25.44)
.SS "guestfs_blkid"
.IX Subsection "guestfs_blkid"
.Vb 3
\& char **
\& guestfs_blkid (guestfs_h *g,
\&                const char *device);
.Ve
.PP
Ця команда повертає атрибути блокового пристрою \f(CW\*(C`пристрій\*(C'\fR. У виведеному
хеші зазвичай є вказані нижче поля. Також у ньому можуть бути інші поля.
.ie n .IP """UUID""" 4
.el .IP "\f(CWUUID\fR" 4
.IX Item "UUID"
Код \s-1UUID\s0 цього пристрою.
.ie n .IP """МІТКА""" 4
.el .IP "\f(CWМІТКА\fR" 4
.IX Item "МІТКА"
Мітка пристрою.
.ie n .IP """ВЕРСІЯ""" 4
.el .IP "\f(CWВЕРСІЯ\fR" 4
.IX Item "ВЕРСІЯ"
Версія програми blkid.
.ie n .IP """ТИП""" 4
.el .IP "\f(CWТИП\fR" 4
.IX Item "ТИП"
Тип файлової системи або \s-1RAID\s0 для цього пристрою.
.ie n .IP """ВИКОРИСТАННЯ""" 4
.el .IP "\f(CWВИКОРИСТАННЯ\fR" 4
.IX Item "ВИКОРИСТАННЯ"
Призначення цього пристрою, наприклад \f(CW\*(C`filesystem\*(C'\fR або \f(CW\*(C`raid\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.15.9)
.SS "guestfs_blockdev_flushbufs"
.IX Subsection "guestfs_blockdev_flushbufs"
.Vb 3
\& int
\& guestfs_blockdev_flushbufs (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
Ця команда наказує ядру спорожнити внутрішні буфери, які пов'язано із
пристроєм \f(CW\*(C`пристрій\*(C'\fR.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_getbsz"
.IX Subsection "guestfs_blockdev_getbsz"
.Vb 3
\& int
\& guestfs_blockdev_getbsz (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Повертає розмір блоку для пристрою.
.PP
Зауваження: цей розмір відрізняється від \fIрозміру у блоках\fR і \fIрозміру
блоку файлової системи\fR. Крім того, цей параметр насправді ніде не
використовується. Вам, ймовірно, не знадобляться ці дані. Файлові системі
мають власні правила щодо вибору розміру блоку.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_getro"
.IX Subsection "guestfs_blockdev_getro"
.Vb 3
\& int
\& guestfs_blockdev_getro (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Повертає булеве значення, яке визначається тим, чи призначено блоковий
пристрій лише для читання (true, якщо пристрій призначено лише для читання,
false, якщо ні).
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_getsize64"
.IX Subsection "guestfs_blockdev_getsize64"
.Vb 3
\& int64_t
\& guestfs_blockdev_getsize64 (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
Повертає розмір пристрою у байтах.
.PP
Див. також \f(CW\*(C`guestfs_blockdev_getsz\*(C'\fR.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_getss"
.IX Subsection "guestfs_blockdev_getss"
.Vb 3
\& int
\& guestfs_blockdev_getss (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Ця команда повертає розмір сектора на блоковому пристрої. Зазвичай, розміром
є 512, але на сучасних пристроях розмір може бути більшим.
.PP
(Зауважте, що це не розмір у секторах. Щоб отримати розмір у секторах,
скористайтеся \f(CW\*(C`guestfs_blockdev_getsz\*(C'\fR).
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_getsz"
.IX Subsection "guestfs_blockdev_getsz"
.Vb 3
\& int64_t
\& guestfs_blockdev_getsz (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Цей повертає розмір пристрою у одиницях 512\-байтових секторах (навіть якщо
розмір сектора не дорівнює 512 байтів ...дивно).
.PP
Див. також \f(CW\*(C`guestfs_blockdev_getss\*(C'\fR, щоб дізнатися справжній розмір сектора
пристрою, і \f(CW\*(C`guestfs_blockdev_getsize64\*(C'\fR для отримання кориснішого
\&\fIрозміру у байтах\fR.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_rereadpt"
.IX Subsection "guestfs_blockdev_rereadpt"
.Vb 3
\& int
\& guestfs_blockdev_rereadpt (guestfs_h *g,
\&                            const char *device);
.Ve
.PP
Повторно прочитати таблицю розділів з пристрою \f(CW\*(C`пристрій\*(C'\fR.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_setbsz"
.IX Subsection "guestfs_blockdev_setbsz"
.Vb 4
\& int
\& guestfs_blockdev_setbsz (guestfs_h *g,
\&                          const char *device,
\&                          int blocksize);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR Замінника не передбачено. Зверніться до
документації із програмного інтерфейсу у підручнику з \fBguestfs\fR\|(3), щоб
дізнатися більше.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Цей виклик не виконує ніяких дій і ніколи цього не робив через ваду у
blockdev. \fBНе використовуйте його.\fR
.PP
Якщо вам потрібно встановити розмір блоку файлової системи, скористайтеся
параметром \f(CW\*(C`blocksize\*(C'\fR \f(CW\*(C`guestfs_mkfs\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_setra"
.IX Subsection "guestfs_blockdev_setra"
.Vb 4
\& int
\& guestfs_blockdev_setra (guestfs_h *g,
\&                         const char *device,
\&                         int sectors);
.Ve
.PP
Встановити випереджальне читання (у 512\-байтових секторах) для пристрою.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.29.10)
.SS "guestfs_blockdev_setro"
.IX Subsection "guestfs_blockdev_setro"
.Vb 3
\& int
\& guestfs_blockdev_setro (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Переводити блоковий пристрій з назвою \f(CW\*(C`пристрій\*(C'\fR у режим лише читання.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.3)
.SS "guestfs_blockdev_setrw"
.IX Subsection "guestfs_blockdev_setrw"
.Vb 3
\& int
\& guestfs_blockdev_setrw (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Встановлює для блокового пристрою із назвою \f(CW\*(C`пристрій\*(C'\fR режим
читання\-запису.
.PP
Використовується програма \fBblockdev\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.3)
.SS "guestfs_btrfs_balance_cancel"
.IX Subsection "guestfs_btrfs_balance_cancel"
.Vb 3
\& int
\& guestfs_btrfs_balance_cancel (guestfs_h *g,
\&                               const char *path);
.Ve
.PP
Скасувати поточний баланс на файловій системі btrfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_balance_pause"
.IX Subsection "guestfs_btrfs_balance_pause"
.Vb 3
\& int
\& guestfs_btrfs_balance_pause (guestfs_h *g,
\&                              const char *path);
.Ve
.PP
Призупинити запущений баланс у файловій системі btrfs
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_balance_resume"
.IX Subsection "guestfs_btrfs_balance_resume"
.Vb 3
\& int
\& guestfs_btrfs_balance_resume (guestfs_h *g,
\&                               const char *path);
.Ve
.PP
Поновити призупинений баланс на файловій системі btrfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_balance_status"
.IX Subsection "guestfs_btrfs_balance_status"
.Vb 3
\& struct guestfs_btrfsbalance *
\& guestfs_btrfs_balance_status (guestfs_h *g,
\&                               const char *path);
.Ve
.PP
Показати стан використовуваного або призупиненого балансу на файловій
системі btrfs.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_btrfsbalance *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_btrfsbalance\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.26)
.SS "guestfs_btrfs_device_add"
.IX Subsection "guestfs_btrfs_device_add"
.Vb 4
\& int
\& guestfs_btrfs_device_add (guestfs_h *g,
\&                           char *const *devices,
\&                           const char *fs);
.Ve
.PP
Додати список пристроїв у записі \f(CW\*(C`пристрої\*(C'\fR до файлової системи btrfs,
змонтованої до файлової системи \f(CW\*(C`файлова система\*(C'\fR.  Якщо \f(CW\*(C`пристрої\*(C'\fR є
порожнім списком, не виконувати ніяких дій.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_device_delete"
.IX Subsection "guestfs_btrfs_device_delete"
.Vb 4
\& int
\& guestfs_btrfs_device_delete (guestfs_h *g,
\&                              char *const *devices,
\&                              const char *fs);
.Ve
.PP
Вилучити \f(CW\*(C`пристрої\*(C'\fR з файлової системи btrfs, змонтованої до точки
\&\f(CW\*(C`файлова система\*(C'\fR. Якщо запис \f(CW\*(C`пристрої\*(C'\fR є порожнім списком, не виконувати
ніяких дій.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_filesystem_balance"
.IX Subsection "guestfs_btrfs_filesystem_balance"
.Vb 3
\& int
\& guestfs_btrfs_filesystem_balance (guestfs_h *g,
\&                                   const char *fs);
.Ve
.PP
Збалансувати фрагменти файлової системи btrfs, змонтованої до точки
\&\f(CW\*(C`файлова_система\*(C'\fR, між підлеглими пристроями.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_filesystem_defragment"
.IX Subsection "guestfs_btrfs_filesystem_defragment"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_defragment (guestfs_h *g,
\&                                      const char *path,
\&                                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_FLUSH, int flush,
\& GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_COMPRESS, const char *compress,
.Ve
.PP
Виконати дефрагментацію файла або каталогу на файловій системі btrfs. Для
параметра «стискання» передбачено два значення: zlib або lzo.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_filesystem_defragment_va"
.IX Subsection "guestfs_btrfs_filesystem_defragment_va"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_defragment_va (guestfs_h *g,
\&                                         const char *path,
\&                                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_btrfs_filesystem_defragment\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_filesystem_defragment_argv"
.IX Subsection "guestfs_btrfs_filesystem_defragment_argv"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_defragment_argv (guestfs_h *g,
\&                                           const char *path,
\&                                           const struct guestfs_btrfs_filesystem_defragment_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_btrfs_filesystem_defragment\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_filesystem_resize"
.IX Subsection "guestfs_btrfs_filesystem_resize"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize (guestfs_h *g,
\&                                  const char *mountpoint,
\&                                  ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE, int64_t size,
.Ve
.PP
Ця команда змінює розмір файлової системи btrfs.
.PP
Зауважте, що на відміну від інших викликів команд зміни розмірів, файлову
систему має бути змонтовано, а параметром команди є точка монтування, а не
пристрій (це вимога самої btrfs).
.PP
Додатковими параметрами є:
.ie n .IP """розмір""" 4
.el .IP "\f(CWрозмір\fR" 4
.IX Item "розмір"
Новий розмір (у байтах) файлової системи. Якщо не вказано, файлову систему
буде розширено до максимального розміру.
.PP
Див. також \fBbtrfs\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.11.17)
.SS "guestfs_btrfs_filesystem_resize_va"
.IX Subsection "guestfs_btrfs_filesystem_resize_va"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize_va (guestfs_h *g,
\&                                     const char *mountpoint,
\&                                     va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_btrfs_filesystem_resize\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_filesystem_resize_argv"
.IX Subsection "guestfs_btrfs_filesystem_resize_argv"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize_argv (guestfs_h *g,
\&                                       const char *mountpoint,
\&                                       const struct guestfs_btrfs_filesystem_resize_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_btrfs_filesystem_resize\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_filesystem_show"
.IX Subsection "guestfs_btrfs_filesystem_show"
.Vb 3
\& char **
\& guestfs_btrfs_filesystem_show (guestfs_h *g,
\&                                const char *device);
.Ve
.PP
Вивести усі пристрої, на які поширюються файлові системи з пристрою
\&\f(CW\*(C`пристрій\*(C'\fR.
.PP
Якщо у системі наявні не усі пристрої для файлових систем, ця функція
завершується повідомленням про помилку, а для \f(CW\*(C`errno\*(C'\fR встановлюється
значення \f(CW\*(C`ENODEV\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.29)
.SS "guestfs_btrfs_filesystem_sync"
.IX Subsection "guestfs_btrfs_filesystem_sync"
.Vb 3
\& int
\& guestfs_btrfs_filesystem_sync (guestfs_h *g,
\&                                const char *fs);
.Ve
.PP
Примусово синхронізувати файлову систему btrfs, яку змонтовано до точки
\&\f(CW\*(C`файлова_система\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_fsck"
.IX Subsection "guestfs_btrfs_fsck"
.Vb 4
\& int
\& guestfs_btrfs_fsck (guestfs_h *g,
\&                     const char *device,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_BTRFS_FSCK_SUPERBLOCK, int64_t superblock,
\& GUESTFS_BTRFS_FSCK_REPAIR, int repair,
.Ve
.PP
Використовується для перевірки файлової системи btrfs, \f(CW\*(C`пристрій\*(C'\fR — файл
пристрою, у якому зберігається файлова система.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.43)
.SS "guestfs_btrfs_fsck_va"
.IX Subsection "guestfs_btrfs_fsck_va"
.Vb 4
\& int
\& guestfs_btrfs_fsck_va (guestfs_h *g,
\&                        const char *device,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_btrfs_fsck\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_fsck_argv"
.IX Subsection "guestfs_btrfs_fsck_argv"
.Vb 4
\& int
\& guestfs_btrfs_fsck_argv (guestfs_h *g,
\&                          const char *device,
\&                          const struct guestfs_btrfs_fsck_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_btrfs_fsck\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_image"
.IX Subsection "guestfs_btrfs_image"
.Vb 5
\& int
\& guestfs_btrfs_image (guestfs_h *g,
\&                      char *const *source,
\&                      const char *image,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_BTRFS_IMAGE_COMPRESSLEVEL, int compresslevel,
.Ve
.PP
Використовується для створення образу файлової системи btrfs. Усі дані буде
перезаписано нулями, але метадані і подібні дані буде збережено.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.32)
.SS "guestfs_btrfs_image_va"
.IX Subsection "guestfs_btrfs_image_va"
.Vb 5
\& int
\& guestfs_btrfs_image_va (guestfs_h *g,
\&                         char *const *source,
\&                         const char *image,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_btrfs_image\*(R"
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_image_argv"
.IX Subsection "guestfs_btrfs_image_argv"
.Vb 5
\& int
\& guestfs_btrfs_image_argv (guestfs_h *g,
\&                           char *const *source,
\&                           const char *image,
\&                           const struct guestfs_btrfs_image_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_btrfs_image\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_qgroup_assign"
.IX Subsection "guestfs_btrfs_qgroup_assign"
.Vb 5
\& int
\& guestfs_btrfs_qgroup_assign (guestfs_h *g,
\&                              const char *src,
\&                              const char *dst,
\&                              const char *path);
.Ve
.PP
Додає q\-групу \f(CW\*(C`джерело\*(C'\fR до батьківської q\-групи \f(CW\*(C`призначення\*(C'\fR. Ця команда
може групувати декілька q\-груп до батьківської q\-групи для спільного
використання загальних обмежень.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_qgroup_create"
.IX Subsection "guestfs_btrfs_qgroup_create"
.Vb 4
\& int
\& guestfs_btrfs_qgroup_create (guestfs_h *g,
\&                              const char *qgroupid,
\&                              const char *subvolume);
.Ve
.PP
Створити групу квот (q\-групу) для підтому \f(CW\*(C`підтом\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_qgroup_destroy"
.IX Subsection "guestfs_btrfs_qgroup_destroy"
.Vb 4
\& int
\& guestfs_btrfs_qgroup_destroy (guestfs_h *g,
\&                               const char *qgroupid,
\&                               const char *subvolume);
.Ve
.PP
Знищити групу квот.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_qgroup_limit"
.IX Subsection "guestfs_btrfs_qgroup_limit"
.Vb 4
\& int
\& guestfs_btrfs_qgroup_limit (guestfs_h *g,
\&                             const char *subvolume,
\&                             int64_t size);
.Ve
.PP
Обмежити розмір підтому із шляхом \f(CW\*(C`підтом\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_qgroup_remove"
.IX Subsection "guestfs_btrfs_qgroup_remove"
.Vb 5
\& int
\& guestfs_btrfs_qgroup_remove (guestfs_h *g,
\&                              const char *src,
\&                              const char *dst,
\&                              const char *path);
.Ve
.PP
Вилучити q\-групу \f(CW\*(C`джерело\*(C'\fR з батьківської q\-групи \f(CW\*(C`призначення\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_qgroup_show"
.IX Subsection "guestfs_btrfs_qgroup_show"
.Vb 3
\& struct guestfs_btrfsqgroup_list *
\& guestfs_btrfs_qgroup_show (guestfs_h *g,
\&                            const char *path);
.Ve
.PP
Вивести усі групи квот підтомів у файловій системі btrfs разом із даними
щодо їхнього використання.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_btrfsqgroup_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_btrfsqgroup_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_quota_enable"
.IX Subsection "guestfs_btrfs_quota_enable"
.Vb 4
\& int
\& guestfs_btrfs_quota_enable (guestfs_h *g,
\&                             const char *fs,
\&                             int enable);
.Ve
.PP
Увімкнути або вимкнути підтримку квот підтомів для файлової системи, яка
містить \f(CW\*(C`шлях\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_quota_rescan"
.IX Subsection "guestfs_btrfs_quota_rescan"
.Vb 3
\& int
\& guestfs_btrfs_quota_rescan (guestfs_h *g,
\&                             const char *fs);
.Ve
.PP
Викинути усі числові дані qgroup і виконати повторне сканування з поточними
налаштуваннями.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_replace"
.IX Subsection "guestfs_btrfs_replace"
.Vb 5
\& int
\& guestfs_btrfs_replace (guestfs_h *g,
\&                        const char *srcdev,
\&                        const char *targetdev,
\&                        const char *mntpoint);
.Ve
.PP
Замінити пристрій файлової системи btrfs. На «живій» файловій системі
здублювати на пристрій призначення дані, які на поточний момент зберігаються
на пристрої джерела. Після завершення операції пристрій джерела буде витерто
і вилучено з файлової системи.
.PP
.Vb 3
\& C<пристрій_призначення> повинен мати той самий або більший розмір за
\&C<пристрій_джерела>. Пристрої, які на поточний момент змонтовано, не можна
\&використовувати як C<пристрій_призначення>.
.Ve
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.48)
.SS "guestfs_btrfs_rescue_chunk_recover"
.IX Subsection "guestfs_btrfs_rescue_chunk_recover"
.Vb 3
\& int
\& guestfs_btrfs_rescue_chunk_recover (guestfs_h *g,
\&                                     const char *device);
.Ve
.PP
Відновити дерево фрагментів файлової системи btrfs шляхом послідовного
сканування пристроїв.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_rescue_super_recover"
.IX Subsection "guestfs_btrfs_rescue_super_recover"
.Vb 3
\& int
\& guestfs_btrfs_rescue_super_recover (guestfs_h *g,
\&                                     const char *device);
.Ve
.PP
Відновити пошкоджені суперблоки із якісних копій.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_scrub_cancel"
.IX Subsection "guestfs_btrfs_scrub_cancel"
.Vb 3
\& int
\& guestfs_btrfs_scrub_cancel (guestfs_h *g,
\&                             const char *path);
.Ve
.PP
Скасувати витирання, що виконується у файловій системі btrfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_scrub_resume"
.IX Subsection "guestfs_btrfs_scrub_resume"
.Vb 3
\& int
\& guestfs_btrfs_scrub_resume (guestfs_h *g,
\&                             const char *path);
.Ve
.PP
Відновити раніше скасований або перерваний зріз на файловій системі btrfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_scrub_start"
.IX Subsection "guestfs_btrfs_scrub_start"
.Vb 3
\& int
\& guestfs_btrfs_scrub_start (guestfs_h *g,
\&                            const char *path);
.Ve
.PP
Читає усі дані і метадані на файловій системі і використовує контрольні суми
та копії\-дублікати зі сховища даних \s-1RAID\s0 для ідентифікації та відновлення
усіх пошкоджених даних.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.22)
.SS "guestfs_btrfs_scrub_status"
.IX Subsection "guestfs_btrfs_scrub_status"
.Vb 3
\& struct guestfs_btrfsscrub *
\& guestfs_btrfs_scrub_status (guestfs_h *g,
\&                             const char *path);
.Ve
.PP
Показати дані щодо стану витирання, яке виконується або завершено на
файловій системі btrfs.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_btrfsscrub *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_btrfsscrub\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.26)
.SS "guestfs_btrfs_set_seeding"
.IX Subsection "guestfs_btrfs_set_seeding"
.Vb 4
\& int
\& guestfs_btrfs_set_seeding (guestfs_h *g,
\&                            const char *device,
\&                            int seeding);
.Ve
.PP
Увімкнути або вимкнути можливість розсіювання для пристрою, на якому
міститься файлова система btrfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.43)
.SS "guestfs_btrfs_subvolume_create"
.IX Subsection "guestfs_btrfs_subvolume_create"
.Vb 3
\& int
\& guestfs_btrfs_subvolume_create (guestfs_h *g,
\&                                 const char *dest);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_btrfs_subvolume_create_opts\*(R" без
додаткових аргументів.
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_create_opts"
.IX Subsection "guestfs_btrfs_subvolume_create_opts"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_create_opts (guestfs_h *g,
\&                                      const char *dest,
\&                                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_BTRFS_SUBVOLUME_CREATE_OPTS_QGROUPID, const char *qgroupid,
.Ve
.PP
Створити підтом btrfs. Значенням аргументу \f(CW\*(C`призначення\*(C'\fR є каталог
призначення і назва підтому у формі
\&\fI/шлях/до/призначення/назва\fR. Додатковий параметр \f(CW\*(C`ідентифікатор q\-групи\*(C'\fR
відповідає q\-групі, до якої слід додати створений підтом.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_create_opts_va"
.IX Subsection "guestfs_btrfs_subvolume_create_opts_va"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_create_opts_va (guestfs_h *g,
\&                                         const char *dest,
\&                                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_btrfs_subvolume_create_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_subvolume_create_opts_argv"
.IX Subsection "guestfs_btrfs_subvolume_create_opts_argv"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_create_opts_argv (guestfs_h *g,
\&                                           const char *dest,
\&                                           const struct guestfs_btrfs_subvolume_create_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_btrfs_subvolume_create_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_subvolume_delete"
.IX Subsection "guestfs_btrfs_subvolume_delete"
.Vb 3
\& int
\& guestfs_btrfs_subvolume_delete (guestfs_h *g,
\&                                 const char *subvolume);
.Ve
.PP
Вилучити вказаний за назвою підтом або знімок btrfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_get_default"
.IX Subsection "guestfs_btrfs_subvolume_get_default"
.Vb 3
\& int64_t
\& guestfs_btrfs_subvolume_get_default (guestfs_h *g,
\&                                      const char *fs);
.Ve
.PP
Отримати типовий підтом або знімок файлової системи, змонтований до точки
\&\f(CW\*(C`точка монтування\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_subvolume_list"
.IX Subsection "guestfs_btrfs_subvolume_list"
.Vb 3
\& struct guestfs_btrfssubvolume_list *
\& guestfs_btrfs_subvolume_list (guestfs_h *g,
\&                               const char *fs);
.Ve
.PP
Виводить список знімків btrfs і підтоми файлової системи btrfs, яку
змонтовано до точки \f(CW\*(C`файлова_система\*(C'\fR.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_btrfssubvolume_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_btrfssubvolume_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_set_default"
.IX Subsection "guestfs_btrfs_subvolume_set_default"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_set_default (guestfs_h *g,
\&                                      int64_t id,
\&                                      const char *fs);
.Ve
.PP
Встановити підтом файлової системи btrfs \f(CW\*(C`файлова_система\*(C'\fR, який буде
типово змонтовано. Див. \f(CW\*(C`guestfs_btrfs_subvolume_list\*(C'\fR, щоб отримати список
підтомів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_show"
.IX Subsection "guestfs_btrfs_subvolume_show"
.Vb 3
\& char **
\& guestfs_btrfs_subvolume_show (guestfs_h *g,
\&                               const char *subvolume);
.Ve
.PP
Повернути докладні дані щодо підтому.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.17)
.SS "guestfs_btrfs_subvolume_snapshot"
.IX Subsection "guestfs_btrfs_subvolume_snapshot"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_snapshot (guestfs_h *g,
\&                                   const char *source,
\&                                   const char *dest);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_btrfs_subvolume_snapshot_opts\*(R"
без додаткових аргументів.
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_snapshot_opts"
.IX Subsection "guestfs_btrfs_subvolume_snapshot_opts"
.Vb 5
\& int
\& guestfs_btrfs_subvolume_snapshot_opts (guestfs_h *g,
\&                                        const char *source,
\&                                        const char *dest,
\&                                        ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_RO, int ro,
\& GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_QGROUPID, const char *qgroupid,
.Ve
.PP
Створити знімок підтому btrfs. Значенням аргументу \f(CW\*(C`призначення\*(C'\fR є каталог
призначення і назва знімка у формі \fI/шлях/до/призначення/назва\fR. Типово,
новостворений знімок придатний до запису. Якщо значенням додаткового
параметра \f(CW\*(C`ro\*(C'\fR є true, буде створено знімок придатний лише до читання.
Додатковий параметр \f(CW\*(C`ідентифікатор q\-групи\*(C'\fR відповідає q\-групі, до якої
слід додати створений знімок.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.35)
.SS "guestfs_btrfs_subvolume_snapshot_opts_va"
.IX Subsection "guestfs_btrfs_subvolume_snapshot_opts_va"
.Vb 5
\& int
\& guestfs_btrfs_subvolume_snapshot_opts_va (guestfs_h *g,
\&                                           const char *source,
\&                                           const char *dest,
\&                                           va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_btrfs_subvolume_snapshot_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfs_subvolume_snapshot_opts_argv"
.IX Subsection "guestfs_btrfs_subvolume_snapshot_opts_argv"
.Vb 5
\& int
\& guestfs_btrfs_subvolume_snapshot_opts_argv (guestfs_h *g,
\&                                             const char *source,
\&                                             const char *dest,
\&                                             const struct guestfs_btrfs_subvolume_snapshot_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_btrfs_subvolume_snapshot_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_btrfstune_enable_extended_inode_refs"
.IX Subsection "guestfs_btrfstune_enable_extended_inode_refs"
.Vb 3
\& int
\& guestfs_btrfstune_enable_extended_inode_refs (guestfs_h *g,
\&                                               const char *device);
.Ve
.PP
Вмикає розширені посилання на inode.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.29)
.SS "guestfs_btrfstune_enable_skinny_metadata_extent_refs"
.IX Subsection "guestfs_btrfstune_enable_skinny_metadata_extent_refs"
.Vb 3
\& int
\& guestfs_btrfstune_enable_skinny_metadata_extent_refs (guestfs_h *g,
\&                                                       const char *device);
.Ve
.PP
Вмикає розширені посилання на спрощені метадані.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.29)
.SS "guestfs_btrfstune_seeding"
.IX Subsection "guestfs_btrfstune_seeding"
.Vb 4
\& int
\& guestfs_btrfstune_seeding (guestfs_h *g,
\&                            const char *device,
\&                            int seeding);
.Ve
.PP
Увімкнути розсіювання пристрою btrfs. Примусово робить файлову систему
придатною лише для читання, щоб її можна було використовувати для побудови
інших файлових систем.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.29)
.SS "guestfs_c_pointer"
.IX Subsection "guestfs_c_pointer"
.Vb 2
\& int64_t
\& guestfs_c_pointer (guestfs_h *g);
.Ve
.PP
In non-C language bindings, this allows you to retrieve the underlying C
pointer to the handle (ie. \f(CW\*(C`guestfs_h *\*(C'\fR).  The purpose of this is to allow
other libraries to interwork with libguestfs.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.29.17)
.SS "guestfs_canonical_device_name"
.IX Subsection "guestfs_canonical_device_name"
.Vb 3
\& char *
\& guestfs_canonical_device_name (guestfs_h *g,
\&                                const char *device);
.Ve
.PP
Ця допоміжна функція корисна для показу назв пристроїв користувачеві. Вона
приймає декілька неформатованих назв пристроїв і повертає їх у відповідному
форматі:
.IP "\fI/dev/hdX\fR" 4
.IX Item "/dev/hdX"
.PD 0
.IP "\fI/dev/vdX\fR" 4
.IX Item "/dev/vdX"
.PD
Дані повертаються у форматі \fI/dev/sdX\fR. Зауважте, що це працює для назв
пристроїв і розділів. Це, у наближеному вигляді, обернення алгоритму,
описаного у розділі \*(L"ІМЕНУВАННЯ БЛОКОВИХ ПРИСТРОЇВ\*(R".
.IP "\fI/dev/mapper/VG\-LV\fR" 4
.IX Item "/dev/mapper/VG-LV"
.PD 0
.IP "\fI/dev/dm\-N\fR" 4
.IX Item "/dev/dm-N"
.PD
Перетворені до форми \fI/dev/VG/LV\fR за допомогою
\&\f(CW\*(C`guestfs_lvm_canonical_lv_name\*(C'\fR.
.PP
Інші рядки повертаються незмінними.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.7)
.SS "guestfs_cap_get_file"
.IX Subsection "guestfs_cap_get_file"
.Vb 3
\& char *
\& guestfs_cap_get_file (guestfs_h *g,
\&                       const char *path);
.Ve
.PP
Ця функція повертає можливості Linux, пов'язані із шляхом \f(CW\*(C`шлях\*(C'\fR. Набір
можливостей повертається у текстовій формі (див. \fBcap_to_text\fR\|(3)).
.PP
Якщо з файлом не пов'язано можливостей, буде повернуто порожній рядок.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`linuxcaps\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.63)
.SS "guestfs_cap_set_file"
.IX Subsection "guestfs_cap_set_file"
.Vb 4
\& int
\& guestfs_cap_set_file (guestfs_h *g,
\&                       const char *path,
\&                       const char *cap);
.Ve
.PP
Ця функція встановлює можливості Linux, пов'язані із шляхом \f(CW\*(C`шлях\*(C'\fR. Набір
можливостей \f(CW\*(C`можливості\*(C'\fR має бути передано у текстовій формі
(див. \fBcap_from_text\fR\|(3)).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`linuxcaps\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.63)
.SS "guestfs_case_sensitive_path"
.IX Subsection "guestfs_case_sensitive_path"
.Vb 3
\& char *
\& guestfs_case_sensitive_path (guestfs_h *g,
\&                              const char *path);
.Ve
.PP
Цією функцією можна скористатися для використання записів шляхів без
врахування регістру символів у системах із врахуванням регістру у шляхах. Це
може знадобитися при читанні з файлів налаштувань Windows або реєстру
Windows до справжнього шляху.
.PP
Команда працює із особливістю драйвера файлових систем ntfs\-3g Linux (та,
ймовірно, інших драйверів), яка полягає у тому, що, хоча у підлеглій
файловій системі регістр символів не враховується, драйвер експортує файлову
систему до Linux як таку, де регістр символів враховується.
.PP
Одним із наслідків цього є те, що спеціалізовані каталоги, зокрема
\&\fIC:\ewindows\fR, можуть показуватися як \fI/WINDOWS\fR або \fI/windows\fR (або інші
записи), залежно від точних характеристик їхнього створення. У самій Windows
це не спричиняє ніяких проблем.
.PP
Вада чи особливість? Вирішувати вам:
http://www.tuxera.com/community/ntfs\-3g\-faq/#posixfilenames1
.PP
\&\f(CW\*(C`guestfs_case_sensitive_path\*(C'\fR намагається визначити справжній регістр
символів кожного запису у шляху. Команда повертає визначений шлях, якщо
існує відповідний повний шлях або його батьківський каталог. Якщо існує
батьківський каталог, але повний шлях не існує, буде визначено регістр для
батьківського каталогу, а решту запису буде додано без змін. Наприклад, якщо
існує файл \f(CW"/Windows/System32/netkvm.sys"\fR:
.ie n .IP """guestfs_case_sensitive_path"" (""/windows/system32/netkvm.sys"")" 4
.el .IP "\f(CWguestfs_case_sensitive_path\fR (``/windows/system32/netkvm.sys'')" 4
.IX Item "guestfs_case_sensitive_path (/windows/system32/netkvm.sys)"
\&\*(L"Windows/System32/netkvm.sys\*(R"
.ie n .IP """guestfs_case_sensitive_path"" (""/windows/system32/NoSuchFile"")" 4
.el .IP "\f(CWguestfs_case_sensitive_path\fR (``/windows/system32/NoSuchFile'')" 4
.IX Item "guestfs_case_sensitive_path (/windows/system32/NoSuchFile)"
\&\*(L"Windows/System32/NoSuchFile\*(R"
.ie n .IP """guestfs_case_sensitive_path"" (""/windows/system33/netkvm.sys"")" 4
.el .IP "\f(CWguestfs_case_sensitive_path\fR (``/windows/system33/netkvm.sys'')" 4
.IX Item "guestfs_case_sensitive_path (/windows/system33/netkvm.sys)"
\&\fI\s-1ERROR\s0\fR
.PP
\&\fIЗауваження\fR: через описану вище поведінку \f(CW\*(C`guestfs_case_sensitive_path\*(C'\fR
не можна використовувати для перевірки наявності файла.
.PP
\&\fIЗауваження\fR: ця функція не обробляє назви дисків, зворотні похилі риски
тощо.
.PP
Див. також \f(CW\*(C`guestfs_realpath\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.75)
.SS "guestfs_cat"
.IX Subsection "guestfs_cat"
.Vb 3
\& char *
\& guestfs_cat (guestfs_h *g,
\&              const char *path);
.Ve
.PP
Повертає вміст файла із назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Оскільки у C ця функція повертає \f(CW\*(C`char *\*(C'\fR, не існує способу відрізнити
символ \f(CW\*(C`\e0\*(C'\fR у вмісті файла і кінець рядка. Для обробки двійкових файлів
скористайтеся функцією \f(CW\*(C`guestfs_read_file\*(C'\fR або \f(CW\*(C`guestfs_download\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 0.4)
.SS "guestfs_checksum"
.IX Subsection "guestfs_checksum"
.Vb 4
\& char *
\& guestfs_checksum (guestfs_h *g,
\&                   const char *csumtype,
\&                   const char *path);
.Ve
.PP
Цей виклик обчислює контрольну суму \s-1MD5,\s0 SHAx або \s-1CRC\s0 для файла із назвою
\&\f(CW\*(C`шлях\*(C'\fR.
.PP
Тип контрольної суми задається параметром \f(CW\*(C`тип_контрольної_суми\*(C'\fR. Можливі
значення цього параметра:
.ie n .IP """crc""" 4
.el .IP "\f(CWcrc\fR" 4
.IX Item "crc"
Обчислити суму циклічної перевірки надлишковості (\s-1CRC\s0) за стандартом \s-1POSIX\s0
для команди \f(CW\*(C`cksum\*(C'\fR.
.ie n .IP """md5""" 4
.el .IP "\f(CWmd5\fR" 4
.IX Item "md5"
Обчислити хеш\-суму \s-1MD5\s0 (за допомогою програми \f(CW\*(C`md5sum\*(C'\fR).
.ie n .IP """sha1""" 4
.el .IP "\f(CWsha1\fR" 4
.IX Item "sha1"
Обчислити хеш\-суму \s-1SHA1\s0 (за допомогою програми \f(CW\*(C`sha1sum\*(C'\fR).
.ie n .IP """sha224""" 4
.el .IP "\f(CWsha224\fR" 4
.IX Item "sha224"
Обчислити хеш\-суму \s-1SHA224\s0 (за допомогою програми \f(CW\*(C`sha224sum\*(C'\fR).
.ie n .IP """sha256""" 4
.el .IP "\f(CWsha256\fR" 4
.IX Item "sha256"
Обчислити хеш\-суму \s-1SHA256\s0 (за допомогою програми \f(CW\*(C`sha256sum\*(C'\fR).
.ie n .IP """sha384""" 4
.el .IP "\f(CWsha384\fR" 4
.IX Item "sha384"
Обчислити хеш\-суму \s-1SHA384\s0 (за допомогою програми \f(CW\*(C`sha384sum\*(C'\fR).
.ie n .IP """sha512""" 4
.el .IP "\f(CWsha512\fR" 4
.IX Item "sha512"
Обчислити хеш\-суму \s-1SHA512\s0 (за допомогою програми \f(CW\*(C`sha512sum\*(C'\fR).
.PP
Контрольна сума повертається у форматі рядка, придатного до друку (\s-1ASCII\s0)
.PP
Щоб отримати контрольну суму пристрою, скористайтеся
\&\f(CW\*(C`guestfs_checksum_device\*(C'\fR.
.PP
Щоб отримати контрольні суми декількох файлів одразу, скористайтеся
\&\f(CW\*(C`guestfs_checksums_out\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.2)
.SS "guestfs_checksum_device"
.IX Subsection "guestfs_checksum_device"
.Vb 4
\& char *
\& guestfs_checksum_device (guestfs_h *g,
\&                          const char *csumtype,
\&                          const char *device);
.Ve
.PP
Цей виклик обчислює контрольну суму \s-1MD5,\s0 SHAx або \s-1CRC\s0 для вмісту пристрою із
назвою \f(CW\*(C`пристрій\*(C'\fR. Типи підтримуваних контрольних сум описано у
документації до команди \f(CW\*(C`guestfs_checksum\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.3.2)
.SS "guestfs_checksums_out"
.IX Subsection "guestfs_checksums_out"
.Vb 5
\& int
\& guestfs_checksums_out (guestfs_h *g,
\&                        const char *csumtype,
\&                        const char *directory,
\&                        const char *sumsfile);
.Ve
.PP
Ця команда обчислює контрольні суми звичайних файлів у каталозі \fIкаталог\fR і
видає список контрольних сум до локального файла результатів \f(CW\*(C`файл_сум\*(C'\fR.
.PP
Командою можна скористатися для перевірки цілісності віртуальної
машини. Втім, щоб забезпечити надійний захист, вам слід звернути увагу на
виведені командою обчислення контрольних сум дані (використовується програма
з \s-1GNU\s0 coreutils). Зокрема, якщо назва файла складається із символів, які
непридатні до друку, coreutils використовує спеціалізований синтаксис із
символом зворотної похилої риски. Щоб дізнатися більше, ознайомтеся із
файлом info \s-1GNU\s0 coreutils.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.7)
.SS "guestfs_chmod"
.IX Subsection "guestfs_chmod"
.Vb 4
\& int
\& guestfs_chmod (guestfs_h *g,
\&                int mode,
\&                const char *path);
.Ve
.PP
Змінити режим (права доступу) для шляху \f(CW\*(C`шлях\*(C'\fR на \f(CW\*(C`режим\*(C'\fR. Передбачено
підтримку лише числових записів режимів.
.PP
\&\fIЗауваження\fR: при використанні цієї команди з guestfish, \f(CW\*(C`режим\*(C'\fR, типово,
має бути вказано у десятковій формі, якщо не буде додано префікса \f(CW0\fR для
вісімкової форми запису, тобто слід вказувати \f(CW0700\fR замість \f(CW700\fR.
.PP
На встановлений режим доступу впливає umask.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_chown"
.IX Subsection "guestfs_chown"
.Vb 5
\& int
\& guestfs_chown (guestfs_h *g,
\&                int owner,
\&                int group,
\&                const char *path);
.Ve
.PP
Змінити власника файла на \f(CW\*(C`власник\*(C'\fR і групу на \f(CW\*(C`група\*(C'\fR.
.PP
Передбачено підтримку лише числових uid і gid. Якщо ви хочете скористатися
текстовими назвами, вам доведеться знайти і обробити файл паролів власноруч
(підтримка Augeas робить це завдання відносно простим).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_clear_backend_setting"
.IX Subsection "guestfs_clear_backend_setting"
.Vb 3
\& int
\& guestfs_clear_backend_setting (guestfs_h *g,
\&                                const char *name);
.Ve
.PP
Якщо рядок параметрів модуля дорівнює \f(CW"name"\fR або починається з
\&\f(CW"name="\fR, цей рядок вилучається з параметрів модуля.
.PP
Цей виклик повертає кількість рядків, які було вилучено (може бути значення
0, 1 або більше за 1).
.PP
Див. \*(L"МОДУЛЬ\*(R", \*(L"ПАРАМЕТРИ МОДУЛЯ\*(R".
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.27.2)
.SS "guestfs_command"
.IX Subsection "guestfs_command"
.Vb 3
\& char *
\& guestfs_command (guestfs_h *g,
\&                  char *const *arguments);
.Ve
.PP
Цей виклик запускає команду з гостьової файлової системи. Файлову систему
має бути змонтовано, вона має містити сумісну операційну систему (тобто
якусь систему Linux із такою або сумісною архітектурою процесора).
.PP
Єдиним параметром є список аргументів у стилі argv. Першим елементом цього
списку є назва програми, яку слід запустити. Наступні елементи є параметрами
цієї програми. Список має бути непорожнім (тобто містити принаймні назву
програми). Зауважте, що команда працює безпосередньо і \fIне\fR викликає
командної оболонки (див. \f(CW\*(C`guestfs_sh\*(C'\fR).
.PP
Повернутим значенням є усі дані, виведені командою до \fIstdout\fR.
.PP
Якщо команда повертає ненульовий стан виходу, тоді ця функція повертає
повідомлення про помилку. Рядок повідомлення про помилку міститиме вміст
\&\fIstderr\fR від команди.
.PP
Змінна середовища \f(CW$PATH\fR міститиме принаймні \fI/usr/bin\fR і \fI/bin\fR. Якщо
вам потрібна програм з іншої теки, вам слід вказати шлях до неї повністю у
першому параметрі.
.PP
Бібліотеки спільного використання та файли даних, потрібні для запуску
програми, мають бути доступними у файлових системах, які змонтовано до
належних точок монтування. Забезпечити відповідність монтування усіх
файлових систем має функція або програма, з якої викликається команда.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.9.1)
.SS "guestfs_command_lines"
.IX Subsection "guestfs_command_lines"
.Vb 3
\& char **
\& guestfs_command_lines (guestfs_h *g,
\&                        char *const *arguments);
.Ve
.PP
Те саме, що і \f(CW\*(C`guestfs_command\*(C'\fR, але результат буде поділено на список
рядків.
.PP
Див. також \f(CW\*(C`guestfs_sh_lines\*(C'\fR
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.9.1)
.SS "guestfs_compress_device_out"
.IX Subsection "guestfs_compress_device_out"
.Vb 6
\& int
\& guestfs_compress_device_out (guestfs_h *g,
\&                              const char *ctype,
\&                              const char *device,
\&                              const char *zdevice,
\&                              ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_COMPRESS_DEVICE_OUT_LEVEL, int level,
.Ve
.PP
Ця команда стискає вміст пристрою \f(CW\*(C`пристрій\*(C'\fR і записує його до локального
файла \f(CW\*(C`z\-пристрій\*(C'\fR.
.PP
Параметр \f(CW\*(C`тип_стискання\*(C'\fR і необов'язковий параметр \f(CW\*(C`рівень\*(C'\fR мають те саме
значення, що і у команді \f(CW\*(C`guestfs_compress_out\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.13.15)
.SS "guestfs_compress_device_out_va"
.IX Subsection "guestfs_compress_device_out_va"
.Vb 6
\& int
\& guestfs_compress_device_out_va (guestfs_h *g,
\&                                 const char *ctype,
\&                                 const char *device,
\&                                 const char *zdevice,
\&                                 va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_compress_device_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_compress_device_out_argv"
.IX Subsection "guestfs_compress_device_out_argv"
.Vb 6
\& int
\& guestfs_compress_device_out_argv (guestfs_h *g,
\&                                   const char *ctype,
\&                                   const char *device,
\&                                   const char *zdevice,
\&                                   const struct guestfs_compress_device_out_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_compress_device_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_compress_out"
.IX Subsection "guestfs_compress_out"
.Vb 6
\& int
\& guestfs_compress_out (guestfs_h *g,
\&                       const char *ctype,
\&                       const char *file,
\&                       const char *zfile,
\&                       ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_COMPRESS_OUT_LEVEL, int level,
.Ve
.PP
Ця команда стискає вміст файла \f(CW\*(C`файл\*(C'\fR і записує його до локального файла
\&\f(CW\*(C`z\-файл\*(C'\fR.
.PP
Вибір програми для стискання керується параметром \f(CW\*(C`тип_стискання\*(C'\fR. Поточні
варіанти значень: \f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR або \f(CW\*(C`lzop\*(C'\fR. У
деяких збірках libguestfs передбачено підтримку не усіх типів
стискання. Якщо підтримки типу стискання не передбачено, буде виведено
повідомлення про помилку, яке міститиме рядок «not supported».
.PP
Необов'язковий параметр \f(CW\*(C`рівень\*(C'\fR керує рівнем стискання. Значення і типові
параметри залежать від використаної програми для стискання.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.13.15)
.SS "guestfs_compress_out_va"
.IX Subsection "guestfs_compress_out_va"
.Vb 6
\& int
\& guestfs_compress_out_va (guestfs_h *g,
\&                          const char *ctype,
\&                          const char *file,
\&                          const char *zfile,
\&                          va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_compress_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_compress_out_argv"
.IX Subsection "guestfs_compress_out_argv"
.Vb 6
\& int
\& guestfs_compress_out_argv (guestfs_h *g,
\&                            const char *ctype,
\&                            const char *file,
\&                            const char *zfile,
\&                            const struct guestfs_compress_out_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_compress_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_config"
.IX Subsection "guestfs_config"
.Vb 4
\& int
\& guestfs_config (guestfs_h *g,
\&                 const char *hvparam,
\&                 const char *hvvalue);
.Ve
.PP
Цією командою можна скористатися для додавання довільних параметрів
гіпервізору у формі \fI\-параметр значення\fR. Насправді, параметр не є зовсім
довільним — ми не даємо вам встановлювати певні параметри, які суперечать
параметрам, які ви використовуєте.
.PP
Першим символом рядка \f(CW\*(C`параметр\-г\-в\*(C'\fR має бути \f(CW\*(C`\-\*(C'\fR (дефіс).
.PP
\&\f(CW\*(C`hvvalue\*(C'\fR може дорівнювати \s-1NULL.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_copy_attributes"
.IX Subsection "guestfs_copy_attributes"
.Vb 5
\& int
\& guestfs_copy_attributes (guestfs_h *g,
\&                          const char *src,
\&                          const char *dest,
\&                          ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 4
\& GUESTFS_COPY_ATTRIBUTES_ALL, int all,
\& GUESTFS_COPY_ATTRIBUTES_MODE, int mode,
\& GUESTFS_COPY_ATTRIBUTES_XATTRIBUTES, int xattributes,
\& GUESTFS_COPY_ATTRIBUTES_OWNERSHIP, int ownership,
.Ve
.PP
Копіювати атрибути шляху (який може вказувати на файл або каталог) до іншого
шляху.
.PP
Типово, атрибут \f(CW\*(C`не\*(C'\fR копіюється, отже, переконайтеся, що щось вказано (або
вкажіть \f(CW\*(C`all\*(C'\fR, щоб скопіювати усі).
.PP
Додаткові аргументи вказують, які атрибути має бути скопійовано:
.ie n .IP """mode""" 4
.el .IP "\f(CWmode\fR" 4
.IX Item "mode"
Копіювати частину режиму файла з запису \f(CW\*(C`джерело\*(C'\fR до запису
\&\f(CW\*(C`призначення\*(C'\fR. Скопіювати можна лише права доступу \s-1UNIX\s0 і липкі біти,
setuid або setgid.
.ie n .IP """xattributes""" 4
.el .IP "\f(CWxattributes\fR" 4
.IX Item "xattributes"
Копіювати розширені атрибути Linux (xattrs) з запису \f(CW\*(C`джерело\*(C'\fR до запису
\&\f(CW\*(C`призначення\*(C'\fR. Цей прапорець не виконує ніяких дій, якщо можливість
\&\fIlinuxxattrs\fR недоступна (див. \f(CW\*(C`guestfs_feature_available\*(C'\fR).
.ie n .IP """ownership""" 4
.el .IP "\f(CWownership\fR" 4
.IX Item "ownership"
Копіювати uid власника і gid групи з запису \f(CW\*(C`джерело\*(C'\fR до запису
\&\f(CW\*(C`призначення\*(C'\fR.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Копіювати \fBусі\fR атрибути із запису \f(CW\*(C`джерело\*(C'\fR до запису
\&\f(CW\*(C`призначення\*(C'\fR. Вмикання цього прапорця вмикає усі інші прапорці, якщо їх ще
не було вказано.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.25.21)
.SS "guestfs_copy_attributes_va"
.IX Subsection "guestfs_copy_attributes_va"
.Vb 5
\& int
\& guestfs_copy_attributes_va (guestfs_h *g,
\&                             const char *src,
\&                             const char *dest,
\&                             va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_copy_attributes\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_attributes_argv"
.IX Subsection "guestfs_copy_attributes_argv"
.Vb 5
\& int
\& guestfs_copy_attributes_argv (guestfs_h *g,
\&                               const char *src,
\&                               const char *dest,
\&                               const struct guestfs_copy_attributes_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_copy_attributes\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_device_to_device"
.IX Subsection "guestfs_copy_device_to_device"
.Vb 5
\& int
\& guestfs_copy_device_to_device (guestfs_h *g,
\&                                const char *src,
\&                                const char *dest,
\&                                ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, int64_t size,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SPARSE, int sparse,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_APPEND, int append,
.Ve
.PP
Чотири виклики — \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR,
\&\f(CW\*(C`guestfs_copy_device_to_file\*(C'\fR, \f(CW\*(C`guestfs_copy_file_to_device\*(C'\fR та
\&\f(CW\*(C`guestfs_copy_file_to_file\*(C'\fR — надають вам змогу копіювати дані джерела
(пристрою або файла) до призначення (пристрою або файла).
.PP
Можливе створення часткових копій, оскільки ви можете додатково вказати
зміщення у джерелі, зміщення у призначенні і розмір копії. Усі ці значення
слід вказувати у байтах. Якщо значення не вказано, обидва зміщення
вважатимуться нульовими, а розмір копії вважатиметься якомога більшим, аж
доки під час копіювання не буде досягнуто кінця джерела.
.PP
Джерело і призначення можуть бути одним і тим самим об'єктом. Втім, області
перекриття може бути скопійовано неправильно.
.PP
Якщо призначенням є файл, його буде, якщо потрібно, створено. Якщо файл
призначення є недостатньо великим, його буде розширено.
.PP
Якщо призначенням є файл і не встановлено прапорець \f(CW\*(C`append\*(C'\fR, файл
призначення буде обрізано. Якщо встановлено прапорець \f(CW\*(C`append\*(C'\fR, копію буде
дописано до початкового файла призначення. У поточній версії прапорець
\&\f(CW\*(C`append\*(C'\fR не можна встановлювати для пристроїв.
.PP
Якщо значенням прапорця \f(CW\*(C`sparse\*(C'\fR є true, виклик уникатиме запису блоку, які
містять лише нулі, що має допомогти у певних ситуаціях, коли резервний диск
є обмеженим у ресурсах. Зауважте, що якщо призначення ще не занулено,
використання цього параметра призведе до некоректних результатів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.13.25)
.SS "guestfs_copy_device_to_device_va"
.IX Subsection "guestfs_copy_device_to_device_va"
.Vb 5
\& int
\& guestfs_copy_device_to_device_va (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_copy_device_to_device\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_device_to_device_argv"
.IX Subsection "guestfs_copy_device_to_device_argv"
.Vb 5
\& int
\& guestfs_copy_device_to_device_argv (guestfs_h *g,
\&                                     const char *src,
\&                                     const char *dest,
\&                                     const struct guestfs_copy_device_to_device_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_copy_device_to_device\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_device_to_file"
.IX Subsection "guestfs_copy_device_to_file"
.Vb 5
\& int
\& guestfs_copy_device_to_file (guestfs_h *g,
\&                              const char *src,
\&                              const char *dest,
\&                              ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_DEVICE_TO_FILE_SIZE, int64_t size,
\& GUESTFS_COPY_DEVICE_TO_FILE_SPARSE, int sparse,
\& GUESTFS_COPY_DEVICE_TO_FILE_APPEND, int append,
.Ve
.PP
Див. \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR, щоб ознайомитися із загальним описом
цього виклику.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.13.25)
.SS "guestfs_copy_device_to_file_va"
.IX Subsection "guestfs_copy_device_to_file_va"
.Vb 5
\& int
\& guestfs_copy_device_to_file_va (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_copy_device_to_file\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_device_to_file_argv"
.IX Subsection "guestfs_copy_device_to_file_argv"
.Vb 5
\& int
\& guestfs_copy_device_to_file_argv (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   const struct guestfs_copy_device_to_file_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_copy_device_to_file\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_file_to_device"
.IX Subsection "guestfs_copy_file_to_device"
.Vb 5
\& int
\& guestfs_copy_file_to_device (guestfs_h *g,
\&                              const char *src,
\&                              const char *dest,
\&                              ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_FILE_TO_DEVICE_SIZE, int64_t size,
\& GUESTFS_COPY_FILE_TO_DEVICE_SPARSE, int sparse,
\& GUESTFS_COPY_FILE_TO_DEVICE_APPEND, int append,
.Ve
.PP
Див. \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR, щоб ознайомитися із загальним описом
цього виклику.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.13.25)
.SS "guestfs_copy_file_to_device_va"
.IX Subsection "guestfs_copy_file_to_device_va"
.Vb 5
\& int
\& guestfs_copy_file_to_device_va (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_copy_file_to_device\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_file_to_device_argv"
.IX Subsection "guestfs_copy_file_to_device_argv"
.Vb 5
\& int
\& guestfs_copy_file_to_device_argv (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   const struct guestfs_copy_file_to_device_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_copy_file_to_device\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_file_to_file"
.IX Subsection "guestfs_copy_file_to_file"
.Vb 5
\& int
\& guestfs_copy_file_to_file (guestfs_h *g,
\&                            const char *src,
\&                            const char *dest,
\&                            ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_FILE_TO_FILE_SIZE, int64_t size,
\& GUESTFS_COPY_FILE_TO_FILE_SPARSE, int sparse,
\& GUESTFS_COPY_FILE_TO_FILE_APPEND, int append,
.Ve
.PP
Див. \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR, щоб ознайомитися із загальним описом
цього виклику.
.PP
Це \fBне\fR функція для копіювання файлів. Цю функцію призначено для копіювання
блоків у наявних файлах. Загальними функціями для копіювання та пересування
файлів є функції \f(CW\*(C`guestfs_cp\*(C'\fR, \f(CW\*(C`guestfs_cp\-a\*(C'\fR та \f(CW\*(C`guestfs_mv\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.13.25)
.SS "guestfs_copy_file_to_file_va"
.IX Subsection "guestfs_copy_file_to_file_va"
.Vb 5
\& int
\& guestfs_copy_file_to_file_va (guestfs_h *g,
\&                               const char *src,
\&                               const char *dest,
\&                               va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_copy_file_to_file\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_file_to_file_argv"
.IX Subsection "guestfs_copy_file_to_file_argv"
.Vb 5
\& int
\& guestfs_copy_file_to_file_argv (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 const struct guestfs_copy_file_to_file_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_copy_file_to_file\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_copy_in"
.IX Subsection "guestfs_copy_in"
.Vb 4
\& int
\& guestfs_copy_in (guestfs_h *g,
\&                  const char *localpath,
\&                  const char *remotedir);
.Ve
.PP
\&\f(CW\*(C`guestfs_copy_in\*(C'\fR копіює локальні файли або каталоги рекурсивно до образу
диска, розташувавши його у каталозі із назвою \f(CW\*(C`remotedir\*(C'\fR (який має
існувати).
.PP
Не можна використовувати символи\-замінники.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.29.24)
.SS "guestfs_copy_out"
.IX Subsection "guestfs_copy_out"
.Vb 4
\& int
\& guestfs_copy_out (guestfs_h *g,
\&                   const char *remotepath,
\&                   const char *localdir);
.Ve
.PP
\&\f(CW\*(C`guestfs_copy_out\*(C'\fR копіює віддалені файли або каталоги рекурсивно з образу
диска, розташовуючи їх на диску основної системи у каталозі із назвою
\&\fI/локальний_каталог\fR (цей каталог має існувати). Ця метакоманда guestfish
перетворюється у послідовність \*(L"download\*(R", \*(L"tar-out\*(R" та інших команд,
якщо це потрібно.
.PP
Щоб отримати поточний каталог, скористайтеся \f(CW\*(C`.\*(C'\fR, ось так:
.PP
.Vb 1
\& C<guestfs_copy_out> /home .
.Ve
.PP
Не можна використовувати символи\-замінники.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.29.24)
.SS "guestfs_copy_size"
.IX Subsection "guestfs_copy_size"
.Vb 5
\& int
\& guestfs_copy_size (guestfs_h *g,
\&                    const char *src,
\&                    const char *dest,
\&                    int64_t size);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_copy_device_to_device\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда копіює точно \f(CW\*(C`розмір\*(C'\fR байтів з одного пристрою або файла джерела
\&\f(CW\*(C`джерело\*(C'\fR до іншого пристрою або файла \f(CW\*(C`призначення\*(C'\fR.
.PP
Зауважте, що команду не вдасться виконати успішно, якщо джерело є надто
малим або призначення є недостатньо великим.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.0.87)
.SS "guestfs_cp"
.IX Subsection "guestfs_cp"
.Vb 4
\& int
\& guestfs_cp (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
Копіює файл з \f(CW\*(C`джерело\*(C'\fR до \f(CW\*(C`призначення\*(C'\fR, де \f(CW\*(C`призначення\*(C'\fR — або назва
файла призначення або назва каталогу призначення.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.18)
.SS "guestfs_cp_a"
.IX Subsection "guestfs_cp_a"
.Vb 4
\& int
\& guestfs_cp_a (guestfs_h *g,
\&               const char *src,
\&               const char *dest);
.Ve
.PP
Копіює файл або каталог з \f(CW\*(C`джерела\*(C'\fR до \f(CW\*(C`призначення\*(C'\fR рекурсивно з
використанням команди \f(CW\*(C`cp \-a\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.18)
.SS "guestfs_cp_r"
.IX Subsection "guestfs_cp_r"
.Vb 4
\& int
\& guestfs_cp_r (guestfs_h *g,
\&               const char *src,
\&               const char *dest);
.Ve
.PP
Копіює файл або каталог з \f(CW\*(C`джерела\*(C'\fR до \f(CW\*(C`призначення\*(C'\fR рекурсивно з
використанням команди \f(CW\*(C`cp \-rP\*(C'\fR.
.PP
Більшості користувачів слід використовувати \f(CW\*(C`guestfs_cp_a\*(C'\fR замість цієї
команди. Ця команда корисна, якщо вам не хочеться зберігати права доступу,
оскільки у файловій системі призначення їх не передбачено (в основному при
записів до файлових систем \s-1FAT DOS\s0).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.21.38)
.SS "guestfs_cpio_out"
.IX Subsection "guestfs_cpio_out"
.Vb 5
\& int
\& guestfs_cpio_out (guestfs_h *g,
\&                   const char *directory,
\&                   const char *cpiofile,
\&                   ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_CPIO_OUT_FORMAT, const char *format,
.Ve
.PP
Ця команда пакує вміст каталогу \fIкаталог\fR отримує його до локального файла
\&\f(CW\*(C`файл cpio\*(C'\fR.
.PP
Передбачено додатковий параметр \f(CW\*(C`format\*(C'\fR, яким можна скористатися для
вибору формату. У поточній версії передбачено підтримку лише таких форматів:
.ie n .IP """newc""" 4
.el .IP "\f(CWnewc\fR" 4
.IX Item "newc"
Новий портативний формат (\s-1SVR4\s0). Цей формат вважається сумісним із
cpio\-подібним форматом, який використовується ядром Linux для initramfs.
.Sp
Цей формат є типовим.
.ie n .IP """crc""" 4
.el .IP "\f(CWcrc\fR" 4
.IX Item "crc"
Новий портативний формат (\s-1SVR4\s0) із контрольною сумою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.27.9)
.SS "guestfs_cpio_out_va"
.IX Subsection "guestfs_cpio_out_va"
.Vb 5
\& int
\& guestfs_cpio_out_va (guestfs_h *g,
\&                      const char *directory,
\&                      const char *cpiofile,
\&                      va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_cpio_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_cpio_out_argv"
.IX Subsection "guestfs_cpio_out_argv"
.Vb 5
\& int
\& guestfs_cpio_out_argv (guestfs_h *g,
\&                        const char *directory,
\&                        const char *cpiofile,
\&                        const struct guestfs_cpio_out_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_cpio_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_dd"
.IX Subsection "guestfs_dd"
.Vb 4
\& int
\& guestfs_dd (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_copy_device_to_device\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда копіює з одного пристрою або файла джерела \f(CW\*(C`джерело\*(C'\fR до іншого
пристрою або файла \f(CW\*(C`призначення\*(C'\fR.  Зазвичай, цією командою слід
користуватися для копіювання на пристрій чи розділ з пристрою чи розділу,
наприклад, для дублювання файлової системи.
.PP
Якщо призначенням є пристрій, він має бути таким самим або більшим за
розміром за файл або пристрій джерела, інакше копіювання виконати не
вдасться. Ця команда не може виконувати часткове копіювання
(див. \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.80)
.SS "guestfs_device_index"
.IX Subsection "guestfs_device_index"
.Vb 3
\& int
\& guestfs_device_index (guestfs_h *g,
\&                       const char *device);
.Ve
.PP
Ця функція приймає назву пристрою (наприклад, «/dev/sdb») і повертає індекс
пристрою у списку пристроїв.
.PP
Нумерація індексів починається з 0. Іменований пристрій має існувати,
наприклад, як рядок, повернутий з \f(CW\*(C`guestfs_list_devices\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_list_devices\*(C'\fR, \f(CW\*(C`guestfs_part_to_dev\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.19.7)
.SS "guestfs_df"
.IX Subsection "guestfs_df"
.Vb 2
\& char *
\& guestfs_df (guestfs_h *g);
.Ve
.PP
Ця команда запускає програму \f(CW\*(C`df\*(C'\fR для отримання даних щодо використаного
місця на диску.
.PP
Ця команда здебільшого корисна для інтерактивних сеансів. Її \fIне\fR
призначено для випадків, коли ви намагаєтеся обробити виведений командою
рядок. Скористайтеся командою \f(CW\*(C`guestfs_statvfs\*(C'\fR, якщо віддаєте команди з
інших програм.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.54)
.SS "guestfs_df_h"
.IX Subsection "guestfs_df_h"
.Vb 2
\& char *
\& guestfs_df_h (guestfs_h *g);
.Ve
.PP
Ця команда запускає програму \f(CW\*(C`df \-h\*(C'\fR для отримання даних щодо використаного
місця на диску у зручному для читання форматі.
.PP
Ця команда здебільшого корисна для інтерактивних сеансів. Її \fIне\fR
призначено для випадків, коли ви намагаєтеся обробити виведений командою
рядок. Скористайтеся командою \f(CW\*(C`guestfs_statvfs\*(C'\fR, якщо віддаєте команди з
інших програм.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.54)
.SS "guestfs_disk_create"
.IX Subsection "guestfs_disk_create"
.Vb 6
\& int
\& guestfs_disk_create (guestfs_h *g,
\&                      const char *filename,
\&                      const char *format,
\&                      int64_t size,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_DISK_CREATE_BACKINGFILE, const char *backingfile,
\& GUESTFS_DISK_CREATE_BACKINGFORMAT, const char *backingformat,
\& GUESTFS_DISK_CREATE_PREALLOCATION, const char *preallocation,
\& GUESTFS_DISK_CREATE_COMPAT, const char *compat,
\& GUESTFS_DISK_CREATE_CLUSTERSIZE, int clustersize,
.Ve
.PP
Створити порожній образ диска із назвою \fIназва_файла\fR (файл основної
системи) із форматом \f(CW\*(C`формат\*(C'\fR (зазвичай, \f(CW\*(C`raw\*(C'\fR або \f(CW\*(C`qcow2\*(C'\fR). Розмір
визначається параметром \f(CW\*(C`розмір\*(C'\fR у байтах.
.PP
Якщо команда використовується із необов'язковим параметром \f(CW\*(C`backingfile\*(C'\fR,
знімок створюється на основі файла резервної копії. У цьому випадку
\&\f(CW\*(C`розмір\*(C'\fR має бути передано як \f(CW\*(C`\-1\*(C'\fR. Розмір знімка є таким самим, як і
розмір файла резервної копії, який визначається автоматично. Вам також варто
передати \f(CW\*(C`backingformat\*(C'\fR для опису формату \f(CW\*(C`backingfile\*(C'\fR.
.PP
Якщо \fIназва_файла\fR відповідає блоковому пристрою, пристрій буде
форматовано. Параметр \f(CW\*(C`розмір\*(C'\fR ігнорується, оскільки блокові пристрої мають
незмінний встановлений розмір.
.PP
Іншими необов’язковими параметрами є:
.ie n .IP """preallocation""" 4
.el .IP "\f(CWpreallocation\fR" 4
.IX Item "preallocation"
Якщо форматом є \f(CW\*(C`raw\*(C'\fR, цей параметр може мати значення \f(CW\*(C`off\*(C'\fR (або
\&\f(CW\*(C`sparse\*(C'\fR) або \f(CW\*(C`full\*(C'\fR для створення розрідженого або повністю розподіленого
файла, відповідно. Типовим є значення \f(CW\*(C`off\*(C'\fR.
.Sp
Якщо форматом є \f(CW\*(C`qcow2\*(C'\fR, цей параметр може мати значення \f(CW\*(C`off\*(C'\fR (або
\&\f(CW\*(C`sparse\*(C'\fR), \f(CW\*(C`metadata\*(C'\fR або \f(CW\*(C`full\*(C'\fR. Попереднє отримання місця під метадані
є швидшим, коли виконується багато записів, але використовує більше
місця. Типовим є значення \f(CW\*(C`off\*(C'\fR.
.ie n .IP """compat""" 4
.el .IP "\f(CWcompat\fR" 4
.IX Item "compat"
Лише \f(CW\*(C`qcow2\*(C'\fR: передайте рядок \f(CW1.1\fR, щоб скористатися розширеним форматом
qcow2, підтримку якого передбачено у qemu ≥ 1.1.
.ie n .IP """clustersize""" 4
.el .IP "\f(CWclustersize\fR" 4
.IX Item "clustersize"
Лише \f(CW\*(C`qcow2\*(C'\fR: змінити розмір кластера qcow2. Типовим є 65536
(байтів). Встановлювати можна будь\-яке значення, яке є степенем двійки від
512 до 2097152.
.PP
Зауважте, що цей виклик не додає новий диск до дескриптора. Вам доведеться
викликати \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR окремо.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.25.31)
.SS "guestfs_disk_create_va"
.IX Subsection "guestfs_disk_create_va"
.Vb 6
\& int
\& guestfs_disk_create_va (guestfs_h *g,
\&                         const char *filename,
\&                         const char *format,
\&                         int64_t size,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_disk_create\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_disk_create_argv"
.IX Subsection "guestfs_disk_create_argv"
.Vb 6
\& int
\& guestfs_disk_create_argv (guestfs_h *g,
\&                           const char *filename,
\&                           const char *format,
\&                           int64_t size,
\&                           const struct guestfs_disk_create_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_disk_create\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_disk_format"
.IX Subsection "guestfs_disk_format"
.Vb 3
\& char *
\& guestfs_disk_format (guestfs_h *g,
\&                      const char *filename);
.Ve
.PP
Визначити і повернути формат образу диска із назвою
\&\fIназва_файла\fR. Значенням \fIназва_файла\fR може бути також пристрій основної
системи. Якщо формат образу диска визначити не вдасться, буде повернуто
рядок \f(CW"unknown"\fR.
.PP
Зауважте, що визначення формату диска може бути небезпечною дією за певних
обставин. Див. \*(L"\s-1CVE\-2010\-3851\*(R"\s0.
.PP
Див. також: \*(L"ФОРМАТИ ОБРАЗІВ ДИСКІВ\*(R"
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.38)
.SS "guestfs_disk_has_backing_file"
.IX Subsection "guestfs_disk_has_backing_file"
.Vb 3
\& int
\& guestfs_disk_has_backing_file (guestfs_h *g,
\&                                const char *filename);
.Ve
.PP
Визначає і повідомляє, чи є у образу диска \fIназва_файла\fR файл резервної
копії.
.PP
Зауважте, що визначення можливостей диска може, за певних обставин,
зашкодити захисту системи. Див. \*(L"\s-1CVE\-2010\-3851\*(R"\s0.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.39)
.SS "guestfs_disk_virtual_size"
.IX Subsection "guestfs_disk_virtual_size"
.Vb 3
\& int64_t
\& guestfs_disk_virtual_size (guestfs_h *g,
\&                            const char *filename);
.Ve
.PP
Визначає і повідомляє віртуальний розмір у байтах образу диска із назвою
\&\fIназва_файла\fR.
.PP
Зауважте, що визначення можливостей диска може, за певних обставин,
зашкодити захисту системи. Див. \*(L"\s-1CVE\-2010\-3851\*(R"\s0.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.19.39)
.SS "guestfs_dmesg"
.IX Subsection "guestfs_dmesg"
.Vb 2
\& char *
\& guestfs_dmesg (guestfs_h *g);
.Ve
.PP
Повертає повідомлення ядра (виведення команди \f(CW\*(C`dmesg\*(C'\fR) гостьової
системи. Іноді корисно для розширеної діагностики проблеми.
.PP
Іншим способом отримання тих самих даних є вмикання докладних повідомлень за
допомогою \f(CW\*(C`guestfs_set_verbose\*(C'\fR або встановленням змінної середовища
\&\f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR перед запуском програми.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.18)
.SS "guestfs_download"
.IX Subsection "guestfs_download"
.Vb 4
\& int
\& guestfs_download (guestfs_h *g,
\&                   const char *remotefilename,
\&                   const char *filename);
.Ve
.PP
Отримати файл \fIназва_віддаленого_файла\fR і зберегти його як \fIназва_файла\fR
на локальній машині.
.PP
Значенням параметра \fIназва_файла\fR також може бути іменований канал обробки
даних.
.PP
Див. також \f(CW\*(C`guestfs_upload\*(C'\fR, \f(CW\*(C`guestfs_cat\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.0.2)
.SS "guestfs_download_blocks"
.IX Subsection "guestfs_download_blocks"
.Vb 7
\& int
\& guestfs_download_blocks (guestfs_h *g,
\&                          const char *device,
\&                          int64_t start,
\&                          int64_t stop,
\&                          const char *filename,
\&                          ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_DOWNLOAD_BLOCKS_UNALLOCATED, int unallocated,
.Ve
.PP
Отримати модулі даних з адреси \fIпочаток\fR до адреси \fIкінець\fR з розділу
диска (наприклад \fI/dev/sda1\fR) і зберегти їх до файла \fIназва_файла\fR у
локальній машині.
.PP
Використання цього програмного інтерфейсу на форматах образів розріджених
дисків, зокрема \s-1QCOW\s0 може призвести до великих заповнених нулями файлів,
отриманих до основної системи.
.PP
Розмір модуля даних залежить від реалізації файлової системи. На файлових
системах \s-1NTFS\s0 модулі даних називаються кластерами, а у ExtX вони називаються
фрагментами.
.PP
Якщо для необов'язкового прапорця \f(CW\*(C`unallocated\*(C'\fR встановлено значення true
(типовим значенням є false), буде видобуто лише нерозміщені блоки. Це
корисно для виявлення прихованих даних або отримання вилучених файлів,
модулі даних яких ще не перезаписано.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`sleuthkit\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.45)
.SS "guestfs_download_blocks_va"
.IX Subsection "guestfs_download_blocks_va"
.Vb 7
\& int
\& guestfs_download_blocks_va (guestfs_h *g,
\&                             const char *device,
\&                             int64_t start,
\&                             int64_t stop,
\&                             const char *filename,
\&                             va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_download_blocks\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_download_blocks_argv"
.IX Subsection "guestfs_download_blocks_argv"
.Vb 7
\& int
\& guestfs_download_blocks_argv (guestfs_h *g,
\&                               const char *device,
\&                               int64_t start,
\&                               int64_t stop,
\&                               const char *filename,
\&                               const struct guestfs_download_blocks_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_download_blocks\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_download_inode"
.IX Subsection "guestfs_download_inode"
.Vb 5
\& int
\& guestfs_download_inode (guestfs_h *g,
\&                         const char *device,
\&                         int64_t inode,
\&                         const char *filename);
.Ve
.PP
Отримати файл, заданий за допомогою inode, з розділу диска (наприклад
\&\fI/dev/sda1\fR) і зберегти його із назвою \fIназва_файла\fR у локальній системі.
.PP
Для виконання цієї команди диск не обов'язково має бути змонтовано.
.PP
Команда здатна отримувати вилучені файли та файли недоступні системі.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`sleuthkit\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.14)
.SS "guestfs_download_offset"
.IX Subsection "guestfs_download_offset"
.Vb 6
\& int
\& guestfs_download_offset (guestfs_h *g,
\&                          const char *remotefilename,
\&                          const char *filename,
\&                          int64_t offset,
\&                          int64_t size);
.Ve
.PP
Отримати файл \fIназва_віддаленого_файла\fR і зберегти його як \fIназва_файла\fR
на локальній машині.
.PP
Читання відбувається з файла \fIназва_віддаленого_файла\fR, розмір визначається
параметром \f(CW\*(C`розмір\*(C'\fR, читання розпочинається з позиції \f(CW\*(C`відступ\*(C'\fR (вказана
область має перебувати у межах файла або пристрою).
.PP
Зауважте, що немає обмеження на обсяг даних, які може бути отримано за
допомогою цього виклику, на відміну від команди \f(CW\*(C`guestfs_pread\*(C'\fR, і цей
виклик завжди читає дані до кінця, якщо не станеться помилки.
.PP
Див. також \f(CW\*(C`guestfs_download\*(C'\fR, \f(CW\*(C`guestfs_pread\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.5.17)
.SS "guestfs_drop_caches"
.IX Subsection "guestfs_drop_caches"
.Vb 3
\& int
\& guestfs_drop_caches (guestfs_h *g,
\&                      int whattodrop);
.Ve
.PP
Це наказує ядру гостьової системи скинути кеш сторінок і/або кеші d\-записів
та inode. Параметр \f(CW\*(C`що_скидати\*(C'\fR вказує ядру, що саме слід скидати,
див. http://linux\-mm.org/Drop_Caches
.PP
Встановлення для \f(CW\*(C`що_скидати\*(C'\fR значення 3 призведе до скидання усього.
.PP
Це автоматично викликає \fBsync\fR\|(2) перед операцією, отже вивільняє
максимальний обсяг пам'яті гостьової системи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.18)
.SS "guestfs_du"
.IX Subsection "guestfs_du"
.Vb 3
\& int64_t
\& guestfs_du (guestfs_h *g,
\&             const char *path);
.Ve
.PP
Ця команда викликає команду \f(CW\*(C`du \-s\*(C'\fR для оцінки використання місця на диску
для шляху \f(CW\*(C`шлях\*(C'\fR.
.PP
\&\f(CW\*(C`шлях\*(C'\fR може бути адресою файла або каталогу. Якщо \f(CW\*(C`шлях\*(C'\fR є каталогом,
оцінка включатиме дані для самого каталогу та усіх його підкаталогів
(рекурсивно).
.PP
Результатом є оцінка розміру у \fIкілобайтах\fR (тобто у одиницях, які
відповідають 1024 байтам).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.0.54)
.SS "guestfs_e2fsck"
.IX Subsection "guestfs_e2fsck"
.Vb 4
\& int
\& guestfs_e2fsck (guestfs_h *g,
\&                 const char *device,
\&                 ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_E2FSCK_CORRECT, int correct,
\& GUESTFS_E2FSCK_FORCEALL, int forceall,
.Ve
.PP
Ця команда виконує перевірку файлової системи ext2/ext3 на пристрої
\&\f(CW\*(C`пристрій\*(C'\fR. Вона може приймати такі необов'язкові аргументи:
.ie n .IP """correct""" 4
.el .IP "\f(CWcorrect\fR" 4
.IX Item "correct"
Автоматично виправляти файлову систему. Використання цього параметра
призведе до того, що e2fsck автоматично виправлятиме усі проблеми файлової
системи, які може бути безпечно виправлено без втручання людини.
.Sp
Цей параметр не можна використовувати одночасно із параметром \f(CW\*(C`forceall\*(C'\fR.
.ie n .IP """forceall""" 4
.el .IP "\f(CWforceall\fR" 4
.IX Item "forceall"
Припускати відповідь «так» на усі питання; уможливлює неінтерактивне
використання e2fsck.
.Sp
Цей параметр не можна використовувати одночасно із параметром \f(CW\*(C`correct\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.15.17)
.SS "guestfs_e2fsck_va"
.IX Subsection "guestfs_e2fsck_va"
.Vb 4
\& int
\& guestfs_e2fsck_va (guestfs_h *g,
\&                    const char *device,
\&                    va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_e2fsck\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_e2fsck_argv"
.IX Subsection "guestfs_e2fsck_argv"
.Vb 4
\& int
\& guestfs_e2fsck_argv (guestfs_h *g,
\&                      const char *device,
\&                      const struct guestfs_e2fsck_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_e2fsck\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_e2fsck_f"
.IX Subsection "guestfs_e2fsck_f"
.Vb 3
\& int
\& guestfs_e2fsck_f (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_e2fsck\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда виконує команду \f(CW\*(C`e2fsck \-p \-f пристрій\*(C'\fR, тобто запускає засіб
перевірки файлової системи ext2/ext3 для пристрою \f(CW\*(C`пристрій\*(C'\fR у
неінтерактивному режимі (\fI\-p\fR), навіть якщо файлову систему позначено як
безпомилкову (\fI\-f\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.29)
.SS "guestfs_echo_daemon"
.IX Subsection "guestfs_echo_daemon"
.Vb 3
\& char *
\& guestfs_echo_daemon (guestfs_h *g,
\&                      char *const *words);
.Ve
.PP
Ця команда з'єднує список слів \f(CW\*(C`слова\*(C'\fR, у якому окремі слова розділено
пробілами, і повертає рядок\-результат.
.PP
Ви можете скористатися цією командою для перевірки з'єднання із фоновою
службою.
.PP
Див. також \f(CW\*(C`guestfs_ping_daemon\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.69)
.SS "guestfs_egrep"
.IX Subsection "guestfs_egrep"
.Vb 4
\& char **
\& guestfs_egrep (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`egrep\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_egrepi"
.IX Subsection "guestfs_egrepi"
.Vb 4
\& char **
\& guestfs_egrepi (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`egrep \-i\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_equal"
.IX Subsection "guestfs_equal"
.Vb 4
\& int
\& guestfs_equal (guestfs_h *g,
\&                const char *file1,
\&                const char *file2);
.Ve
.PP
Порівнює два файли, \fIфайл1\fR і \fIфайл2\fR і повертає true, якщо їхній вміст
повністю ідентичний; якщо це не так, повертає false.
.PP
Для порівнювання використовується зовнішня програма \fBcmp\fR\|(1).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.18)
.SS "guestfs_exists"
.IX Subsection "guestfs_exists"
.Vb 3
\& int
\& guestfs_exists (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
Ця команда повертає \f(CW\*(C`true\*(C'\fR тоді і лише тоді, коли існує файл, каталог (або
будь\-який інший об'єкт файлової системи) із вказаною назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_is_file\*(C'\fR, \f(CW\*(C`guestfs_is_dir\*(C'\fR, \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_extlinux"
.IX Subsection "guestfs_extlinux"
.Vb 3
\& int
\& guestfs_extlinux (guestfs_h *g,
\&                   const char *directory);
.Ve
.PP
Встановлює завантажувач \s-1SYSLINUX\s0 на пристрій, змонтований до каталогу
\&\fIdirectory\fR. На відміну від команди \f(CW\*(C`guestfs_syslinux\*(C'\fR, якій потрібна
файлова система \s-1FAT,\s0 ця команда може бути використана для файлових систем
ext2/3/4 та btrfs.
.PP
Параметр \fIкаталог\fR може бути точкою монтування або каталогом у точці
монтування.
.PP
Крім того, вам слід позначити розділ як «активний»
(\f(CW\*(C`guestfs_part_set_bootable\*(C'\fR), і на першому секторі усього диска має бути
встановлено \s-1MBR\s0 (наприклад, за допомогою \f(CW\*(C`guestfs_pwrite_device\*(C'\fR). До
складу пакунка \s-1SYSLINUX\s0 включено деякі з відповідних \s-1MBR.\s0 Щоб дізнатися
більше, див. сторінку підручника \fBextlinux\fR\|(1).
.PP
Додатково налаштувати \s-1SYSLINUX\s0 можна за допомогою файла із назвою
\&\fIextlinux.conf\fR у каталозі файлової системи \fIкаталог\fR. Докладніше про це
та вміст файла можна дізнатися зі сторінки підручника \fBextlinux\fR\|(1).
.PP
Див. також \f(CW\*(C`guestfs_syslinux\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`extlinux\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.21.27)
.SS "guestfs_f2fs_expand"
.IX Subsection "guestfs_f2fs_expand"
.Vb 3
\& int
\& guestfs_f2fs_expand (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
This expands a f2fs filesystem to match the size of the underlying device.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
This function depends on the feature \f(CW\*(C`f2fs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.39.3)
.SS "guestfs_fallocate"
.IX Subsection "guestfs_fallocate"
.Vb 4
\& int
\& guestfs_fallocate (guestfs_h *g,
\&                    const char *path,
\&                    int len);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_fallocate64\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда отримує місце для файла (заповнене нульовими байтами) із назвою
\&\f(CW\*(C`шлях\*(C'\fR і розміром \f(CW\*(C`довжина\*(C'\fR байтів. Якщо файл вже існує, його буде
перезаписано.
.PP
Не слід плутати цю команду із специфічною для guestfish командою \f(CW\*(C`alloc\*(C'\fR,
яка отримує місце для файла у основній системі і долучає його як пристрій.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_fallocate64"
.IX Subsection "guestfs_fallocate64"
.Vb 4
\& int
\& guestfs_fallocate64 (guestfs_h *g,
\&                      const char *path,
\&                      int64_t len);
.Ve
.PP
Ця команда отримує місце для файла (заповнене нульовими байтами) із назвою
\&\f(CW\*(C`шлях\*(C'\fR і розміром \f(CW\*(C`довжина\*(C'\fR байтів. Якщо файл вже існує, його буде
перезаписано.
.PP
Зауважте, що ця команда отримує блоки на диску для файла. Щоб створити
розріджений файл, скористайтеся \f(CW\*(C`guestfs_truncate_size\*(C'\fR.
.PP
Застаріла команда \f(CW\*(C`guestfs_fallocate\*(C'\fR виконує те саме завдання, але через
недогляд функція надає змогу використовувати лише 30\-бітові довжини, що
обмежує максимальний можливий розмір створених за допомогою цієї команди
файлів 1 ГБ.
.PP
Не слід плутати цю команду із специфічними для guestfish командами \f(CW\*(C`alloc\*(C'\fR
та \f(CW\*(C`sparse\*(C'\fR, які створюють файл у основній системі і долучають його як
пристрій.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.17)
.SS "guestfs_feature_available"
.IX Subsection "guestfs_feature_available"
.Vb 3
\& int
\& guestfs_feature_available (guestfs_h *g,
\&                            char *const *groups);
.Ve
.PP
Те саме, що і \f(CW\*(C`guestfs_available\*(C'\fR, але повертає простий результат у булевій
формі true або false замість виклику виключення, якщо можливості не буде
виявлено. Із іншими аспектами документації можна ознайомитися у розділі
\&\f(CW\*(C`guestfs_available\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.21.26)
.SS "guestfs_fgrep"
.IX Subsection "guestfs_fgrep"
.Vb 4
\& char **
\& guestfs_fgrep (guestfs_h *g,
\&                const char *pattern,
\&                const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`fgrep\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_fgrepi"
.IX Subsection "guestfs_fgrepi"
.Vb 4
\& char **
\& guestfs_fgrepi (guestfs_h *g,
\&                 const char *pattern,
\&                 const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`fgrep \-i\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_file"
.IX Subsection "guestfs_file"
.Vb 3
\& char *
\& guestfs_file (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Для визначення типу або вмісту файла використовується стандартна програма
\&\fBfile\fR\|(1).
.PP
Цей виклик також прозоро обробляє різні типи стиснутих файлів.
.PP
Команда, яку буде виконано, — це \f(CW\*(C`file \-zb шлях\*(C'\fR. Зокрема, слід зауважити,
що до виведених даних не буде додано назву файла (параметр \fI\-b\fR).
.PP
Виведені дані залежать від того, що виведе підлегла команда \fBfile\fR\|(1), їх
може бути змінено у майбутньому у спосіб, який залишається поза нашим
контролем. Іншими словами, \s-1ABI\s0 щодо виведених даних не гарантовано.
.PP
Див. також: \fBfile\fR\|(1), \f(CW\*(C`guestfs_vfs_type\*(C'\fR, \f(CW\*(C`guestfs_lstat\*(C'\fR,
\&\f(CW\*(C`guestfs_is_file\*(C'\fR, \f(CW\*(C`guestfs_is_blockdev\*(C'\fR (тощо), \f(CW\*(C`guestfs_is_zero\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.9.1)
.SS "guestfs_file_architecture"
.IX Subsection "guestfs_file_architecture"
.Vb 3
\& char *
\& guestfs_file_architecture (guestfs_h *g,
\&                            const char *filename);
.Ve
.PP
Визначає архітектуру виконуваного файла \fIназва_файла\fR і повертає її
значення, якщо воно визначене у програмі.
.PP
Архітектурами, визначеними у поточній версії є:
.ie n .IP """aarch64""" 4
.el .IP "``aarch64''" 4
.IX Item "aarch64"
64\-бітовий \s-1ARM.\s0
.ie n .IP """arm""" 4
.el .IP "``arm''" 4
.IX Item "arm"
32\-бітовий \s-1ARM.\s0
.ie n .IP """i386""" 4
.el .IP "``i386''" 4
.IX Item "i386"
Цей рядок буде повернуто для всіх виконуваних файлів для 32\-бітових
процесорів i386, i486, i586, i686, незалежно від точного значення версії
процесора, визначеного для виконуваного файла.
.ie n .IP """ia64""" 4
.el .IP "``ia64''" 4
.IX Item "ia64"
Intel Itanium.
.ie n .IP """ppc""" 4
.el .IP "``ppc''" 4
.IX Item "ppc"
32\-бітовий Power \s-1PC.\s0
.ie n .IP """ppc64""" 4
.el .IP "``ppc64''" 4
.IX Item "ppc64"
64\-бітовий Power \s-1PC\s0 (зворотний порядок байтів).
.ie n .IP """ppc64le""" 4
.el .IP "``ppc64le''" 4
.IX Item "ppc64le"
64\-бітовий Power \s-1PC\s0 (прямий порядок байтів).
.ie n .IP """riscv32""" 4
.el .IP "``riscv32''" 4
.IX Item "riscv32"
.PD 0
.ie n .IP """riscv64""" 4
.el .IP "``riscv64''" 4
.IX Item "riscv64"
.ie n .IP """riscv128""" 4
.el .IP "``riscv128''" 4
.IX Item "riscv128"
.PD
32\-, 64\- і 128\- бітові різновиди RISC-V.
.ie n .IP """s390""" 4
.el .IP "``s390''" 4
.IX Item "s390"
31\-бітовий \s-1IBM S/390.\s0
.ie n .IP """s390x""" 4
.el .IP "``s390x''" 4
.IX Item "s390x"
64\-бітовий \s-1IBM S/390.\s0
.ie n .IP """sparc""" 4
.el .IP "``sparc''" 4
.IX Item "sparc"
32\-бітовий \s-1SPARC.\s0
.ie n .IP """sparc64""" 4
.el .IP "``sparc64''" 4
.IX Item "sparc64"
64\-бітовий \s-1SPARC V9\s0 або новіша версія.
.ie n .IP """x86_64""" 4
.el .IP "``x86_64''" 4
.IX Item "x86_64"
64\-бітовий x86\-64.
.PP
У майбутніх версіях Libguestfs може повертати і інші рядки назв архітектур.
.PP
Функція працює принаймні для таких типів файлів:
.IP "\(bu" 4
багатьох типів виконуваних файлів Un*x та Linux
.IP "\(bu" 4
багатьох типів бібліотек спільного використання Un*x та Linux
.IP "\(bu" 4
виконуваних файлів Windows Win32 та Win64
.IP "\(bu" 4
\&\s-1DLL\s0 Windows Win32 і Win64
.Sp
виконувані файли та \s-1DLL\s0 Win32 повертають \f(CW\*(C`i386\*(C'\fR.
.Sp
виконувані файли та \s-1DLL\s0 Win64 повертають \f(CW\*(C`x86_64\*(C'\fR.
.IP "\(bu" 4
модулів ядра Linux
.IP "\(bu" 4
образів нового стилю initrd Linux
.IP "\(bu" 4
деяких ядер vmlinuz Linux для архітектур, відмінних від x86
.PP
Що не можна зробити у поточній версії:
.IP "\(bu" 4
статичні бібліотеки (libfoo.a)
.IP "\(bu" 4
initrd Linux у старому стилі, зі стиснутою файловою системою ext2 (\s-1RHEL 3\s0)
.IP "\(bu" 4
ядра vmlinuz Linux x86
.Sp
Образи vmlinuz архітектури x86 (формат bzImage) складаються із суміші
16\-бітового, 32\-бітового і стисненого коду. Їх дуже важко
розпаковувати. Якщо ви хочете визначити архітектуру ядра, скористайтеся
архітектурою пов'язаного initrd або модулів ядра.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_filesize"
.IX Subsection "guestfs_filesize"
.Vb 3
\& int64_t
\& guestfs_filesize (guestfs_h *g,
\&                   const char *file);
.Ve
.PP
Ця команда повертає розмір файла \fIфайл\fR у байтах.
.PP
Щоб отримати інші статистичні дані щодо файла, скористайтеся
\&\f(CW\*(C`guestfs_stat\*(C'\fR, \f(CW\*(C`guestfs_lstat\*(C'\fR, \f(CW\*(C`guestfs_is_dir\*(C'\fR, \f(CW\*(C`guestfs_is_file\*(C'\fR
тощо. Щоб отримати розміри блокових пристроїв, скористайтеся
\&\f(CW\*(C`guestfs_blockdev_getsize64\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.82)
.SS "guestfs_filesystem_available"
.IX Subsection "guestfs_filesystem_available"
.Vb 3
\& int
\& guestfs_filesystem_available (guestfs_h *g,
\&                               const char *filesystem);
.Ve
.PP
Перевірити, чи передбачено у libguestfs підтримку вказаної за назвою
файлової системи. Аргумент \f(CW\*(C`файлова_система\*(C'\fR є назвою файлової системи,
наприклад, \f(CW\*(C`ext3\*(C'\fR.
.PP
Перед використанням цієї команди вам слід викликати \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
Головним чином корисне для перевірки того, що підтримки не передбачено. Те,
що команда повертає true, ще не означає, що певну файлову систему може бути
створено чи змонтовано, оскільки помилки можуть траплятися через інші
причини, зокрема невідповідність версії файлової системи, несумісність
можливостей або недоступність належного засобу
mkfs.<\fIфайлова_система\fR>.
.PP
Див. також \f(CW\*(C`guestfs_available\*(C'\fR, \f(CW\*(C`guestfs_feature_available\*(C'\fR,
\&\*(L"\s-1AVAILABILITY\*(R"\s0.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.5)
.SS "guestfs_filesystem_walk"
.IX Subsection "guestfs_filesystem_walk"
.Vb 3
\& struct guestfs_tsk_dirent_list *
\& guestfs_filesystem_walk (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Пройтися внутрішньою структурою розділу диска (наприклад \fI/dev/sda1\fR) з
метою визначення і повернення списку усіх файлів та каталогів, які на ньому
зберігаються.
.PP
Для виконання цієї команди монтування розділу диска не є обов'язковим.
.PP
Буде повернуто усі записи у файловій системі. Ця функція може виводити
список вилучених або недоступних файлів. Записи \fIне\fR упорядковуються.
.PP
Структура \f(CW\*(C`tsk_dirent\*(C'\fR містить вказані нижче поля.
.ie n .IP """tsk_inode""" 4
.el .IP "\f(CWtsk_inode\fR" 4
.IX Item "tsk_inode"
Номер вузла у файловій системі. Може дорівнювати \f(CW0\fR, якщо вузол було
вилучено.
.ie n .IP """tsk_type""" 4
.el .IP "\f(CWtsk_type\fR" 4
.IX Item "tsk_type"
Базові дані щодо типу файлів. Докладний список значень наведено нижче.
.ie n .IP """tsk_size""" 4
.el .IP "\f(CWtsk_size\fR" 4
.IX Item "tsk_size"
Розмір файла у байтах. Може мати значення \f(CW\*(C`\-1\*(C'\fR, якщо вузол файла було
вилучено.
.ie n .IP """tsk_name""" 4
.el .IP "\f(CWtsk_name\fR" 4
.IX Item "tsk_name"
Шлях до файла відносно його каталогу.
.ie n .IP """tsk_flags""" 4
.el .IP "\f(CWtsk_flags\fR" 4
.IX Item "tsk_flags"
Бітове поле, яке містить додаткові дані щодо запису. Є результатом
застосування логічного АБО до таких значень:
.RS 4
.IP "0x0001" 4
.IX Item "0x0001"
Якщо встановлено значення \f(CW1\fR, файл розміщено у файловій системі, і файл є
видимим. Якщо ні, файл було вилучено. За певних обставин функцією
\&\f(CW\*(C`download_inode\*(C'\fR можна скористатися для відновлення вилучених файлів.
.IP "0x0002" 4
.IX Item "0x0002"
У деяких файлових системах, зокрема \s-1NTFS\s0 та Ext2 і новіших, назву файла
відокремлено від структури метаданих. Цей біт встановлюється у значення
\&\f(CW1\fR, якщо назва файла перебуває у нерозміщеному стані, а структура даних —
у розміщеному. Це, загалом кажучи, неявно вказує на те, що метадані було
повторно використано для нового файла. Тому дані щодо типу файла, розміру
файла, часових позначок, кількості посилань та призначення символічного
посилання можуть не відповідати даним початкового вилученого запису.
.IP "0x0004" 4
.IX Item "0x0004"
Цей біт встановлюється у значення \f(CW1\fR, якщо файл було стиснуто з
використанням вбудованої підтримки стискання у файловій системі
(\s-1NTFS\s0). Програмний інтерфейс не може визначити застосований рівень
стискання.
.RE
.RS 4
.RE
.ie n .IP """tsk_atime_sec""" 4
.el .IP "\f(CWtsk_atime_sec\fR" 4
.IX Item "tsk_atime_sec"
.PD 0
.ie n .IP """tsk_atime_nsec""" 4
.el .IP "\f(CWtsk_atime_nsec\fR" 4
.IX Item "tsk_atime_nsec"
.ie n .IP """tsk_mtime_sec""" 4
.el .IP "\f(CWtsk_mtime_sec\fR" 4
.IX Item "tsk_mtime_sec"
.ie n .IP """tsk_mtime_nsec""" 4
.el .IP "\f(CWtsk_mtime_nsec\fR" 4
.IX Item "tsk_mtime_nsec"
.ie n .IP """tsk_ctime_sec""" 4
.el .IP "\f(CWtsk_ctime_sec\fR" 4
.IX Item "tsk_ctime_sec"
.ie n .IP """tsk_ctime_nsec""" 4
.el .IP "\f(CWtsk_ctime_nsec\fR" 4
.IX Item "tsk_ctime_nsec"
.ie n .IP """tsk_crtime_sec""" 4
.el .IP "\f(CWtsk_crtime_sec\fR" 4
.IX Item "tsk_crtime_sec"
.ie n .IP """tsk_crtime_nsec""" 4
.el .IP "\f(CWtsk_crtime_nsec\fR" 4
.IX Item "tsk_crtime_nsec"
.PD
Час доступу, внесення змін, останньої зміни стану та часу створення,
відповідно, у форматі Unix, визначений у секундах і наносекундах.
.ie n .IP """tsk_nlink""" 4
.el .IP "\f(CWtsk_nlink\fR" 4
.IX Item "tsk_nlink"
Кількість назв файлів, які вказують на цей запис.
.ie n .IP """tsk_link""" 4
.el .IP "\f(CWtsk_link\fR" 4
.IX Item "tsk_link"
Якщо записом є символічне посилання, у цьому полі міститиметься шлях до
файла призначення.
.PP
Поле \f(CW\*(C`tsk_type\*(C'\fR міститиме один із таких символів:
.IP "'b'" 4
.IX Item "'b'"
Блоковий особливий
.IP "'c'" 4
.IX Item "'c'"
Символьний особливий
.IP "'d'" 4
.IX Item "'d'"
Каталог
.IP "'f'" 4
.IX Item "'f'"
\&\s-1FIFO\s0 (іменований канал)
.IP "'l'" 4
.IX Item "'l'"
Символічне посилання
.IP "'r'" 4
.IX Item "'r'"
Звичайний файл
.IP "'s'" 4
.IX Item "'s'"
Сокет
.IP "'h'" 4
.IX Item "'h'"
Тіньовий inode (Solaris)
.IP "'w'" 4
.IX Item "'w'"
Витерти inode (\s-1BSD\s0)
.IP "'u'" 4
.IX Item "'u'"
Невідомий тип файла
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_tsk_dirent_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_tsk_dirent_list\*(C'\fI\fR.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`libtsk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.39)
.SS "guestfs_fill"
.IX Subsection "guestfs_fill"
.Vb 5
\& int
\& guestfs_fill (guestfs_h *g,
\&               int c,
\&               int len,
\&               const char *path);
.Ve
.PP
Ця команда створює новий файл із назвою \f(CW\*(C`шлях\*(C'\fR. Спочатку файл буде
заповнено вісімковими значеннями до довжини \f(CW\*(C`кількість\*(C'\fR. Вісімкове значення
задається параметром \f(CW\*(C`c\*(C'\fR, де \f(CW\*(C`c\*(C'\fR має бути числом у діапазоні \f(CW\*(C`[0..255]\*(C'\fR.
.PP
Для заповнення файла нульовими байтами (розріджено) набагато ефективнішим є
використання \f(CW\*(C`guestfs_truncate_size\*(C'\fR. Для створення файла, заповненого
повторюваними вказаними послідовностями байтів, скористайтеся командою
\&\f(CW\*(C`guestfs_fill_pattern\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.0.79)
.SS "guestfs_fill_dir"
.IX Subsection "guestfs_fill_dir"
.Vb 4
\& int
\& guestfs_fill_dir (guestfs_h *g,
\&                   const char *dir,
\&                   int nr);
.Ve
.PP
Ця корисна для тестування файлових систем функція створює \f(CW\*(C`число\*(C'\fR порожніх
файлів у каталозі \f(CW\*(C`каталог\*(C'\fR із назвами від \f(CW00000000\fR до \f(CW\*(C`число\-1\*(C'\fR (тобто
кожна назва файла складається з 8 цифр, які доповнено нулями).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.32)
.SS "guestfs_fill_pattern"
.IX Subsection "guestfs_fill_pattern"
.Vb 5
\& int
\& guestfs_fill_pattern (guestfs_h *g,
\&                       const char *pattern,
\&                       int len,
\&                       const char *path);
.Ve
.PP
Ця функція подібна до \f(CW\*(C`guestfs_fill\*(C'\fR, але створює файл довжини \f(CW\*(C`len\*(C'\fR,
заповнений повторюваними наборами байтів \f(CW\*(C`pattern\*(C'\fR. Якщо потрібно, взірець
буде обрізано так, щоб довжина файла складала точно \f(CW\*(C`len\*(C'\fR байтів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.3.12)
.SS "guestfs_find"
.IX Subsection "guestfs_find"
.Vb 3
\& char **
\& guestfs_find (guestfs_h *g,
\&               const char *directory);
.Ve
.PP
Ця команда виводить список усіх файлів і каталогів, рекурсивно, починаючи з
каталогу \fIкаталог\fR. В основному, еквівалентна команді оболонки \f(CW\*(C`find
каталог \-print\*(C'\fR, але виведені дані буде дещо оброблено. Опис обробки
наведено нижче.
.PP
Ця команда повертає список рядків \fIбез будь\-якого префікса\fR. Отже, якщо
структура каталогів є такою:
.PP
.Vb 3
\& /tmp/a
\& /tmp/b
\& /tmp/c/d
.Ve
.PP
повернутий \f(CW\*(C`guestfs_find\*(C'\fR \fI/tmp\fR список складатиметься з 4 елементів:
.PP
.Vb 4
\& a
\& b
\& c
\& c/d
.Ve
.PP
Якщо \fIкаталог\fR не є каталогом, ця команда повертає помилку.
.PP
Список результатів буде впорядковано.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.27)
.SS "guestfs_find0"
.IX Subsection "guestfs_find0"
.Vb 4
\& int
\& guestfs_find0 (guestfs_h *g,
\&                const char *directory,
\&                const char *files);
.Ve
.PP
Ця команда виводить список усіх файлів і каталогів, рекурсивно, починаючи з
каталогу \fIкаталог\fR, записуючи отриманий список до зовнішнього файла із
назвою \fIфайли\fR.
.PP
Ця команда працює так само, як\f(CW\*(C`guestfs_find\*(C'\fR, за такими виключеннями:
.IP "\(bu" 4
Список результат записується до зовнішнього файла.
.IP "\(bu" 4
Записи (назви файлів) у результаті буде відокремлено символами
\&\f(CW\*(C`\e0\*(C'\fR. Див. параметр \fBfind\fR\|(1) \fI\-print0\fR.
.IP "\(bu" 4
Список результатів не буде впорядковано.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.74)
.SS "guestfs_find_inode"
.IX Subsection "guestfs_find_inode"
.Vb 4
\& struct guestfs_tsk_dirent_list *
\& guestfs_find_inode (guestfs_h *g,
\&                     const char *device,
\&                     int64_t inode);
.Ve
.PP
Шукає усі записи, пов'язані із заданим inode.
.PP
Для кожного запису буде повернуто структуру
\&\f(CW\*(C`tsk_dirent\*(C'\fR. Див. \f(CW\*(C`filesystem_walk\*(C'\fR, щоб дізнатися більше про структури
\&\f(CW\*(C`tsk_dirent\*(C'\fR.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_tsk_dirent_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_tsk_dirent_list\*(C'\fI\fR.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`libtsk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.35.6)
.SS "guestfs_findfs_label"
.IX Subsection "guestfs_findfs_label"
.Vb 3
\& char *
\& guestfs_findfs_label (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
Ця команда виконує пошук у файлових системах і повертає ту з них, яка має
вказану мітку. Якщо таких систем не буде знайдено, буде повернуто
повідомлення про помилку.
.PP
Щоб визначити мітку файлової системи, скористайтеся \f(CW\*(C`guestfs_vfs_label\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_findfs_uuid"
.IX Subsection "guestfs_findfs_uuid"
.Vb 3
\& char *
\& guestfs_findfs_uuid (guestfs_h *g,
\&                      const char *uuid);
.Ve
.PP
Ця команда виконує пошук у файлових системах і повертає ту з них, яка має
вказаний \s-1UUID.\s0 Якщо таких систем не буде знайдено, буде повернуто
повідомлення про помилку.
.PP
Щоб визначити \s-1UUID\s0 файлової системи, скористайтеся \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_fsck"
.IX Subsection "guestfs_fsck"
.Vb 4
\& int
\& guestfs_fsck (guestfs_h *g,
\&               const char *fstype,
\&               const char *device);
.Ve
.PP
Виконує перевірку файлової системи (fsck) на пристрої \f(CW\*(C`пристрій\*(C'\fR, де дані
зберігаються у файловій системі типу \f(CW\*(C`тип_файлової_системи\*(C'\fR.
.PP
Повернуте ціле число є станом. Зі списком кодів стану \f(CW\*(C`fsck\*(C'\fR можна
ознайомитися у документації до \fBfsck\fR\|(8).
.PP
Нотатки:
.IP "\(bu" 4
Якщо кодів стану декілька, виводиться їхня сума.
.IP "\(bu" 4
Ненульовий повернутий код може означати «успіх», наприклад, якщо помилки у
файловій системі було виправлено.
.IP "\(bu" 4
Підтримки перевірки або відновлення томів \s-1NTFS\s0 не передбачено (у
linux-ntfs).
.PP
Ця команда повністю еквівалентна запуску \f(CW\*(C`fsck \-a \-t тип_файлової_системи
пристрій\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.16)
.SS "guestfs_fstrim"
.IX Subsection "guestfs_fstrim"
.Vb 4
\& int
\& guestfs_fstrim (guestfs_h *g,
\&                 const char *mountpoint,
\&                 ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 3
\& GUESTFS_FSTRIM_OFFSET, int64_t offset,
\& GUESTFS_FSTRIM_LENGTH, int64_t length,
\& GUESTFS_FSTRIM_MINIMUMFREEEXTENT, int64_t minimumfreeextent,
.Ve
.PP
Обрізати вільне місце на файловій системі, змонтованій до точки монтування
\&\f(CW\*(C`точка_монтування\*(C'\fR. Файлову систему має бути змонтовано для читання і
запису.
.PP
Вміст файлової системи змінено не буде, але усе вільне місце на ній буде
«обрізано», тобто, якщо розглядати пристрій основної системи, повернуто до
пристрою, що зробить образ диска розрідженішим і уможливить повторне
використання невикористаного простору у файлах qcow2 тощо.
.PP
Ця операція потребує підтримки у libguestfs, змонтованій файловій системі,
файловій системі основної системи, qemu та ядрі основної системи. Якщо цієї
підтримки немає, операція призведе до помилки або навіть виконуватиметься.
.PP
Якщо у драйвері віртуальної файлової системи ядра не передбачено обрізання,
цей виклик завершиться повідомленням про помилку із номером помилки
\&\f(CW\*(C`ENOTSUP\*(C'\fR. У поточній версії таке трапляється під час спроб обрізання
файлових систем \s-1FAT.\s0
.PP
Див. також \f(CW\*(C`guestfs_zero_free_space\*(C'\fR. Це дещо інша операція, яка занулює
вільне місце у файловій системі. Ви можете викликати \f(CW\*(C`guestfs_fstrim\*(C'\fR
замість команди або після команди \f(CW\*(C`guestfs_zero_free_space\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`fstrim\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.6)
.SS "guestfs_fstrim_va"
.IX Subsection "guestfs_fstrim_va"
.Vb 4
\& int
\& guestfs_fstrim_va (guestfs_h *g,
\&                    const char *mountpoint,
\&                    va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_fstrim\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_fstrim_argv"
.IX Subsection "guestfs_fstrim_argv"
.Vb 4
\& int
\& guestfs_fstrim_argv (guestfs_h *g,
\&                      const char *mountpoint,
\&                      const struct guestfs_fstrim_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_fstrim\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_get_append"
.IX Subsection "guestfs_get_append"
.Vb 2
\& const char *
\& guestfs_get_append (guestfs_h *g);
.Ve
.PP
Повертає додаткові параметри ядра, які було додано до командного рядка ядра
базової системи libguestfs.
.PP
Якщо повернуто \f(CW\*(C`NULL\*(C'\fR, до командного рядка не додавалося параметрів.
.PP
Ця функція повертає рядок, який може бути порожнім (\s-1NULL\s0). Способу
повернення повідомлення про помилку цією функцією не передбачено. Рядок
належить дескриптору гостьової системи, його \fIне слід\fR звільняти.
.PP
(Додано у 1.0.26)
.SS "guestfs_get_attach_method"
.IX Subsection "guestfs_get_attach_method"
.Vb 2
\& char *
\& guestfs_get_attach_method (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_get_backend\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає назву поточного модуля.
.PP
Див. \f(CW\*(C`guestfs_set_backend\*(C'\fR і \*(L"МОДУЛЬ\*(R".
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.9.8)
.SS "guestfs_get_autosync"
.IX Subsection "guestfs_get_autosync"
.Vb 2
\& int
\& guestfs_get_autosync (guestfs_h *g);
.Ve
.PP
Отримати значення прапорця автоматичної синхронізації.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_get_backend"
.IX Subsection "guestfs_get_backend"
.Vb 2
\& char *
\& guestfs_get_backend (guestfs_h *g);
.Ve
.PP
Повертає назву поточного модуля.
.PP
Ця властивість дескриптора раніше називалася «метод долучення».
.PP
Див. \f(CW\*(C`guestfs_set_backend\*(C'\fR і \*(L"МОДУЛЬ\*(R".
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.21.26)
.SS "guestfs_get_backend_setting"
.IX Subsection "guestfs_get_backend_setting"
.Vb 3
\& char *
\& guestfs_get_backend_setting (guestfs_h *g,
\&                              const char *name);
.Ve
.PP
Знайти рядок параметрів модуля обробки, який або дорівнює \f(CW"назва"\fR, або
починається із запису \f(CW"назва="\fR. Якщо знайдено рядок \f(CW"назва"\fR, буде
повернуто рядок \f(CW"1"\fR. Якщо знайдено рядок \f(CW"назва="\fR, буде повернуто
частину рядка після знаку рівності (може бути повернуто порожній рядок).
.PP
Якщо відповідного параметра не знайдено, ця функція повертає повідомлення
про помилку. У такому випадку для номера помилки
(див. \f(CW\*(C`guestfs_last_errno\*(C'\fR) буде встановлено значення \f(CW\*(C`ESRCH\*(C'\fR.
.PP
Див. \*(L"МОДУЛЬ\*(R", \*(L"ПАРАМЕТРИ МОДУЛЯ\*(R".
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.27.2)
.SS "guestfs_get_backend_settings"
.IX Subsection "guestfs_get_backend_settings"
.Vb 2
\& char **
\& guestfs_get_backend_settings (guestfs_h *g);
.Ve
.PP
Повертає поточні параметри модуля.
.PP
Цей виклик повертає рядки параметрів усіх модулів. Якщо вам потрібен лише
якийсь окремий параметр модуля, скористайтеся
\&\f(CW\*(C`guestfs_get_backend_setting\*(C'\fR.
.PP
Див. \*(L"МОДУЛЬ\*(R", \*(L"ПАРАМЕТРИ МОДУЛЯ\*(R".
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.25.24)
.SS "guestfs_get_cachedir"
.IX Subsection "guestfs_get_cachedir"
.Vb 2
\& char *
\& guestfs_get_cachedir (guestfs_h *g);
.Ve
.PP
Отримати назву каталогу, який використовується дескриптором для зберігання
кешу базової системи.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.58)
.SS "guestfs_get_direct"
.IX Subsection "guestfs_get_direct"
.Vb 2
\& int
\& guestfs_get_direct (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_internal_get_console_socket\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає значення прапорця безпосередньої роботи із базовою системою.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.72)
.SS "guestfs_get_e2attrs"
.IX Subsection "guestfs_get_e2attrs"
.Vb 3
\& char *
\& guestfs_get_e2attrs (guestfs_h *g,
\&                      const char *file);
.Ve
.PP
Ця команда повертає атрибути файла, пов'язані із назвою \fIфайл\fR.
.PP
Атрибути є пов'язаним зі кожним записом inode набором бітів, який впливає на
поведінку файла. Атрибути повертаються як рядок літер (описано нижче). Рядок
може бути порожнім, що означає, що ніяких атрибутів для файла не
встановлено.
.PP
Ці атрибути є, лише якщо файл зберігається у файловій системі
ext2/3/4. Використання цієї команди для інших типів файлових систем призведе
до помилки.
.PP
У поточній версії передбачено такі повернуті символи (атрибути файла):
.IP "'A'" 4
.IX Item "'A'"
Під час доступу до файла його atime не змінюється.
.IP "'a'" 4
.IX Item "'a'"
До файла можна лише дописувати дані.
.IP "'c'" 4
.IX Item "'c'"
Файл стиснено на диску.
.IP "'D'" 4
.IX Item "'D'"
(Лише для каталогів.) Зміни до цього каталогу синхронно записуються на диск.
.IP "'d'" 4
.IX Item "'d'"
Файл не є кандидатом на резервне копіювання (див. \fBdump\fR\|(8)).
.IP "'E'" 4
.IX Item "'E'"
Файл стиснуто з помилками.
.IP "'e'" 4
.IX Item "'e'"
Файл використовує розширення.
.IP "'h'" 4
.IX Item "'h'"
Файл зберігає свої блоки у одиницях розміру блоків файлової системи замість
секторів.
.IP "'I'" 4
.IX Item "'I'"
(Лише каталоги.) У каталозі використовуються хешовані дерева ієрархії.
.IP "'i'" 4
.IX Item "'i'"
Цей файл є незмінним. До нього не можна вносити зміни, його не можна
вилучати або перейменовувати. На цей файл не можна створювати посилання.
.IP "'j'" 4
.IX Item "'j'"
Файл входить до журналу даних.
.IP "'s'" 4
.IX Item "'s'"
Після вилучення файла усі його блоки буде перезаписано нулями.
.IP "'S'" 4
.IX Item "'S'"
Зміни до цього файла синхронно записуються на диск.
.IP "'T'" 4
.IX Item "'T'"
(Лише каталоги.) Це підказка засобу розміщення у блоках щодо того, що
підкаталоги, які містяться у цьому каталозі слід розподілити між
блоками. Якщо немає, засіб розподілу за блоками спробує згрупувати
підкаталоги.
.IP "'t'" 4
.IX Item "'t'"
Для файлів вимикає об'єднання «хвостів». (Не використовується у основних
реалізаціях ext2.)
.IP "'u'" 4
.IX Item "'u'"
Коли файл вилучається, його блоки буде збережено, уможливлюючи відновлення
вилученого файла.
.IP "'X'" 4
.IX Item "'X'"
Можна отримувати доступ до необробленого вмісту стисненого файла.
.IP "'Z'" 4
.IX Item "'Z'"
Для стисненого файла встановлено прапорець незавершеної зміни.
.PP
У майбутніх версіях може бути додано інші атрибути файлів. Тип
встановлюваних атрибутів залежить від типу файла. Докладний опис можна
знайти на сторінці підручника щодо \fBchattr\fR\|(1).
.PP
Див. також \f(CW\*(C`guestfs_set_e2attrs\*(C'\fR.
.PP
Don't confuse these attributes with extended attributes (see
\&\f(CW\*(C`guestfs_getxattr\*(C'\fR).
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.17.31)
.SS "guestfs_get_e2generation"
.IX Subsection "guestfs_get_e2generation"
.Vb 3
\& int64_t
\& guestfs_get_e2generation (guestfs_h *g,
\&                           const char *file);
.Ve
.PP
Повертає генерацію файла ext2 для файла. Генерація (яку зазвичай називають
«версією») є числом, пов'язаним із inode. Найпоширенішою областю
використання є сервери \s-1NFS.\s0
.PP
Генерація є характерною особливістю файлової системи ext2/3/4. Використання
цієї команди для інших типів файлових систем призведе до помилки.
.PP
Див. \f(CW\*(C`guestfs_set_e2generation\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.17.31)
.SS "guestfs_get_e2label"
.IX Subsection "guestfs_get_e2label"
.Vb 3
\& char *
\& guestfs_get_e2label (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_vfs_label\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда повертає мітку файлової системи ext2/3/4 для файлової системи на
пристрої \f(CW\*(C`пристрій\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.15)
.SS "guestfs_get_e2uuid"
.IX Subsection "guestfs_get_e2uuid"
.Vb 3
\& char *
\& guestfs_get_e2uuid (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_vfs_uuid\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда повертає \s-1UUID\s0 файлової системи ext2/3/4 для файлової системи на
пристрої \f(CW\*(C`пристрій\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.15)
.SS "guestfs_get_hv"
.IX Subsection "guestfs_get_hv"
.Vb 2
\& char *
\& guestfs_get_hv (guestfs_h *g);
.Ve
.PP
Повертає назву виконуваного файла поточного гіпервізору.
.PP
Це значення ніколи не дорівнює \s-1NULL.\s0 Якщо його ще не встановлено, команда
поверне типову назву виконуваного файла qemu.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.23.17)
.SS "guestfs_get_identifier"
.IX Subsection "guestfs_get_identifier"
.Vb 2
\& const char *
\& guestfs_get_identifier (guestfs_h *g);
.Ve
.PP
Отримати ідентифікатор дескриптора. Див. \f(CW\*(C`guestfs_set_identifier\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо сталася помилка. Рядок належить
дескриптору гостьової системи, його \fIне слід\fR звільняти.
.PP
(Додано у 1.31.14)
.SS "guestfs_get_libvirt_requested_credential_challenge"
.IX Subsection "guestfs_get_libvirt_requested_credential_challenge"
.Vb 3
\& char *
\& guestfs_get_libvirt_requested_credential_challenge (guestfs_h *g,
\&                                                     int index);
.Ve
.PP
Виконати перевірку (за даними libvirt) реєстраційних даних із номером
\&\f(CW\*(C`індекс\*(C'\fR. Якщо у libvirt не буде знайдено відповідника для перевірки,
команда поверне порожній рядок, \f(CW""\fR.
.PP
Документацію і приклад коду наведено у розділі \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.52)
.SS "guestfs_get_libvirt_requested_credential_defresult"
.IX Subsection "guestfs_get_libvirt_requested_credential_defresult"
.Vb 3
\& char *
\& guestfs_get_libvirt_requested_credential_defresult (guestfs_h *g,
\&                                                     int index);
.Ve
.PP
Отримати типовий результат (за даними libvirt) реєстраційних даних із
номером \f(CW\*(C`індекс\*(C'\fR. Якщо у libvirt не буде знайдено відповідника для типового
результату, команда поверне порожній рядок, \f(CW""\fR.
.PP
Документацію і приклад коду наведено у розділі \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.52)
.SS "guestfs_get_libvirt_requested_credential_prompt"
.IX Subsection "guestfs_get_libvirt_requested_credential_prompt"
.Vb 3
\& char *
\& guestfs_get_libvirt_requested_credential_prompt (guestfs_h *g,
\&                                                  int index);
.Ve
.PP
Отримати запит (за даними libvirt) реєстраційних даних із номером
\&\f(CW\*(C`індекс\*(C'\fR. Якщо у libvirt не буде знайдено відповідника для запиту, команда
поверне порожній рядок, \f(CW""\fR.
.PP
Документацію і приклад коду наведено у розділі \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.52)
.SS "guestfs_get_libvirt_requested_credentials"
.IX Subsection "guestfs_get_libvirt_requested_credentials"
.Vb 2
\& char **
\& guestfs_get_libvirt_requested_credentials (guestfs_h *g);
.Ve
.PP
Цю команду слід викликати під час зворотного виклику подій для подій типу
\&\f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR.
.PP
Повертає список реєстраційних даних, запит на які надсилає libvirt. Можливі
значення є підмножиною рядків, які надаються, коли ви викликаєте
\&\f(CW\*(C`guestfs_set_libvirt_supported_credentials\*(C'\fR.
.PP
Документацію і приклад коду наведено у розділі \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.19.52)
.SS "guestfs_get_memsize"
.IX Subsection "guestfs_get_memsize"
.Vb 2
\& int
\& guestfs_get_memsize (guestfs_h *g);
.Ve
.PP
Отримує розмір у мегабайтах отриманої для гіпервізору пам'яті.
.PP
Якщо для цього дескриптора не було викликано \f(CW\*(C`guestfs_set_memsize\*(C'\fR і якщо
не було встановлено \f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR, якщо команда повертає типове
вкомпільоване значення розміру пам'яті (memsize).
.PP
Докладніший опис архітектури libguestfs наведено у підручнику з
\&\fBguestfs\fR\|(3).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.55)
.SS "guestfs_get_network"
.IX Subsection "guestfs_get_network"
.Vb 2
\& int
\& guestfs_get_network (guestfs_h *g);
.Ve
.PP
Повертає значення прапорця вмикання мережі.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.4)
.SS "guestfs_get_path"
.IX Subsection "guestfs_get_path"
.Vb 2
\& const char *
\& guestfs_get_path (guestfs_h *g);
.Ve
.PP
Повертає поточний шлях пошуку.
.PP
Це значення ніколи не дорівнює \s-1NULL.\s0 Якщо його ще не встановлено, команда
поверне типовий вміст змінної середовища \s-1PATH.\s0
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо сталася помилка. Рядок належить
дескриптору гостьової системи, його \fIне слід\fR звільняти.
.PP
(Додано у 0.3)
.SS "guestfs_get_pgroup"
.IX Subsection "guestfs_get_pgroup"
.Vb 2
\& int
\& guestfs_get_pgroup (guestfs_h *g);
.Ve
.PP
Повертає прапорець групи процесів.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.18)
.SS "guestfs_get_pid"
.IX Subsection "guestfs_get_pid"
.Vb 2
\& int
\& guestfs_get_pid (guestfs_h *g);
.Ve
.PP
Повертає ідентифікатор гіпервізору. Якщо жодного гіпервізору не запущено,
команда поверне повідомлення про помилку.
.PP
Це внутрішній виклик, який використовується для діагностики і тестування.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.56)
.SS "guestfs_get_program"
.IX Subsection "guestfs_get_program"
.Vb 2
\& const char *
\& guestfs_get_program (guestfs_h *g);
.Ve
.PP
Отримати назву програми. Див. \f(CW\*(C`guestfs_set_program\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо сталася помилка. Рядок належить
дескриптору гостьової системи, його \fIне слід\fR звільняти.
.PP
(Додано у 1.21.29)
.SS "guestfs_get_qemu"
.IX Subsection "guestfs_get_qemu"
.Vb 2
\& const char *
\& guestfs_get_qemu (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_get_hv\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає назву поточного виконуваного файла гіпервізору (типово, qemu).
.PP
Це значення ніколи не дорівнює \s-1NULL.\s0 Якщо його ще не встановлено, команда
поверне типову назву виконуваного файла qemu.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо сталася помилка. Рядок належить
дескриптору гостьової системи, його \fIне слід\fR звільняти.
.PP
(Додано у 1.0.6)
.SS "guestfs_get_recovery_proc"
.IX Subsection "guestfs_get_recovery_proc"
.Vb 2
\& int
\& guestfs_get_recovery_proc (guestfs_h *g);
.Ve
.PP
Повертає прапорець вмикання відновлення процесу.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_get_selinux"
.IX Subsection "guestfs_get_selinux"
.Vb 2
\& int
\& guestfs_get_selinux (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_selinux_relabel\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає поточне значення прапорця selinux, який передається базовій системі
під час її завантаження. Див. \f(CW\*(C`guestfs_set_selinux\*(C'\fR.
.PP
Докладніший опис архітектури libguestfs наведено у підручнику з
\&\fBguestfs\fR\|(3).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.67)
.SS "guestfs_get_smp"
.IX Subsection "guestfs_get_smp"
.Vb 2
\& int
\& guestfs_get_smp (guestfs_h *g);
.Ve
.PP
Повертає кількість віртуальних процесорів, які пов'язано із базовою
системою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.13.15)
.SS "guestfs_get_sockdir"
.IX Subsection "guestfs_get_sockdir"
.Vb 2
\& char *
\& guestfs_get_sockdir (guestfs_h *g);
.Ve
.PP
Отримати назву каталогу, який використовується дескриптором для зберігання
файлів тимчасових сокетів.
.PP
Ця команда відрізняється від \f(CW\*(C`guestfs_tmpdir\*(C'\fR, оскільки для сокетів
потрібні коротші шляхи (через обмеження буферів назв файлів для сокетів
\&\s-1UNIX\s0), а \f(CW\*(C`guestfs_tmpdir\*(C'\fR може бути надто довгим для таких шляхів.
.PP
Типове значення керується змінною середовища \f(CW\*(C`XDG_RUNTIME_DIR\*(C'\fR: якщо
встановлено \f(CW\*(C`XDG_RUNTIME_DIR\*(C'\fR, її значення буде типовим. Якщо ж значення
змінної не встановлено, типовим значенням буде \fI/tmp\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.33.8)
.SS "guestfs_get_state"
.IX Subsection "guestfs_get_state"
.Vb 2
\& int
\& guestfs_get_state (guestfs_h *g);
.Ve
.PP
Повертає поточний стан як непрозоре ціле число. Корисно лише для виведення
діагностичних повідомлень та повідомлень про внутрішні помилки.
.PP
Докладніший опис станів наведено у підручнику з \fBguestfs\fR\|(3).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.2)
.SS "guestfs_get_tmpdir"
.IX Subsection "guestfs_get_tmpdir"
.Vb 2
\& char *
\& guestfs_get_tmpdir (guestfs_h *g);
.Ve
.PP
Отримати назву каталогу, який використовується дескриптором для зберігання
тимчасових файлів.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.58)
.SS "guestfs_get_trace"
.IX Subsection "guestfs_get_trace"
.Vb 2
\& int
\& guestfs_get_trace (guestfs_h *g);
.Ve
.PP
Повертає прапорець трасування команди.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.69)
.SS "guestfs_get_umask"
.IX Subsection "guestfs_get_umask"
.Vb 2
\& int
\& guestfs_get_umask (guestfs_h *g);
.Ve
.PP
Повертає поточне значення umask. Типовим значенням umask є \f(CW022\fR, якщо інше
значення не було встановлено за допомогою виклику \f(CW\*(C`guestfs_umask\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.3.4)
.SS "guestfs_get_verbose"
.IX Subsection "guestfs_get_verbose"
.Vb 2
\& int
\& guestfs_get_verbose (guestfs_h *g);
.Ve
.PP
Повертає значення прапорця докладності повідомлень.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_getcon"
.IX Subsection "guestfs_getcon"
.Vb 2
\& char *
\& guestfs_getcon (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_selinux_relabel\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда отримує контекст безпеки SELinux фонової служби.
.PP
Див. документацію з \s-1SELINUX\s0 у \fBguestfs\fR\|(3) та c<guestfs_setcon>
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`selinux\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.67)
.SS "guestfs_getxattr"
.IX Subsection "guestfs_getxattr"
.Vb 5
\& char *
\& guestfs_getxattr (guestfs_h *g,
\&                   const char *path,
\&                   const char *name,
\&                   size_t *size_r);
.Ve
.PP
Отримати окремий розширений атрибут з файла \f(CW\*(C`path\*(C'\fR за назвою \f(CW\*(C`name\*(C'\fR. У
цьому виклику виконується перехід за символічними посиланнями. Якщо ви
хочете визначити розширений атрибут для самого символічного посилання,
скористайтеся \f(CW\*(C`guestfs_lgetxattr\*(C'\fR.
.PP
Зазвичай, краще отримати усі розширені атрибути файла одним викликом
\&\f(CW\*(C`guestfs_getxattrs\*(C'\fR. Втім, у реалізації деяких файлових систем у Linux є
вади, які заважають отримання повного списку атрибутів. Для таких файлових
систем (найпоширенішою з яких є ntfs\-3g) вам доведеться визначити назви
потрібних вам розширених атрибутів і викликати цю функцію.
.PP
Значеннями розширених атрибутів є блоки двійкових даних. Якщо розширеного
атрибута із назвою \f(CW\*(C`назва\*(C'\fR не існує, командою буде повернуто повідомлення
про помилку.
.PP
Див. також \f(CW\*(C`guestfs_getxattrs\*(C'\fR, \f(CW\*(C`guestfs_lgetxattr\*(C'\fR, \fBattr\fR\|(5).
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.7.24)
.SS "guestfs_getxattrs"
.IX Subsection "guestfs_getxattrs"
.Vb 3
\& struct guestfs_xattr_list *
\& guestfs_getxattrs (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
Ця команда виводить список розширених атрибутів файла або каталогу \f(CW\*(C`шлях\*(C'\fR.
.PP
На рівні системи, ця команда є поєднанням викликів \fBlistxattr\fR\|(2) і
\&\fBgetxattr\fR\|(2).
.PP
Див. також \f(CW\*(C`guestfs_lgetxattrs\*(C'\fR, \fBattr\fR\|(5).
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.59)
.SS "guestfs_glob_expand"
.IX Subsection "guestfs_glob_expand"
.Vb 3
\& char **
\& guestfs_glob_expand (guestfs_h *g,
\&                      const char *pattern);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_glob_expand_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.0.50)
.SS "guestfs_glob_expand_opts"
.IX Subsection "guestfs_glob_expand_opts"
.Vb 4
\& char **
\& guestfs_glob_expand_opts (guestfs_h *g,
\&                           const char *pattern,
\&                           ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_GLOB_EXPAND_OPTS_DIRECTORYSLASH, int directoryslash,
.Ve
.PP
Ця команда виконує пошук усіх назв шляхів, які збігаються із шаблоном
\&\f(CW\*(C`шаблон\*(C'\fR, відповідно до правил розгортання замінників, які використовуються
командною оболонкою.
.PP
Якщо шляхів знайдено не буде, команда поверне порожній список (не помилку).
.PP
Це обгортка навколо функції C \fBglob\fR\|(3) із прапорцями
\&\f(CW\*(C`GLOB_MARK|GLOB_BRACE\*(C'\fR. Див. відповідну сторінку підручника, щоб дізнатися
більше.
.PP
Аргумент \f(CW\*(C`directoryslash\*(C'\fR визначає, чи слід використовувати прапорець
\&\f(CW\*(C`GLOB_MARK\*(C'\fR для \fBglob\fR\|(3). Типовим його значенням є true
(використовувати). Його можна явним чином вимкнути, щоб команда не повертала
завершальних символів похилої риски у назвах каталогів.
.PP
Зауважте, що схожої команди для розгортання назв пристроїв (наприклад
\&\fI/dev/sd*\fR) не існує. З цією метою слід використовувати
\&\f(CW\*(C`guestfs_list_devices\*(C'\fR, \f(CW\*(C`guestfs_list_partitions\*(C'\fR тощо.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.50)
.SS "guestfs_glob_expand_opts_va"
.IX Subsection "guestfs_glob_expand_opts_va"
.Vb 4
\& char **
\& guestfs_glob_expand_opts_va (guestfs_h *g,
\&                              const char *pattern,
\&                              va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_glob_expand_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_glob_expand_opts_argv"
.IX Subsection "guestfs_glob_expand_opts_argv"
.Vb 4
\& char **
\& guestfs_glob_expand_opts_argv (guestfs_h *g,
\&                                const char *pattern,
\&                                const struct guestfs_glob_expand_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_glob_expand_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_grep"
.IX Subsection "guestfs_grep"
.Vb 4
\& char **
\& guestfs_grep (guestfs_h *g,
\&               const char *regex,
\&               const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_grep_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.0.66)
.SS "guestfs_grep_opts"
.IX Subsection "guestfs_grep_opts"
.Vb 5
\& char **
\& guestfs_grep_opts (guestfs_h *g,
\&                    const char *regex,
\&                    const char *path,
\&                    ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 4
\& GUESTFS_GREP_OPTS_EXTENDED, int extended,
\& GUESTFS_GREP_OPTS_FIXED, int fixed,
\& GUESTFS_GREP_OPTS_INSENSITIVE, int insensitive,
\& GUESTFS_GREP_OPTS_COMPRESSED, int compressed,
.Ve
.PP
Викликає зовнішню програму \f(CW\*(C`grep\*(C'\fR і повертає рядки\-відповідники.
.PP
Необов'язковими прапорцями є такі:
.ie n .IP """extended""" 4
.el .IP "\f(CWextended\fR" 4
.IX Item "extended"
Використовувати розширені формальні вирази. Те саме, що використання
прапорця \fI\-E\fR.
.ie n .IP """fixed""" 4
.el .IP "\f(CWfixed\fR" 4
.IX Item "fixed"
Фіксована відповідність (не використовувати формальні вирази). Те саме, що
використання прапорця \fI\-F\fR.
.ie n .IP """insensitive""" 4
.el .IP "\f(CWinsensitive\fR" 4
.IX Item "insensitive"
Не враховувати під час пошуку регістр символів. Те саме, що використання
прапорця \fI\-i\fR.
.ie n .IP """compressed""" 4
.el .IP "\f(CWcompressed\fR" 4
.IX Item "compressed"
Використовує \f(CW\*(C`zgrep\*(C'\fR замість \f(CW\*(C`grep\*(C'\fR. Це надає змогу обробляти стиснені
compress або gzip дані.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_grep_opts_va"
.IX Subsection "guestfs_grep_opts_va"
.Vb 5
\& char **
\& guestfs_grep_opts_va (guestfs_h *g,
\&                       const char *regex,
\&                       const char *path,
\&                       va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_grep_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_grep_opts_argv"
.IX Subsection "guestfs_grep_opts_argv"
.Vb 5
\& char **
\& guestfs_grep_opts_argv (guestfs_h *g,
\&                         const char *regex,
\&                         const char *path,
\&                         const struct guestfs_grep_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_grep_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_grepi"
.IX Subsection "guestfs_grepi"
.Vb 4
\& char **
\& guestfs_grepi (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця функція викликає зовнішню програму \f(CW\*(C`grep \-i\*(C'\fR і повертає відповідні
рядки.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_grub_install"
.IX Subsection "guestfs_grub_install"
.Vb 4
\& int
\& guestfs_grub_install (guestfs_h *g,
\&                       const char *root,
\&                       const char *device);
.Ve
.PP
Ця команда встановлює \s-1GRUB 1\s0 (Grand Unified Bootloader) на \f(CW\*(C`пристрій\*(C'\fR із
кореневим каталогом \f(CW\*(C`корінь\*(C'\fR.
.PP
Нотатки:
.IP "\(bu" 4
У програмному інтерфейсі поточної версії немає способів встановити
завантажувач grub2, який використовується у більшості сучасних гостьових
систем Linux. Команду grub2 можна запустити з самої гостьової системи, втім,
у такого способу запуску є певні проблеми, описані у розділі
\&\*(L"ЗАПУСК КОМАНД\*(R".
.IP "\(bu" 4
Ця команда використовує \f(CW\*(C`grub\-install\*(C'\fR з основної системи. На жаль, grub не
завжди сумісний сам із собою, отже це працює у доволі вузькому діапазоні
ситуацій. Радимо ретельно усе перевіряти для кожної версії гостьової
системи.
.IP "\(bu" 4
Якщо grub-install повідомляє про помилку «No suitable drive was found in the
generated device map.», ймовірно, вам слід спочатку створити файл
\&\fI/boot/grub/device.map\fR, який міститиме прив'язки назв пристроїв grub до
назв пристроїв Linux. Зазвичай, достатньо створити файл з таким вмістом:
.Sp
.Vb 1
\& (hd0) /dev/vda
.Ve
.Sp
замінивши \fI/dev/vda\fR на назву пристрою для встановлення.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`grub\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.17)
.SS "guestfs_head"
.IX Subsection "guestfs_head"
.Vb 3
\& char **
\& guestfs_head (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Ця команда повертає перші 10 рядків файла як список рядків.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.54)
.SS "guestfs_head_n"
.IX Subsection "guestfs_head_n"
.Vb 4
\& char **
\& guestfs_head_n (guestfs_h *g,
\&                 int nrlines,
\&                 const char *path);
.Ve
.PP
Якщо параметр \f(CW\*(C`к\-ть_рядків\*(C'\fR є додатним числом, повертає перші
\&\f(CW\*(C`к\-ть_рядків\*(C'\fR рядків з файла \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо значенням параметра \f(CW\*(C`к\-ть_рядків\*(C'\fR є від'ємне число, команда повертає
усі рядки з файла \f(CW\*(C`шлях\*(C'\fR, окрім останніх \f(CW\*(C`к\-ть_рядків\*(C'\fR рядків.
.PP
Якщо значенням параметра \f(CW\*(C`к\-ть_рядків\*(C'\fR є нуль, команда повертає порожній
список.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.54)
.SS "guestfs_hexdump"
.IX Subsection "guestfs_hexdump"
.Vb 3
\& char *
\& guestfs_hexdump (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Ця команда виконує \f(CW\*(C`hexdump \-C\*(C'\fR для вказаного файла \f(CW\*(C`шлях\*(C'\fR. Результатом
виконання є зручний для читання канонічний шістнадцятковий дамп файла.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.22)
.SS "guestfs_hivex_close"
.IX Subsection "guestfs_hivex_close"
.Vb 2
\& int
\& guestfs_hivex_close (guestfs_h *g);
.Ve
.PP
Закрити поточний елемент керування hivex.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_commit"
.IX Subsection "guestfs_hivex_commit"
.Vb 3
\& int
\& guestfs_hivex_commit (guestfs_h *g,
\&                       const char *filename);
.Ve
.PP
Вносить (записує) зміни до рою.
.PP
Якщо значенням необов'язкового параметра \fIназва_файла\fR є null, зміни буде
записано до того самого рою, який було відкрито. Якщо значенням не є null,
зміни буде записано до вказаного альтернативного файла, а початковий рій
залишиться незмінним.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_add_child"
.IX Subsection "guestfs_hivex_node_add_child"
.Vb 4
\& int64_t
\& guestfs_hivex_node_add_child (guestfs_h *g,
\&                               int64_t parent,
\&                               const char *name);
.Ve
.PP
Додати дочірній вузол до із назвою \f(CW\*(C`назва\*(C'\fR до батьківського запису
\&\f(CW\*(C`батьківський_запис\*(C'\fR.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_children"
.IX Subsection "guestfs_hivex_node_children"
.Vb 3
\& struct guestfs_hivex_node_list *
\& guestfs_hivex_node_children (guestfs_h *g,
\&                              int64_t nodeh);
.Ve
.PP
Повертає список вузлів, які є підключами вузла \f(CW\*(C`вузол\*(C'\fR.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_hivex_node_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_hivex_node_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_delete_child"
.IX Subsection "guestfs_hivex_node_delete_child"
.Vb 3
\& int
\& guestfs_hivex_node_delete_child (guestfs_h *g,
\&                                  int64_t nodeh);
.Ve
.PP
Вилучаєe \f(CW\*(C`вузол\*(C'\fR, якщо потрібно, рекурсивно.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_get_child"
.IX Subsection "guestfs_hivex_node_get_child"
.Vb 4
\& int64_t
\& guestfs_hivex_node_get_child (guestfs_h *g,
\&                               int64_t nodeh,
\&                               const char *name);
.Ve
.PP
Повертає дочірній вузол із назвою \f(CW\*(C`назва\*(C'\fR для вузла \f(CW\*(C`вузол\*(C'\fR, якщо такий
існує. Може повернути \f(CW0\fR, що означатиме, що вузла із вказаною назвою не
існує.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_get_value"
.IX Subsection "guestfs_hivex_node_get_value"
.Vb 4
\& int64_t
\& guestfs_hivex_node_get_value (guestfs_h *g,
\&                               int64_t nodeh,
\&                               const char *key);
.Ve
.PP
Повертає значення, пов'язане із вузлом \f(CW\*(C`вузол\*(C'\fR, яке має назву \f(CW\*(C`ключ\*(C'\fR, якщо
таке існує. Може повернути \f(CW0\fR, що означатиме, що ключа із вказаною назвою
не існує.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_name"
.IX Subsection "guestfs_hivex_node_name"
.Vb 3
\& char *
\& guestfs_hivex_node_name (guestfs_h *g,
\&                          int64_t nodeh);
.Ve
.PP
Повернути назву \f(CW\*(C`nodeh\*(C'\fR.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_parent"
.IX Subsection "guestfs_hivex_node_parent"
.Vb 3
\& int64_t
\& guestfs_hivex_node_parent (guestfs_h *g,
\&                            int64_t nodeh);
.Ve
.PP
Повернути батьківський вузол \f(CW\*(C`nodeh\*(C'\fR.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_set_value"
.IX Subsection "guestfs_hivex_node_set_value"
.Vb 7
\& int
\& guestfs_hivex_node_set_value (guestfs_h *g,
\&                               int64_t nodeh,
\&                               const char *key,
\&                               int64_t t,
\&                               const char *val,
\&                               size_t val_size);
.Ve
.PP
Встановлює або замінює окреме значення у вузлі \f(CW\*(C`вузол\*(C'\fR. Значенням аргументу
\&\f(CW\*(C`ключ\*(C'\fR є назва, \f(CW\*(C`тип\*(C'\fR — тип, а \f(CW\*(C`значення\*(C'\fR — дані.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_node_values"
.IX Subsection "guestfs_hivex_node_values"
.Vb 3
\& struct guestfs_hivex_value_list *
\& guestfs_hivex_node_values (guestfs_h *g,
\&                            int64_t nodeh);
.Ve
.PP
Повертає масив кортежів (ключ, тип даних, дані), пов'язаний із \f(CW\*(C`nodeh\*(C'\fR.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_hivex_value_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_hivex_value_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_open"
.IX Subsection "guestfs_hivex_open"
.Vb 4
\& int
\& guestfs_hivex_open (guestfs_h *g,
\&                     const char *filename,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 4
\& GUESTFS_HIVEX_OPEN_VERBOSE, int verbose,
\& GUESTFS_HIVEX_OPEN_DEBUG, int debug,
\& GUESTFS_HIVEX_OPEN_WRITE, int write,
\& GUESTFS_HIVEX_OPEN_UNSAFE, int unsafe,
.Ve
.PP
Відкриває файл рою реєстру Windows із назвою \fIназва_файла\fR. Якщо вже
існував дескриптор hivex, пов'язаний із цим сеансом guestfs, його буде
закрито.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_open_va"
.IX Subsection "guestfs_hivex_open_va"
.Vb 4
\& int
\& guestfs_hivex_open_va (guestfs_h *g,
\&                        const char *filename,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_hivex_open\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_hivex_open_argv"
.IX Subsection "guestfs_hivex_open_argv"
.Vb 4
\& int
\& guestfs_hivex_open_argv (guestfs_h *g,
\&                          const char *filename,
\&                          const struct guestfs_hivex_open_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_hivex_open\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_hivex_root"
.IX Subsection "guestfs_hivex_root"
.Vb 2
\& int64_t
\& guestfs_hivex_root (guestfs_h *g);
.Ve
.PP
Повернути кореневий вузол гілки.
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_value_key"
.IX Subsection "guestfs_hivex_value_key"
.Vb 3
\& char *
\& guestfs_hivex_value_key (guestfs_h *g,
\&                          int64_t valueh);
.Ve
.PP
Повертає ключ (назву) поля для кортежу (ключ, тип даних, дані).
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_value_string"
.IX Subsection "guestfs_hivex_value_string"
.Vb 3
\& char *
\& guestfs_hivex_value_string (guestfs_h *g,
\&                             int64_t valueh);
.Ve
.PP
Ця команда викликає \f(CW\*(C`guestfs_hivex_value_value\*(C'\fR (яка повертає поле даних на
основі кортежу значень hivex). Далі, припускається, що вмістом поля є рядок
\&\s-1UTF\-16LE,\s0 який перетворюється на рядок \s-1UTF\-8\s0 (або, якщо це неможливо,
команда повертає повідомлення про помилку).
.PP
Команда корисна для читання рядків з реєстру Windows. Втім, вона працює
нестабільно, оскільки реєстр не є строго типізованим, а поля можуть містити
довільні або неочікувані дані.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.37.22)
.SS "guestfs_hivex_value_type"
.IX Subsection "guestfs_hivex_value_type"
.Vb 3
\& int64_t
\& guestfs_hivex_value_type (guestfs_h *g,
\&                           int64_t valueh);
.Ve
.PP
Повертає значення поля типу даних для кортежу (ключ, тип даних, дані).
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_value_utf8"
.IX Subsection "guestfs_hivex_value_utf8"
.Vb 3
\& char *
\& guestfs_hivex_value_utf8 (guestfs_h *g,
\&                           int64_t valueh);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_hivex_value_string\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда викликає \f(CW\*(C`guestfs_hivex_value_value\*(C'\fR (яка повертає поле даних на
основі кортежу значень hivex). Далі, припускається, що вмістом поля є рядок
\&\s-1UTF\-16LE,\s0 який перетворюється на рядок \s-1UTF\-8\s0 (або, якщо це неможливо,
команда повертає повідомлення про помилку).
.PP
Команда корисна для читання рядків з реєстру Windows. Втім, вона працює
нестабільно, оскільки реєстр не є строго типізованим, а поля можуть містити
довільні або неочікувані дані.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_hivex_value_value"
.IX Subsection "guestfs_hivex_value_value"
.Vb 4
\& char *
\& guestfs_hivex_value_value (guestfs_h *g,
\&                            int64_t valueh,
\&                            size_t *size_r);
.Ve
.PP
Повертає значення поля даних для кортежу (ключ, тип даних, дані).
.PP
Обгортка до команди \fBhivex\fR\|(3) із тією ж самою назвою.
.PP
Див. також \f(CW\*(C`guestfs_hivex_value_utf8\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`hivex\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.35)
.SS "guestfs_initrd_cat"
.IX Subsection "guestfs_initrd_cat"
.Vb 5
\& char *
\& guestfs_initrd_cat (guestfs_h *g,
\&                     const char *initrdpath,
\&                     const char *filename,
\&                     size_t *size_r);
.Ve
.PP
Ця команда розпаковує файл \fIназва_файла\fR з файла initrd із назвою
\&\fIшлях_initrd\fR. Назву файла слід вказувати \fIбез\fR початкового символу \fI/\fR.
.PP
Наприклад, у guestfish ви можете скористатися такою командою для вивчення
скрипту завантаження (зазвичай, він має назву \fI/init\fR), який міститься у
initrd Linux або образі initramfs:
.PP
.Vb 1
\& initrd\-cat /boot/initrd\-<версія>.img init
.Ve
.PP
Див. також \f(CW\*(C`guestfs_initrd_list\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.84)
.SS "guestfs_initrd_list"
.IX Subsection "guestfs_initrd_list"
.Vb 3
\& char **
\& guestfs_initrd_list (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
Ця команда виводить список файлів, які містяться у initrd.
.PP
Записи у списку буде виведено без початкового символу \fI/\fR. Список буде
упорядковано за появою файлів (не обов'язково за абеткою). Назви каталогів
буде показано у списку як окремі записи.
.PP
У старих ядрах Linux (2.4 і старіших) як initrd використовується стиснена
файлова система ext2. У нашій команді передбачено підтримку \fIлише\fR новішого
формату initramfs (стиснених файлів cpio).
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.54)
.SS "guestfs_inotify_add_watch"
.IX Subsection "guestfs_inotify_add_watch"
.Vb 4
\& int64_t
\& guestfs_inotify_add_watch (guestfs_h *g,
\&                            const char *path,
\&                            int mask);
.Ve
.PP
Спостерігати для запису \f(CW\*(C`шлях\*(C'\fR за появою подій зі списку \f(CW\*(C`маска\*(C'\fR.
.PP
Зауважте, що якщо запис \f(CW\*(C`шлях\*(C'\fR є каталогом, спостереження вестиметься і за
подіями у каталозі, але \fIне\fR виконуватиметься рекурсивно (у підкаталогах).
.PP
Зауваження для викликів з\-поза C та з\-поза Linux: події inotify визначено у
\&\s-1ABI\s0 ядра Linux. Список наведено у \fI/usr/include/sys/inotify.h\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`inotify\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_inotify_close"
.IX Subsection "guestfs_inotify_close"
.Vb 2
\& int
\& guestfs_inotify_close (guestfs_h *g);
.Ve
.PP
Ця команда закриває дескриптор inotify, який раніше було відкрито
inotify_init. Команда вилучає усі спостереження, викидає усі події з черги і
скасовує надання пам'яті для усіх ресурсів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`inotify\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_inotify_files"
.IX Subsection "guestfs_inotify_files"
.Vb 2
\& char **
\& guestfs_inotify_files (guestfs_h *g);
.Ve
.PP
Ця функція є корисною обгорткою навколо \f(CW\*(C`guestfs_inotify_read\*(C'\fR, яка просто
повертає список назв шляхів об'єктів, які було оброблено touch. Список назв
шляхів буде упорядковано, дублікати записів буде вилучено.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`inotify\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_inotify_init"
.IX Subsection "guestfs_inotify_init"
.Vb 3
\& int
\& guestfs_inotify_init (guestfs_h *g,
\&                       int maxevents);
.Ve
.PP
Ця команда створює дескриптор inotify. Підсистемою inotify можна
скористатися для отримання сповіщень щодо подій, які відбуваються із
об'єктами у файловій системі гостьової операційної системи.
.PP
Значенням параметра \f(CW\*(C`maxevents\*(C'\fR є максимальна кількість подій, які може
бути додано до черги між викликами \f(CW\*(C`guestfs_inotify_read\*(C'\fR або
\&\f(CW\*(C`guestfs_inotify_files\*(C'\fR. Якщо буде передано значення \f(CW0\fR, буде використано
типове значення для ядра (або раніше встановлене значення). Для Linux 2.6.29
типовим значенням є 16384 подій. Якщо обмеження буде перевищено, ядро просто
відкидатиме події, але записуватиме повідомлення щодо факту відкидання,
встановлюючи прапорець \f(CW\*(C`IN_Q_OVERFLOW\*(C'\fR у списку повернутої структури
(див. \f(CW\*(C`guestfs_inotify_read\*(C'\fR).
.PP
Перш ніж буде створено якесь повідомлення про подію, вам слід додати певні
спостереження до внутрішнього списку
спостережень. Див. \f(CW\*(C`guestfs_inotify_add_watch\*(C'\fR та
\&\f(CW\*(C`guestfs_inotify_rm_watch\*(C'\fR.
.PP
Записи подій з черги мають періодично читатися викликом
\&\f(CW\*(C`guestfs_inotify_read\*(C'\fR (або \f(CW\*(C`guestfs_inotify_files\*(C'\fR, який є корисною
обгорткою навколо \f(CW\*(C`guestfs_inotify_read\*(C'\fR). Якщо записи подій не
читатимуться достатньо часто, внутрішню чергу записів може бути переповнено.
.PP
Після використання дескриптор слід закрити викликом
\&\f(CW\*(C`guestfs_inotify_close\*(C'\fR. У процесі закриття буде автоматично вилучено усі
спостереження.
.PP
Огляд інтерфейсу inotify, який відкриває ядро Linux, можна знайти на
сторінці підручника \fBinotify\fR\|(7). Саме цей інтерфейс, грубо кажучи, ми і
відкриваємо за допомогою libguestfs. Зауважте, що для кожного екземпляра
libguestfs відкривається один загальний дескриптор inotify.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`inotify\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_inotify_read"
.IX Subsection "guestfs_inotify_read"
.Vb 2
\& struct guestfs_inotify_event_list *
\& guestfs_inotify_read (guestfs_h *g);
.Ve
.PP
Повертає повну чергу подій, які трапилися з моменту попереднього виклику
читання черги.
.PP
Якщо подій не траплялося, повертає порожній список.
.PP
\&\fIЗауваження\fR: щоб переконатися, що усі записи подій було прочитано, вам
слід повторно викликати цю функцію, аж доки не буде повернуто порожній
список. Причиною є те, що виклик читає записи подій до досягнення
максимального розміру черги повідомлень appliance-to-host і лишає решту
подій у черзі.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_inotify_event_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_inotify_event_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`inotify\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_inotify_rm_watch"
.IX Subsection "guestfs_inotify_rm_watch"
.Vb 3
\& int
\& guestfs_inotify_rm_watch (guestfs_h *g,
\&                           int wd);
.Ve
.PP
Вилучити раніше визначене спостереження
inotify. Див. \f(CW\*(C`guestfs_inotify_add_watch\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`inotify\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_inspect_get_arch"
.IX Subsection "guestfs_inspect_get_arch"
.Vb 3
\& char *
\& guestfs_inspect_get_arch (guestfs_h *g,
\&                           const char *root);
.Ve
.PP
Повертає архітектуру інспектованої операційної системи. Список можливих
повернутих значень можна знайти у описі \f(CW\*(C`guestfs_file_architecture\*(C'\fR.
.PP
Якщо архітектуру визначити не вдасться, буде повернуто рядок \f(CW\*(C`unknown\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_distro"
.IX Subsection "guestfs_inspect_get_distro"
.Vb 3
\& char *
\& guestfs_inspect_get_distro (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
Ця команда повертає дистрибутив інспектованої операційної системи.
.PP
У поточній версії визначено такі дистрибутиви:
.ie n .IP """alpinelinux""" 4
.el .IP "``alpinelinux''" 4
.IX Item "alpinelinux"
Alpine Linux.
.ie n .IP """altlinux""" 4
.el .IP "``altlinux''" 4
.IX Item "altlinux"
\&\s-1ALT\s0 Linux.
.ie n .IP """archlinux""" 4
.el .IP "``archlinux''" 4
.IX Item "archlinux"
Arch Linux.
.ie n .IP """buildroot""" 4
.el .IP "``buildroot''" 4
.IX Item "buildroot"
Дистрибутив, що походить від buildroot, але не той, який ми можемо окремо
визначити.
.ie n .IP """centos""" 4
.el .IP "``centos''" 4
.IX Item "centos"
CentOS.
.ie n .IP """cirros""" 4
.el .IP "``cirros''" 4
.IX Item "cirros"
Cirros.
.ie n .IP """coreos""" 4
.el .IP "``coreos''" 4
.IX Item "coreos"
CoreOS.
.ie n .IP """debian""" 4
.el .IP "``debian''" 4
.IX Item "debian"
Debian.
.ie n .IP """fedora""" 4
.el .IP "``fedora''" 4
.IX Item "fedora"
Fedora.
.ie n .IP """freebsd""" 4
.el .IP "``freebsd''" 4
.IX Item "freebsd"
FreeBSD.
.ie n .IP """freedos""" 4
.el .IP "``freedos''" 4
.IX Item "freedos"
FreeDOS.
.ie n .IP """frugalware""" 4
.el .IP "``frugalware''" 4
.IX Item "frugalware"
Frugalware.
.ie n .IP """gentoo""" 4
.el .IP "``gentoo''" 4
.IX Item "gentoo"
Gentoo.
.ie n .IP """kalilinux""" 4
.el .IP "``kalilinux''" 4
.IX Item "kalilinux"
Kali Linux.
.ie n .IP """linuxmint""" 4
.el .IP "``linuxmint''" 4
.IX Item "linuxmint"
Linux Mint.
.ie n .IP """mageia""" 4
.el .IP "``mageia''" 4
.IX Item "mageia"
Mageia.
.ie n .IP """mandriva""" 4
.el .IP "``mandriva''" 4
.IX Item "mandriva"
Mandriva.
.ie n .IP """meego""" 4
.el .IP "``meego''" 4
.IX Item "meego"
MeeGo.
.ie n .IP """msdos""" 4
.el .IP "``msdos''" 4
.IX Item "msdos"
Microsoft \s-1DOS.\s0
.ie n .IP """neokylin""" 4
.el .IP "``neokylin''" 4
.IX Item "neokylin"
NeoKylin.
.ie n .IP """netbsd""" 4
.el .IP "``netbsd''" 4
.IX Item "netbsd"
NetBSD.
.ie n .IP """openbsd""" 4
.el .IP "``openbsd''" 4
.IX Item "openbsd"
OpenBSD.
.ie n .IP """opensuse""" 4
.el .IP "``opensuse''" 4
.IX Item "opensuse"
OpenSUSE.
.ie n .IP """oraclelinux""" 4
.el .IP "``oraclelinux''" 4
.IX Item "oraclelinux"
Oracle Linux.
.ie n .IP """pardus""" 4
.el .IP "``pardus''" 4
.IX Item "pardus"
Pardus.
.ie n .IP """pldlinux""" 4
.el .IP "``pldlinux''" 4
.IX Item "pldlinux"
\&\s-1PLD\s0 Linux.
.ie n .IP """redhat-based""" 4
.el .IP "``redhat-based''" 4
.IX Item "redhat-based"
Дистрибутив, що походить від Red Hat.
.ie n .IP """rhel""" 4
.el .IP "``rhel''" 4
.IX Item "rhel"
Red Hat Enterprise Linux.
.ie n .IP """scientificlinux""" 4
.el .IP "``scientificlinux''" 4
.IX Item "scientificlinux"
Scientific Linux.
.ie n .IP """slackware""" 4
.el .IP "``slackware''" 4
.IX Item "slackware"
Slackware.
.ie n .IP """sles""" 4
.el .IP "``sles''" 4
.IX Item "sles"
SuSE Linux Enterprise Server або Desktop.
.ie n .IP """suse-based""" 4
.el .IP "``suse-based''" 4
.IX Item "suse-based"
Дистрибутив, заснований на openSuSE.
.ie n .IP """ttylinux""" 4
.el .IP "``ttylinux''" 4
.IX Item "ttylinux"
ttylinux.
.ie n .IP """ubuntu""" 4
.el .IP "``ubuntu''" 4
.IX Item "ubuntu"
Ubuntu.
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
Дистрибутив, тип якого не вдалося визначити.
.ie n .IP """voidlinux""" 4
.el .IP "``voidlinux''" 4
.IX Item "voidlinux"
Void Linux.
.ie n .IP """windows""" 4
.el .IP "``windows''" 4
.IX Item "windows"
У Windows немає дистрибутивів. Цей рядок буде повернуто, якщо операційна
система належить до сімейства Windows.
.PP
У майбутніх версіях libguestfs цією командою можуть повертатися інші
рядки. Функція, звідки викликається команда, має готуватися до обробки
будь\-якого рядка.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_drive_mappings"
.IX Subsection "guestfs_inspect_get_drive_mappings"
.Vb 3
\& char **
\& guestfs_inspect_get_drive_mappings (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
Цей виклик корисний для Windows, де використовується примітивна система
призначення літер дисків (зокрема \fIC:\e\fR) до розділів. Цей програмний
інтерфейс інспектування вивчає реєстр Windows, щоб визначити спосіб
прив'язування дисків і розділів до літер, і повертає хеш\-таблицю, як у
наведеному нижче прикладі:
.PP
.Vb 3
\& C      =>     /dev/vda2
\& E      =>     /dev/vdb1
\& F      =>     /dev/vdc1
.Ve
.PP
Зауважте, що ключі є літерами дисків. Для Windows регістр символів запису
ключа не враховується і складається із простої літери диска без
символу\-відокремлювача, двокрапки.
.PP
У майбутньому ми можемо реалізувати підтримку інших операційних систем, де
також використовуються літери для дисків, але ключі для таких систем можуть
не бути незалежними від регістру символів і можуть перевищувати за довжиною
1 символ. Наприклад, у \s-1OS\-9\s0 диски називалися \f(CW\*(C`h0\*(C'\fR, \f(CW\*(C`h1\*(C'\fR тощо.
.PP
Для гостьових систем Windows у поточній версії повертається лише прив'язка
жорстких дисків. Портативні диски (зокрема DVD-ROM) ігноруються.
.PP
У гостьових системах, де не використовується прив'язка дисків, або прив'язку
дисків не можна визначити, ця команда повертає таблицю порожніх хешів.
.PP
З докладнішими даними можна ознайомитися у розділі
\&\*(L"\s-1INSPECTION\*(R"\s0. Див. також <guestfs_inspect_get_mountpoints>,
<guestfs_inspect_get_filesystems>.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.9.17)
.SS "guestfs_inspect_get_filesystems"
.IX Subsection "guestfs_inspect_get_filesystems"
.Vb 3
\& char **
\& guestfs_inspect_get_filesystems (guestfs_h *g,
\&                                  const char *root);
.Ve
.PP
Ця команда повертає список усіх файлових систем, які, як ми вважаємо,
пов'язано із вказаною операційною системою. Це, зокрема, коренева файлова
система, інші звичайні файлові системи та незмонтовані пристрої, зокрема
диски резервної пам'яті.
.PP
У випадку віртуальної машини із варіантами завантаження операційних систем
файлова система може бути спільною для одразу декількох операційних систем.
.PP
З докладнішими даними можна ознайомитися у розділі
\&\*(L"\s-1INSPECTION\*(R"\s0. Див. також <guestfs_inspect_get_mountpoints>.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_format"
.IX Subsection "guestfs_inspect_get_format"
.Vb 3
\& char *
\& guestfs_inspect_get_format (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR Замінника не передбачено. Зверніться до
документації із програмного інтерфейсу у підручнику з \fBguestfs\fR\|(3), щоб
дізнатися більше.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
До libguestfs 1.38 було передбачено певну ненадійну підтримку виявлення
образів компакт\-дисків для встановлення. Цей програмний інтерфейс мав
повертати таке:
.ie n .IP """installed""" 4
.el .IP "``installed''" 4
.IX Item "installed"
Це встановлена операційна система.
.ie n .IP """installer""" 4
.el .IP "``installer''" 4
.IX Item "installer"
Інспектований образ диска не є встановленою операційною системою, а лише
\&\fIпридатним до завантаження\fR диском, компакт\-диском із портативною
операційною системою або чимось подібним.
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
Формат цього образу диска є невідомим.
.PP
У libguestfs ≥ 1.38 ця команда повертала лише
\&\f(CW\*(C`installed\*(C'\fR. Скористайтеся безпосередньо libosinfo для визначення системи
на компакт\-диску зі встановлювачем.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.9.4)
.SS "guestfs_inspect_get_hostname"
.IX Subsection "guestfs_inspect_get_hostname"
.Vb 3
\& char *
\& guestfs_inspect_get_hostname (guestfs_h *g,
\&                               const char *root);
.Ve
.PP
Ця функція повертає назву вузла операційної системи, яку визначено засобом
інспектування за файлами налаштувань гостьової операційної системи.
.PP
Якщо назву вузла не вдасться визначити, буде повернуто рядок \f(CW\*(C`unknown\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.7.9)
.SS "guestfs_inspect_get_icon"
.IX Subsection "guestfs_inspect_get_icon"
.Vb 5
\& char *
\& guestfs_inspect_get_icon (guestfs_h *g,
\&                           const char *root,
\&                           size_t *size_r,
\&                           ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_INSPECT_GET_ICON_FAVICON, int favicon,
\& GUESTFS_INSPECT_GET_ICON_HIGHQUALITY, int highquality,
.Ve
.PP
Ця функція повертає піктограму, яка відповідає інспектованій операційній
системі. Піктограма повертається як буфер, який містить зображення \s-1PNG\s0
(перекодується до \s-1PNG,\s0 якщо потрібно).
.PP
Якщо отримання піктограми неможливе, ця функція повертає буфер нульової
довжини (не\-NULL). \fIФункції, які викликають цю команду, мають перевіряти
цей випадок\fR.
.PP
Libguestfs починає із пошуку файла із назвою \fI/etc/favicon.png\fR або
\&\fIC:\eetc\efavicon.png\fR і, якщо дані зберігаються у належному форматі, буде
повернуто вміст цього файла. Ви можете вимкнути такі піктограми передаванням
для необов'язкового параметра \f(CW\*(C`favicon\*(C'\fR значення false (типовим значенням є
true).
.PP
Якщо пошук favicon завершиться невдачею, буде виконано пошук відповідної
піктограми у інших місцях гостьової системи.
.PP
Якщо для необов'язкового параметра \f(CW\*(C`highquality\*(C'\fR встановлено значення true,
команда повертатиме лише високоякісні піктограми, тобто піктограми із
високою роздільною здатністю і каналом прозорості. Типово, (зі значенням
false) буде повернуто будь\-яку знайдено піктограму, навіть якщо її якість
буде низькою.
.PP
Нотатки:
.IP "\(bu" 4
На відміну від більшості інших викликів програмного інтерфейсу, перш ніж ви
викличете цю команду, диски гостьової системи має бути змонтовано, оскільки
під час виклику доведеться читати дані з файлової системи гостьової
операційної системи.
.IP "\(bu" 4
\&\fBБезпека:\fR Дані піктограми походять із ненадійної гостьової системи, ними
слід користуватися обережно. Відомі випадки додавання шкідливого коду до
файлів \s-1PNG.\s0 Переконайтеся, що ви користуєтеся libpng (або іншими
відповідними бібліотеками) останньої версії, перш ніж намагатися обробити
або показати піктограму.
.IP "\(bu" 4
Розмір повернутого зображення \s-1PNG\s0 може бути довільним. Зображення може бути
неквадратним. Libguestfs намагається повернути найбільшу доступну піктограму
найвищої якості. Програма сама має масштабувати її до бажаного розміру.
.IP "\(bu" 4
Для видобування піктограм із гостьових систем Windows потрібна зовнішня
програма \f(CW\*(C`wrestool\*(C'\fR з пакунка \f(CW\*(C`icoutils\*(C'\fR та декілька програм (\f(CW\*(C`bmptopnm\*(C'\fR,
\&\f(CW\*(C`pnmtopng\*(C'\fR, \f(CW\*(C`pamcut\*(C'\fR) з пакунка \f(CW\*(C`netpbm\*(C'\fR. Ці програми має бути
встановлено окремо.
.IP "\(bu" 4
Піктограми операційної системи захищено авторськими правами. Перш ніж
використовувати захищені авторським правом дані у власних програмах,
проконсультуйтеся щодо законодавчих аспектів такого використання.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
(Додано у 1.11.12)
.SS "guestfs_inspect_get_icon_va"
.IX Subsection "guestfs_inspect_get_icon_va"
.Vb 5
\& char *
\& guestfs_inspect_get_icon_va (guestfs_h *g,
\&                              const char *root,
\&                              size_t *size_r,
\&                              va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_inspect_get_icon\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_inspect_get_icon_argv"
.IX Subsection "guestfs_inspect_get_icon_argv"
.Vb 5
\& char *
\& guestfs_inspect_get_icon_argv (guestfs_h *g,
\&                                const char *root,
\&                                size_t *size_r,
\&                                const struct guestfs_inspect_get_icon_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_inspect_get_icon\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_inspect_get_major_version"
.IX Subsection "guestfs_inspect_get_major_version"
.Vb 3
\& int
\& guestfs_inspect_get_major_version (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
Ця команда повертає номер основної версії інспектованої операційної системи.
.PP
У Windows використовується послідовна схема нумерування версій, яку \fIне\fR
відображено у назвах ринкових продуктів операційної системи. Зокрема,
операційна система, яку ми знаємо за назвою «Windows 7», насправді має номер
6.1 (тобто основна версія = 6, додаткова версія = 1). Ви можете визначити
справжні номери версій випусків Windows за статтями Вікіпедії або \s-1MSDN.\s0
.PP
Якщо версію не вдасться визначити, буде повернуто \f(CW0\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_minor_version"
.IX Subsection "guestfs_inspect_get_minor_version"
.Vb 3
\& int
\& guestfs_inspect_get_minor_version (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
Ця команда повертає номер додаткової версії інспектованої операційної
системи.
.PP
Якщо версію не вдасться визначити, буде повернуто \f(CW0\fR.
.PP
З докладнішими даними можна ознайомитися у розділі
\&\*(L"\s-1INSPECTION\*(R"\s0. Див. також <guestfs_inspect_get_major_version>.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_mountpoints"
.IX Subsection "guestfs_inspect_get_mountpoints"
.Vb 3
\& char **
\& guestfs_inspect_get_mountpoints (guestfs_h *g,
\&                                  const char *root);
.Ve
.PP
Ця команда повертає хеш даних щодо місця, у якому, як ми гадаємо, має бути
змонтовано файлові системи, пов'язані із операційною системою. Слід
зауважити, що ці дані, у найкращому випадку, визначено на основі здогадок,
заснованих на вивченні файлів налаштувань, зокрема
\&\fI/etc/fstab\fR. \fIЗокрема\fR, використання цієї команди може призвести до
отримання записів файлових систем, яких не існує або які непридатні до
монтування. У коді, який викликатиме команду, слід правильно обробити
випадки, коли під час спроби монтування отриманих файлових систем
ставатимуться помилки.
.PP
У кожного з елементів повернутої хеш\-таблиці буде ключ, який відповідатиме
шляху до точки монтування (наприклад, \fI/boot\fR), і значення, яке
відповідатиме файловій системі, яку має бути змонтовано до цієї точки
монтування (наприклад, \fI/dev/sda1\fR).
.PP
Непридатні до монтування пристрої, зокрема пристрої резервної пам'яті на
диску, \fIне\fR включатимуться до повернутого списку.
.PP
Для операційних систем, подібних до Windows, де для позначення дисків усе ще
використовуються літери, ця команда поверне запис першого диска
«змонтованого до» \fI/\fR. Щоб дізнатися більше про прив'язку літер дисків до
розділів, див. \f(CW\*(C`guestfs_inspect_get_drive_mappings\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі
\&\*(L"\s-1INSPECTION\*(R"\s0. Див. також <guestfs_inspect_get_filesystems>.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_osinfo"
.IX Subsection "guestfs_inspect_get_osinfo"
.Vb 3
\& char *
\& guestfs_inspect_get_osinfo (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
This function returns a possible short \s-1ID\s0 for libosinfo corresponding to the
guest.
.PP
\&\fINote:\fR The returned \s-1ID\s0 is only a guess by libguestfs, and nothing ensures
that it actually exists in osinfo-db.
.PP
If no \s-1ID\s0 could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR is returned.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Added in 1.39.1)
.SS "guestfs_inspect_get_package_format"
.IX Subsection "guestfs_inspect_get_package_format"
.Vb 3
\& char *
\& guestfs_inspect_get_package_format (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
Ця функція і \f(CW\*(C`guestfs_inspect_get_package_management\*(C'\fR повертають формат
пакунків та засіб для керування пакунками, який використовується у
інспектованій операційній системі. Наприклад, для Fedora ці функції мають
повернути \f(CW\*(C`rpm\*(C'\fR (формат пакунків) та \f(CW\*(C`yum\*(C'\fR або \f(CW\*(C`dnf\*(C'\fR (засіб для керування
пакунками).
.PP
Ця команда поверне рядок \f(CW\*(C`unknown\*(C'\fR, якщо не вдасться визначити формат
пакунків \fIабо\fR якщо у операційній системі не використовується система
пакунків (наприклад, у Windows).
.PP
Можливі варіанти рядків: \f(CW\*(C`rpm\*(C'\fR, \f(CW\*(C`deb\*(C'\fR, \f(CW\*(C`ebuild\*(C'\fR, \f(CW\*(C`pisi\*(C'\fR, \f(CW\*(C`pacman\*(C'\fR,
\&\f(CW\*(C`pkgsrc\*(C'\fR, \f(CW\*(C`apk\*(C'\fR, \f(CW\*(C`xbps\*(C'\fR. У майбутніх версіях libguestfs може бути
реалізовано повернення інших рядків.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.7.5)
.SS "guestfs_inspect_get_package_management"
.IX Subsection "guestfs_inspect_get_package_management"
.Vb 3
\& char *
\& guestfs_inspect_get_package_management (guestfs_h *g,
\&                                         const char *root);
.Ve
.PP
\&\f(CW\*(C`guestfs_inspect_get_package_format\*(C'\fR і ця функція повертають формат
пакунків та засіб для керування пакунками, який використовується у
інспектованій операційній системі. Наприклад, для Fedora ці функції мають
повернути \f(CW\*(C`rpm\*(C'\fR (формат пакунків) та \f(CW\*(C`yum\*(C'\fR або \f(CW\*(C`dnf\*(C'\fR (засіб для керування
пакунками).
.PP
Ця команда поверне рядок \f(CW\*(C`unknown\*(C'\fR, якщо не вдасться визначити засіб для
керування пакунками \fIабо\fR якщо у операційній системі не використовується
система пакунків (наприклад, у Windows).
.PP
Можливі варіанти повернутих рядків: \f(CW\*(C`yum\*(C'\fR, \f(CW\*(C`dnf\*(C'\fR, \f(CW\*(C`up2date\*(C'\fR, \f(CW\*(C`apt\*(C'\fR (для
усіх похідних Debian), \f(CW\*(C`portage\*(C'\fR, \f(CW\*(C`pisi\*(C'\fR, \f(CW\*(C`pacman\*(C'\fR, \f(CW\*(C`urpmi\*(C'\fR, \f(CW\*(C`zypper\*(C'\fR,
\&\f(CW\*(C`apk\*(C'\fR, \f(CW\*(C`xbps\*(C'\fR. У майбутніх версіях libguestfs може бути реалізовано
повернення інших рядків.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.7.5)
.SS "guestfs_inspect_get_product_name"
.IX Subsection "guestfs_inspect_get_product_name"
.Vb 3
\& char *
\& guestfs_inspect_get_product_name (guestfs_h *g,
\&                                   const char *root);
.Ve
.PP
Ця команда повертає назву продукту для інспектованої операційної
системи. Назва продукту, у загальному випадку, є рядком довільної форми,
який може бути показано користувачеві, але який не призначено для обробки
програмами.
.PP
Якщо назву продукту визначити не вдалося, буде повернуто рядок \f(CW\*(C`unknown\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_product_variant"
.IX Subsection "guestfs_inspect_get_product_variant"
.Vb 3
\& char *
\& guestfs_inspect_get_product_variant (guestfs_h *g,
\&                                      const char *root);
.Ve
.PP
Ця команда повертає варіант продукту інспектованої операційної системи.
.PP
Для гостьових операційних систем Windows ця команда повертає вміст ключа
реєстру \f(CW\*(C`HKLM\eSoftware\eMicrosoft\eWindows NT\eCurrentVersion\*(C'\fR
\&\f(CW\*(C`InstallationType\*(C'\fR, який типово є рядком, зокрема \f(CW\*(C`Client\*(C'\fR або \f(CW\*(C`Server\*(C'\fR
(можливі й інші варіанти). Цим рядком можна скористатися для розрізнення
домашніх і промислових версій Windows для випусків із однаковим номером
версії (наприклад, Windows 7 і Windows 2008 Server обидві мають номер версії
6.1, але перша має значення варіанта \f(CW\*(C`Client\*(C'\fR, а друга — \f(CW\*(C`Server\*(C'\fR).
.PP
Для промислових версій гостьових систем Linux у майбутньому ми маємо намір
реалізувати код, який повертатиме варіанти продукту, зокрема \f(CW\*(C`Desktop\*(C'\fR,
\&\f(CW\*(C`Server\*(C'\fR тощо. Але у поточній версії цей код ще не реалізовано.
.PP
Якщо варіант продукту визначити не вдалося, буде повернуто рядок \f(CW\*(C`unknown\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі
\&\*(L"\s-1INSPECTION\*(R"\s0. Див. також <guestfs_inspect_get_product_name>,
<guestfs_inspect_get_major_version>.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.9.13)
.SS "guestfs_inspect_get_roots"
.IX Subsection "guestfs_inspect_get_roots"
.Vb 2
\& char **
\& guestfs_inspect_get_roots (guestfs_h *g);
.Ve
.PP
Ця функція є зручним способом отримання списку кореневих пристроїв,
повернутого попереднім викликом \f(CW\*(C`guestfs_inspect_os\*(C'\fR, але без повторного
виконання усієї процедури інспектування.
.PP
Команда повертає порожній список, якщо не буде знайдено кореневих пристроїв
або якщо не було викликано \f(CW\*(C`guestfs_inspect_os\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.7.3)
.SS "guestfs_inspect_get_type"
.IX Subsection "guestfs_inspect_get_type"
.Vb 3
\& char *
\& guestfs_inspect_get_type (guestfs_h *g,
\&                           const char *root);
.Ve
.PP
Ця команда повертає тип інспектованої операційної системи. У поточній версії
визначено такі типи:
.ie n .IP """linux""" 4
.el .IP "``linux''" 4
.IX Item "linux"
Будь\-яка заснована на Linux операційна система.
.ie n .IP """windows""" 4
.el .IP "``windows''" 4
.IX Item "windows"
Будь\-яка операційна система Microsoft Windows.
.ie n .IP """freebsd""" 4
.el .IP "``freebsd''" 4
.IX Item "freebsd"
FreeBSD.
.ie n .IP """netbsd""" 4
.el .IP "``netbsd''" 4
.IX Item "netbsd"
NetBSD.
.ie n .IP """openbsd""" 4
.el .IP "``openbsd''" 4
.IX Item "openbsd"
OpenBSD.
.ie n .IP """hurd""" 4
.el .IP "``hurd''" 4
.IX Item "hurd"
GNU/Hurd.
.ie n .IP """dos""" 4
.el .IP "``dos''" 4
.IX Item "dos"
MS-DOS, FreeDOS та інші.
.ie n .IP """minix""" 4
.el .IP "``minix''" 4
.IX Item "minix"
\&\s-1MINIX.\s0
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
Не вдалося визначити тип операційної системи.
.PP
У майбутніх версіях libguestfs цією командою можуть повертатися інші
рядки. Функція, звідки викликається команда, має готуватися до обробки
будь\-якого рядка.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_inspect_get_windows_current_control_set"
.IX Subsection "guestfs_inspect_get_windows_current_control_set"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_current_control_set (guestfs_h *g,
\&                                                  const char *root);
.Ve
.PP
Ця команда повертає Windows CurrentControlSet інспектованої гостьової
системи. CurrentControlSet є назвою ключа реєстру, наприклад
\&\f(CW\*(C`ControlSet001\*(C'\fR.
.PP
У цій команді припускається, що гостьовою системою є Windows і що її реєстр
можна вивчити засобами інспектування. Якщо ці припущення не справджуються,
команда поверне повідомлення про помилку.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.9.17)
.SS "guestfs_inspect_get_windows_software_hive"
.IX Subsection "guestfs_inspect_get_windows_software_hive"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_software_hive (guestfs_h *g,
\&                                            const char *root);
.Ve
.PP
Ця команда повертає шлях до рою (двійкового файла реєстру Windows), який
відповідає HKLM\eSOFTWARE.
.PP
У цій команді припускається, що гостьовою системою є Windows і що у
гостьовій системі є файл рою програмного забезпечення із відповідною
назвою. Якщо ці припущення не справджуються, команда поверне повідомлення
про помилку. Ця команд не виконує перевірки того, що знайдений рій є
коректним роєм реєстру Windows.
.PP
Ви можете скористатися командою \f(CW\*(C`guestfs_hivex_open\*(C'\fR для читання або запису
рою.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.35.26)
.SS "guestfs_inspect_get_windows_system_hive"
.IX Subsection "guestfs_inspect_get_windows_system_hive"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_system_hive (guestfs_h *g,
\&                                          const char *root);
.Ve
.PP
Ця команда повертає шлях до рою (двійкового файла реєстру Windows), який
відповідає HKLM\eSYSTEM.
.PP
У цій команді припускається, що гостьовою системою є Windows і що у
гостьовій системі є файл рою системи із відповідною назвою. Якщо ці
припущення не справджуються, команда поверне повідомлення про помилку. Ця
команда не виконує перевірки того, що знайдений рій є коректним роєм реєстру
Windows.
.PP
Ви можете скористатися командою \f(CW\*(C`guestfs_hivex_open\*(C'\fR для читання або запису
рою.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.35.26)
.SS "guestfs_inspect_get_windows_systemroot"
.IX Subsection "guestfs_inspect_get_windows_systemroot"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_systemroot (guestfs_h *g,
\&                                         const char *root);
.Ve
.PP
Ця команда повертає системний кореневий каталог інспектованої гостьової
системи Windows. Системним кореневим каталогом є шлях, зокрема \fI/WINDOWS\fR.
.PP
У цій команді припускається, що гостьовою системою є Windows і що її
системний кореневий каталог можна визначити засобами інспектування. Якщо ці
припущення не справджуються, команда поверне повідомлення про помилку.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.25)
.SS "guestfs_inspect_is_live"
.IX Subsection "guestfs_inspect_is_live"
.Vb 3
\& int
\& guestfs_inspect_is_live (guestfs_h *g,
\&                          const char *root);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR Замінника не передбачено. Зверніться до
документації із програмного інтерфейсу у підручнику з \fBguestfs\fR\|(3), щоб
дізнатися більше.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда є застарілою і завжди повертає \f(CW\*(C`false\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.4)
.SS "guestfs_inspect_is_multipart"
.IX Subsection "guestfs_inspect_is_multipart"
.Vb 3
\& int
\& guestfs_inspect_is_multipart (guestfs_h *g,
\&                               const char *root);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR Замінника не передбачено. Зверніться до
документації із програмного інтерфейсу у підручнику з \fBguestfs\fR\|(3), щоб
дізнатися більше.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда є застарілою і завжди повертає \f(CW\*(C`false\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.4)
.SS "guestfs_inspect_is_netinst"
.IX Subsection "guestfs_inspect_is_netinst"
.Vb 3
\& int
\& guestfs_inspect_is_netinst (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR Замінника не передбачено. Зверніться до
документації із програмного інтерфейсу у підручнику з \fBguestfs\fR\|(3), щоб
дізнатися більше.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда є застарілою і завжди повертає \f(CW\*(C`false\*(C'\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.4)
.SS "guestfs_inspect_list_applications"
.IX Subsection "guestfs_inspect_list_applications"
.Vb 3
\& struct guestfs_application_list *
\& guestfs_inspect_list_applications (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_inspect_list_applications2\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає список програм, встановлених у операційній системі.
.PP
\&\fIЗауваження:\fR ця команда працює інакше за інші частини програмного
інтерфейсу інспектування. Вам слід викликати \f(CW\*(C`guestfs_inspect_os\*(C'\fR, потім
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, потім змонтувати диски, потім викликати
цю команду. Побудова списку програм є значно складнішою операцією, яка
потребує доступу до усієї файлової системи. Також зауважте, що на відміну
від інших команд \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR, які лише повертають дані,
кешовані у дескрипторі libguestfs, ця команда справді читає частини
змонтованої файлової системи під час виконання.
.PP
Ця команда повертає порожній список, якщо засобу інспектування не вдасться
визначити список програм.
.PP
Структура application містить такі поля:
.ie n .IP """app_name""" 4
.el .IP "\f(CWapp_name\fR" 4
.IX Item "app_name"
Назва програми. Для гостьових систем Linux на основі Red Hat або Debian це
назва пакунка.
.ie n .IP """app_display_name""" 4
.el .IP "\f(CWapp_display_name\fR" 4
.IX Item "app_display_name"
Показана назва програми, іноді локалізована відповідно до мови встановлення
гостьової операційної системи.
.Sp
Якщо дані недоступні, команда поверне порожній рядок \f(CW""\fR. Там, де потрібно
щось показати, можна скористатися замість цієї команди командою \f(CW\*(C`app_name\*(C'\fR.
.ie n .IP """app_epoch""" 4
.el .IP "\f(CWapp_epoch\fR" 4
.IX Item "app_epoch"
Для засобів керування пакунками, у яких використовуються епохи, це поле
містить дані щодо епохи пакунка (ціле число). Якщо дані недоступні, буде
повернуто значення \f(CW0\fR.
.ie n .IP """app_version""" 4
.el .IP "\f(CWapp_version\fR" 4
.IX Item "app_version"
Рядок версії програми або пакунка. Якщо такого рядка не передбачено, буде
повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app_release""" 4
.el .IP "\f(CWapp_release\fR" 4
.IX Item "app_release"
Рядок випуску програми або пакунка у системах пакування, де передбачено
підтримку відповідних даних. Якщо такого рядка не передбачено, буде
повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app_install_path""" 4
.el .IP "\f(CWapp_install_path\fR" 4
.IX Item "app_install_path"
Шлях встановлення програми (у операційних системах, зокрема Windows, де
використовуються шляхи встановлення). Цей шлях записується у форматі, який
використовується гостьовою операційною системою, а не у форматі шляху
libguestfs.
.Sp
Якщо не передбачено, буде повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app_trans_path""" 4
.el .IP "\f(CWapp_trans_path\fR" 4
.IX Item "app_trans_path"
Шлях для встановлення, перетворений у шлях libguestfs. Якщо такого шляху не
передбачено, буде повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app_publisher""" 4
.el .IP "\f(CWapp_publisher\fR" 4
.IX Item "app_publisher"
Назва розповсюджувача програми у системах пакування, де передбачено
підтримку відповідних даних. Якщо такої назви не передбачено, буде повернуто
порожній рядок \f(CW""\fR.
.ie n .IP """app_url""" 4
.el .IP "\f(CWapp_url\fR" 4
.IX Item "app_url"
Адреса (сайта) програми. Якщо такої адреси не передбачено, буде повернуто
порожній рядок \f(CW""\fR.
.ie n .IP """app_source_package""" 4
.el .IP "\f(CWapp_source_package\fR" 4
.IX Item "app_source_package"
Для систем пакування, де передбачено таку підтримку, назва пакунка із
початковим кодом. Якщо такої назви не передбачено, буде повернуто порожній
рядок \f(CW""\fR.
.ie n .IP """app_summary""" 4
.el .IP "\f(CWapp_summary\fR" 4
.IX Item "app_summary"
Короткий (зазвичай, у один рядок) опис програми або пакунка. Якщо такого
опису не передбачено, буде повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app_description""" 4
.el .IP "\f(CWapp_description\fR" 4
.IX Item "app_description"
Докладніший опис програми або пакунка. Якщо опис недоступний, замість нього
буде повернуто порожній рядок \f(CW""\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_application_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_application_list\*(C'\fI\fR.
.PP
(Додано у 1.7.8)
.SS "guestfs_inspect_list_applications2"
.IX Subsection "guestfs_inspect_list_applications2"
.Vb 3
\& struct guestfs_application2_list *
\& guestfs_inspect_list_applications2 (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
Повертає список програм, встановлених у операційній системі.
.PP
\&\fIЗауваження:\fR ця команда працює інакше за інші частини програмного
інтерфейсу інспектування. Вам слід викликати \f(CW\*(C`guestfs_inspect_os\*(C'\fR, потім
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, потім змонтувати диски, потім викликати
цю команду. Побудова списку програм є значно складнішою операцією, яка
потребує доступу до усієї файлової системи. Також зауважте, що на відміну
від інших команд \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR, які лише повертають дані,
кешовані у дескрипторі libguestfs, ця команда справді читає частини
змонтованої файлової системи під час виконання.
.PP
Ця команда повертає порожній список, якщо засобу інспектування не вдасться
визначити список програм.
.PP
Структура application містить такі поля:
.ie n .IP """app2_name""" 4
.el .IP "\f(CWapp2_name\fR" 4
.IX Item "app2_name"
Назва програми. Для гостьових систем Linux на основі Red Hat або Debian це
назва пакунка.
.ie n .IP """app2_display_name""" 4
.el .IP "\f(CWapp2_display_name\fR" 4
.IX Item "app2_display_name"
Показана назва програми, іноді локалізована відповідно до мови встановлення
гостьової операційної системи.
.Sp
Якщо дані недоступні, команда поверне порожній рядок \f(CW""\fR. Там, де потрібно
щось показати, можна скористатися замість цієї команди командою
\&\f(CW\*(C`app2_name\*(C'\fR.
.ie n .IP """app2_epoch""" 4
.el .IP "\f(CWapp2_epoch\fR" 4
.IX Item "app2_epoch"
Для засобів керування пакунками, у яких використовуються епохи, це поле
містить дані щодо епохи пакунка (ціле число). Якщо дані недоступні, буде
повернуто значення \f(CW0\fR.
.ie n .IP """app2_version""" 4
.el .IP "\f(CWapp2_version\fR" 4
.IX Item "app2_version"
Рядок версії програми або пакунка. Якщо такого рядка не передбачено, буде
повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app2_release""" 4
.el .IP "\f(CWapp2_release\fR" 4
.IX Item "app2_release"
Рядок випуску програми або пакунка у системах пакування, де передбачено
підтримку відповідних даних. Якщо такого рядка не передбачено, буде
повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app2_arch""" 4
.el .IP "\f(CWapp2_arch\fR" 4
.IX Item "app2_arch"
Рядок архітектури програми або пакунка у системах пакування, де передбачено
підтримку відповідних даних. Якщо такого рядка не передбачено, буде
повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app2_install_path""" 4
.el .IP "\f(CWapp2_install_path\fR" 4
.IX Item "app2_install_path"
Шлях встановлення програми (у операційних системах, зокрема Windows, де
використовуються шляхи встановлення). Цей шлях записується у форматі, який
використовується гостьовою операційною системою, а не у форматі шляху
libguestfs.
.Sp
Якщо не передбачено, буде повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app2_trans_path""" 4
.el .IP "\f(CWapp2_trans_path\fR" 4
.IX Item "app2_trans_path"
Шлях для встановлення, перетворений у шлях libguestfs. Якщо такого шляху не
передбачено, буде повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app2_publisher""" 4
.el .IP "\f(CWapp2_publisher\fR" 4
.IX Item "app2_publisher"
Назва розповсюджувача програми у системах пакування, де передбачено
підтримку відповідних даних. Якщо такої назви не передбачено, буде повернуто
порожній рядок \f(CW""\fR.
.ie n .IP """app2_url""" 4
.el .IP "\f(CWapp2_url\fR" 4
.IX Item "app2_url"
Адреса (сайта) програми. Якщо такої адреси не передбачено, буде повернуто
порожній рядок \f(CW""\fR.
.ie n .IP """app2_source_package""" 4
.el .IP "\f(CWapp2_source_package\fR" 4
.IX Item "app2_source_package"
Для систем пакування, де передбачено таку підтримку, назва пакунка із
початковим кодом. Якщо такої назви не передбачено, буде повернуто порожній
рядок \f(CW""\fR.
.ie n .IP """app2_summary""" 4
.el .IP "\f(CWapp2_summary\fR" 4
.IX Item "app2_summary"
Короткий (зазвичай, у один рядок) опис програми або пакунка. Якщо такого
опису не передбачено, буде повернуто порожній рядок \f(CW""\fR.
.ie n .IP """app2_description""" 4
.el .IP "\f(CWapp2_description\fR" 4
.IX Item "app2_description"
Докладніший опис програми або пакунка. Якщо опис недоступний, замість нього
буде повернуто порожній рядок \f(CW""\fR.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_application2_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_application2_list\*(C'\fI\fR.
.PP
(Додано у 1.19.56)
.SS "guestfs_inspect_os"
.IX Subsection "guestfs_inspect_os"
.Vb 2
\& char **
\& guestfs_inspect_os (guestfs_h *g);
.Ve
.PP
Ця функція використовує інші функції libguestfs та певну евристику для
інспектування дисків (зазвичай, диски належать до віртуальної машини) під
час пошуку операційних систем.
.PP
Список повернутих значень буде порожнім, якщо не буде знайдено жодної
операційної системи.
.PP
Якщо буде знайдено одну операційну систему, команда поверне список із єдиним
елементом, який буде назвою кореневої файлової системи цієї операційної
системи. Крім того, ця функція може повертати список, що містить декілька
елементів, позначаючи таким чином віртуальну машину із подвійним або кратним
завантаженням. Кожен з елементів списку буде записом кореневої файлової
системи однієї з операційних систем.
.PP
Ви можете передати повернуті рядки кореневих каталогів іншим функціями
\&\f(CW\*(C`guestfs_inspect_get_*\*(C'\fR, щоб отримати подальші відомості щодо усіх
операційних систем, зокрема назву і версію.
.PP
Ця функція використовує інші можливості libguestfs, зокрема
\&\f(CW\*(C`guestfs_mount_ro\*(C'\fR і \f(CW\*(C`guestfs_umount_all\*(C'\fR, щоб монтувати і демонтовувати
файлові системи і переглядати їхній вміст. Її слід викликати до того, як
буде змонтовано диски. Ця функція також може використовувати Augeas, отже
усі наявні дескриптори Augeas буде закрито.
.PP
Ця функція не може розшифровувати зашифровані диски. Якщо диск зашифровано,
про його розшифровування має подбати (надати відповідні ключі) функція
виклику.
.PP
З докладнішими даними можна ознайомитися у розділі \*(L"\s-1INSPECTION\*(R"\s0.
.PP
Див. також \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.5.3)
.SS "guestfs_is_blockdev"
.IX Subsection "guestfs_is_blockdev"
.Vb 3
\& int
\& guestfs_is_blockdev (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_is_blockdev_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_blockdev_opts"
.IX Subsection "guestfs_is_blockdev_opts"
.Vb 4
\& int
\& guestfs_is_blockdev_opts (guestfs_h *g,
\&                           const char *path,
\&                           ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_IS_BLOCKDEV_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує блоковий пристрій із вказаною
назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо додатковий прапорець \f(CW\*(C`followsymlinks\*(C'\fR має значення true, функція
поверне true, якщо існує символічне посилання (або ланцюжок символічних
посилань), який завершується блоковим пристроєм.
.PP
Ця команда лише шукає файли у файловій системі гостьової системи. У цій
команді як параметр \f(CW\*(C`шлях\*(C'\fR не можна використовувати розділи і блокові
пристрої libguestfs (наприклад \fI/dev/sda\fR).
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_blockdev_opts_va"
.IX Subsection "guestfs_is_blockdev_opts_va"
.Vb 4
\& int
\& guestfs_is_blockdev_opts_va (guestfs_h *g,
\&                              const char *path,
\&                              va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_is_blockdev_opts\*(R"
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_blockdev_opts_argv"
.IX Subsection "guestfs_is_blockdev_opts_argv"
.Vb 4
\& int
\& guestfs_is_blockdev_opts_argv (guestfs_h *g,
\&                                const char *path,
\&                                const struct guestfs_is_blockdev_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_is_blockdev_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_busy"
.IX Subsection "guestfs_is_busy"
.Vb 2
\& int
\& guestfs_is_busy (guestfs_h *g);
.Ve
.PP
Ця функція завжди повертає false. Ця функція вважається застарілою і не має
новішого аналогу. Не використовуйте цю функцію.
.PP
Докладніший опис станів наведено у підручнику з \fBguestfs\fR\|(3).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.2)
.SS "guestfs_is_chardev"
.IX Subsection "guestfs_is_chardev"
.Vb 3
\& int
\& guestfs_is_chardev (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_is_chardev_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_chardev_opts"
.IX Subsection "guestfs_is_chardev_opts"
.Vb 4
\& int
\& guestfs_is_chardev_opts (guestfs_h *g,
\&                          const char *path,
\&                          ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_IS_CHARDEV_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує символьний пристрій із вказаною
назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо додатковий прапорець \f(CW\*(C`followsymlinks\*(C'\fR має значення true, функція
поверне true, якщо існує символічне посилання (або ланцюжок символічних
посилань), який завершується символьним пристроєм.
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_chardev_opts_va"
.IX Subsection "guestfs_is_chardev_opts_va"
.Vb 4
\& int
\& guestfs_is_chardev_opts_va (guestfs_h *g,
\&                             const char *path,
\&                             va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_is_chardev_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_chardev_opts_argv"
.IX Subsection "guestfs_is_chardev_opts_argv"
.Vb 4
\& int
\& guestfs_is_chardev_opts_argv (guestfs_h *g,
\&                               const char *path,
\&                               const struct guestfs_is_chardev_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_is_chardev_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_config"
.IX Subsection "guestfs_is_config"
.Vb 2
\& int
\& guestfs_is_config (guestfs_h *g);
.Ve
.PP
Повертає true тоді і лише тоді, коли налаштовується цей дескриптор (у стані
\&\f(CW\*(C`CONFIG\*(C'\fR).
.PP
Докладніший опис станів наведено у підручнику з \fBguestfs\fR\|(3).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.2)
.SS "guestfs_is_dir"
.IX Subsection "guestfs_is_dir"
.Vb 3
\& int
\& guestfs_is_dir (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_is_dir_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 0.8)
.SS "guestfs_is_dir_opts"
.IX Subsection "guestfs_is_dir_opts"
.Vb 4
\& int
\& guestfs_is_dir_opts (guestfs_h *g,
\&                      const char *path,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_IS_DIR_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує каталог із вказаною назвою
\&\f(CW\*(C`шлях\*(C'\fR. Зауважте, що команда повертає false для усіх інших об'єктів,
зокрема файлів.
.PP
Якщо додатковий прапорець \f(CW\*(C`followsymlinks\*(C'\fR має значення true, функція
поверне true, якщо існує символічне посилання (або ланцюжок символічних
посилань), який завершується каталогом.
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_is_dir_opts_va"
.IX Subsection "guestfs_is_dir_opts_va"
.Vb 4
\& int
\& guestfs_is_dir_opts_va (guestfs_h *g,
\&                         const char *path,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_is_dir_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_dir_opts_argv"
.IX Subsection "guestfs_is_dir_opts_argv"
.Vb 4
\& int
\& guestfs_is_dir_opts_argv (guestfs_h *g,
\&                           const char *path,
\&                           const struct guestfs_is_dir_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_is_dir_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_fifo"
.IX Subsection "guestfs_is_fifo"
.Vb 3
\& int
\& guestfs_is_fifo (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_is_fifo_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_fifo_opts"
.IX Subsection "guestfs_is_fifo_opts"
.Vb 4
\& int
\& guestfs_is_fifo_opts (guestfs_h *g,
\&                       const char *path,
\&                       ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_IS_FIFO_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує \s-1FIFO\s0 (іменований канал) із вказаною
назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо додатковий прапорець \f(CW\*(C`followsymlinks\*(C'\fR має значення true, функція
поверне true, якщо існує символічне посилання (або ланцюжок символічних
посилань), який завершується \s-1FIFO.\s0
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_fifo_opts_va"
.IX Subsection "guestfs_is_fifo_opts_va"
.Vb 4
\& int
\& guestfs_is_fifo_opts_va (guestfs_h *g,
\&                          const char *path,
\&                          va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_is_fifo_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_fifo_opts_argv"
.IX Subsection "guestfs_is_fifo_opts_argv"
.Vb 4
\& int
\& guestfs_is_fifo_opts_argv (guestfs_h *g,
\&                            const char *path,
\&                            const struct guestfs_is_fifo_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_is_fifo_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_file"
.IX Subsection "guestfs_is_file"
.Vb 3
\& int
\& guestfs_is_file (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_is_file_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 0.8)
.SS "guestfs_is_file_opts"
.IX Subsection "guestfs_is_file_opts"
.Vb 4
\& int
\& guestfs_is_file_opts (guestfs_h *g,
\&                       const char *path,
\&                       ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує звичайний файл із вказаною назвою
\&\f(CW\*(C`шлях\*(C'\fR. Зауважте, що команда повертає false для усіх інших об'єктів,
зокрема каталогів.
.PP
Якщо додатковий прапорець \f(CW\*(C`followsymlinks\*(C'\fR має значення true, функція
поверне true, якщо існує символічне посилання (або ланцюжок символічних
посилань), який завершується файлом.
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_is_file_opts_va"
.IX Subsection "guestfs_is_file_opts_va"
.Vb 4
\& int
\& guestfs_is_file_opts_va (guestfs_h *g,
\&                          const char *path,
\&                          va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_is_file_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_file_opts_argv"
.IX Subsection "guestfs_is_file_opts_argv"
.Vb 4
\& int
\& guestfs_is_file_opts_argv (guestfs_h *g,
\&                            const char *path,
\&                            const struct guestfs_is_file_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_is_file_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_launching"
.IX Subsection "guestfs_is_launching"
.Vb 2
\& int
\& guestfs_is_launching (guestfs_h *g);
.Ve
.PP
Ця функція повертає true тоді і лише тоді, коли дескриптор запускає
підпроцес (у стані \f(CW\*(C`LAUNCHING\*(C'\fR).
.PP
Докладніший опис станів наведено у підручнику з \fBguestfs\fR\|(3).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.2)
.SS "guestfs_is_lv"
.IX Subsection "guestfs_is_lv"
.Vb 3
\& int
\& guestfs_is_lv (guestfs_h *g,
\&                const char *mountable);
.Ve
.PP
Ця команда перевіряє, чи є \f(CW\*(C`монтування\*(C'\fR логічним томом, і повертає true
тоді і лише тоді, коли це так.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.3)
.SS "guestfs_is_ready"
.IX Subsection "guestfs_is_ready"
.Vb 2
\& int
\& guestfs_is_ready (guestfs_h *g);
.Ve
.PP
Ця функція повертає true тоді і лише тоді, коли дескриптор готовий до
отримання команд (у стані \f(CW\*(C`READY\*(C'\fR).
.PP
Докладніший опис станів наведено у підручнику з \fBguestfs\fR\|(3).
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.2)
.SS "guestfs_is_socket"
.IX Subsection "guestfs_is_socket"
.Vb 3
\& int
\& guestfs_is_socket (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_is_socket_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_socket_opts"
.IX Subsection "guestfs_is_socket_opts"
.Vb 4
\& int
\& guestfs_is_socket_opts (guestfs_h *g,
\&                         const char *path,
\&                         ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_IS_SOCKET_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує сокет домену \s-1UNIX\s0 із вказаною
назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо додатковий прапорець \f(CW\*(C`followsymlinks\*(C'\fR має значення true, функція
поверне true, якщо існує символічне посилання (або ланцюжок символічних
посилань), який завершується сокетом.
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_socket_opts_va"
.IX Subsection "guestfs_is_socket_opts_va"
.Vb 4
\& int
\& guestfs_is_socket_opts_va (guestfs_h *g,
\&                            const char *path,
\&                            va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_is_socket_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_socket_opts_argv"
.IX Subsection "guestfs_is_socket_opts_argv"
.Vb 4
\& int
\& guestfs_is_socket_opts_argv (guestfs_h *g,
\&                              const char *path,
\&                              const struct guestfs_is_socket_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_is_socket_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_is_symlink"
.IX Subsection "guestfs_is_symlink"
.Vb 3
\& int
\& guestfs_is_symlink (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
Повертає \f(CW\*(C`true\*(C'\fR і лише тоді, якщо існує символічне посилання із вказаною
назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.10)
.SS "guestfs_is_whole_device"
.IX Subsection "guestfs_is_whole_device"
.Vb 3
\& int
\& guestfs_is_whole_device (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Ця команда повертає \f(CW\*(C`true\*(C'\fR тоді і лише тоді, коли \f(CW\*(C`пристрій\*(C'\fR стосується
повного блокового пристрою, тобто не розділу і не логічного пристрою.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.21.9)
.SS "guestfs_is_zero"
.IX Subsection "guestfs_is_zero"
.Vb 3
\& int
\& guestfs_is_zero (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Повертає true тоді і лише тоді, коли файл існує і є порожнім або містить
лише нульові байти.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.8)
.SS "guestfs_is_zero_device"
.IX Subsection "guestfs_is_zero_device"
.Vb 3
\& int
\& guestfs_is_zero_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Повертає true тоді і лише тоді, коли пристрій існує і містить лише нульові
байти.
.PP
Зауважте, що на пристроях великого об'єму виконання цієї програми може бути
досить тривалим.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.8)
.SS "guestfs_isoinfo"
.IX Subsection "guestfs_isoinfo"
.Vb 3
\& struct guestfs_isoinfo *
\& guestfs_isoinfo (guestfs_h *g,
\&                  const char *isofile);
.Ve
.PP
Це те саме, що і \f(CW\*(C`guestfs_isoinfo_device\*(C'\fR, але працює для файла \s-1ISO,\s0
розташованого всередині якоїсь іншої змонтованої файлової системи. Зауважте,
що у типовому випадку, коли ви додали файл \s-1ISO\s0 як пристрій libguestfs, вам
\&\fIне\fR слід викликати цю команду. Замість цього, слід викликати
\&\f(CW\*(C`guestfs_isoinfo_device\*(C'\fR.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_isoinfo *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_isoinfo\*(C'\fI\fR.
.PP
(Додано у 1.17.19)
.SS "guestfs_isoinfo_device"
.IX Subsection "guestfs_isoinfo_device"
.Vb 3
\& struct guestfs_isoinfo *
\& guestfs_isoinfo_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
\&\f(CW\*(C`пристрій\*(C'\fR є пристроєм \s-1ISO.\s0 Ця команда повертає структуру даних, прочитану
з дескриптора основного тому (еквівалента суперблоку у \s-1ISO\s0) вказаного
пристрою.
.PP
Зазвичай, ефективніше скористатися командою \fBisoinfo\fR\|(1) з параметром \fI\-d\fR
у основній системі для аналізу файлів \s-1ISO,\s0 а не використовувати засоби
libguestfs.
.PP
Відомості щодо полів дескриптора основного тому можна отримати тут:
http://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_isoinfo *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_isoinfo\*(C'\fI\fR.
.PP
(Додано у 1.17.19)
.SS "guestfs_journal_close"
.IX Subsection "guestfs_journal_close"
.Vb 2
\& int
\& guestfs_journal_close (guestfs_h *g);
.Ve
.PP
Завершити роботу обробника журналу.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_journal_get"
.IX Subsection "guestfs_journal_get"
.Vb 2
\& struct guestfs_xattr_list *
\& guestfs_journal_get (guestfs_h *g);
.Ve
.PP
Читає поточний запис журналу. Команда повертає усі поля у журналі як набір
пар значень \f(CW\*(C`(назва_атрибута, значення_атрибута)\*(C'\fR. Значенням
\&\f(CW\*(C`назва_атрибута\*(C'\fR є назва поля (рядок).
.PP
Значенням \f(CW\*(C`значення_атрибута\*(C'\fR є значення поля (двійковий набір даних,
часто, але не завжди, рядок). Будь ласка, зауважте, що \f(CW\*(C`значення_атрибута\*(C'\fR
є масивом байтів, а \fIне\fR рядком C, який завершується символом \e0.
.PP
Дані може бути обрізано за пороговою довжиною
(див. \f(CW\*(C`guestfs_journal_set_data_threshold\*(C'\fR,
\&\f(CW\*(C`guestfs_journal_get_data_threshold\*(C'\fR).
.PP
Якщо ви не обмежуєте порогове значення даних (\f(CW0\fR), ця команда може
прочитати запис журналу довільного розміру, тобто розмір не обмежуватиметься
протоколом libguestfs.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_journal_get_data_threshold"
.IX Subsection "guestfs_journal_get_data_threshold"
.Vb 2
\& int64_t
\& guestfs_journal_get_data_threshold (guestfs_h *g);
.Ve
.PP
Отримує поточне значення порогу даних для читання записів журналу. Це
значення є підказкою журналу щодо того, що засіб журналювання може обрізати
поля даних до цього розміру під час читання (зауважте також, що засіб
журналювання може і не обрізати їх). Якщо команда повертає \f(CW0\fR, порогове
обмеження не встановлено.
.PP
Див. також \f(CW\*(C`guestfs_journal_set_data_threshold\*(C'\fR
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_journal_get_realtime_usec"
.IX Subsection "guestfs_journal_get_realtime_usec"
.Vb 2
\& int64_t
\& guestfs_journal_get_realtime_usec (guestfs_h *g);
.Ve
.PP
Отримує поточну часову позначку (за годинником системи) поточного запису
журналу
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.27.18)
.SS "guestfs_journal_next"
.IX Subsection "guestfs_journal_next"
.Vb 2
\& int
\& guestfs_journal_next (guestfs_h *g);
.Ve
.PP
Переводить до наступного запису журналу. Вам слід викликати цю команду
принаймні один раз, одразу після відкриття дескриптора, перш ніж ви зможете
читати дані.
.PP
Ця команда повертає булеве значення, яке повідомляє вам, чи існують ще
записи журналу для читання. Значення \f(CW\*(C`true\*(C'\fR означає, що ви можете прочитати
наступний запис (наприклад, за допомогою \f(CW\*(C`guestfs_journal_get\*(C'\fR), а значення
\&\f(CW\*(C`false\*(C'\fR означає, що досягнуто кінця журналу.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_journal_open"
.IX Subsection "guestfs_journal_open"
.Vb 3
\& int
\& guestfs_journal_open (guestfs_h *g,
\&                       const char *directory);
.Ve
.PP
Відкриває журналу systemd, який зберігається у каталозі \fIкаталог\fR. Усі
раніше відкриті дескриптори журналу при цьому буде закрито.
.PP
Вміст журналу можна прочитати за допомогою \f(CW\*(C`guestfs_journal_next\*(C'\fR і
\&\f(CW\*(C`guestfs_journal_get\*(C'\fR.
.PP
Після завершення використання журналу вам слід закрити дескриптор викликом
\&\f(CW\*(C`guestfs_journal_close\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_journal_set_data_threshold"
.IX Subsection "guestfs_journal_set_data_threshold"
.Vb 3
\& int
\& guestfs_journal_set_data_threshold (guestfs_h *g,
\&                                     int64_t threshold);
.Ve
.PP
Встановлює значення порогу даних для читання записів журналу. Це значення є
підказкою журналу щодо того, що засіб журналювання може обрізати поля даних
до цього розміру під час читання (зауважте також, що засіб журналювання може
і не обрізати їх). Якщо ви встановите значення \f(CW0\fR, порогове обмеження
застосовано не буде.
.PP
Див. також \f(CW\*(C`guestfs_journal_get_data_threshold\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_journal_skip"
.IX Subsection "guestfs_journal_skip"
.Vb 3
\& int64_t
\& guestfs_journal_skip (guestfs_h *g,
\&                       int64_t skip);
.Ve
.PP
Прокручування записів журналу вперед (\f(CW\*(C`пропуск ≥ 0\*(C'\fR) або назад
(\f(CW\*(C`пропуск < 0\*(C'\fR).
.PP
Команда повертає кількість записів, на яку насправді вдалося просунутися
(зауважте, що \f(CW\*(C`rskip ≥ 0\*(C'\fR). Якщо повернуте значення не дорівнює
пропуску за модулем (\f(CW\*(C`|пропуск|\*(C'\fR), ви досягли кінця або початку журналу.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`journal\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.23.11)
.SS "guestfs_kill_subprocess"
.IX Subsection "guestfs_kill_subprocess"
.Vb 2
\& int
\& guestfs_kill_subprocess (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_shutdown\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда завершує роботу гіпервізору.
.PP
Не викликайте цю функцію. Замість неї слід використовувати
\&\f(CW\*(C`guestfs_shutdown\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_launch"
.IX Subsection "guestfs_launch"
.Vb 2
\& int
\& guestfs_launch (guestfs_h *g);
.Ve
.PP
Вам слід викликати цю команду після налаштовування дескриптора (наприклад,
після додавання дисків), але перед виконанням із ним будь\-яких інших дій.
.PP
Не викликайте \f(CW\*(C`guestfs_launch\*(C'\fR двічі для одного і того самого
дескриптора. Хоча такий виклик і не призведе до помилки (з історичних
причин), точну поведінку бібліотеки у цьому випадку не
визначено. Дескриптори є доволі невибагливими до ресурсів об'єктами, тому
варто створювати окремий новий дескриптор для кожного запуску.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 0.3)
.SS "guestfs_lchown"
.IX Subsection "guestfs_lchown"
.Vb 5
\& int
\& guestfs_lchown (guestfs_h *g,
\&                 int owner,
\&                 int group,
\&                 const char *path);
.Ve
.PP
Змінює власника файла на \f(CW\*(C`власник\*(C'\fR і групу на \f(CW\*(C`група\*(C'\fR. Команда подібна до
\&\f(CW\*(C`guestfs_chown\*(C'\fR, але якщо \f(CW\*(C`шлях\*(C'\fR є символічним посиланням, буде змінено
параметри самого посилання, а не файла чи каталогу, на яке воно вказує.
.PP
Передбачено підтримку лише числових uid і gid. Якщо ви хочете скористатися
текстовими назвами, вам доведеться знайти і обробити файл паролів власноруч
(підтримка Augeas робить це завдання відносно простим).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_ldmtool_create_all"
.IX Subsection "guestfs_ldmtool_create_all"
.Vb 2
\& int
\& guestfs_ldmtool_create_all (guestfs_h *g);
.Ve
.PP
Ця функція сканує усі блокові пристрої, шукаючи динамічні томи дисків і
розділи, а потім створює пристрої для усіх знайдених записів.
.PP
Викликати \f(CW\*(C`guestfs_list_ldm_volumes\*(C'\fR і \f(CW\*(C`guestfs_list_ldm_partitions\*(C'\fR для
повернення списку усіх пристроїв.
.PP
Зауважте, що зазвичай вам \fBне\fR потрібно викликати цю команду явним чином,
оскільки вона виконується автоматично під час виконання
\&\f(CW\*(C`guestfs_launch\*(C'\fR. Втім, може виникнути потреба у виклику цієї функції, якщо
ви з'єднували диски у «гарячому» режимі або щойно створили динамічний диск
Windows.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_diskgroup_disks"
.IX Subsection "guestfs_ldmtool_diskgroup_disks"
.Vb 3
\& char **
\& guestfs_ldmtool_diskgroup_disks (guestfs_h *g,
\&                                  const char *diskgroup);
.Ve
.PP
Повертає диски у групі динамічних дисків Windows. Значенням параметра
\&\f(CW\*(C`diskgroup\*(C'\fR має бути \s-1GUID\s0 групи дисків, одним із елементів списку, який
повертає \f(CW\*(C`guestfs_ldmtool_scan\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_diskgroup_name"
.IX Subsection "guestfs_ldmtool_diskgroup_name"
.Vb 3
\& char *
\& guestfs_ldmtool_diskgroup_name (guestfs_h *g,
\&                                 const char *diskgroup);
.Ve
.PP
Повертає назву групи динамічних дисків Windows. Значенням параметра
\&\f(CW\*(C`diskgroup\*(C'\fR має бути \s-1GUID\s0 групи дисків, одним із елементів списку, який
повертає \f(CW\*(C`guestfs_ldmtool_scan\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_diskgroup_volumes"
.IX Subsection "guestfs_ldmtool_diskgroup_volumes"
.Vb 3
\& char **
\& guestfs_ldmtool_diskgroup_volumes (guestfs_h *g,
\&                                    const char *diskgroup);
.Ve
.PP
Повертає томи у групі динамічних дисків Windows. Значенням параметра
\&\f(CW\*(C`diskgroup\*(C'\fR має бути \s-1GUID\s0 групи дисків, одним із елементів списку, який
повертає \f(CW\*(C`guestfs_ldmtool_scan\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_remove_all"
.IX Subsection "guestfs_ldmtool_remove_all"
.Vb 2
\& int
\& guestfs_ldmtool_remove_all (guestfs_h *g);
.Ve
.PP
Загалом, ця функція є оберненою до \f(CW\*(C`guestfs_ldmtool_create_all\*(C'\fR. Вона
вилучає прив'язки пристроїв для усіх томів динамічних дисків Windows.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_scan"
.IX Subsection "guestfs_ldmtool_scan"
.Vb 2
\& char **
\& guestfs_ldmtool_scan (guestfs_h *g);
.Ve
.PP
Ця функція шукає динамічні диски Windows. Вона повертає список
ідентифікаторів (\s-1GUID\s0) для усіх груп дисків, які було знайдено. Ці
ідентифікатори можна передавати іншим функціям \f(CW\*(C`guestfs_ldmtool_*\*(C'\fR.
.PP
Ця функція сканує усі блокові пристрої. Щоб виконати сканування якоїсь
підмножини блокових пристроїв, скористайтеся функцією
\&\f(CW\*(C`guestfs_ldmtool_scan_devices\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_scan_devices"
.IX Subsection "guestfs_ldmtool_scan_devices"
.Vb 3
\& char **
\& guestfs_ldmtool_scan_devices (guestfs_h *g,
\&                               char *const *devices);
.Ve
.PP
Ця функція шукає динамічні диски Windows. Вона повертає список
ідентифікаторів (\s-1GUID\s0) для усіх груп дисків, які було знайдено. Ці
ідентифікатори можна передавати іншим функціям \f(CW\*(C`guestfs_ldmtool_*\*(C'\fR.
.PP
Параметр \f(CW\*(C`пристрої\*(C'\fR є списком блокових пристроїв, на яких слід виконати
пошук. Якщо список є порожнім, буде виконано сканування усіх блокових
пристроїв.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_volume_hint"
.IX Subsection "guestfs_ldmtool_volume_hint"
.Vb 4
\& char *
\& guestfs_ldmtool_volume_hint (guestfs_h *g,
\&                              const char *diskgroup,
\&                              const char *volume);
.Ve
.PP
Повертає поле підказки для тому із назвою \f(CW\*(C`том\*(C'\fR у групі дисків із \s-1GUID\s0
\&\f(CW\*(C`група_дисків\*(C'\fR. Таку підказку може бути не визначено. Якщо підказку не
визначено, команда поверне порожній рядок. У полі підказки часто, але не
завжди, міститься назва диска у Windows, наприклад \f(CW\*(C`E:\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_volume_partitions"
.IX Subsection "guestfs_ldmtool_volume_partitions"
.Vb 4
\& char **
\& guestfs_ldmtool_volume_partitions (guestfs_h *g,
\&                                    const char *diskgroup,
\&                                    const char *volume);
.Ve
.PP
Повертає список розділів на томі із назвою \f(CW\*(C`том\*(C'\fR у групі дисків із \s-1GUID\s0
\&\f(CW\*(C`група_дисків\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_ldmtool_volume_type"
.IX Subsection "guestfs_ldmtool_volume_type"
.Vb 4
\& char *
\& guestfs_ldmtool_volume_type (guestfs_h *g,
\&                              const char *diskgroup,
\&                              const char *volume);
.Ve
.PP
Повертає тип тому із назвою \f(CW\*(C`том\*(C'\fR у групі дисків із \s-1GUID\s0 \f(CW\*(C`група_дисків\*(C'\fR.
.PP
Можливими типами томів, які повертає ця команда є такі: \f(CW\*(C`simple\*(C'\fR,
\&\f(CW\*(C`spanned\*(C'\fR, \f(CW\*(C`striped\*(C'\fR, \f(CW\*(C`mirrored\*(C'\fR, \f(CW\*(C`raid5\*(C'\fR. Також може бути повернуто
інші типи.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_lgetxattr"
.IX Subsection "guestfs_lgetxattr"
.Vb 5
\& char *
\& guestfs_lgetxattr (guestfs_h *g,
\&                    const char *path,
\&                    const char *name,
\&                    size_t *size_r);
.Ve
.PP
Отримати окремий розширений атрибут з файла \f(CW\*(C`шлях\*(C'\fR за назвою \f(CW\*(C`назва\*(C'\fR. Якщо
\&\f(CW\*(C`шлях\*(C'\fR є символічним посиланням, ця команда поверне розширений атрибут з
символічного посилання.
.PP
Зазвичай, краще отримати усі розширені атрибути файла одним викликом
\&\f(CW\*(C`guestfs_getxattrs\*(C'\fR. Втім, у реалізації деяких файлових систем у Linux є
вади, які заважають отримання повного списку атрибутів. Для таких файлових
систем (найпоширенішою з яких є ntfs\-3g) вам доведеться визначити назви
потрібних вам розширених атрибутів і викликати цю функцію.
.PP
Значеннями розширених атрибутів є блоки двійкових даних. Якщо розширеного
атрибута із назвою \f(CW\*(C`назва\*(C'\fR не існує, командою буде повернуто повідомлення
про помилку.
.PP
Див. також \f(CW\*(C`guestfs_lgetxattrs\*(C'\fR, \f(CW\*(C`guestfs_getxattr\*(C'\fR, \fBattr\fR\|(5).
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.7.24)
.SS "guestfs_lgetxattrs"
.IX Subsection "guestfs_lgetxattrs"
.Vb 3
\& struct guestfs_xattr_list *
\& guestfs_lgetxattrs (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
Те саме, що і \f(CW\*(C`guestfs_getxattrs\*(C'\fR, але якщо \f(CW\*(C`шлях\*(C'\fR є символічним
посиланням, повертає розширені атрибути самого символічного посилання.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.59)
.SS "guestfs_list_9p"
.IX Subsection "guestfs_list_9p"
.Vb 2
\& char **
\& guestfs_list_9p (guestfs_h *g);
.Ve
.PP
Виводить список усіх файлових систем 9p, з'єднаних із гостьовою
системою. Повертає список теґів монтування.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.11.12)
.SS "guestfs_list_devices"
.IX Subsection "guestfs_list_devices"
.Vb 2
\& char **
\& guestfs_list_devices (guestfs_h *g);
.Ve
.PP
Вивести список усіх блокових пристроїв.
.PP
Буде повернуто повні назви блокових пристроїв, наприклад \fI/dev/sda\fR.
.PP
Див. також \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.4)
.SS "guestfs_list_disk_labels"
.IX Subsection "guestfs_list_disk_labels"
.Vb 2
\& char **
\& guestfs_list_disk_labels (guestfs_h *g);
.Ve
.PP
Якщо ви додаєте диски з використанням необов'язкового параметра \f(CW\*(C`label\*(C'\fR
команди \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR, ви можете скористатися цією командою для
прив'язування міток до простих блокових пристроїв та назв розділів
(наприклад \fI/dev/sda\fR та \fI/dev/sda1\fR).
.PP
Ця команда повертає таблицю хешів, у якій ключами є мітки дисків (\fIбез\fR
префіксів \fI/dev/disk/guestfs\fR), а значеннями є повні назви простих блокових
пристроїв та розділів (наприклад \fI/dev/sda\fR і \fI/dev/sda1\fR).
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.19.49)
.SS "guestfs_list_dm_devices"
.IX Subsection "guestfs_list_dm_devices"
.Vb 2
\& char **
\& guestfs_list_dm_devices (guestfs_h *g);
.Ve
.PP
Виводить список усіх пристроїв засобу прив'язування пристроїв.
.PP
У повернутому списку міститимуться пристрої \fI/dev/mapper/*\fR, наприклад,
пристрої, створені попереднім викликом \f(CW\*(C`guestfs_luks_open\*(C'\fR.
.PP
Пристрої засобу прив'язування пристроїв, які відповідають логічним томам
\&\fIне\fR буде включено до повернутого списку. Якщо вам потрібен список логічних
томів, скористайтеся командою \f(CW\*(C`guestfs_lvs\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.11.15)
.SS "guestfs_list_filesystems"
.IX Subsection "guestfs_list_filesystems"
.Vb 2
\& char **
\& guestfs_list_filesystems (guestfs_h *g);
.Ve
.PP
Ця команда засобу інспектування шукає усі файлові системи на розділах,
блокових пристроях та логічних томах і повертає список \f(CW\*(C`монтувань\*(C'\fR, де
містяться дані щодо файлових систем та їхнього типу.
.PP
Повернуте значення є хешем, де ключами є пристрої, на яких містяться файлові
системи, а значеннями є типи файлових систем. Приклад:
.PP
.Vb 4
\& "/dev/sda1" => "ntfs"
\& "/dev/sda2" => "ext2"
\& "/dev/vg_guest/lv_root" => "ext4"
\& "/dev/vg_guest/lv_swap" => "swap"
.Ve
.PP
Ключем не обов'язково є блоковий пристрій. Ним також може бути не зовсім
прозорий рядок «mountable», який можна передавати \f(CW\*(C`guestfs_mount\*(C'\fR.
.PP
Значенням може бути особливий рядок «unknown», який означає, що вміст
пристрою не вдалося визначити або пристрій є порожнім. Рядок «swap» означає
розділ резервної пам'яті Linux.
.PP
У libguestfs ≤ 1.36 ця команда запускає інші команди libguestfs, серед
яких можуть бути команди \f(CW\*(C`guestfs_mount\*(C'\fR і \f(CW\*(C`guestfs_umount\*(C'\fR. Тому її слід
віддавати поближче до launch і лише тоді, коли ще нічого не змонтовано. Це
обмеження було усунено у libguestfs ≥ 1.38.
.PP
Не усі файлові системи із повернутого списку є придатними до
монтування. Зокрема, у списку можуть бути розділи резервної пам'яті. Крім
того, ця команда не перевіряє, чи є кожна зі знайдених файлових систем
коректною і придатною до монтування. Деякі із систем можуть бути придатними
до монтування, але потребувати спеціальних параметрів. Файлові системи
можуть належати різним логічним операційними системами (для пошуку
операційних систем скористайтеся командою \f(CW\*(C`guestfs_inspect_os\*(C'\fR).
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.5.15)
.SS "guestfs_list_ldm_partitions"
.IX Subsection "guestfs_list_ldm_partitions"
.Vb 2
\& char **
\& guestfs_list_ldm_partitions (guestfs_h *g);
.Ve
.PP
Ця функція повертає усі розділи динамічних дисків Windows, які було знайдено
на час запуску. Повернутим значенням є список назв пристроїв.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_list_ldm_volumes"
.IX Subsection "guestfs_list_ldm_volumes"
.Vb 2
\& char **
\& guestfs_list_ldm_volumes (guestfs_h *g);
.Ve
.PP
Ця функція повертає усі томи динамічних дисків Windows, які було знайдено на
час запуску. Повернутим значенням є список назв пристроїв.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ldm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.20.0)
.SS "guestfs_list_md_devices"
.IX Subsection "guestfs_list_md_devices"
.Vb 2
\& char **
\& guestfs_list_md_devices (guestfs_h *g);
.Ve
.PP
Вивести список усіх пристроїв md у Linux.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.15.4)
.SS "guestfs_list_partitions"
.IX Subsection "guestfs_list_partitions"
.Vb 2
\& char **
\& guestfs_list_partitions (guestfs_h *g);
.Ve
.PP
Вивести усі розділи, визначені як блокові пристрої.
.PP
Буде повернуто назви пристроїв розділів повністю, наприклад \fI/dev/sda1\fR
.PP
Не повертає логічних томів. Для логічних томів слід викликати
\&\f(CW\*(C`guestfs_lvs\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.4)
.SS "guestfs_ll"
.IX Subsection "guestfs_ll"
.Vb 3
\& char *
\& guestfs_ll (guestfs_h *g,
\&             const char *directory);
.Ve
.PP
Виводить список файлів у каталозі \fIкаталог\fR (відносно кореневого каталогу,
немає поточного робочого каталогу) у форматі команди «ls \-la».
.PP
Ця команда здебільшого корисна для інтерактивних сеансів. Її \fIне\fR
призначено для випадків, коли ви намагаєтеся обробити виведений командою
рядок.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 0.4)
.SS "guestfs_llz"
.IX Subsection "guestfs_llz"
.Vb 3
\& char *
\& guestfs_llz (guestfs_h *g,
\&              const char *directory);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_lgetxattrs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Виводить список файлів у каталозі \fIкаталог\fR у форматі команди «ls \-laZ».
.PP
Ця команда здебільшого корисна для інтерактивних сеансів. Її \fIне\fR
призначено для випадків, коли ви намагаєтеся обробити виведений командою
рядок.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.17.6)
.SS "guestfs_ln"
.IX Subsection "guestfs_ln"
.Vb 4
\& int
\& guestfs_ln (guestfs_h *g,
\&             const char *target,
\&             const char *linkname);
.Ve
.PP
Ця команда створює жорстке посилання за допомогою команди \f(CW\*(C`ln\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_ln_f"
.IX Subsection "guestfs_ln_f"
.Vb 4
\& int
\& guestfs_ln_f (guestfs_h *g,
\&               const char *target,
\&               const char *linkname);
.Ve
.PP
Ця команда створює жорстке посилання за допомогою команди \f(CW\*(C`ln
\&\-f\*(C'\fR. Наявність параметра \fI\-f\fR вилучає посилання (\f(CW\*(C`назва_посилання\*(C'\fR), якщо
таке вже існує.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_ln_s"
.IX Subsection "guestfs_ln_s"
.Vb 4
\& int
\& guestfs_ln_s (guestfs_h *g,
\&               const char *target,
\&               const char *linkname);
.Ve
.PP
Ця команда створює символічне посилання за допомогою команди \f(CW\*(C`ln \-s\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_ln_sf"
.IX Subsection "guestfs_ln_sf"
.Vb 4
\& int
\& guestfs_ln_sf (guestfs_h *g,
\&                const char *target,
\&                const char *linkname);
.Ve
.PP
Ця команда створює символічне посилання за допомогою команди \f(CW\*(C`ln
\&\-sf\*(C'\fR. Наявність параметра \fI\-f\fR вилучає посилання (\f(CW\*(C`назва_посилання\*(C'\fR), якщо
таке вже існує.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_lremovexattr"
.IX Subsection "guestfs_lremovexattr"
.Vb 4
\& int
\& guestfs_lremovexattr (guestfs_h *g,
\&                       const char *xattr,
\&                       const char *path);
.Ve
.PP
Те саме, що і \f(CW\*(C`guestfs_removexattr\*(C'\fR, але якщо \f(CW\*(C`path\*(C'\fR є символічним
посиланням, вилучає розширені атрибути самого символічного посилання.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.59)
.SS "guestfs_ls"
.IX Subsection "guestfs_ls"
.Vb 3
\& char **
\& guestfs_ls (guestfs_h *g,
\&             const char *directory);
.Ve
.PP
Виводить список файлів у каталозі \fIкаталог\fR (відносно кореневого каталогу,
немає поточного робочого каталогу). Записи «.» та «..» повернуто не буде,
але приховані файли буде показано.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.4)
.SS "guestfs_ls0"
.IX Subsection "guestfs_ls0"
.Vb 4
\& int
\& guestfs_ls0 (guestfs_h *g,
\&              const char *dir,
\&              const char *filenames);
.Ve
.PP
Цю спеціалізовану команду використовують для отримання списку назв файлів у
каталозі \f(CW\*(C`каталог\*(C'\fR. Список назв файлів буде записано до локального файла
\&\fIназви_файлів\fR (у основній системі).
.PP
У файлі результатів обробки назви файлів буде відокремлено символами \f(CW\*(C`\e0\*(C'\fR.
.PP
Серед записів результатів не буде \f(CW\*(C`.\*(C'\fR і \f(CW\*(C`..\*(C'\fR. Назви файлів не
упорядковуватимуться.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.32)
.SS "guestfs_lsetxattr"
.IX Subsection "guestfs_lsetxattr"
.Vb 6
\& int
\& guestfs_lsetxattr (guestfs_h *g,
\&                    const char *xattr,
\&                    const char *val,
\&                    int vallen,
\&                    const char *path);
.Ve
.PP
Те саме, що і \f(CW\*(C`guestfs_setxattr\*(C'\fR, але якщо \f(CW\*(C`path\*(C'\fR є символічним
посиланням, встановлює розширений атрибут самого символічного посилання.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.59)
.SS "guestfs_lstat"
.IX Subsection "guestfs_lstat"
.Vb 3
\& struct guestfs_stat *
\& guestfs_lstat (guestfs_h *g,
\&                const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_lstatns\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає дані щодо файла за вказаним шляхом \f(CW\*(C`шлях\*(C'\fR.
.PP
Те саме, що і \f(CW\*(C`guestfs_stat\*(C'\fR, але якщо \f(CW\*(C`path\*(C'\fR є символічним посиланням,
статистику буде зібрано для цього посилання, а не для запису, на який воно
посилається.
.PP
Це те саме, що системний виклик \fBlstat\fR\|(2).
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_stat *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_stat\*(C'\fI\fR.
.PP
(Додано у 1.9.2)
.SS "guestfs_lstatlist"
.IX Subsection "guestfs_lstatlist"
.Vb 4
\& struct guestfs_stat_list *
\& guestfs_lstatlist (guestfs_h *g,
\&                    const char *path,
\&                    char *const *names);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_lstatnslist\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Цей виклик надає змогу виконувати дію \f(CW\*(C`guestfs_lstat\*(C'\fR над декількома
файлами, які зберігаються у каталозі \f(CW\*(C`path\*(C'\fR. Значенням аргументу \f(CW\*(C`names\*(C'\fR є
список файлів у цьому каталозі.
.PP
Команда повертає список структур статистичних даних із однозначною
відповідністю до списку \f(CW\*(C`назви\*(C'\fR. Якщо якоїсь із назв не існує або для
якоїсь із назв не вдасться зібрати статистичні дані, для поля \f(CW\*(C`st_ino\*(C'\fR
структури буде встановлено значення \f(CW\*(C`\-1\*(C'\fR.
.PP
Цю команду призначено для програм, яким потрібно ефективно будувати список
вмісту каталогів без виконання багатьох обходів. Див. також
\&\f(CW\*(C`guestfs_lxattrlist\*(C'\fR, якщо потрібний подібний ефективний підхід для
отримання розширених атрибутів.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_stat_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_stat_list\*(C'\fI\fR.
.PP
(Додано у 1.0.77)
.SS "guestfs_lstatns"
.IX Subsection "guestfs_lstatns"
.Vb 3
\& struct guestfs_statns *
\& guestfs_lstatns (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Повертає дані щодо файла за вказаним шляхом \f(CW\*(C`шлях\*(C'\fR.
.PP
Те саме, що і \f(CW\*(C`guestfs_statns\*(C'\fR, але якщо \f(CW\*(C`path\*(C'\fR є символічним посиланням,
статистику буде зібрано для цього посилання, а не для запису, на який воно
посилається.
.PP
Це те саме, що системний виклик \fBlstat\fR\|(2).
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_statns *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_statns\*(C'\fI\fR.
.PP
(Додано у 1.27.53)
.SS "guestfs_lstatnslist"
.IX Subsection "guestfs_lstatnslist"
.Vb 4
\& struct guestfs_statns_list *
\& guestfs_lstatnslist (guestfs_h *g,
\&                      const char *path,
\&                      char *const *names);
.Ve
.PP
Цей виклик надає змогу виконувати дію \f(CW\*(C`guestfs_lstatns\*(C'\fR над декількома
файлами, які зберігаються у каталозі \f(CW\*(C`шлях\*(C'\fR. Значенням аргументу \f(CW\*(C`назви\*(C'\fR є
список файлів у цьому каталозі.
.PP
Команда повертає список структур статистичних даних із однозначною
відповідністю до списку \f(CW\*(C`назви\*(C'\fR. Якщо якоїсь із назв не існує або для
якоїсь із назв не вдасться зібрати статистичні дані, для поля \f(CW\*(C`st_ino\*(C'\fR
структури буде встановлено значення \f(CW\*(C`\-1\*(C'\fR.
.PP
Цю команду призначено для програм, яким потрібно ефективно будувати список
вмісту каталогів без виконання багатьох обходів. Див. також
\&\f(CW\*(C`guestfs_lxattrlist\*(C'\fR, якщо потрібний подібний ефективний підхід для
отримання розширених атрибутів.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_statns_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_statns_list\*(C'\fI\fR.
.PP
(Додано у 1.27.53)
.SS "guestfs_luks_add_key"
.IX Subsection "guestfs_luks_add_key"
.Vb 6
\& int
\& guestfs_luks_add_key (guestfs_h *g,
\&                       const char *device,
\&                       const char *key,
\&                       const char *newkey,
\&                       int keyslot);
.Ve
.PP
Ця команда додає новий ключ на пристрій \s-1LUKS\s0 \f(CW\*(C`пристрій\*(C'\fR. Ключем \f(CW\*(C`ключ\*(C'\fR є
будь\-який наявний ключ, його буде використано для доступу до
пристрою. Значенням параметра \f(CW\*(C`новий_ключ\*(C'\fR є новий ключ, який слід
додати. Значенням параметра \f(CW\*(C`слот_ключів\*(C'\fR є слот ключів, який має бути
замінено.
.PP
Зауважте, що якщо у слоті \f(CW\*(C`keyslot\*(C'\fR вже міститься ключ, успішно виконати цю
команду не вдасться. Вам доведеться спочатку скористатися командою
\&\f(CW\*(C`guestfs_luks_kill_slot\*(C'\fR для вилучення наявного ключа.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Ця функція отримує параметр ключа або пароля, тобто дані, які можуть бути
конфіденційними. Щоб дізнатися більше про це, ознайомтеся із розділом
\&\*(L"КЛЮЧІ І ПАРОЛІ\*(R".
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.2)
.SS "guestfs_luks_close"
.IX Subsection "guestfs_luks_close"
.Vb 3
\& int
\& guestfs_luks_close (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
Ця команда закриває пристрій \s-1LUKS,\s0 який раніше було створено за допомогою
\&\f(CW\*(C`guestfs_luks_open\*(C'\fR або \f(CW\*(C`guestfs_luks_open_ro\*(C'\fR. Значенням параметра
\&\f(CW\*(C`device\*(C'\fR має бути назва пристрою прив'язки \s-1LUKS\s0 (тобто
\&\fI/dev/mapper/назва_прив'язки\fR), а \fIне\fR назва підлеглого блокового
пристрою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.1)
.SS "guestfs_luks_format"
.IX Subsection "guestfs_luks_format"
.Vb 5
\& int
\& guestfs_luks_format (guestfs_h *g,
\&                      const char *device,
\&                      const char *key,
\&                      int keyslot);
.Ve
.PP
Ця команда витирає наявні дані на пристрої \f(CW\*(C`пристрій\*(C'\fR і форматує пристрій
як зашифрований пристрій \s-1LUKS.\s0 Значенням параметра \f(CW\*(C`ключ\*(C'\fR є початковий
ключ, який додається до слоту ключів \f(CW\*(C`слот\*(C'\fR. (У \s-1LUKS\s0 передбачено підтримку
8 слотів ключів, пронумерованих 0\-7).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Ця функція отримує параметр ключа або пароля, тобто дані, які можуть бути
конфіденційними. Щоб дізнатися більше про це, ознайомтеся із розділом
\&\*(L"КЛЮЧІ І ПАРОЛІ\*(R".
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.2)
.SS "guestfs_luks_format_cipher"
.IX Subsection "guestfs_luks_format_cipher"
.Vb 6
\& int
\& guestfs_luks_format_cipher (guestfs_h *g,
\&                             const char *device,
\&                             const char *key,
\&                             int keyslot,
\&                             const char *cipher);
.Ve
.PP
Ця команда виконує ті самі дії, що і \f(CW\*(C`guestfs_luks_format\*(C'\fR, але, крім того,
надає вам змогу вказати використане \f(CW\*(C`cipher\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Ця функція отримує параметр ключа або пароля, тобто дані, які можуть бути
конфіденційними. Щоб дізнатися більше про це, ознайомтеся із розділом
\&\*(L"КЛЮЧІ І ПАРОЛІ\*(R".
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.2)
.SS "guestfs_luks_kill_slot"
.IX Subsection "guestfs_luks_kill_slot"
.Vb 5
\& int
\& guestfs_luks_kill_slot (guestfs_h *g,
\&                         const char *device,
\&                         const char *key,
\&                         int keyslot);
.Ve
.PP
Ця команда вилучає ключ у слоті ключів \f(CW\*(C`слот_ключів\*(C'\fR із зашифрованого
пристрою \s-1LUKS\s0 \f(CW\*(C`пристрій\*(C'\fR. Значенням параметра \f(CW\*(C`ключ\*(C'\fR має бути один з
\&\fIінших\fR ключів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Ця функція отримує параметр ключа або пароля, тобто дані, які можуть бути
конфіденційними. Щоб дізнатися більше про це, ознайомтеся із розділом
\&\*(L"КЛЮЧІ І ПАРОЛІ\*(R".
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.2)
.SS "guestfs_luks_open"
.IX Subsection "guestfs_luks_open"
.Vb 5
\& int
\& guestfs_luks_open (guestfs_h *g,
\&                    const char *device,
\&                    const char *key,
\&                    const char *mapname);
.Ve
.PP
Ця команда відкриває блоковий пристрій, який було зашифровано відповідно до
стандарту Linux Unified Key Setup (\s-1LUKS\s0).
.PP
\&\f(CW\*(C`пристрій\*(C'\fR — шифрований блоковий пристрій або розділ.
.PP
Засіб виклику має надати один з ключів, пов'язаних із блоковим пристроєм
\&\s-1LUKS,\s0 у параметрі \f(CW\*(C`ключ\*(C'\fR.
.PP
Ця команда створює блоковий пристрій із назвою
\&\fI/dev/mapper/назва_прив'язки\fR. Читання та запис на цій блоковий пристрій
відбувається із розшифровуванням та шифруванням на підлеглому пристрої
\&\f(CW\*(C`пристрій\*(C'\fR.
.PP
If this block device contains \s-1LVM\s0 volume groups, then calling
\&\f(CW\*(C`guestfs_lvm_scan\*(C'\fR with the \f(CW\*(C`activate\*(C'\fR parameter \f(CW\*(C`true\*(C'\fR will make them
visible.
.PP
Скористайтеся командою \f(CW\*(C`guestfs_list_dm_devices\*(C'\fR, щоб отримати список усіх
пристроїв засобу прив'язування пристроїв.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Ця функція отримує параметр ключа або пароля, тобто дані, які можуть бути
конфіденційними. Щоб дізнатися більше про це, ознайомтеся із розділом
\&\*(L"КЛЮЧІ І ПАРОЛІ\*(R".
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.1)
.SS "guestfs_luks_open_ro"
.IX Subsection "guestfs_luks_open_ro"
.Vb 5
\& int
\& guestfs_luks_open_ro (guestfs_h *g,
\&                       const char *device,
\&                       const char *key,
\&                       const char *mapname);
.Ve
.PP
Виконує ті самі дії, що і \f(CW\*(C`guestfs_luks_open\*(C'\fR, але зі створенням прив'язки,
яка придатна лише для читання даних.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Ця функція отримує параметр ключа або пароля, тобто дані, які можуть бути
конфіденційними. Щоб дізнатися більше про це, ознайомтеся із розділом
\&\*(L"КЛЮЧІ І ПАРОЛІ\*(R".
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`luks\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.1)
.SS "guestfs_lvcreate"
.IX Subsection "guestfs_lvcreate"
.Vb 5
\& int
\& guestfs_lvcreate (guestfs_h *g,
\&                   const char *logvol,
\&                   const char *volgroup,
\&                   int mbytes);
.Ve
.PP
Ця команда створює логічний том \s-1LVM\s0 із назвою \f(CW\*(C`логічний_том\*(C'\fR у групі томів
\&\f(CW\*(C`група_томів\*(C'\fR із розміром \f(CW\*(C`мегабайти\*(C'\fR мегабайтів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.8)
.SS "guestfs_lvcreate_free"
.IX Subsection "guestfs_lvcreate_free"
.Vb 5
\& int
\& guestfs_lvcreate_free (guestfs_h *g,
\&                        const char *logvol,
\&                        const char *volgroup,
\&                        int percent);
.Ve
.PP
Створює логічний том \s-1LVM\s0 із назвою \fI/dev/група_томів/логічний_том\fR, який
використовуватиме приблизно \f(CW\*(C`відсоткиt\*(C'\fR % залишкового вільного місця у
групі томів. Найпоширенішим є використання значення \f(CW\*(C`відсотки\*(C'\fR рівного
\&\f(CW100\fR для створення найбільшого можливого логічного тому.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.18)
.SS "guestfs_lvm_canonical_lv_name"
.IX Subsection "guestfs_lvm_canonical_lv_name"
.Vb 3
\& char *
\& guestfs_lvm_canonical_lv_name (guestfs_h *g,
\&                                const char *lvname);
.Ve
.PP
Ця команда перетворює альтернативні схеми найменування логічних томів, які
можуть зустрітися на практиці, на канонічні назви. Приклад:
\&\fI/dev/mapper/група_томів\-логічний_том\fR буде перетворено на
\&\fI/dev/група_томів/логічний_том\fR.
.PP
Ця команда повертає повідомлення про помилку, якщо параметр
\&\f(CW\*(C`назва_логічного_тому\*(C'\fR не є назвою наявного логічного тому.
.PP
Див. також \f(CW\*(C`guestfs_is_lv\*(C'\fR, \f(CW\*(C`guestfs_canonical_device_name\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.24)
.SS "guestfs_lvm_clear_filter"
.IX Subsection "guestfs_lvm_clear_filter"
.Vb 2
\& int
\& guestfs_lvm_clear_filter (guestfs_h *g);
.Ve
.PP
Скасовує дію \f(CW\*(C`guestfs_lvm_set_filter\*(C'\fR. \s-1LVM\s0 зможе бачити усі блокові
пристрої.
.PP
Крім того, ця команда спорожняє кеш \s-1LVM\s0 і виконує сканування груп томів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.1)
.SS "guestfs_lvm_remove_all"
.IX Subsection "guestfs_lvm_remove_all"
.Vb 2
\& int
\& guestfs_lvm_remove_all (guestfs_h *g);
.Ve
.PP
Ця команда вилучає усі логічні томи, групи томів та фізичні томи \s-1LVM.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.8)
.SS "guestfs_lvm_scan"
.IX Subsection "guestfs_lvm_scan"
.Vb 3
\& int
\& guestfs_lvm_scan (guestfs_h *g,
\&                   int activate);
.Ve
.PP
This scans all block devices and rebuilds the list of \s-1LVM\s0 physical volumes,
volume groups and logical volumes.
.PP
If the \f(CW\*(C`activate\*(C'\fR parameter is \f(CW\*(C`true\*(C'\fR then newly found volume groups and
logical volumes are activated, meaning the \s-1LV\s0 \fI/dev/VG/LV\fR devices become
visible.
.PP
When a libguestfs handle is launched it scans for existing devices, so you
do not normally need to use this \s-1API.\s0  However it is useful when you have
added a new device or deleted an existing device (such as when the
\&\f(CW\*(C`guestfs_luks_open\*(C'\fR \s-1API\s0 is used).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Added in 1.39.8)
.SS "guestfs_lvm_set_filter"
.IX Subsection "guestfs_lvm_set_filter"
.Vb 3
\& int
\& guestfs_lvm_set_filter (guestfs_h *g,
\&                         char *const *devices);
.Ve
.PP
Ця команда встановлює фільтр пристроїв \s-1LVM\s0 так, що \s-1LVM\s0 зможе «бачити» лише
блокові пристрої зі списку \f(CW\*(C`пристрої\*(C'\fR і ігноруватиме усі інші з'єднані
блокові пристрої.
.PP
Там, де образи дисків містять дублікати фізичних томів або груп томів, ця
команда корисна для того, щоб \s-1LVM\s0 ігнорувала такі дублікати і уникала
конфліктів. Слід також зауважити, що існує два типи дублювання: клоновані
фізичні томи або групи томів, які мають однакові UUIDs; та групи томів, які
не було клоновано, але які мають однакові назви. За звичайних умов,
створення таких дублікатів неможливе, але їх може бути створено за межами
\&\s-1LVM,\s0 наприклад, внаслідок клонування образів дисків або втручання до
метаданих \s-1LVM.\s0
.PP
Крім того, ця команда спорожняє кеш \s-1LVM\s0 і виконує сканування груп томів.
.PP
Ви можете фільтрувати усі блокові пристрої або окремі розділи.
.PP
Цією командою не можна користуватися, якщо якась з груп томів
використовується (наприклад, містить змонтовану файлову систему), навіть
якщо ви не викидаєте за допомогою фільтрування цю групу томів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.5.1)
.SS "guestfs_lvremove"
.IX Subsection "guestfs_lvremove"
.Vb 3
\& int
\& guestfs_lvremove (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Вилучає логічний том \s-1LVM\s0 \f(CW\*(C`пристрій\*(C'\fR, де \f(CW\*(C`пристрій\*(C'\fR — це шлях до логічного
тому, наприклад \fI/dev/група_томів/логічний_том\fR.
.PP
Ви також можете вилучити усі логічні томи у групі томів, вказавши назву
групи томів, \fI/dev/група_томів\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.13)
.SS "guestfs_lvrename"
.IX Subsection "guestfs_lvrename"
.Vb 4
\& int
\& guestfs_lvrename (guestfs_h *g,
\&                   const char *logvol,
\&                   const char *newlogvol);
.Ve
.PP
Перейменувати логічний том \f(CW\*(C`логічний_том\*(C'\fR на том із назвою
\&\f(CW\*(C`новий_логічний_том\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.83)
.SS "guestfs_lvresize"
.IX Subsection "guestfs_lvresize"
.Vb 4
\& int
\& guestfs_lvresize (guestfs_h *g,
\&                   const char *device,
\&                   int mbytes);
.Ve
.PP
Ця команда змінює розмір (розширює або стискає) наявний логічний том \s-1LVM\s0 до
розміру \f(CW\*(C`мегабайти\*(C'\fR. Якщо розміри тому зменшуються, дані у відкинутій у
результаті зменшення розмірів частині тому буде втрачено.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.27)
.SS "guestfs_lvresize_free"
.IX Subsection "guestfs_lvresize_free"
.Vb 4
\& int
\& guestfs_lvresize_free (guestfs_h *g,
\&                        const char *lv,
\&                        int percent);
.Ve
.PP
Ця команда розширює наявний \f(CW\*(C`логічний_том\*(C'\fR так, що він займатиме
\&\f(CW\*(C`відсотки\*(C'\fR% залишкового вільного місця у групі томів. Типово, ця команда
викликається із значенням відсотки = 100 для розширення логічного тому на
максимальний розмір, використовуючи усе вільне місце у групі томів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.3.3)
.SS "guestfs_lvs"
.IX Subsection "guestfs_lvs"
.Vb 2
\& char **
\& guestfs_lvs (guestfs_h *g);
.Ve
.PP
Виводить список усіх виявлених логічних томів. Є еквівалентом команди
\&\fBlvs\fR\|(8).
.PP
Ця команда повертає список назв пристроїв логічних томів (наприклад
\&\fI/dev/VolGroup00/LogVol00\fR).
.PP
Див. також \f(CW\*(C`guestfs_lvs_full\*(C'\fR, \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.4)
.SS "guestfs_lvs_full"
.IX Subsection "guestfs_lvs_full"
.Vb 2
\& struct guestfs_lvm_lv_list *
\& guestfs_lvs_full (guestfs_h *g);
.Ve
.PP
Виводить список усіх виявлених логічних томів. Є еквівалентом команди
\&\fBlvs\fR\|(8). «Повна» версія включає усі поля.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_lvm_lv_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_lvm_lv_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.4)
.SS "guestfs_lvuuid"
.IX Subsection "guestfs_lvuuid"
.Vb 3
\& char *
\& guestfs_lvuuid (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
Ця команда повертає \s-1UUID\s0 логічного тому \s-1LVM\s0 \f(CW\*(C`пристрій\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.87)
.SS "guestfs_lxattrlist"
.IX Subsection "guestfs_lxattrlist"
.Vb 4
\& struct guestfs_xattr_list *
\& guestfs_lxattrlist (guestfs_h *g,
\&                     const char *path,
\&                     char *const *names);
.Ve
.PP
Цей виклик надає змогу отримувати розширені атрибути декількох файлів, які
зберігаються у каталозі \f(CW\*(C`шлях\*(C'\fR. Значенням аргументу \f(CW\*(C`назви\*(C'\fR є список
файлів у цьому каталозі.
.PP
Повернуто буде плоский список структур xattr, який слід обробляти
послідовно. Перша структура xattr завжди матиме \f(CW\*(C`attrname\*(C'\fR нульової
довжини. \f(CW\*(C`attrval\*(C'\fR нульової довжини у цій структурі вказуватиме на те, що
під час обробки цього файла за допомогою \f(CW\*(C`lgetxattr\*(C'\fR сталася помилка. \fIor\fR
є рядком C, який містить десяткове число (кількість наступних атрибутів для
цього файла, може бути \f(CW"0"\fR).  Далі, після першої структури xattr буде
розташовано нуль або більше атрибутів першого іменованого файла. Далі, дані
повторюватиметься для другого та наступних файлів.
.PP
Цю команду призначено для програм, яким потрібно ефективно будувати список
вмісту каталогів без виконання багатьох обходів. Див. також
\&\f(CW\*(C`guestfs_lstatlist\*(C'\fR, якщо потрібний подібний ефективний підхід для
отримання стандартних статистичних даних.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.77)
.SS "guestfs_max_disks"
.IX Subsection "guestfs_max_disks"
.Vb 2
\& int
\& guestfs_max_disks (guestfs_h *g);
.Ve
.PP
Повертає максимальну кількість дисків, які може бути додано до дескриптора
(наприклад, за допомогою \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR та подібних команд).
.PP
Цю функцію було додано у libguestfs 1.19.7. У попередніх версіях libguestfs
діяло обмеження у 25.
.PP
Див. \*(L"МАКСИМАЛЬНА КІЛЬКІСТЬ ДИСКІВ\*(R", щоб дізнатися більше про
це.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.19.7)
.SS "guestfs_md_create"
.IX Subsection "guestfs_md_create"
.Vb 5
\& int
\& guestfs_md_create (guestfs_h *g,
\&                    const char *name,
\&                    char *const *devices,
\&                    ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_MD_CREATE_MISSINGBITMAP, int64_t missingbitmap,
\& GUESTFS_MD_CREATE_NRDEVICES, int nrdevices,
\& GUESTFS_MD_CREATE_SPARE, int spare,
\& GUESTFS_MD_CREATE_CHUNK, int64_t chunk,
\& GUESTFS_MD_CREATE_LEVEL, const char *level,
.Ve
.PP
Створює пристрій md (\s-1RAID\s0) Linux із назвою \f(CW\*(C`назва\*(C'\fR на пристроях зі списку
\&\f(CW\*(C`пристрої\*(C'\fR.
.PP
Додатковими параметрами є:
.ie n .IP """missingbitmap""" 4
.el .IP "\f(CWmissingbitmap\fR" 4
.IX Item "missingbitmap"
Бітова карта пристроїв, яких не вистачає. Якщо біт встановлено, це означає,
що до масиву додано пристрій, якого не вистачає. Найменший біт відповідає
першому пристрої у масиві.
.Sp
Приклади:
.Sp
Якщо \f(CW\*(C`пристрої = ["/dev/sda"]\*(C'\fR і \f(CW\*(C`missingbitmap = 0x1\*(C'\fR,
масивом\-результатом має бути \f(CW\*(C`[<missing>, "/dev/sda"]\*(C'\fR.
.Sp
Якщо \f(CW\*(C`пристрої = ["/dev/sda"]\*(C'\fR і \f(CW\*(C`missingbitmap = 0x2\*(C'\fR,
масивом\-результатом має бути \f(CW\*(C`["/dev/sda", <missing>]\*(C'\fR.
.Sp
Типовим є значення \f(CW0\fR (немає пристроїв, яких не вистачає).
.Sp
Довжина запису \f(CW\*(C`пристрої\*(C'\fR + кількість бітів, встановлених у
\&\f(CW\*(C`missingbitmap\*(C'\fR має дорівнювати \f(CW\*(C`nrdevices\*(C'\fR + \f(CW\*(C`spare\*(C'\fR.
.ie n .IP """nrdevices""" 4
.el .IP "\f(CWnrdevices\fR" 4
.IX Item "nrdevices"
Кількість активних пристроїв \s-1RAID.\s0
.Sp
Якщо не встановлено, типовим значенням є довжина запису \f(CW\*(C`пристрої\*(C'\fR плюс
кількість бітів, які встановлено у \f(CW\*(C`missingbitmap\*(C'\fR.
.ie n .IP """spare""" 4
.el .IP "\f(CWspare\fR" 4
.IX Item "spare"
Кількість резервних пристроїв.
.Sp
Якщо не встановлено, типовим значенням є \f(CW0\fR.
.ie n .IP """chunk""" 4
.el .IP "\f(CWchunk\fR" 4
.IX Item "chunk"
Розмір фрагмента у байтах.
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
Рівень \s-1RAID,\s0 одне з таких значень: \fIlinear\fR, \fIraid0\fR, \fI0\fR, \fIstripe\fR,
\&\fIraid1\fR, \fI1\fR, \fImirror\fR, \fIraid4\fR, \fI4\fR, \fIraid5\fR, \fI5\fR, \fIraid6\fR, \fI6\fR,
\&\fIraid10\fR, \fI10\fR.  Деякі з цих значень є синонімами, інші рівні може бути
додано у майбутніх версіях.
.Sp
Якщо не встановлено, типовим значенням є \f(CW\*(C`raid1\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mdadm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.15.6)
.SS "guestfs_md_create_va"
.IX Subsection "guestfs_md_create_va"
.Vb 5
\& int
\& guestfs_md_create_va (guestfs_h *g,
\&                       const char *name,
\&                       char *const *devices,
\&                       va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_md_create\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_md_create_argv"
.IX Subsection "guestfs_md_create_argv"
.Vb 5
\& int
\& guestfs_md_create_argv (guestfs_h *g,
\&                         const char *name,
\&                         char *const *devices,
\&                         const struct guestfs_md_create_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_md_create\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_md_detail"
.IX Subsection "guestfs_md_detail"
.Vb 3
\& char **
\& guestfs_md_detail (guestfs_h *g,
\&                    const char *md);
.Ve
.PP
Ця команда розкриває виведені «mdadm \-DY <md>» дані. У повернутому
хеші, зазвичай, будуть вказані нижче поля. Також там можуть бути інші поля.
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
Рівень \s-1RAID\s0 пристрою \s-1MD.\s0
.ie n .IP """devices""" 4
.el .IP "\f(CWdevices\fR" 4
.IX Item "devices"
Кількість підлеглих пристроїв у пристрої \s-1MD.\s0
.ie n .IP """metadata""" 4
.el .IP "\f(CWmetadata\fR" 4
.IX Item "metadata"
Використана версія метаданих.
.ie n .IP """uuid""" 4
.el .IP "\f(CWuuid\fR" 4
.IX Item "uuid"
\&\s-1UUID\s0 пристрою \s-1MD.\s0
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
Назва пристрою \s-1MD.\s0
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mdadm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.15.6)
.SS "guestfs_md_stat"
.IX Subsection "guestfs_md_stat"
.Vb 3
\& struct guestfs_mdstat_list *
\& guestfs_md_stat (guestfs_h *g,
\&                  const char *md);
.Ve
.PP
Ця команда повертає список підлеглих пристроїв, з яких складається окремий
програмний масив \s-1RAID\s0 пристрою \f(CW\*(C`md\*(C'\fR.
.PP
Щоб отримати список пристроїв програмних \s-1RAID,\s0 скористайтеся викликом
\&\f(CW\*(C`guestfs_list_md_devices\*(C'\fR.
.PP
Кожна повернута структура відповідає одному пристрою із додатковими
відомостями щодо стану:
.ie n .IP """mdstat_device""" 4
.el .IP "\f(CWmdstat_device\fR" 4
.IX Item "mdstat_device"
Назва підлеглого пристрою.
.ie n .IP """mdstat_index""" 4
.el .IP "\f(CWmdstat_index\fR" 4
.IX Item "mdstat_index"
Індекс цього пристрою у масиві.
.ie n .IP """mdstat_flags""" 4
.el .IP "\f(CWmdstat_flags\fR" 4
.IX Item "mdstat_flags"
Прапорці, пов'язані із цим пристроєм. Ця рядок містить (неупорядкованими)
нуль або більше таких прапорців:
.RS 4
.ie n .IP """W""" 4
.el .IP "\f(CWW\fR" 4
.IX Item "W"
write-mostly
.ie n .IP """F""" 4
.el .IP "\f(CWF\fR" 4
.IX Item "F"
пристрій працює з помилками
.ie n .IP """S""" 4
.el .IP "\f(CWS\fR" 4
.IX Item "S"
пристрій є запасною частиною \s-1RAID\s0
.ie n .IP """R""" 4
.el .IP "\f(CWR\fR" 4
.IX Item "R"
заміна
.RE
.RS 4
.RE
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_mdstat_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_mdstat_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mdadm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.21)
.SS "guestfs_md_stop"
.IX Subsection "guestfs_md_stop"
.Vb 3
\& int
\& guestfs_md_stop (guestfs_h *g,
\&                  const char *md);
.Ve
.PP
Ця команда деактивує масив \s-1MD\s0 із назвою \f(CW\*(C`md\*(C'\fR. Роботу пристрою буде
припинено, але без знищення або занулення.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mdadm\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.15.6)
.SS "guestfs_mkdir"
.IX Subsection "guestfs_mkdir"
.Vb 3
\& int
\& guestfs_mkdir (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Створює каталог із назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_mkdir_mode"
.IX Subsection "guestfs_mkdir_mode"
.Vb 4
\& int
\& guestfs_mkdir_mode (guestfs_h *g,
\&                     const char *path,
\&                     int mode);
.Ve
.PP
Ця команда створює каталог, встановлюючи початкові права доступу до нього у
значення \f(CW\*(C`режим\*(C'\fR.
.PP
Для типових файлових систем Linux справжній режим доступу, який
встановлюється, визначається виразом \f(CW\*(C`режим & ~umask & 01777\*(C'\fR. У файлових
системах, які не є природними для Linux, цей режим може визначатися у інший
спосіб.
.PP
Див. також \f(CW\*(C`guestfs_mkdir\*(C'\fR, \f(CW\*(C`guestfs_umask\*(C'\fR
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_mkdir_p"
.IX Subsection "guestfs_mkdir_p"
.Vb 3
\& int
\& guestfs_mkdir_p (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Створює каталог із назвою \f(CW\*(C`шлях\*(C'\fR зі створенням усіх потрібних проміжних
каталогів. Результат подібний до результату дії команди оболонки \f(CW\*(C`mkdir
\&\-p\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_mkdtemp"
.IX Subsection "guestfs_mkdtemp"
.Vb 3
\& char *
\& guestfs_mkdtemp (guestfs_h *g,
\&                  const char *tmpl);
.Ve
.PP
Ця команда створює тимчасовий каталог. Значенням параметра \f(CW\*(C`tmpl\*(C'\fR має бути
повна назва шляху до тимчасового каталогу із завершальними шістьма символами
«XXXXXX».
.PP
Приклади: «/tmp/myprogXXXXXX» або «/Temp/myprogXXXXXX». Другий варіант є
придатним для файлових систем Windows.
.PP
Буде повернуто назву тимчасового каталогу, який було створено.
.PP
Тимчасовий каталог буде створено із режимом доступу 0700, його власником
буде користувач root.
.PP
За вилучення тимчасового каталогу і його вмісту після використання
відповідає функція виклику.
.PP
Див. також \fBmkdtemp\fR\|(3)
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.54)
.SS "guestfs_mke2fs"
.IX Subsection "guestfs_mke2fs"
.Vb 4
\& int
\& guestfs_mke2fs (guestfs_h *g,
\&                 const char *device,
\&                 ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 10
\& GUESTFS_MKE2FS_BLOCKSCOUNT, int64_t blockscount,
\& GUESTFS_MKE2FS_BLOCKSIZE, int64_t blocksize,
\& GUESTFS_MKE2FS_FRAGSIZE, int64_t fragsize,
\& GUESTFS_MKE2FS_BLOCKSPERGROUP, int64_t blockspergroup,
\& GUESTFS_MKE2FS_NUMBEROFGROUPS, int64_t numberofgroups,
\& GUESTFS_MKE2FS_BYTESPERINODE, int64_t bytesperinode,
\& GUESTFS_MKE2FS_INODESIZE, int64_t inodesize,
\& GUESTFS_MKE2FS_JOURNALSIZE, int64_t journalsize,
\& GUESTFS_MKE2FS_NUMBEROFINODES, int64_t numberofinodes,
\& GUESTFS_MKE2FS_STRIDESIZE, int64_t stridesize,
\& GUESTFS_MKE2FS_STRIPEWIDTH, int64_t stripewidth,
\& GUESTFS_MKE2FS_MAXONLINERESIZE, int64_t maxonlineresize,
\& GUESTFS_MKE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
\& GUESTFS_MKE2FS_MMPUPDATEINTERVAL, int mmpupdateinterval,
\& GUESTFS_MKE2FS_JOURNALDEVICE, const char *journaldevice,
\& GUESTFS_MKE2FS_LABEL, const char *label,
\& GUESTFS_MKE2FS_LASTMOUNTEDDIR, const char *lastmounteddir,
\& GUESTFS_MKE2FS_CREATOROS, const char *creatoros,
\& GUESTFS_MKE2FS_FSTYPE, const char *fstype,
\& GUESTFS_MKE2FS_USAGETYPE, const char *usagetype,
\& GUESTFS_MKE2FS_UUID, const char *uuid,
\& GUESTFS_MKE2FS_FORCECREATE, int forcecreate,
\& GUESTFS_MKE2FS_WRITESBANDGROUPONLY, int writesbandgrouponly,
\& GUESTFS_MKE2FS_LAZYITABLEINIT, int lazyitableinit,
\& GUESTFS_MKE2FS_LAZYJOURNALINIT, int lazyjournalinit,
\& GUESTFS_MKE2FS_TESTFS, int testfs,
\& GUESTFS_MKE2FS_DISCARD, int discard,
\& GUESTFS_MKE2FS_QUOTATYPE, int quotatype,
\& GUESTFS_MKE2FS_EXTENT, int extent,
\& GUESTFS_MKE2FS_FILETYPE, int filetype,
\& GUESTFS_MKE2FS_FLEXBG, int flexbg,
\& GUESTFS_MKE2FS_HASJOURNAL, int hasjournal,
\& GUESTFS_MKE2FS_JOURNALDEV, int journaldev,
\& GUESTFS_MKE2FS_LARGEFILE, int largefile,
\& GUESTFS_MKE2FS_QUOTA, int quota,
\& GUESTFS_MKE2FS_RESIZEINODE, int resizeinode,
\& GUESTFS_MKE2FS_SPARSESUPER, int sparsesuper,
\& GUESTFS_MKE2FS_UNINITBG, int uninitbg,
.Ve
.PP
\&\f(CW\*(C`mke2fs\*(C'\fR використовується для створення файлових систем ext2, ext3 та ext4
на пристрої \f(CW\*(C`пристрій\*(C'\fR.
.PP
Необов'язковий параметр \f(CW\*(C`blockscount\*(C'\fR визначає розмір файлової системи у
блоках. Якщо його не вказано, типовим значенням буде розмір пристрою
\&\f(CW\*(C`пристрій\*(C'\fR. Зауважте, що якщо файлова система буде надто малою для того,
щоб містити журнал, \f(CW\*(C`mke2fs\*(C'\fR без додаткових повідомлень створить файлову
систему ext2.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.44)
.SS "guestfs_mke2fs_va"
.IX Subsection "guestfs_mke2fs_va"
.Vb 4
\& int
\& guestfs_mke2fs_va (guestfs_h *g,
\&                    const char *device,
\&                    va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mke2fs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mke2fs_argv"
.IX Subsection "guestfs_mke2fs_argv"
.Vb 4
\& int
\& guestfs_mke2fs_argv (guestfs_h *g,
\&                      const char *device,
\&                      const struct guestfs_mke2fs_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mke2fs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mke2fs_J"
.IX Subsection "guestfs_mke2fs_J"
.Vb 6
\& int
\& guestfs_mke2fs_J (guestfs_h *g,
\&                   const char *fstype,
\&                   int blocksize,
\&                   const char *device,
\&                   const char *journal);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mke2fs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда створює файлову систему ext2/3/4 на пристрої \f(CW\*(C`пристрій\*(C'\fR із
зовнішнім журналом на розділі \f(CW\*(C`журнал\*(C'\fR. Вона еквівалентна до такої команди:
.PP
.Vb 1
\& mke2fs \-t тип_файлової_системи \-b розмір_блоку \-J device=<журнал> <пристрій>
.Ve
.PP
Див. також \f(CW\*(C`guestfs_mke2journal\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.68)
.SS "guestfs_mke2fs_JL"
.IX Subsection "guestfs_mke2fs_JL"
.Vb 6
\& int
\& guestfs_mke2fs_JL (guestfs_h *g,
\&                    const char *fstype,
\&                    int blocksize,
\&                    const char *device,
\&                    const char *label);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mke2fs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда створює файлову систему ext2/3/4 на пристрої \f(CW\*(C`пристрій\*(C'\fR із
зовнішнім журналом на розділі із міткою \f(CW\*(C`мітка\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_mke2journal_L\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.68)
.SS "guestfs_mke2fs_JU"
.IX Subsection "guestfs_mke2fs_JU"
.Vb 6
\& int
\& guestfs_mke2fs_JU (guestfs_h *g,
\&                    const char *fstype,
\&                    int blocksize,
\&                    const char *device,
\&                    const char *uuid);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mke2fs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда створює файлову систему ext2/3/4 на пристрої \f(CW\*(C`пристрій\*(C'\fR із
зовнішнім журналом на розділі із \s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_mke2journal_U\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxfsuuid\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.68)
.SS "guestfs_mke2journal"
.IX Subsection "guestfs_mke2journal"
.Vb 4
\& int
\& guestfs_mke2journal (guestfs_h *g,
\&                      int blocksize,
\&                      const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mke2fs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда створює зовнішній журнал ext2 на пристрої \f(CW\*(C`пристрій\*(C'\fR. Вона
еквівалентна до такої команди:
.PP
.Vb 1
\& mke2fs \-O пристрій_журналу \-b розмір_блоку пристрій
.Ve
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.68)
.SS "guestfs_mke2journal_L"
.IX Subsection "guestfs_mke2journal_L"
.Vb 5
\& int
\& guestfs_mke2journal_L (guestfs_h *g,
\&                        int blocksize,
\&                        const char *label,
\&                        const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mke2fs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда створює зовнішній журнал ext2 на пристрої \f(CW\*(C`пристрій\*(C'\fR з міткою
\&\f(CW\*(C`мітка\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.68)
.SS "guestfs_mke2journal_U"
.IX Subsection "guestfs_mke2journal_U"
.Vb 5
\& int
\& guestfs_mke2journal_U (guestfs_h *g,
\&                        int blocksize,
\&                        const char *uuid,
\&                        const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mke2fs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда створює зовнішній журнал ext2 на пристрої \f(CW\*(C`пристрій\*(C'\fR із \s-1UUID\s0
\&\f(CW\*(C`uuid\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxfsuuid\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.68)
.SS "guestfs_mkfifo"
.IX Subsection "guestfs_mkfifo"
.Vb 4
\& int
\& guestfs_mkfifo (guestfs_h *g,
\&                 int mode,
\&                 const char *path);
.Ve
.PP
Ця команда створює \s-1FIFO\s0 (іменований канал даних) із назвою \f(CW\*(C`path\*(C'\fR і режимом
доступу \f(CW\*(C`mode\*(C'\fR. Це просто зручна обгортка до \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
На відміну від \f(CW\*(C`guestfs_mknod\*(C'\fR, параметр \f(CW\*(C`mode\*(C'\fR \fBмає\fR містити лише біти
прав доступу.
.PP
На встановлений режим доступу впливає umask.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mknod\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.55)
.SS "guestfs_mkfs"
.IX Subsection "guestfs_mkfs"
.Vb 4
\& int
\& guestfs_mkfs (guestfs_h *g,
\&               const char *fstype,
\&               const char *device);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_mkfs_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 0.8)
.SS "guestfs_mkfs_opts"
.IX Subsection "guestfs_mkfs_opts"
.Vb 5
\& int
\& guestfs_mkfs_opts (guestfs_h *g,
\&                    const char *fstype,
\&                    const char *device,
\&                    ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_MKFS_OPTS_BLOCKSIZE, int blocksize,
\& GUESTFS_MKFS_OPTS_FEATURES, const char *features,
\& GUESTFS_MKFS_OPTS_INODE, int inode,
\& GUESTFS_MKFS_OPTS_SECTORSIZE, int sectorsize,
\& GUESTFS_MKFS_OPTS_LABEL, const char *label,
.Ve
.PP
Ця функція створює файлову систему на пристрої \f(CW\*(C`пристрій\*(C'\fR. Типом файлової
системи буде \f(CW\*(C`тип_файлової_системи\*(C'\fR, наприклад \f(CW\*(C`ext3\*(C'\fR.
.PP
Необов'язковими аргументами є:
.ie n .IP """blocksize""" 4
.el .IP "\f(CWblocksize\fR" 4
.IX Item "blocksize"
Розмір блоку файлової системи. Підтримувані розміри блоків залежать від типу
файлової системи, але типовими є  \f(CW1024\fR, \f(CW2048\fR і \f(CW4096\fR для файлових
систем ext2/3 Linux.
.Sp
Для \s-1VFAT\s0 і \s-1NTFS\s0 значення параметра \f(CW\*(C`розмір_блоку\*(C'\fR обробляється як бажаний
розмір кластера.
.Sp
Дані щодо розмірів блоків \s-1UFS\s0 можна знайти у підручнику до \fBmkfs.ufs\fR\|(8).
.ie n .IP """features""" 4
.el .IP "\f(CWfeatures\fR" 4
.IX Item "features"
Передає параметр \fI\-O\fR зовнішній програмі mkfs.
.Sp
Для деяких типів файлових систем це надає змогу вибрати додаткові можливості
файлової системи. Щоб дізнатися більше, див. \fBmke2fs\fR\|(8) та \fBmkfs.ufs\fR\|(8).
.Sp
Цей додатковий параметр не можна використовувати для типів файлових систем
\&\f(CW\*(C`gfs\*(C'\fR та \f(CW\*(C`gfs2\*(C'\fR.
.ie n .IP """inode""" 4
.el .IP "\f(CWinode\fR" 4
.IX Item "inode"
Передає параметр \fI\-I\fR зовнішній програмі \fBmke2fs\fR\|(8), тобто визначає
розмір inode (у поточній версії лише для файлових систем ext2/3/4).
.ie n .IP """sectorsize""" 4
.el .IP "\f(CWsectorsize\fR" 4
.IX Item "sectorsize"
Передає параметр \fI\-S\fR зовнішній програмі \fBmkfs.ufs\fR\|(8), тобто визначає
розмір сектора для файлової системи ufs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_mkfs_opts_va"
.IX Subsection "guestfs_mkfs_opts_va"
.Vb 5
\& int
\& guestfs_mkfs_opts_va (guestfs_h *g,
\&                       const char *fstype,
\&                       const char *device,
\&                       va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mkfs_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mkfs_opts_argv"
.IX Subsection "guestfs_mkfs_opts_argv"
.Vb 5
\& int
\& guestfs_mkfs_opts_argv (guestfs_h *g,
\&                         const char *fstype,
\&                         const char *device,
\&                         const struct guestfs_mkfs_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mkfs_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mkfs_b"
.IX Subsection "guestfs_mkfs_b"
.Vb 5
\& int
\& guestfs_mkfs_b (guestfs_h *g,
\&                 const char *fstype,
\&                 int blocksize,
\&                 const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mkfs\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Цей виклик подібний до \f(CW\*(C`guestfs_mkfs\*(C'\fR, але надає вам змогу контролювати
розмір блоку отриманої файлової системи. Набір підтримуваних розмірів блоків
залежить від типу файлової системи, але типовими є \f(CW1024\fR, \f(CW2048\fR та
\&\f(CW4096\fR.
.PP
Для \s-1VFAT\s0 і \s-1NTFS\s0 значення параметра \f(CW\*(C`розмір_блоку\*(C'\fR обробляється як бажаний
розмір кластера.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.68)
.SS "guestfs_mkfs_btrfs"
.IX Subsection "guestfs_mkfs_btrfs"
.Vb 4
\& int
\& guestfs_mkfs_btrfs (guestfs_h *g,
\&                     char *const *devices,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 8
\& GUESTFS_MKFS_BTRFS_ALLOCSTART, int64_t allocstart,
\& GUESTFS_MKFS_BTRFS_BYTECOUNT, int64_t bytecount,
\& GUESTFS_MKFS_BTRFS_DATATYPE, const char *datatype,
\& GUESTFS_MKFS_BTRFS_LEAFSIZE, int leafsize,
\& GUESTFS_MKFS_BTRFS_LABEL, const char *label,
\& GUESTFS_MKFS_BTRFS_METADATA, const char *metadata,
\& GUESTFS_MKFS_BTRFS_NODESIZE, int nodesize,
\& GUESTFS_MKFS_BTRFS_SECTORSIZE, int sectorsize,
.Ve
.PP
Створює файлову систему btrfs із можливим встановленням усіх
налаштувань. Щоб дізнатися більше про додаткові параметри, ознайомтеся зі
сторінкою підручника \fBmkfs.btrfs\fR\|(8).
.PP
Оскільки дані файлової системи btrfs може бути розподілено між декількома
пристроями, команда приймає непорожній список пристроїв.
.PP
Для створення файлових систем скористайтеся \f(CW\*(C`guestfs_mkfs\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`btrfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.25)
.SS "guestfs_mkfs_btrfs_va"
.IX Subsection "guestfs_mkfs_btrfs_va"
.Vb 4
\& int
\& guestfs_mkfs_btrfs_va (guestfs_h *g,
\&                        char *const *devices,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mkfs_btrfs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mkfs_btrfs_argv"
.IX Subsection "guestfs_mkfs_btrfs_argv"
.Vb 4
\& int
\& guestfs_mkfs_btrfs_argv (guestfs_h *g,
\&                          char *const *devices,
\&                          const struct guestfs_mkfs_btrfs_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mkfs_btrfs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mklost_and_found"
.IX Subsection "guestfs_mklost_and_found"
.Vb 3
\& int
\& guestfs_mklost_and_found (guestfs_h *g,
\&                           const char *mountpoint);
.Ve
.PP
Створює каталог \f(CW\*(C`lost+found\*(C'\fR, зазвичай, у кореневому каталозі файлової
системи ext2/3/4. \f(CW\*(C`точка_монтування\*(C'\fR є каталогом, у якому ми спробуємо
створити каталог \f(CW\*(C`lost+found\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.56)
.SS "guestfs_mkmountpoint"
.IX Subsection "guestfs_mkmountpoint"
.Vb 3
\& int
\& guestfs_mkmountpoint (guestfs_h *g,
\&                       const char *exemptpath);
.Ve
.PP
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR і \f(CW\*(C`guestfs_rmmountpoint\*(C'\fR є спеціалізованими
викликами, якими можна скористатися для створення додаткових точок
монтування перед монтуванням першої файлової системи.
.PP
Ця виклики необхідні \fIлише\fR у дуже обмежених випадках. Основним їхнім
призначенням є випадок, коли ви хочете змонтувати суміш непов'язаних і/або
придатних лише для читання файлових систем разом.
.PP
Наприклад, образи компакт\-дисків портативних систем часто місять «матрьошку»
з файлових систем: зовнішній шар \s-1ISO,\s0 образ squashfs всередині і вкладений у
нього образ ext2/3. Розпакувати такий образ у guestfish можна таким чином:
.PP
.Vb 8
\& add\-ro Fedora\-11\-i686\-Live.iso
\& run
\& mkmountpoint /cd
\& mkmountpoint /sqsh
\& mkmountpoint /ext3fs
\& mount /dev/sda /cd
\& mount\-loop /cd/LiveOS/squashfs.img /sqsh
\& mount\-loop /sqsh/LiveOS/ext3fs.img /ext3fs
.Ve
.PP
Внутрішню файлову систему тепер розпаковано до точки монтування /ext3fs.
.PP
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR є несумісною з \f(CW\*(C`guestfs_umount_all\*(C'\fR. Якщо ви
спробуєте суміщати ці виклики, можуть статися неочікувані
помилки. Найбезпечніше демонтувати файлові системи вручну, а потім вилучити
точки монтування після використання.
.PP
\&\f(CW\*(C`guestfs_umount_all\*(C'\fR демонтує файлові системи упорядковуючи шляхи так, щоб
у списку найдовші шляхи були першими. Щоб ця команда могла працювати зі
створеними вручну точками монтування, системи має бути змонтовано так, щоб
точки монтування із найбільшим рівнем вкладеності мали найдовші назви
шляхів, як у наведеному вище прикладі.
.PP
Докладніше про це тут: https://bugzilla.redhat.com/show_bug.cgi?id=599503
.PP
Автоматична синхронізація [див. \f(CW\*(C`guestfs_set_autosync\*(C'\fR, встановлюється
типово на дескрипторах] може спричиняти виклик \f(CW\*(C`guestfs_umount_all\*(C'\fR, коли
дескриптор закривається, що теж може призвести до таких проблем.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.62)
.SS "guestfs_mknod"
.IX Subsection "guestfs_mknod"
.Vb 6
\& int
\& guestfs_mknod (guestfs_h *g,
\&                int mode,
\&                int devmajor,
\&                int devminor,
\&                const char *path);
.Ve
.PP
Створює спеціальні блокові або символьні пристрої або іменовані канали
(\s-1FIFO\s0).
.PP
Параметр \f(CW\*(C`режим\*(C'\fR має визначати режим доступу з використанням стандартних
сталих. Параметри \f(CW\*(C`первинний_пристрій\*(C'\fR і \f(CW\*(C`вторинний_пристрій\*(C'\fR є номерами
первинного і вторинного пристроїв, які використовуються, лише під час
створення спеціальних блокових та символьних пристроїв.
.PP
Зауважте, що, як і у \fBmknod\fR\|(2), значення режиму має бути результатом
застосування бітового АБО до значень S_IFBLK, S_IFCHR, S_IFIFO та S_IFSOCK
(інакше цей виклик просто створить звичайний файл). Ці сталі доступні у
стандартних файлах заголовків Linux. Ви також можете скористатися
\&\f(CW\*(C`guestfs_mknod_b\*(C'\fR, \f(CW\*(C`guestfs_mknod_c\*(C'\fR або \f(CW\*(C`guestfs_mkfifo\*(C'\fR, які є
обгортками навколо цієї команди, які виконують бітове АБО і створюють
відповідну сталу за вас.
.PP
На встановлений режим доступу впливає umask.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mknod\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.55)
.SS "guestfs_mknod_b"
.IX Subsection "guestfs_mknod_b"
.Vb 6
\& int
\& guestfs_mknod_b (guestfs_h *g,
\&                  int mode,
\&                  int devmajor,
\&                  int devminor,
\&                  const char *path);
.Ve
.PP
Створює вузол блокового пристрою із назвою \f(CW\*(C`path\*(C'\fR і режимом доступу \f(CW\*(C`mode\*(C'\fR
та первинний і вторинний пристрої \f(CW\*(C`devmajor\*(C'\fR і \f(CW\*(C`devminor\*(C'\fR. Це лише зручна
обгортка навколо \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
На відміну від \f(CW\*(C`guestfs_mknod\*(C'\fR, параметр \f(CW\*(C`mode\*(C'\fR \fBмає\fR містити лише біти
прав доступу.
.PP
На встановлений режим доступу впливає umask.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mknod\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.55)
.SS "guestfs_mknod_c"
.IX Subsection "guestfs_mknod_c"
.Vb 6
\& int
\& guestfs_mknod_c (guestfs_h *g,
\&                  int mode,
\&                  int devmajor,
\&                  int devminor,
\&                  const char *path);
.Ve
.PP
Створює вузол символьного пристрою із назвою \f(CW\*(C`path\*(C'\fR і режимом доступу
\&\f(CW\*(C`mode\*(C'\fR та первинний і вторинний пристрої \f(CW\*(C`devmajor\*(C'\fR і \f(CW\*(C`devminor\*(C'\fR. Це лише
зручна обгортка навколо \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
На відміну від \f(CW\*(C`guestfs_mknod\*(C'\fR, параметр \f(CW\*(C`mode\*(C'\fR \fBмає\fR містити лише біти
прав доступу.
.PP
На встановлений режим доступу впливає umask.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`mknod\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.55)
.SS "guestfs_mksquashfs"
.IX Subsection "guestfs_mksquashfs"
.Vb 5
\& int
\& guestfs_mksquashfs (guestfs_h *g,
\&                     const char *path,
\&                     const char *filename,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_MKSQUASHFS_COMPRESS, const char *compress,
\& GUESTFS_MKSQUASHFS_EXCLUDES, char *const *excludes,
.Ve
.PP
Створює файлову систему squashfs для вказаного шляху \f(CW\*(C`шлях\*(C'\fR.
.PP
Необов'язковий прапорець \f(CW\*(C`compress\*(C'\fR керує стисканням. Якщо його не вказано,
виведені дані буде стиснуто за допомогою \f(CW\*(C`gzip\*(C'\fR. Ви також можете вказати
такі рядки для вибору типу стискання squashfs: \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`lzma\*(C'\fR, \f(CW\*(C`lzo\*(C'\fR,
\&\f(CW\*(C`lz4\*(C'\fR, \f(CW\*(C`xz\*(C'\fR.
.PP
Іншими необов'язковими параметрами є такі:
.ie n .IP """excludes""" 4
.el .IP "\f(CWexcludes\fR" 4
.IX Item "excludes"
Список шаблонів. Файли буде виключено, якщо вони відповідатимуть якомусь із
вказаних шаблонів.
.PP
Будь ласка, зауважте, що цей програмний інтерфейс може не спрацювати, якщо
ним користуватися для стискання каталогів із великими файлами, зокрема
такими, для яких отримана файлова система squashfs матиме об'єм понад 3 ГБ.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`squashfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.35.25)
.SS "guestfs_mksquashfs_va"
.IX Subsection "guestfs_mksquashfs_va"
.Vb 5
\& int
\& guestfs_mksquashfs_va (guestfs_h *g,
\&                        const char *path,
\&                        const char *filename,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mksquashfs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mksquashfs_argv"
.IX Subsection "guestfs_mksquashfs_argv"
.Vb 5
\& int
\& guestfs_mksquashfs_argv (guestfs_h *g,
\&                          const char *path,
\&                          const char *filename,
\&                          const struct guestfs_mksquashfs_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mksquashfs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mkswap"
.IX Subsection "guestfs_mkswap"
.Vb 3
\& int
\& guestfs_mkswap (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_mkswap_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.0.55)
.SS "guestfs_mkswap_opts"
.IX Subsection "guestfs_mkswap_opts"
.Vb 4
\& int
\& guestfs_mkswap_opts (guestfs_h *g,
\&                      const char *device,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_MKSWAP_OPTS_LABEL, const char *label,
\& GUESTFS_MKSWAP_OPTS_UUID, const char *uuid,
.Ve
.PP
Створює розділ резервної пам'яті на диску (swap) Linux на пристрої
\&\f(CW\*(C`пристрій\*(C'\fR.
.PP
За допомогою аргументів параметра \f(CW\*(C`мітка\*(C'\fR і \f(CW\*(C`uuid\*(C'\fR ви можете вказати мітку
і/або \s-1UUID\s0 для нового розділу резервної пам'яті на диску.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.55)
.SS "guestfs_mkswap_opts_va"
.IX Subsection "guestfs_mkswap_opts_va"
.Vb 4
\& int
\& guestfs_mkswap_opts_va (guestfs_h *g,
\&                         const char *device,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mkswap_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mkswap_opts_argv"
.IX Subsection "guestfs_mkswap_opts_argv"
.Vb 4
\& int
\& guestfs_mkswap_opts_argv (guestfs_h *g,
\&                           const char *device,
\&                           const struct guestfs_mkswap_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mkswap_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mkswap_L"
.IX Subsection "guestfs_mkswap_L"
.Vb 4
\& int
\& guestfs_mkswap_L (guestfs_h *g,
\&                   const char *label,
\&                   const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mkswap\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Створює розділ резервної пам'яті на диску на пристрої \f(CW\*(C`пристрій\*(C'\fR зі міткою
\&\f(CW\*(C`мітка\*(C'\fR.
.PP
Зауважте, що не можна додавати мітку резервної пам'яті на диску (swap) до
блокового пристрою (наприклад, до \fI/dev/sda\fR), лише до розділу. Здається,
це є обмеженням ядра або інструментів для роботи із розділом резервної
пам'яті на диску.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.55)
.SS "guestfs_mkswap_U"
.IX Subsection "guestfs_mkswap_U"
.Vb 4
\& int
\& guestfs_mkswap_U (guestfs_h *g,
\&                   const char *uuid,
\&                   const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_mkswap\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Створює розділ резервної пам'яті на диску на пристрої \f(CW\*(C`пристрій\*(C'\fR із \s-1UUID\s0
\&\f(CW\*(C`uuid\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxfsuuid\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.55)
.SS "guestfs_mkswap_file"
.IX Subsection "guestfs_mkswap_file"
.Vb 3
\& int
\& guestfs_mkswap_file (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
Створити файл резервної пам’яті.
.PP
Ця команда просто записує підпис файла резервної пам'яті на диску до
наявного файла. Для створення самого файла скористайтеся чимось подібним до
\&\f(CW\*(C`guestfs_fallocate\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_mktemp"
.IX Subsection "guestfs_mktemp"
.Vb 4
\& char *
\& guestfs_mktemp (guestfs_h *g,
\&                 const char *tmpl,
\&                 ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_MKTEMP_SUFFIX, const char *suffix,
.Ve
.PP
Ця команда створює тимчасовий файл. Значенням параметра \f(CW\*(C`tmpl\*(C'\fR має бути
повна назва шляху до тимчасового каталогу із завершальними шістьма символами
«XXXXXX».
.PP
Приклади: «/tmp/myprogXXXXXX» або «/Temp/myprogXXXXXX». Другий варіант є
придатним для файлових систем Windows.
.PP
Буде повернуто назву тимчасового файла, який було створено.
.PP
Тимчасовий файл буде створено із режимом доступу 0600, його власником буде
користувач root.
.PP
За вилучення тимчасового файла після використання відповідає функція
виклику.
.PP
Якщо буде вказано необов'язковий параметр \f(CW\*(C`suffix\*(C'\fR, до назви тимчасового
файла буде додано вказаний суфікс (наприклад, \f(CW\*(C`.txt\*(C'\fR).
.PP
Див. також \f(CW\*(C`guestfs_mkdtemp\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.19.53)
.SS "guestfs_mktemp_va"
.IX Subsection "guestfs_mktemp_va"
.Vb 4
\& char *
\& guestfs_mktemp_va (guestfs_h *g,
\&                    const char *tmpl,
\&                    va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mktemp\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mktemp_argv"
.IX Subsection "guestfs_mktemp_argv"
.Vb 4
\& char *
\& guestfs_mktemp_argv (guestfs_h *g,
\&                      const char *tmpl,
\&                      const struct guestfs_mktemp_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mktemp\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_modprobe"
.IX Subsection "guestfs_modprobe"
.Vb 3
\& int
\& guestfs_modprobe (guestfs_h *g,
\&                   const char *modulename);
.Ve
.PP
Завантажує модуль ядра у базовій системі.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxmodules\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.68)
.SS "guestfs_mount"
.IX Subsection "guestfs_mount"
.Vb 4
\& int
\& guestfs_mount (guestfs_h *g,
\&                const char *mountable,
\&                const char *mountpoint);
.Ve
.PP
Монтує диск гостьової системи до вказаного місця у файловій системі. Назви
блокових пристроїв визначаються за схемою \fI/dev/sda\fR, \fI/dev/sdb\fR тощо за
порядком, у якому їх було додано до гостьової системи. Якщо на цих блокових
пристроях містяться розділи, вони матимуть звичні назви (наприклад
\&\fI/dev/sda1\fR). Крім того, можна використовувати назви у стилі \s-1LVM\s0
\&\fI/dev/VG/LV\fR або рядки «mountable», які повертають команди
\&\f(CW\*(C`guestfs_list_filesystems\*(C'\fR та \f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR.
.PP
Правила є тими самими, що і для \fBmount\fR\|(2): файлову систему має бути
спочатку змонтовано до \fI/\fR, а вже потім мають монтуватися інші файлові
системи. Інші файлові системи може бути змонтовано лише до каталогів, які
вже створено у системі.
.PP
Змонтована файлова система є придатною до запису, якщо є достатні права
доступу до підлеглого пристрою.
.PP
До версії libguestfs 1.13.16 цей виклик неявним чином додавав параметри
монтування \f(CW\*(C`sync\*(C'\fR та \f(CW\*(C`noatime\*(C'\fR. Використання параметра \f(CW\*(C`sync\*(C'\fR значно
уповільнювало запис і спричиняло значні проблеми для користувачів. Якщо ваша
програма має працювати із застарілими версіями libguestfs, краще
скористайтеся \f(CW\*(C`guestfs_mount_options\*(C'\fR (використовуючи порожній рядок як
перший параметр, якщо ви не хочете визначати ніяких нетипових параметрів
монтування).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_mount_9p"
.IX Subsection "guestfs_mount_9p"
.Vb 5
\& int
\& guestfs_mount_9p (guestfs_h *g,
\&                   const char *mounttag,
\&                   const char *mountpoint,
\&                   ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_MOUNT_9P_OPTIONS, const char *options,
.Ve
.PP
Монтує файлову систему virtio\-9p із міткою \f(CW\*(C`мітка_монтування\*(C'\fR до каталогу
\&\f(CW\*(C`точка_монтування\*(C'\fR.
.PP
Якщо потрібно, до параметрів буде автоматично додано \f(CW\*(C`trans=virtio\*(C'\fR. Усі
інші потрібні параметри можна передати за допомогою необов'язкового
параметра \f(CW\*(C`options\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.12)
.SS "guestfs_mount_9p_va"
.IX Subsection "guestfs_mount_9p_va"
.Vb 5
\& int
\& guestfs_mount_9p_va (guestfs_h *g,
\&                      const char *mounttag,
\&                      const char *mountpoint,
\&                      va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mount_9p\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mount_9p_argv"
.IX Subsection "guestfs_mount_9p_argv"
.Vb 5
\& int
\& guestfs_mount_9p_argv (guestfs_h *g,
\&                        const char *mounttag,
\&                        const char *mountpoint,
\&                        const struct guestfs_mount_9p_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mount_9p\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mount_local"
.IX Subsection "guestfs_mount_local"
.Vb 4
\& int
\& guestfs_mount_local (guestfs_h *g,
\&                      const char *localmountpoint,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 4
\& GUESTFS_MOUNT_LOCAL_READONLY, int readonly,
\& GUESTFS_MOUNT_LOCAL_OPTIONS, const char *options,
\& GUESTFS_MOUNT_LOCAL_CACHETIMEOUT, int cachetimeout,
\& GUESTFS_MOUNT_LOCAL_DEBUGCALLS, int debugcalls,
.Ve
.PP
Цей виклик експортує доступну для libguestfs файлову систему до локальної
точки монтування (каталогу) із назвою \f(CW\*(C`локальна_точка_монтування\*(C'\fR. Звичайні
запити щодо читання і запису до файлів і каталогів у каталозі
\&\f(CW\*(C`локальна_точка_монтування\*(C'\fR переспрямовуватимуться через libguestfs.
.PP
Якщо для необов'язкового прапорця \f(CW\*(C`readonly\*(C'\fR встановлено значення true,
спроби запису до файлової системи призводитимуть до помилки \f(CW\*(C`EROFS\*(C'\fR.
.PP
Аргументом \f(CW\*(C`options\*(C'\fR має бути список параметрів монтування, відокремлених
комами. Корисну інформацію щодо параметрів можна знайти на сторінці
підручника щодо \fBguestmount\fR\|(1).
.PP
\&\f(CW\*(C`cachetimeout\*(C'\fR встановлює час очікування у секундах на отримання записів
каталогу кешування. Типовим значенням є 60 секунд. Див. \fBguestmount\fR\|(1),
щоб дізнатися більше.
.PP
Якщо для параметра \f(CW\*(C`debugcalls\*(C'\fR встановлено значення true, для кожного
виклику \s-1FUSE\s0 створюються додаткові діагностичні дані.
.PP
Коли \f(CW\*(C`guestfs_mount_local\*(C'\fR повертає керування, файлова система готова, але
не обробляє запити (доступ до неї блокуватиметься). Вам слід викликати
\&\f(CW\*(C`guestfs_mount_local_run\*(C'\fR, щоб запустити основний цикл обробки.
.PP
Із повною документацією можна ознайомитися у розділі \*(L"ЛОКАЛЬНЕ
МОНТУВАННЯ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.17.22)
.SS "guestfs_mount_local_va"
.IX Subsection "guestfs_mount_local_va"
.Vb 4
\& int
\& guestfs_mount_local_va (guestfs_h *g,
\&                         const char *localmountpoint,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_mount_local\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mount_local_argv"
.IX Subsection "guestfs_mount_local_argv"
.Vb 4
\& int
\& guestfs_mount_local_argv (guestfs_h *g,
\&                           const char *localmountpoint,
\&                           const struct guestfs_mount_local_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_mount_local\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_mount_local_run"
.IX Subsection "guestfs_mount_local_run"
.Vb 2
\& int
\& guestfs_mount_local_run (guestfs_h *g);
.Ve
.PP
Виконує основний цикл обробки, який перетворює виклики ядра на виклики
libguestfs.
.PP
Цю команду слід викликати, лише якщо успішно виконано
\&\f(CW\*(C`guestfs_mount_local\*(C'\fR. Виклик команди не поверне керування, доки файлову
систему не буде змонтовано.
.PP
\&\fBЗауваження\fR: \fIне\fR виконуйте конкурентні виклики libguestfs щодо одного
дескриптора з різних потоків обробки.
.PP
Ви можете викликати цю команду із іншого потоку обробки ніж той, з якого
викликано \*(L"guestfs_mount_local\*(R", виконуючи звичні правила щодо роботи з
декількома потоками обробки і libguestfs (див. \*(L"ОБРОБКА У
ДЕКІЛЬКА ДЕСКРПИТОРІВ І ПОТОКІВ\*(R").
.PP
Із повною документацією можна ознайомитися у розділі \*(L"ЛОКАЛЬНЕ
МОНТУВАННЯ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.17.22)
.SS "guestfs_mount_loop"
.IX Subsection "guestfs_mount_loop"
.Vb 4
\& int
\& guestfs_mount_loop (guestfs_h *g,
\&                     const char *file,
\&                     const char *mountpoint);
.Ve
.PP
За допомогою цієї команди ви можете змонтувати \fIфайл\fR (образ файлової
системи у файлі) до точки монтування. Це точний еквівалент команди \f(CW\*(C`mount
\&\-o loop файл точка_монтування\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.54)
.SS "guestfs_mount_options"
.IX Subsection "guestfs_mount_options"
.Vb 5
\& int
\& guestfs_mount_options (guestfs_h *g,
\&                        const char *options,
\&                        const char *mountable,
\&                        const char *mountpoint);
.Ve
.PP
Те саме, що і команда \f(CW\*(C`guestfs_mount\*(C'\fR, але надає вам змогу встановити
параметри монтування, подібно до параметра команди \fBmount\fR\|(8) \fI\-o\fR.
.PP
Якщо значенням параметра \f(CW\*(C`параметри\*(C'\fR є порожній рядок, параметри не
передаватимуться (буде використано типовий набір параметрів для файлової
системи).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.10)
.SS "guestfs_mount_ro"
.IX Subsection "guestfs_mount_ro"
.Vb 4
\& int
\& guestfs_mount_ro (guestfs_h *g,
\&                   const char *mountable,
\&                   const char *mountpoint);
.Ve
.PP
Те саме, що і команда \f(CW\*(C`guestfs_mount\*(C'\fR, але монтує файлову систему у режимі
лише читання (використовує параметр \fI\-o ro\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.10)
.SS "guestfs_mount_vfs"
.IX Subsection "guestfs_mount_vfs"
.Vb 6
\& int
\& guestfs_mount_vfs (guestfs_h *g,
\&                    const char *options,
\&                    const char *vfstype,
\&                    const char *mountable,
\&                    const char *mountpoint);
.Ve
.PP
Те саме, що і команда \f(CW\*(C`guestfs_mount\*(C'\fR, але надає вам змогу встановити
параметри монтування і тип файлової системи, подібно до параметрів команди
\&\fBmount\fR\|(8) \fI\-o\fR і \fI\-t\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.10)
.SS "guestfs_mountable_device"
.IX Subsection "guestfs_mountable_device"
.Vb 3
\& char *
\& guestfs_mountable_device (guestfs_h *g,
\&                           const char *mountable);
.Ve
.PP
Повертає назву пристрою для монтування. У переважній кількості випадків
значенням параметра «монтування» є назва пристрою.
.PP
Втім, це не стосується підтомів btrfs, де значенням параметра «монтування» є
поєднання назви пристрою та шляху до підтому (див. також
\&\f(CW\*(C`guestfs_mountable_subvolume\*(C'\fR, щоб дізнатися про те, як визначити шлях до
підтому для монтування, якщо такий передбачено).
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.33.15)
.SS "guestfs_mountable_subvolume"
.IX Subsection "guestfs_mountable_subvolume"
.Vb 3
\& char *
\& guestfs_mountable_subvolume (guestfs_h *g,
\&                              const char *mountable);
.Ve
.PP
Повертає шлях до підтому для монтування. Монтування підтомів btrfs є
поєднаннями назви пристрою і шляху до підтому (див. також
\&\f(CW\*(C`guestfs_mountable_device\*(C'\fR, щоб дізнатися про те, як визначити назву
пристрою для монтування).
.PP
Якщо монтування є не підтомом btrfs, ця функція завершує роботу із помилкою
і встановлює для \f(CW\*(C`errno\*(C'\fR значення \f(CW\*(C`EINVAL\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.33.15)
.SS "guestfs_mountpoints"
.IX Subsection "guestfs_mountpoints"
.Vb 2
\& char **
\& guestfs_mountpoints (guestfs_h *g);
.Ve
.PP
Цей виклик подібний до \f(CW\*(C`guestfs_mounts\*(C'\fR. Виклик повертає список
пристроїв. Запис списку є таблицею хешів (картою) з назви пристрою і
каталогу, до якого змонтовано пристрій.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.62)
.SS "guestfs_mounts"
.IX Subsection "guestfs_mounts"
.Vb 2
\& char **
\& guestfs_mounts (guestfs_h *g);
.Ve
.PP
Повертає список поточних змонтованих файлових систем. Результатом виконання
є список пристроїв (наприклад, \fI/dev/sda1\fR, \fI/dev/VG/LV\fR).
.PP
Деякі внутрішні монтування не буде включено до списку.
.PP
Див. також \f(CW\*(C`guestfs_mountpoints\*(C'\fR
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.8)
.SS "guestfs_mv"
.IX Subsection "guestfs_mv"
.Vb 4
\& int
\& guestfs_mv (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
Пересуває файл з адреси \f(CW\*(C`джерело\*(C'\fR до адреси \f(CW\*(C`призначення\*(C'\fR, де значенням
\&\f(CW\*(C`призначення\*(C'\fR є або назва файла призначення, або назва каталогу
призначення.
.PP
Див. також \f(CW\*(C`guestfs_rename\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.18)
.SS "guestfs_nr_devices"
.IX Subsection "guestfs_nr_devices"
.Vb 2
\& int
\& guestfs_nr_devices (guestfs_h *g);
.Ve
.PP
Повертає кількість усіх доданих блокових пристроїв. Це та сама кількість
пристроїв, яку було б повернуто, якби ви викликали \f(CW\*(C`guestfs_list_devices\*(C'\fR.
.PP
Щоб визначити максимальну кількість пристроїв, які може бути додано,
викличте \f(CW\*(C`guestfs_max_disks\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.19.15)
.SS "guestfs_ntfs_3g_probe"
.IX Subsection "guestfs_ntfs_3g_probe"
.Vb 4
\& int
\& guestfs_ntfs_3g_probe (guestfs_h *g,
\&                        int rw,
\&                        const char *device);
.Ve
.PP
Ця команда запускає програму \fBntfs\-3g.probe\fR\|(8), яка зондує пристрій \s-1NTFS\s0
\&\f(CW\*(C`пристрій\*(C'\fR на можливість монтування. (Не усі томи \s-1NTFS\s0 може бути змонтовано
для читання і запису, а деякі не може бути змонтовано взагалі).
.PP
\&\f(CW\*(C`rw\*(C'\fR є булевим прапорцем. Встановіть значення true, якщо ви хочете
перевірити, чи можна змонтувати том у режимі читання\-запису. Встановіть
значення false, якщо ви хочете перевірити, чи може бути змонтовано тому у
режимі лише читання.
.PP
Повертає ціле значення рівне \f(CW0\fR, якщо дію з монтування може бути виконано
успішно, або рівне якомусь іншому значенню, документацію щодо якого можна
знайти на сторінці підручника щодо \fBntfs\-3g.probe\fR\|(8).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ntfs3g\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.43)
.SS "guestfs_ntfscat_i"
.IX Subsection "guestfs_ntfscat_i"
.Vb 5
\& int
\& guestfs_ntfscat_i (guestfs_h *g,
\&                    const char *device,
\&                    int64_t inode,
\&                    const char *filename);
.Ve
.PP
Отримати файл, заданий за допомогою inode, з файлової системи \s-1NTFS\s0 і
зберегти його з назвою \fIназва файла\fR на локальній машині.
.PP
Надає змогу отримувати недоступні у інший спосіб файли, зокрема файли з теки
\&\f(CW$Extend\fR.
.PP
Файлову систему, звідки слід видобути файл, має бути демонтовано. Якщо цього
не буде зроблено, виклик завершиться повідомленням про помилку.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.33.14)
.SS "guestfs_ntfsclone_in"
.IX Subsection "guestfs_ntfsclone_in"
.Vb 4
\& int
\& guestfs_ntfsclone_in (guestfs_h *g,
\&                       const char *backupfile,
\&                       const char *device);
.Ve
.PP
Відновити \f(CW\*(C`backupfile\*(C'\fR (створений попереднім викликом
\&\f(CW\*(C`guestfs_ntfsclone_out\*(C'\fR) на пристрої \f(CW\*(C`device\*(C'\fR із перезаписом усього
наявного вмісту пристрою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ntfs3g\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.9)
.SS "guestfs_ntfsclone_out"
.IX Subsection "guestfs_ntfsclone_out"
.Vb 5
\& int
\& guestfs_ntfsclone_out (guestfs_h *g,
\&                        const char *device,
\&                        const char *backupfile,
\&                        ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 5
\& GUESTFS_NTFSCLONE_OUT_METADATAONLY, int metadataonly,
\& GUESTFS_NTFSCLONE_OUT_RESCUE, int rescue,
\& GUESTFS_NTFSCLONE_OUT_IGNOREFSCHECK, int ignorefscheck,
\& GUESTFS_NTFSCLONE_OUT_PRESERVETIMESTAMPS, int preservetimestamps,
\& GUESTFS_NTFSCLONE_OUT_FORCE, int force,
.Ve
.PP
Записати дані файлової системи \s-1NTFS\s0 з пристрою \f(CW\*(C`пристрій\*(C'\fR до локального
файла \f(CW\*(C`файл_резервної_копії\*(C'\fR. Для файла резервної копії буде використано
спеціальний формат, який використовується програмою \fBntfsclone\fR\|(8).
.PP
Якщо для необов'язкового прапорця \f(CW\*(C`metadataonly\*(C'\fR встановлено значення true,
збережено буде \fIлише\fR метадані. Усі дані користувача буде втрачено (такий
режим є корисним для діагностування проблем файлової системи).
.PP
Опис необов'язкових прапорців \f(CW\*(C`rescue\*(C'\fR, \f(CW\*(C`ignorefscheck\*(C'\fR,
\&\f(CW\*(C`preservetimestamps\*(C'\fR та \f(CW\*(C`force\*(C'\fR можна знайти на сторінці підручника
\&\fBntfsclone\fR\|(8).
.PP
Використовує \f(CW\*(C`guestfs_ntfsclone_in\*(C'\fR для відновлення резервної копії у файлі
на пристрої libguestfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ntfs3g\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.9)
.SS "guestfs_ntfsclone_out_va"
.IX Subsection "guestfs_ntfsclone_out_va"
.Vb 5
\& int
\& guestfs_ntfsclone_out_va (guestfs_h *g,
\&                           const char *device,
\&                           const char *backupfile,
\&                           va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_ntfsclone_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_ntfsclone_out_argv"
.IX Subsection "guestfs_ntfsclone_out_argv"
.Vb 5
\& int
\& guestfs_ntfsclone_out_argv (guestfs_h *g,
\&                             const char *device,
\&                             const char *backupfile,
\&                             const struct guestfs_ntfsclone_out_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_ntfsclone_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_ntfsfix"
.IX Subsection "guestfs_ntfsfix"
.Vb 4
\& int
\& guestfs_ntfsfix (guestfs_h *g,
\&                  const char *device,
\&                  ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_NTFSFIX_CLEARBADSECTORS, int clearbadsectors,
.Ve
.PP
Ця команда виправляє деякі фундаментальні проблеми \s-1NTFS,\s0 відновлює
початковий стан журналу \s-1NTFS\s0 і додає заплановану перевірку коректності \s-1NTFS\s0
під час першого ж завантаження до Windows.
.PP
Ця команда \fIне\fR є еквівалентом \f(CW\*(C`chkdsk\*(C'\fR Windows. Вона \fIне\fR виконує
перевірки коректності файлової системи.
.PP
За допомогою необов'язкового прапорця \f(CW\*(C`clearbadsectors\*(C'\fR можна спорожнити
список помилкових секторів. Це корисно при клонуванні диска із помилковими
секторами на новий диск.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ntfs3g\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.9)
.SS "guestfs_ntfsfix_va"
.IX Subsection "guestfs_ntfsfix_va"
.Vb 4
\& int
\& guestfs_ntfsfix_va (guestfs_h *g,
\&                     const char *device,
\&                     va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_ntfsfix\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_ntfsfix_argv"
.IX Subsection "guestfs_ntfsfix_argv"
.Vb 4
\& int
\& guestfs_ntfsfix_argv (guestfs_h *g,
\&                       const char *device,
\&                       const struct guestfs_ntfsfix_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_ntfsfix\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_ntfsresize"
.IX Subsection "guestfs_ntfsresize"
.Vb 3
\& int
\& guestfs_ntfsresize (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_ntfsresize_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.3.2)
.SS "guestfs_ntfsresize_opts"
.IX Subsection "guestfs_ntfsresize_opts"
.Vb 4
\& int
\& guestfs_ntfsresize_opts (guestfs_h *g,
\&                          const char *device,
\&                          ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_NTFSRESIZE_OPTS_SIZE, int64_t size,
\& GUESTFS_NTFSRESIZE_OPTS_FORCE, int force,
.Ve
.PP
Ця команда змінює розмір файлової системи \s-1NTFS,\s0 розширюючи або стискаючи її
до розміру підлеглого пристрою.
.PP
Додатковими параметрами є:
.ie n .IP """розмір""" 4
.el .IP "\f(CWрозмір\fR" 4
.IX Item "розмір"
Новий розмір (у байтах) файлової системи. Якщо не вказано, розмір файлової
системи буде змінено до розмірів контейнера (наприклад розділу).
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
Якщо цей параметр має значення true, буде виконано примусову зміну розміру
файлової системи, навіть якщо файлову систему позначено як таку, яка
потребує перевірки на коректність.
.Sp
Після виконання дії зі зміни розміру файлову систему завжди буде позначено
як таку, яка потребує перевірки на коректність (з міркувань безпеки). Вам
слід завантажити Windows, щоб виконати перевірку і зняти позначення. Якщо ви
\&\fIне\fR встановлювали параметр \f(CW\*(C`force\*(C'\fR, \f(CW\*(C`guestfs_ntfsresize\*(C'\fR не можна буде
викликати декілька разів поспіль для однієї файлової системи без
завантаження Windows між діями зі зміни розміру.
.PP
Див. також \fBntfsresize\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ntfsprogs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.3.2)
.SS "guestfs_ntfsresize_opts_va"
.IX Subsection "guestfs_ntfsresize_opts_va"
.Vb 4
\& int
\& guestfs_ntfsresize_opts_va (guestfs_h *g,
\&                             const char *device,
\&                             va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_ntfsresize_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_ntfsresize_opts_argv"
.IX Subsection "guestfs_ntfsresize_opts_argv"
.Vb 4
\& int
\& guestfs_ntfsresize_opts_argv (guestfs_h *g,
\&                               const char *device,
\&                               const struct guestfs_ntfsresize_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_ntfsresize_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_ntfsresize_size"
.IX Subsection "guestfs_ntfsresize_size"
.Vb 4
\& int
\& guestfs_ntfsresize_size (guestfs_h *g,
\&                          const char *device,
\&                          int64_t size);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_ntfsresize\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда виконує ті самі дії, що і \f(CW\*(C`guestfs_ntfsresize\*(C'\fR, але вона надає
вам змогу вказати новий розмір (у байтах) явним чином.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`ntfsprogs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.3.14)
.SS "guestfs_parse_environment"
.IX Subsection "guestfs_parse_environment"
.Vb 2
\& int
\& guestfs_parse_environment (guestfs_h *g);
.Ve
.PP
Виконує обробку середовища програми і встановлює прапорців у дескрипторі
відповідним чином. Наприклад, якщо \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR, у дескрипторі буде
встановлено прапорець «verbose».
.PP
\&\fIУ більшості програм потреби у виконанні цієї дії немає\fR Дія неявним чином
виконується під час виклику \f(CW\*(C`guestfs_create\*(C'\fR.
.PP
Див \*(L"ЗМІННІ СЕРЕДОВИЩА\*(R", де наведено список змінних середовища,
які впливають на засоби обробки libguestfs. Див. також
\&\*(L"guestfs_create_flags\*(R" та guestfs_parse_environment_list.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.53)
.SS "guestfs_parse_environment_list"
.IX Subsection "guestfs_parse_environment_list"
.Vb 3
\& int
\& guestfs_parse_environment_list (guestfs_h *g,
\&                                 char *const *environment);
.Ve
.PP
Обробляє список рядків у аргументі \f(CW\*(C`середовище\*(C'\fR і встановлює відповідним
чином прапорці у дескрипторі. Наприклад, якщо у списку є рядок
\&\f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR, у дескрипторі буде встановлено прапорець «verbose».
.PP
Те саме, що і \f(CW\*(C`guestfs_parse_environment\*(C'\fR, але обробляє явним список
рядків, замість середовища програми.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.53)
.SS "guestfs_part_add"
.IX Subsection "guestfs_part_add"
.Vb 6
\& int
\& guestfs_part_add (guestfs_h *g,
\&                   const char *device,
\&                   const char *prlogex,
\&                   int64_t startsect,
\&                   int64_t endsect);
.Ve
.PP
Ця команда додає розділ на пристрої \f(CW\*(C`device\*(C'\fR. Якщо на пристрої немає
таблиці розділів, спочатку слід викликати \f(CW\*(C`guestfs_part_init\*(C'\fR.
.PP
Значенням параметра \f(CW\*(C`prlogex\*(C'\fR є тип розділу. Зазвичай, вам слід передати
тип \f(CW\*(C`p\*(C'\fR або \f(CW\*(C`primary\*(C'\fR, але у таблицях розділів \s-1MBR\s0 також передбачено
підтримку типів розділів \f(CW\*(C`l\*(C'\fR (або \f(CW\*(C`logical\*(C'\fR) і \f(CW\*(C`e\*(C'\fR (або \f(CW\*(C`extended\*(C'\fR).
.PP
Значеннями параметрів \f(CW\*(C`початковий_сектор\*(C'\fR і \f(CW\*(C`кінцевий_сектор\*(C'\fR є початок і
кінець розділу, вказані за номерами \fIсекторів\fR. Значенням параметра
\&\f(CW\*(C`кінцевий_сектор\*(C'\fR може бути від'ємне значення, що означає, що сектори слід
лічити з кінця диска (\f(CW\*(C`\-1\*(C'\fR означає «останній сектор»).
.PP
Створення розділу, який займатиме увесь диск є непростою справою. Для
виконання цього завдання скористайтеся \f(CW\*(C`guestfs_part_disk\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_del"
.IX Subsection "guestfs_part_del"
.Vb 4
\& int
\& guestfs_part_del (guestfs_h *g,
\&                   const char *device,
\&                   int partnum);
.Ve
.PP
Ця команда вилучає розділ із номером \f(CW\*(C`номер_розділу\*(C'\fR на пристрої
\&\f(CW\*(C`пристрій\*(C'\fR.
.PP
Зауважте, що у випадку розділів у \s-1MBR\s0 вилучення розширеного розділу
призводить до вилучення усіх логічних розділів, які на ньому містяться.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.2)
.SS "guestfs_part_disk"
.IX Subsection "guestfs_part_disk"
.Vb 4
\& int
\& guestfs_part_disk (guestfs_h *g,
\&                    const char *device,
\&                    const char *parttype);
.Ve
.PP
Ця команда є простою комбінацією \f(CW\*(C`guestfs_part_init\*(C'\fR з наступною
\&\f(CW\*(C`guestfs_part_add\*(C'\fR для створення єдиного основного розділу, який займатиме
увесь диск.
.PP
Значенням параметра \f(CW\*(C`parttype\*(C'\fR є тип таблиці розділів, зазвичай, \f(CW\*(C`mbr\*(C'\fR або
\&\f(CW\*(C`gpt\*(C'\fR, але можливі і інші значення, описані у довідці з
\&\f(CW\*(C`guestfs_part_init\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_expand_gpt"
.IX Subsection "guestfs_part_expand_gpt"
.Vb 3
\& int
\& guestfs_part_expand_gpt (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Пересуває резервні копії структур даних \s-1GPT\s0 у кінець диска. Корисно у
випадку розширення образу на місці, оскільки простір на диску після
резервної копії заголовка \s-1GPT\s0 не можна використовувати. Еквівалент \f(CW\*(C`sgdisk
\&\-e\*(C'\fR.
.PP
Див. також \fBsgdisk\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.2)
.SS "guestfs_part_get_bootable"
.IX Subsection "guestfs_part_get_bootable"
.Vb 4
\& int
\& guestfs_part_get_bootable (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
Ця команда повертає true, якщо для розділу \f(CW\*(C`номер_розділу\*(C'\fR на пристрої
\&\f(CW\*(C`пристрій\*(C'\fR встановлено прапорець можливості завантаження.
.PP
Див. також \f(CW\*(C`guestfs_part_set_bootable\*(C'\fR.
.PP
Ця функція повертає значення true з C у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.2)
.SS "guestfs_part_get_disk_guid"
.IX Subsection "guestfs_part_get_disk_guid"
.Vb 3
\& char *
\& guestfs_part_get_disk_guid (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
Повертає ідентифікатор диска (\s-1GUID\s0) пристрою \f(CW\*(C`пристрій\*(C'\fR із таблицею
розділів \s-1GPT.\s0 Для інших типів таблиць розділів поведінку команди не
визначено.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.2)
.SS "guestfs_part_get_gpt_attributes"
.IX Subsection "guestfs_part_get_gpt_attributes"
.Vb 4
\& int64_t
\& guestfs_part_get_gpt_attributes (guestfs_h *g,
\&                                  const char *device,
\&                                  int partnum);
.Ve
.PP
Повертає прапорці атрибутів вказаного за номером розділу \s-1GPT\s0
\&\f(CW\*(C`номер_розділу\*(C'\fR. Повертає помилку для розділів \s-1MBR.\s0
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.21.1)
.SS "guestfs_part_get_gpt_guid"
.IX Subsection "guestfs_part_get_gpt_guid"
.Vb 4
\& char *
\& guestfs_part_get_gpt_guid (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
Повертає \s-1GUID\s0 вказаного за номером розділу \s-1GPT\s0 \f(CW\*(C`номер_розділу\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.25)
.SS "guestfs_part_get_gpt_type"
.IX Subsection "guestfs_part_get_gpt_type"
.Vb 4
\& char *
\& guestfs_part_get_gpt_type (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
Повертає \s-1GUID\s0 типу вказаного за номером розділу \s-1GPT\s0 \f(CW\*(C`номер_розділу\*(C'\fR. Для
розділів \s-1MBR\s0 повертає відповідний \s-1GUID\s0 для типу \s-1MBR.\s0 Для інших типів
розділів поведінку не визначено.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.21.1)
.SS "guestfs_part_get_mbr_id"
.IX Subsection "guestfs_part_get_mbr_id"
.Vb 4
\& int
\& guestfs_part_get_mbr_id (guestfs_h *g,
\&                          const char *device,
\&                          int partnum);
.Ve
.PP
Повертає байт типу \s-1MBR\s0 (також відомий як байт \s-1ID\s0) для вказаного за номером
розділу \f(CW\*(C`номер_розділу\*(C'\fR.
.PP
Зауважте, що байти типу мають лише розділи \s-1MBR\s0 (застарілі розділи у стилі
\&\s-1DOS\s0). Ви отримаєте невизначені результати для інших типів таблиць розділів
(див. \f(CW\*(C`guestfs_part_get_parttype\*(C'\fR).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.3.2)
.SS "guestfs_part_get_mbr_part_type"
.IX Subsection "guestfs_part_get_mbr_part_type"
.Vb 4
\& char *
\& guestfs_part_get_mbr_part_type (guestfs_h *g,
\&                                 const char *device,
\&                                 int partnum);
.Ve
.PP
Повертає тип розділу \s-1MBR,\s0 вказаного за номером \f(CW\*(C`номер_розділу\*(C'\fR, на пристрої
\&\f(CW\*(C`пристрій\*(C'\fR.
.PP
Повертає \f(CW\*(C`primary\*(C'\fR, \f(CW\*(C`logical\*(C'\fR або \f(CW\*(C`extended\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.29.32)
.SS "guestfs_part_get_name"
.IX Subsection "guestfs_part_get_name"
.Vb 4
\& char *
\& guestfs_part_get_name (guestfs_h *g,
\&                        const char *device,
\&                        int partnum);
.Ve
.PP
Ця команда отримує назву розділу на вказаному за номером розділі \f(CW\*(C`номер
розділу\*(C'\fR на пристрої \f(CW\*(C`пристрій\*(C'\fR. Зауважте, що нумерація розділів
розпочинається з 1.
.PP
Назву розділу можна прочитати лише для певних типів таблиць розділів. Це
працює для таблиць \f(CW\*(C`gpt\*(C'\fR, але не для таблиць \f(CW\*(C`mbr\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.25.33)
.SS "guestfs_part_get_parttype"
.IX Subsection "guestfs_part_get_parttype"
.Vb 3
\& char *
\& guestfs_part_get_parttype (guestfs_h *g,
\&                            const char *device);
.Ve
.PP
Ця команда виконує вивчення таблиці розділів на пристрої \f(CW\*(C`пристрій\*(C'\fR і
повертає тип таблиці розділів (формат), який на ньому використано.
.PP
Серед типових повернутих значень: \f(CW\*(C`msdos\*(C'\fR (таблиця розділів \s-1MBR\s0 у стилі
DOS/Windows), \f(CW\*(C`gpt\*(C'\fR (таблиця розділів у стилі \s-1GPT/EFI\s0). Можливі також інші
значення, але вони є рідкісними. Повний список можна знайти у розділі щодо
\&\f(CW\*(C`guestfs_part_init\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_init"
.IX Subsection "guestfs_part_init"
.Vb 4
\& int
\& guestfs_part_init (guestfs_h *g,
\&                    const char *device,
\&                    const char *parttype);
.Ve
.PP
Ця команда створює порожню таблицю розділів на пристрої \f(CW\*(C`пристрій\*(C'\fR,
використовуючи тип розділів із наведеного нижче списку. Зазвичай, значенням
параметра \f(CW\*(C`тип_розділу\*(C'\fR має бути \f(CW\*(C`msdos\*(C'\fR або \f(CW\*(C`gpt\*(C'\fR (для великих дисків).
.PP
Спочатку на пристрої немає розділів. Після цієї команди вам слід викликати
\&\f(CW\*(C`guestfs_part_add\*(C'\fR для кожного потрібного вам розділу.
.PP
Можливі значення для параметра \f(CW\*(C`тип_розділу\*(C'\fR:
.IP "\fBefi\fR" 4
.IX Item "efi"
.PD 0
.IP "\fBgpt\fR" 4
.IX Item "gpt"
.PD
Таблиця розділів \s-1EFI / GPT\s0 Intel.
.Sp
Цей варіант є рекомендованим для розділів із розміром >= 2 ТБ, доступ до
яких здійснюватиметься з Linux та заснованої на архітектурі Intel Mac \s-1OS
X.\s0 Крім того, цей варіант має обмежену зворотну сумісність із форматом
\&\f(CW\*(C`mbr\*(C'\fR.
.IP "\fBmbr\fR" 4
.IX Item "mbr"
.PD 0
.IP "\fBmsdos\fR" 4
.IX Item "msdos"
.PD
Стандартний для ПК формат «Master Boot Record» (\s-1MBR\s0), який використовувався
MS-DOS і Windows. Цей тип розділу працюватиме \fBлише\fR для пристроїв, розмір
яких не перевищує 2 ТБ. Для дисків більшого розміру ми рекомендуємо
скористатися \f(CW\*(C`gpt\*(C'\fR.
.PP
Для інших типів таблиць розділів це теж може працювати, але їхньої підтримки
не передбачено. Це зокрема:
.IP "\fBaix\fR" 4
.IX Item "aix"
Мітки дисків \s-1AIX.\s0
.IP "\fBamiga\fR" 4
.IX Item "amiga"
.PD 0
.IP "\fBrdb\fR" 4
.IX Item "rdb"
.PD
Формат \*(L"Rigid Disk Block\*(R" Amiga.
.IP "\fBbsd\fR" 4
.IX Item "bsd"
Мітки дисків \s-1BSD.\s0
.IP "\fBdasd\fR" 4
.IX Item "dasd"
\&\s-1DASD,\s0 використовувалися у мейнфреймах \s-1IBM.\s0
.IP "\fBdvh\fR" 4
.IX Item "dvh"
Томи \s-1MIPS/SGI.\s0
.IP "\fBmac\fR" 4
.IX Item "mac"
Старий формат розділів Mac. Сучасні системи Mac використовують \f(CW\*(C`gpt\*(C'\fR.
.IP "\fBpc98\fR" 4
.IX Item "pc98"
Формат \s-1NEC PC\-98,\s0 поширений у Японії.
.IP "\fBsun\fR" 4
.IX Item "sun"
Мітки дисків Sun.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_list"
.IX Subsection "guestfs_part_list"
.Vb 3
\& struct guestfs_partition_list *
\& guestfs_part_list (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
Ця команда обробляє таблицю розділів пристрою \f(CW\*(C`пристрій\*(C'\fR і повертає список
знайдених розділів.
.PP
Поля повернутої структури:
.IP "\fBpart_num\fR" 4
.IX Item "part_num"
Номер розділу, відлік від 1.
.IP "\fBpart_start\fR" 4
.IX Item "part_start"
Позиція початку розділу \fIу байтах\fR. Для отримання позиції у секторах вам
слід поділити це значення на розмір сектора, див. \f(CW\*(C`guestfs_blockdev_getss\*(C'\fR.
.IP "\fBpart_end\fR" 4
.IX Item "part_end"
Позиція завершення розділу у байтах.
.IP "\fBpart_size\fR" 4
.IX Item "part_size"
Розмір розділу у байтах.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_partition_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_partition_list\*(C'\fI\fR.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_resize"
.IX Subsection "guestfs_part_resize"
.Vb 5
\& int
\& guestfs_part_resize (guestfs_h *g,
\&                      const char *device,
\&                      int partnum,
\&                      int64_t endsect);
.Ve
.PP
Ця команда змінює розмір розділу із номером \f(CW\*(C`номер_розділу\*(C'\fR на пристрої
\&\f(CW\*(C`пристрій\*(C'\fR, посуваючи позицію кінця розділу.
.PP
Зауважте, що ця команда не вносить змін до файлових систем на розділі. Якщо
вам потрібно змінити розмір файлової системи, вам слід скористатися
командами зміни розмірів файлових систем, наприклад \f(CW\*(C`guestfs_resize2fs\*(C'\fR.
.PP
Якщо ви збільшуєте розміри розділу, далі вам слід збільшити розміри файлової
системи. Якщо ж ви зменшуєте розміри розділу, спочатку вам слід зменшити
розміри файлової системи на ньому.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.37.20)
.SS "guestfs_part_set_bootable"
.IX Subsection "guestfs_part_set_bootable"
.Vb 5
\& int
\& guestfs_part_set_bootable (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            int bootable);
.Ve
.PP
Ця команда встановлює прапорець можливості завантаження на вказаному за
номером розділі \f(CW\*(C`номер розділу\*(C'\fR на пристрої \f(CW\*(C`пристрій\*(C'\fR. Зауважте, що
нумерація розділів розпочинається з 1.
.PP
Прапорець можливості завантаження використовується певними операційними
системами (найпоширенішою з яких є Windows) для визначення розділу, з якого
слід виконувати завантаження. Він ніяким чином не є універсальним.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_set_disk_guid"
.IX Subsection "guestfs_part_set_disk_guid"
.Vb 4
\& int
\& guestfs_part_set_disk_guid (guestfs_h *g,
\&                             const char *device,
\&                             const char *guid);
.Ve
.PP
Встановлює ідентифікатор диска (\s-1GUID\s0) пристрою із таблицею розділів \s-1GPT\s0
\&\f(CW\*(C`пристрій\*(C'\fR у значення \f(CW\*(C`guid\*(C'\fR. Повертає помилку, якщо таблицею розділів
пристрою \f(CW\*(C`пристрій\*(C'\fR не є \s-1GPT\s0 або якщо \f(CW\*(C`guid\*(C'\fR не є коректним \s-1GUID.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.2)
.SS "guestfs_part_set_disk_guid_random"
.IX Subsection "guestfs_part_set_disk_guid_random"
.Vb 3
\& int
\& guestfs_part_set_disk_guid_random (guestfs_h *g,
\&                                    const char *device);
.Ve
.PP
Встановлює ідентифікатор диска (\s-1GUID\s0) пристрою із таблицею розділів \s-1GPT\s0
\&\f(CW\*(C`пристрій\*(C'\fR у створене випадковим чином значення. Повертає помилку, якщо
таблицею розділів пристрою \f(CW\*(C`пристрій\*(C'\fR не є \s-1GPT.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.2)
.SS "guestfs_part_set_gpt_attributes"
.IX Subsection "guestfs_part_set_gpt_attributes"
.Vb 5
\& int
\& guestfs_part_set_gpt_attributes (guestfs_h *g,
\&                                  const char *device,
\&                                  int partnum,
\&                                  int64_t attributes);
.Ve
.PP
Встановлює прапорці атрибутів вказаного за номером розділу \s-1GPT\s0
\&\f(CW\*(C`номер_розділу\*(C'\fR у значення \f(CW\*(C`атрибути\*(C'\fR. Повертає помилку, якщо таблицею
розділів пристрою \f(CW\*(C`пристрій\*(C'\fR не є \s-1GPT.\s0
.PP
Див.
https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries, де
наведено корисний список атрибутів розділів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.21.1)
.SS "guestfs_part_set_gpt_guid"
.IX Subsection "guestfs_part_set_gpt_guid"
.Vb 5
\& int
\& guestfs_part_set_gpt_guid (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            const char *guid);
.Ve
.PP
Встановлює \s-1GUID\s0 вказаного за номером \f(CW\*(C`номер_розділу\*(C'\fR пристрою із таблицею
розділів \s-1GPT\s0 \f(CW\*(C`пристрій\*(C'\fR у значення \f(CW\*(C`guid\*(C'\fR. Повертає помилку, якщо таблицею
розділів пристрою \f(CW\*(C`пристрій\*(C'\fR не є \s-1GPT\s0 або якщо \f(CW\*(C`guid\*(C'\fR не є коректним \s-1GUID.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.29.25)
.SS "guestfs_part_set_gpt_type"
.IX Subsection "guestfs_part_set_gpt_type"
.Vb 5
\& int
\& guestfs_part_set_gpt_type (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            const char *guid);
.Ve
.PP
Встановлює \s-1GUID\s0 типу пристрою вказаного за номером \f(CW\*(C`номер_розділу\*(C'\fR пристрою
із таблицею розділів \s-1GPT\s0 у значення \f(CW\*(C`guid\*(C'\fR. Повертає помилку, якщо таблицею
розділів пристрою \f(CW\*(C`пристрій\*(C'\fR не є \s-1GPT\s0 або якщо \f(CW\*(C`guid\*(C'\fR не є коректним \s-1GUID.\s0
.PP
Див.
http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs,
де наведено корисний список \s-1GUID\s0 типів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`gdisk\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.21.1)
.SS "guestfs_part_set_mbr_id"
.IX Subsection "guestfs_part_set_mbr_id"
.Vb 5
\& int
\& guestfs_part_set_mbr_id (guestfs_h *g,
\&                          const char *device,
\&                          int partnum,
\&                          int idbyte);
.Ve
.PP
Встановлює байт типу \s-1MBR\s0 (також відомий як байт \s-1ID\s0) для вказаного за номером
розділу \f(CW\*(C`номер_розділу\*(C'\fR у значення \f(CW\*(C`ід_байт\*(C'\fR. Зауважте, що байти типів у
більшій частині документації є насправді шістнадцятковими числами, але
фігурують у тексті без початкового «0x», що може ввести читача в оману.
.PP
Зауважте, що байти типу мають лише розділи \s-1MBR\s0 (застарілі розділи у стилі
\&\s-1DOS\s0). Ви отримаєте невизначені результати для інших типів таблиць розділів
(див. \f(CW\*(C`guestfs_part_get_parttype\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.2)
.SS "guestfs_part_set_name"
.IX Subsection "guestfs_part_set_name"
.Vb 5
\& int
\& guestfs_part_set_name (guestfs_h *g,
\&                        const char *device,
\&                        int partnum,
\&                        const char *name);
.Ve
.PP
Ця команда встановлює назву розділу на вказаному за номером розділі \f(CW\*(C`номер
розділу\*(C'\fR на пристрої \f(CW\*(C`пристрій\*(C'\fR. Зауважте, що нумерація розділів
розпочинається з 1.
.PP
Назву розділу можна встановити лише для певних типів таблиць розділів. Це
працює для таблиць \f(CW\*(C`gpt\*(C'\fR, але не для таблиць \f(CW\*(C`mbr\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.78)
.SS "guestfs_part_to_dev"
.IX Subsection "guestfs_part_to_dev"
.Vb 3
\& char *
\& guestfs_part_to_dev (guestfs_h *g,
\&                      const char *partition);
.Ve
.PP
Цій функції передається назва розділу (наприклад «/dev/sdb1»), вона вилучає
номер розділу, повертаючи назву розділу (наприклад «/dev/sdb»).
.PP
Іменований розділ має існувати, наприклад, як рядок, який повертає
\&\f(CW\*(C`guestfs_list_partitions\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_part_to_partnum\*(C'\fR, \f(CW\*(C`guestfs_device_index\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.5.15)
.SS "guestfs_part_to_partnum"
.IX Subsection "guestfs_part_to_partnum"
.Vb 3
\& int
\& guestfs_part_to_partnum (guestfs_h *g,
\&                          const char *partition);
.Ve
.PP
Цій функції передається назва розділу (наприклад «/dev/sdb1»), вона повертає
номер розділу (наприклад \f(CW1\fR).
.PP
Іменований розділ має існувати, наприклад, як рядок, який повертає
\&\f(CW\*(C`guestfs_list_partitions\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_part_to_dev\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.13.25)
.SS "guestfs_ping_daemon"
.IX Subsection "guestfs_ping_daemon"
.Vb 2
\& int
\& guestfs_ping_daemon (guestfs_h *g);
.Ve
.PP
Це зонд для тестування фонової служби guestfs, запущеної у базовій системі
libguestfs. Виклик цієї служби перевіряє, чи відповідає фонова служба на
луна\-повідомлення, ніяк інакше не впливаючи на роботу фонової служби або
долучених блокових пристроїв.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.18)
.SS "guestfs_pread"
.IX Subsection "guestfs_pread"
.Vb 6
\& char *
\& guestfs_pread (guestfs_h *g,
\&                const char *path,
\&                int count,
\&                int64_t offset,
\&                size_t *size_r);
.Ve
.PP
За допомогою цієї команди ви можете прочитати частину файла. Вона читає
\&\f(CW\*(C`кількість\*(C'\fR байтів з файла, починаючи з позиції \f(CW\*(C`відступ\*(C'\fR. Файл задається
записом \f(CW\*(C`шлях\*(C'\fR.
.PP
Команда може прочитати менше байтів, ніж було вказано у параметрах
команди. Щоб дізнатися більше про це, ознайомтеся зі сторінкою підручника
щодо системного виклику \fBpread\fR\|(2).
.PP
Див. також \f(CW\*(C`guestfs_pwrite\*(C'\fR, \f(CW\*(C`guestfs_pread_device\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.77)
.SS "guestfs_pread_device"
.IX Subsection "guestfs_pread_device"
.Vb 6
\& char *
\& guestfs_pread_device (guestfs_h *g,
\&                       const char *device,
\&                       int count,
\&                       int64_t offset,
\&                       size_t *size_r);
.Ve
.PP
За допомогою цієї команди ви можете прочитати частину вмісту блокового
пристрою. Вона читає \f(CW\*(C`кількість\*(C'\fR байтів з пристрою \f(CW\*(C`пристрій\*(C'\fR, починаючи з
позиції \f(CW\*(C`відступ\*(C'\fR.
.PP
Команда може прочитати менше байтів, ніж було вказано у параметрах
команди. Щоб дізнатися більше про це, ознайомтеся зі сторінкою підручника
щодо системного виклику \fBpread\fR\|(2).
.PP
Див. також \f(CW\*(C`guestfs_pread\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.5.21)
.SS "guestfs_pvchange_uuid"
.IX Subsection "guestfs_pvchange_uuid"
.Vb 3
\& int
\& guestfs_pvchange_uuid (guestfs_h *g,
\&                        const char *device);
.Ve
.PP
Створити новий випадковий \s-1UUID\s0 для фізичного тому \f(CW\*(C`пристрій\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.26)
.SS "guestfs_pvchange_uuid_all"
.IX Subsection "guestfs_pvchange_uuid_all"
.Vb 2
\& int
\& guestfs_pvchange_uuid_all (guestfs_h *g);
.Ve
.PP
Створити нові випадкові \s-1UUID\s0 для всіх фізичних томів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.26)
.SS "guestfs_pvcreate"
.IX Subsection "guestfs_pvcreate"
.Vb 3
\& int
\& guestfs_pvcreate (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Ця команда створює фізичний том \s-1LVM\s0 із назвою \f(CW\*(C`пристрій\*(C'\fR, де \f(CW\*(C`пристрій\*(C'\fR,
зазвичай, має бути назвою розділу, наприклад \fI/dev/sda1\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.8)
.SS "guestfs_pvremove"
.IX Subsection "guestfs_pvremove"
.Vb 3
\& int
\& guestfs_pvremove (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Ця команда витирає вміст фізичного тому \f(CW\*(C`пристрій\*(C'\fR так, що \s-1LVM\s0 більше його
не розпізнає.
.PP
У цій реалізації використано команду \f(CW\*(C`pvremove\*(C'\fR, яка забороняє витирати
фізичні томи, які містять будь\-які групи томів. Тому вам слід спочатку
вилучити групи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.13)
.SS "guestfs_pvresize"
.IX Subsection "guestfs_pvresize"
.Vb 3
\& int
\& guestfs_pvresize (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Ця команда змінює розмір (розширює або стискає) наявний логічний том \s-1LVM\s0
так, щоб він відповідав за розміром новому розміру базового пристрою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.26)
.SS "guestfs_pvresize_size"
.IX Subsection "guestfs_pvresize_size"
.Vb 4
\& int
\& guestfs_pvresize_size (guestfs_h *g,
\&                        const char *device,
\&                        int64_t size);
.Ve
.PP
Ця команда виконує ті самі дії, що і \f(CW\*(C`guestfs_pvresize\*(C'\fR, але вона надає вам
змогу вказати новий розмір (у байтах) явним чином.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.3.14)
.SS "guestfs_pvs"
.IX Subsection "guestfs_pvs"
.Vb 2
\& char **
\& guestfs_pvs (guestfs_h *g);
.Ve
.PP
Виводить список усіх виявлених фізичних томів. Є еквівалентом команди
\&\fBpvs\fR\|(8).
.PP
Ця команда повертає список назв лише тих пристроїв, на яких містяться
фізичні томи (наприклад \fI/dev/sda2\fR).
.PP
Див. також \f(CW\*(C`guestfs_pvs_full\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.4)
.SS "guestfs_pvs_full"
.IX Subsection "guestfs_pvs_full"
.Vb 2
\& struct guestfs_lvm_pv_list *
\& guestfs_pvs_full (guestfs_h *g);
.Ve
.PP
Виводить список усіх виявлених фізичних томів. Є еквівалентом команди
\&\fBpvs\fR\|(8). «Повна» версія включає усі поля.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_lvm_pv_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_lvm_pv_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.4)
.SS "guestfs_pvuuid"
.IX Subsection "guestfs_pvuuid"
.Vb 3
\& char *
\& guestfs_pvuuid (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
Ця команда повертає \s-1UUID\s0 фізичного тому \s-1LVM\s0 \f(CW\*(C`пристрій\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.87)
.SS "guestfs_pwrite"
.IX Subsection "guestfs_pwrite"
.Vb 6
\& int
\& guestfs_pwrite (guestfs_h *g,
\&                 const char *path,
\&                 const char *content,
\&                 size_t content_size,
\&                 int64_t offset);
.Ve
.PP
Ця команда записує частину файла. Команда записує буфер даних \f(CW\*(C`дані\*(C'\fR до
файла \f(CW\*(C`шлях\*(C'\fR, починаючи з відступу \f(CW\*(C`відступ\*(C'\fR.
.PP
Ця команда реалізує системний виклик \fBpwrite\fR\|(2) і, подібно до цього
системного виклику, вона може не записати повністю вказані дані. Повернуте
значення є кількістю байтів, які насправді було записано до файла. Цим
значенням може бути навіть 0, хоча обрізані записи є малоймовірними для
звичайних файлів у звичайних обставинах.
.PP
Див. також \f(CW\*(C`guestfs_pread\*(C'\fR, \f(CW\*(C`guestfs_pwrite_device\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.3.14)
.SS "guestfs_pwrite_device"
.IX Subsection "guestfs_pwrite_device"
.Vb 6
\& int
\& guestfs_pwrite_device (guestfs_h *g,
\&                        const char *device,
\&                        const char *content,
\&                        size_t content_size,
\&                        int64_t offset);
.Ve
.PP
Ця команда записує частину пристрою. Команда записує буфер даних \f(CW\*(C`дані\*(C'\fR до
пристрою \f(CW\*(C`пристрій\*(C'\fR, починаючи з відступу \f(CW\*(C`відступ\*(C'\fR.
.PP
Ця команда реалізує системний виклик \fBpwrite\fR\|(2) і, подібно до цього
системного виклику, вона може не записати повністю вказані дані (хоча
обрізаний запис на дискові пристрої і розділи майже неможливий зі
стандартними ядрами Linux).
.PP
Див. також \f(CW\*(C`guestfs_pwrite\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.5.20)
.SS "guestfs_read_file"
.IX Subsection "guestfs_read_file"
.Vb 4
\& char *
\& guestfs_read_file (guestfs_h *g,
\&                    const char *path,
\&                    size_t *size_r);
.Ve
.PP
Цей виклик повертає вміст файла \f(CW\*(C`шлях\*(C'\fR як буфер даних.
.PP
На відміну від \f(CW\*(C`guestfs_cat\*(C'\fR, ця функція може правильно обробляти файли,
які містять вбудовані символи \s-1NUL ASCII.\s0
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
(Додано у 1.0.63)
.SS "guestfs_read_lines"
.IX Subsection "guestfs_read_lines"
.Vb 3
\& char **
\& guestfs_read_lines (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
Повертає вміст файла із назвою \f(CW\*(C`шлях\*(C'\fR.
.PP
Вміст файла повертається як список рядків. Послідовності символів \f(CW\*(C`LF\*(C'\fR та
\&\f(CW\*(C`CRLF\*(C'\fR наприкінці рядків \fIне\fR повертаються.
.PP
Зауважте, що ця функція не може належним чином обробляти двійкові файли
(особливо, файли, у яких містяться символи \f(CW\*(C`\e0\*(C'\fR, які вважаються символами
кінця рядка). Для таких файлів слід використовувати функцію
\&\f(CW\*(C`guestfs_read_file\*(C'\fR і ділити буфер на рядки власноруч.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 0.7)
.SS "guestfs_readdir"
.IX Subsection "guestfs_readdir"
.Vb 3
\& struct guestfs_dirent_list *
\& guestfs_readdir (guestfs_h *g,
\&                  const char *dir);
.Ve
.PP
Ця команда повертає список записів у каталозі \f(CW\*(C`каталог\*(C'\fR.
.PP
Буде повернуто усі записи у каталозі, зокрема і записи \f(CW\*(C`.\*(C'\fR та \f(CW\*(C`..\*(C'\fR. Записи
\&\fIне\fR упорядковуватимуться, їх буде повернуто у тому самому порядку, у якому
вони зберігаються у базовій файловій системі.
.PP
Крім того, цей виклик повертає базові дані щодо типу файла для кожного з
файлів. У полі \f(CW\*(C`ftyp\*(C'\fR міститиметься один з таких символів:
.IP "'b'" 4
.IX Item "'b'"
Блоковий особливий
.IP "'c'" 4
.IX Item "'c'"
Символьний особливий
.IP "'d'" 4
.IX Item "'d'"
Каталог
.IP "'f'" 4
.IX Item "'f'"
\&\s-1FIFO\s0 (іменований канал)
.IP "'l'" 4
.IX Item "'l'"
Символічне посилання
.IP "'r'" 4
.IX Item "'r'"
Звичайний файл
.IP "'s'" 4
.IX Item "'s'"
Сокет
.IP "'u'" 4
.IX Item "'u'"
Невідомий тип файла
.IP "'?'" 4
Викликом \fBreaddir\fR\|(3) повернуто поле \f(CW\*(C`d_type\*(C'\fR із неочікуваним значенням
.PP
Цю функцію створено, в основному, для використання у програмах. Щоб отримати
простий список назв, скористайтеся \f(CW\*(C`guestfs_ls\*(C'\fR. Щоб отримати придатний для
друку і сприйняття людиною список каталогу, скористайтеся \f(CW\*(C`guestfs_ll\*(C'\fR.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_dirent_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_dirent_list\*(C'\fI\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.55)
.SS "guestfs_readlink"
.IX Subsection "guestfs_readlink"
.Vb 3
\& char *
\& guestfs_readlink (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
Ця команда читає файл, на який посилається символічне посилання.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.66)
.SS "guestfs_readlinklist"
.IX Subsection "guestfs_readlinklist"
.Vb 4
\& char **
\& guestfs_readlinklist (guestfs_h *g,
\&                       const char *path,
\&                       char *const *names);
.Ve
.PP
Цей виклик надає змогу виконувати дію \*(L"readlink\*(R" над декількома файлами,
які зберігаються у каталозі \f(CW\*(C`шлях\*(C'\fR. Значенням аргументу \f(CW\*(C`назви\*(C'\fR є список
файлів у цьому каталозі.
.PP
Повернуто буде список рядків із однозначною відповідністю до списку
\&\f(CW\*(C`назви\*(C'\fR. У кожному рядку буде значення символічного посилання.
.PP
Якщо не вдається виконати дію \fBreadlink\fR\|(2) для якоїсь із назв, відповідним
рядком\-результатом буде порожній рядок \f(CW""\fR.  Втім, обробку буде завершено,
навіть якщо стануться якісь помилки у \fBreadlink\fR\|(2), тому ви можете
викликати цю функцію для назв, про які немає відомостей щодо того, чи є вони
символічними посиланнями (хоча такі виклики і будуть дещо менш ефективними).
.PP
Цю команду призначено для програм, яким потрібно ефективно будувати список
вмісту каталогів без виконання багатьох обходів.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.77)
.SS "guestfs_realpath"
.IX Subsection "guestfs_realpath"
.Vb 3
\& char *
\& guestfs_realpath (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
Повертає перетворену до канонічної форми абсолютну назву шляху \f(CW\*(C`шлях\*(C'\fR. У
повернутому шляху не буде елементів \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`..\*(C'\fR або шляхів символічних
посилань.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.66)
.SS "guestfs_remount"
.IX Subsection "guestfs_remount"
.Vb 4
\& int
\& guestfs_remount (guestfs_h *g,
\&                  const char *mountpoint,
\&                  ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_REMOUNT_RW, int rw,
.Ve
.PP
За допомогою цього виклику ви можете змінити значення прапорця \f(CW\*(C`rw\*(C'\fR (лише
читання/читання і запис) на вже змонтованій до точки монтування
\&\f(CW\*(C`точка_монтування\*(C'\fR файловій системі, перетворивши придатну лише для читання
файлову систему на систему із можливостями читання і запису, і навпаки.
.PP
Зауважте, що у поточній версії вам доведеться вказати «необов'язковий»
параметр \f(CW\*(C`rw\*(C'\fR. У майбутньому ми можемо уможливити зміну інших прапорців
файлової системи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.23.2)
.SS "guestfs_remount_va"
.IX Subsection "guestfs_remount_va"
.Vb 4
\& int
\& guestfs_remount_va (guestfs_h *g,
\&                     const char *mountpoint,
\&                     va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_remount\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_remount_argv"
.IX Subsection "guestfs_remount_argv"
.Vb 4
\& int
\& guestfs_remount_argv (guestfs_h *g,
\&                       const char *mountpoint,
\&                       const struct guestfs_remount_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_remount\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_remove_drive"
.IX Subsection "guestfs_remove_drive"
.Vb 3
\& int
\& guestfs_remove_drive (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
Концептуально, ця функція є протилежністю \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR. Вона
вилучає диск, який раніше було додано з міткою \f(CW\*(C`label\*(C'\fR.
.PP
Зауважте, що для вилучення дисків за допомогою цієї команди вам слід
додавати їх з мітками (див. необов'язковий аргумент \f(CW\*(C`label\*(C'\fR у
\&\f(CW\*(C`guestfs_add_drive_opts\*(C'\fR). Якщо ви не вказали мітку, вилучити диск за
допомогою цієї команди не вдасться.
.PP
Цю функцію можна викликати до або після запуску дескриптора. Якщо її
викликано після запуску і підтримку подібної операції передбачено у модулі
обробки, буде виконано спробу від'єднання диска у «гарячому» режимі:
див. \*(L"З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ\*(R". Диск під час цієї операції
вже \fBне повинен\fR використовуватися (тобто бути змонтованим). Функція
намагатиметься визначити, чи використовується диск, і запобігатиме
від'єднанню використаних дисків.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.49)
.SS "guestfs_removexattr"
.IX Subsection "guestfs_removexattr"
.Vb 4
\& int
\& guestfs_removexattr (guestfs_h *g,
\&                      const char *xattr,
\&                      const char *path);
.Ve
.PP
Цей виклик вилучає розширений атрибут із назвою \f(CW\*(C`розширений_атрибут\*(C'\fR з
файла \f(CW\*(C`шлях\*(C'\fR.
.PP
Див. також \f(CW\*(C`guestfs_lremovexattr\*(C'\fR, \fBattr\fR\|(5).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.59)
.SS "guestfs_rename"
.IX Subsection "guestfs_rename"
.Vb 4
\& int
\& guestfs_rename (guestfs_h *g,
\&                 const char *oldpath,
\&                 const char *newpath);
.Ve
.PP
Перейменовує файл, пересуваючи його до нового місця у файловій системі. Те
саме, що системний виклик \fBrename\fR\|(2)  у Linux. У більшості випадків варто
замість цієї команди використовувати \f(CW\*(C`guestfs_mv\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.21.5)
.SS "guestfs_resize2fs"
.IX Subsection "guestfs_resize2fs"
.Vb 3
\& int
\& guestfs_resize2fs (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
Змінює розміри файлової системи ext2, ext3 або ext4 так, щоб її розмір
збігався із розміром базового пристрою.
.PP
Див. також \*(L"\s-1RESIZE2FS ERRORS\*(R"\s0.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.27)
.SS "guestfs_resize2fs_M"
.IX Subsection "guestfs_resize2fs_M"
.Vb 3
\& int
\& guestfs_resize2fs_M (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
Ця команда аналогічна до \f(CW\*(C`guestfs_resize2fs\*(C'\fR, але розмір файлової системи
змінюється до найменшого. Це працює як параметр \fI\-M\fR команди \f(CW\*(C`resize2fs\*(C'\fR.
.PP
Щоб отримати остаточний розмір файлової системи, вам слід викликати
\&\f(CW\*(C`guestfs_tune2fs_l\*(C'\fR і прочитати значення \f(CW\*(C`Block size\*(C'\fR та \f(CW\*(C`Block
count\*(C'\fR. Ці два числа, перемножені між собою, дадуть остаточний розмір
файлової системи у байтах.
.PP
Див. також \*(L"\s-1RESIZE2FS ERRORS\*(R"\s0.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.4)
.SS "guestfs_resize2fs_size"
.IX Subsection "guestfs_resize2fs_size"
.Vb 4
\& int
\& guestfs_resize2fs_size (guestfs_h *g,
\&                         const char *device,
\&                         int64_t size);
.Ve
.PP
Ця команда виконує ті самі дії, що і \f(CW\*(C`guestfs_resize2fs\*(C'\fR, але вона надає
вам змогу вказати новий розмір (у байтах) явним чином.
.PP
Див. також \*(L"\s-1RESIZE2FS ERRORS\*(R"\s0.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.14)
.SS "guestfs_rm"
.IX Subsection "guestfs_rm"
.Vb 3
\& int
\& guestfs_rm (guestfs_h *g,
\&             const char *path);
.Ve
.PP
Вилучити одинарний файл \f(CW\*(C`шлях\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_rm_f"
.IX Subsection "guestfs_rm_f"
.Vb 3
\& int
\& guestfs_rm_f (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Вилучити файл \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо файла не існує, помилку буде проігноровано. (Інші помилки, наприклад
помилки введення\-виведення та помилки у шляхах, не ігноруватимуться.)
.PP
Ця команда не може вилучати каталоги. Для вилучення порожнього каталогу
скористайтеся командою \f(CW\*(C`guestfs_rmdir\*(C'\fR. Для рекурсивного вилучення
каталогів слід використовувати \f(CW\*(C`guestfs_rm_rf\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.42)
.SS "guestfs_rm_rf"
.IX Subsection "guestfs_rm_rf"
.Vb 3
\& int
\& guestfs_rm_rf (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Вилучає файл або каталог \f(CW\*(C`шлях\*(C'\fR. Діє рекурсивно, якщо вказано
каталог. Подібна до команди \f(CW\*(C`rm \-rf\*(C'\fR, відданої з командної оболонки.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_rmdir"
.IX Subsection "guestfs_rmdir"
.Vb 3
\& int
\& guestfs_rmdir (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Вилучає окремий каталог \f(CW\*(C`шлях\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_rmmountpoint"
.IX Subsection "guestfs_rmmountpoint"
.Vb 3
\& int
\& guestfs_rmmountpoint (guestfs_h *g,
\&                       const char *exemptpath);
.Ve
.PP
This call removes a mountpoint that was previously created with
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR.  See \f(CW\*(C`guestfs_mkmountpoint\*(C'\fR for full details.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.62)
.SS "guestfs_rsync"
.IX Subsection "guestfs_rsync"
.Vb 5
\& int
\& guestfs_rsync (guestfs_h *g,
\&                const char *src,
\&                const char *dest,
\&                ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_RSYNC_ARCHIVE, int archive,
\& GUESTFS_RSYNC_DELETEDEST, int deletedest,
.Ve
.PP
Цим викликом можна скористатися для копіювання або синхронізування двох
каталогів у одному дескрипторі libguestfs. Використовується програма
\&\fBrsync\fR\|(1), у якій реалізовано швидкий алгоритм для уникнення непотрібного
копіювання файлів.
.PP
Значеннями параметрів \f(CW\*(C`джерело\*(C'\fR і \f(CW\*(C`призначення\*(C'\fR є назви каталогу
походження даних і кінцевого каталогу. Файли копіюються з каталогу
\&\f(CW\*(C`джерело\*(C'\fR до каталогу \f(CW\*(C`призначення\*(C'\fR.
.PP
Необов'язковими аргументами є:
.ie n .IP """archive""" 4
.el .IP "\f(CWarchive\fR" 4
.IX Item "archive"
Вмикає режим архівування. Те саме, що передати параметр \fI\-\-archive\fR команді
\&\f(CW\*(C`rsync\*(C'\fR.
.ie n .IP """deletedest""" 4
.el .IP "\f(CWdeletedest\fR" 4
.IX Item "deletedest"
Вилучити файли у каталозі призначення, яких немає у каталозі джерела.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`rsync\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.29)
.SS "guestfs_rsync_va"
.IX Subsection "guestfs_rsync_va"
.Vb 5
\& int
\& guestfs_rsync_va (guestfs_h *g,
\&                   const char *src,
\&                   const char *dest,
\&                   va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_rsync\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_rsync_argv"
.IX Subsection "guestfs_rsync_argv"
.Vb 5
\& int
\& guestfs_rsync_argv (guestfs_h *g,
\&                     const char *src,
\&                     const char *dest,
\&                     const struct guestfs_rsync_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_rsync\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_rsync_in"
.IX Subsection "guestfs_rsync_in"
.Vb 5
\& int
\& guestfs_rsync_in (guestfs_h *g,
\&                   const char *remote,
\&                   const char *dest,
\&                   ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_RSYNC_IN_ARCHIVE, int archive,
\& GUESTFS_RSYNC_IN_DELETEDEST, int deletedest,
.Ve
.PP
Цим викликом можна скористатися для копіювання або синхронізування файлових
систем у основній системі або на віддаленому комп'ютері із файловою системою
у libguestfs. Використовується програма \fBrsync\fR\|(1), у якій реалізовано
швидкий алгоритм для уникнення непотрібного копіювання файлів.
.PP
Ця команда працюватиме, лише якщо увімкнено можливість роботи у
мережі. Див. \f(CW\*(C`guestfs_set_network\*(C'\fR або параметр \fI\-\-network\fR різноманітних
інструментів, зокрема \fBguestfish\fR\|(1).
.PP
Файли копіюються з віддаленого сервера та каталогу, вказаного за допомогою
параметра \f(CW\*(C`віддалений_комп\*(Aqютер\*(C'\fR, до каталогу призначення \f(CW\*(C`призначення\*(C'\fR.
.PP
Формат рядка віддаленого сервера визначається \fBrsync\fR\|(1). Зауважте, що не
передбачено способу вказати пароль, отже призначення має бути налаштовано
так, щоб пароль не потрібно було вказувати.
.PP
Необов'язкові аргументи такі самі, як і у \f(CW\*(C`guestfs_rsync\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`rsync\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.29)
.SS "guestfs_rsync_in_va"
.IX Subsection "guestfs_rsync_in_va"
.Vb 5
\& int
\& guestfs_rsync_in_va (guestfs_h *g,
\&                      const char *remote,
\&                      const char *dest,
\&                      va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_rsync_in\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_rsync_in_argv"
.IX Subsection "guestfs_rsync_in_argv"
.Vb 5
\& int
\& guestfs_rsync_in_argv (guestfs_h *g,
\&                        const char *remote,
\&                        const char *dest,
\&                        const struct guestfs_rsync_in_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_rsync_in\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_rsync_out"
.IX Subsection "guestfs_rsync_out"
.Vb 5
\& int
\& guestfs_rsync_out (guestfs_h *g,
\&                    const char *src,
\&                    const char *remote,
\&                    ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_RSYNC_OUT_ARCHIVE, int archive,
\& GUESTFS_RSYNC_OUT_DELETEDEST, int deletedest,
.Ve
.PP
Цим викликом можна скористатися для копіювання або синхронізування файлової
системи у libguestfs із файловою системою у основній системі або на
віддаленому комп'ютері. Використовується програма \fBrsync\fR\|(1), у якій
реалізовано швидкий алгоритм для уникнення непотрібного копіювання файлів.
.PP
Ця команда працюватиме, лише якщо увімкнено можливість роботи у
мережі. Див. \f(CW\*(C`guestfs_set_network\*(C'\fR або параметр \fI\-\-network\fR різноманітних
інструментів, зокрема \fBguestfish\fR\|(1).
.PP
Файли копіюються з каталогу джерела \f(CW\*(C`джерело\*(C'\fR до віддаленого сервера та
каталогу, вказаного за допомогою параметра \f(CW\*(C`віддалений_комп\*(Aqютер\*(C'\fR.
.PP
Формат рядка віддаленого сервера визначається \fBrsync\fR\|(1). Зауважте, що не
передбачено способу вказати пароль, отже призначення має бути налаштовано
так, щоб пароль не потрібно було вказувати.
.PP
Необов'язкові аргументи такі самі, як і у \f(CW\*(C`guestfs_rsync\*(C'\fR.
.PP
У параметрі \f(CW\*(C`src\*(C'\fR не виконується підставляння замість
символів\-замінників. У програмах, де програмний інтерфейс використовується
безпосередньо, вам слід розгортати замінники власноруч (див.
\&\f(CW\*(C`guestfs_glob_expand\*(C'\fR). У guestfish ви можете скористатися командою \f(CW\*(C`glob\*(C'\fR
(див. \*(L"glob\*(R" in \fBguestfish\fR\|(1)). Приклад:
.PP
.Vb 1
\& ><fs> glob rsync\-out /* rsync://remote/
.Ve
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`rsync\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.29)
.SS "guestfs_rsync_out_va"
.IX Subsection "guestfs_rsync_out_va"
.Vb 5
\& int
\& guestfs_rsync_out_va (guestfs_h *g,
\&                       const char *src,
\&                       const char *remote,
\&                       va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_rsync_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_rsync_out_argv"
.IX Subsection "guestfs_rsync_out_argv"
.Vb 5
\& int
\& guestfs_rsync_out_argv (guestfs_h *g,
\&                         const char *src,
\&                         const char *remote,
\&                         const struct guestfs_rsync_out_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_rsync_out\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_scrub_device"
.IX Subsection "guestfs_scrub_device"
.Vb 3
\& int
\& guestfs_scrub_device (guestfs_h *g,
\&                       const char *device);
.Ve
.PP
Ця команда записує зразкові дані на \f(CW\*(C`пристрій\*(C'\fR для утруднення відновлення
даних на ньому.
.PP
Ця команда є інтерфейсом до програми \fBscrub\fR\|(1). Див. відповідну сторінку
підручника, щоб дізнатися більше.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`scrub\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.52)
.SS "guestfs_scrub_file"
.IX Subsection "guestfs_scrub_file"
.Vb 3
\& int
\& guestfs_scrub_file (guestfs_h *g,
\&                     const char *file);
.Ve
.PP
Ця команда записує зразкові дані до файла для утруднення відновлення його
даних після витирання.
.PP
Після заповнення даними взірця файл буде \fIвилучено\fR.
.PP
Ця команда є інтерфейсом до програми \fBscrub\fR\|(1). Див. відповідну сторінку
підручника, щоб дізнатися більше.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`scrub\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.52)
.SS "guestfs_scrub_freespace"
.IX Subsection "guestfs_scrub_freespace"
.Vb 3
\& int
\& guestfs_scrub_freespace (guestfs_h *g,
\&                          const char *dir);
.Ve
.PP
Ця команда створює каталог \f(CW\*(C`dir\*(C'\fR, а потім заповнює його файлами, аж доки
файлову систему не буде повністю заповнено, далі витирає файли, як у команді
\&\f(CW\*(C`guestfs_scrub_file\*(C'\fR, і вилучає їх. Команду призначено для витирання усіх
даних з вільного місця на розділі, де зберігається каталог \f(CW\*(C`dir\*(C'\fR.
.PP
Ця команда є інтерфейсом до програми \fBscrub\fR\|(1). Див. відповідну сторінку
підручника, щоб дізнатися більше.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`scrub\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.52)
.SS "guestfs_selinux_relabel"
.IX Subsection "guestfs_selinux_relabel"
.Vb 5
\& int
\& guestfs_selinux_relabel (guestfs_h *g,
\&                          const char *specfile,
\&                          const char *path,
\&                          ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_SELINUX_RELABEL_FORCE, int force,
.Ve
.PP
Повторне встановлення міток SELinux у файловій системі.
.PP
Параметр \f(CW\*(C`файл_специфікацій\*(C'\fR визначає використаний файл специфікацій
правил. Вам слід обробити \f(CW\*(C`/etc/selinux/config\*(C'\fR, щоб визначити належні
правила SELinux, а потім передати файл специфікацій, зазвичай, так:
\&\f(CW\*(C`/etc/selinux/\*(C'\fR + \fIтип_selinux\fR + \f(CW\*(C`/contexts/files/file_contexts\*(C'\fR.
.PP
Обов'язковий параметр \f(CW\*(C`шлях\*(C'\fR визначає каталог верхнього рівня, з якого
починається повторне встановлення міток.  Зазвичай, вам слід передати як
\&\f(CW\*(C`шлях\*(C'\fR значення \f(CW\*(C`/\*(C'\fR, щоб повторно встановити мітки для усієї гостьової
файлової системи.
.PP
Необов'язковий булевий параметр \f(CW\*(C`force\*(C'\fR керує тим, чи буде скинуто контекст
для налаштовуваних файлів, а також тим, чи буде змінено частини контексту
файла, пов'язані із записами користувача, ролі та діапазону.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`selinuxrelabel\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.33.43)
.SS "guestfs_selinux_relabel_va"
.IX Subsection "guestfs_selinux_relabel_va"
.Vb 5
\& int
\& guestfs_selinux_relabel_va (guestfs_h *g,
\&                             const char *specfile,
\&                             const char *path,
\&                             va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_selinux_relabel\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_selinux_relabel_argv"
.IX Subsection "guestfs_selinux_relabel_argv"
.Vb 5
\& int
\& guestfs_selinux_relabel_argv (guestfs_h *g,
\&                               const char *specfile,
\&                               const char *path,
\&                               const struct guestfs_selinux_relabel_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_selinux_relabel\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_set_append"
.IX Subsection "guestfs_set_append"
.Vb 3
\& int
\& guestfs_set_append (guestfs_h *g,
\&                     const char *append);
.Ve
.PP
Ця функція використовується для додавання параметрів до командного рядка
елементарного ядра libguestfs.
.PP
Типовим значенням є \f(CW\*(C`NULL\*(C'\fR, якщо його не перевизначено за допомогою змінної
середовища \f(CW\*(C`LIBGUESTFS_APPEND\*(C'\fR.
.PP
Встановлення для параметра \f(CW\*(C`append\*(C'\fR значення \f(CW\*(C`NULL\*(C'\fR означає, що ніяких
додаткових параметрів \fIне\fR передаватиметься (libguestfs завжди додає
декілька параметрів автоматично).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.26)
.SS "guestfs_set_attach_method"
.IX Subsection "guestfs_set_attach_method"
.Vb 3
\& int
\& guestfs_set_attach_method (guestfs_h *g,
\&                            const char *backend);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_set_backend\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Встановлює спосіб, яким libguestfs користується для встановлення з'єднання
із фоновою службою guestfsd модуля обробки.
.PP
Див. \*(L"МОДУЛЬ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.9.8)
.SS "guestfs_set_autosync"
.IX Subsection "guestfs_set_autosync"
.Vb 3
\& int
\& guestfs_set_autosync (guestfs_h *g,
\&                       int autosync);
.Ve
.PP
Встановлення для \f(CW\*(C`autosync\*(C'\fR значення вмикає автоматичну
синхронізацію. Libguestfs з усіх сил намагатиметься підтримувати коректний і
синхронізований стан файлових систем, коли ви закриватимете дескриптор (а
також у ситуаціях, коли програма завершує роботу без закриття дескрипторів).
.PP
Автоматичну синхронізацію типово увімкнено (з версії libguestfs 1.5.24, у
попередніх версіях її було вимкнено).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_set_backend"
.IX Subsection "guestfs_set_backend"
.Vb 3
\& int
\& guestfs_set_backend (guestfs_h *g,
\&                      const char *backend);
.Ve
.PP
Встановлює спосіб, яким libguestfs користується для встановлення з'єднання
із фоновою службою guestfsd модуля обробки.
.PP
Ця властивість дескриптора раніше називалася «метод долучення».
.PP
Див. \*(L"МОДУЛЬ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.21.26)
.SS "guestfs_set_backend_setting"
.IX Subsection "guestfs_set_backend_setting"
.Vb 4
\& int
\& guestfs_set_backend_setting (guestfs_h *g,
\&                              const char *name,
\&                              const char *val);
.Ve
.PP
Дописує рядок \f(CW"назва=значення"\fR до списку рядків параметрів модуля
обробки. Втім, якщо у списку вже існує рядок \f(CW"назва"\fR або рядок, що
починається із запису \f(CW"назва="\fR, його буде замінено на новий вказаний
рядок.
.PP
Див. \*(L"МОДУЛЬ\*(R", \*(L"ПАРАМЕТРИ МОДУЛЯ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.27.2)
.SS "guestfs_set_backend_settings"
.IX Subsection "guestfs_set_backend_settings"
.Vb 3
\& int
\& guestfs_set_backend_settings (guestfs_h *g,
\&                               char *const *settings);
.Ve
.PP
Встановлює список із нульової або довільної кількості параметрів, які
передаються поточному модулю обробки. Кожен параметр визначається рядком,
який обробляється у специфічний для модуля спосіб або ігнорується, якщо
модуль обробки його не сприймає.
.PP
Типовим значенням є порожній список, якщо на час створення дескриптора не
було визначено змінну середовища \f(CW\*(C`LIBGUESTFS_BACKEND_SETTINGS\*(C'\fR. У цій
змінній середовища міститься список параметрів, відокремлених двокрапками.
.PP
Цей виклик замінює усі параметри модуля обробки. Якщо вам потрібно замінити
лише один рядок параметра, скористайтеся
\&\f(CW\*(C`guestfs_set_backend_setting\*(C'\fR. Якщо вам потрібно прибрати один рядок
параметра, скористайтеся \f(CW\*(C`guestfs_clear_backend_setting\*(C'\fR.
.PP
Див. \*(L"МОДУЛЬ\*(R", \*(L"ПАРАМЕТРИ МОДУЛЯ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.25.24)
.SS "guestfs_set_cachedir"
.IX Subsection "guestfs_set_cachedir"
.Vb 3
\& int
\& guestfs_set_cachedir (guestfs_h *g,
\&                       const char *cachedir);
.Ve
.PP
Встановити назву каталогу, який використовується дескриптором для зберігання
кешу базової системи, якщо використовується базова система supermin. Базова
система кешується і спільно використовується усіма дескрипторами, які мають
однаковий ідентифікатор ефективного користувача.
.PP
Змінні середовища \f(CW\*(C`LIBGUESTFS_CACHEDIR\*(C'\fR і \f(CW\*(C`TMPDIR\*(C'\fR керують типовим
значенням: якщо встановлено значення \f(CW\*(C`LIBGUESTFS_CACHEDIR\*(C'\fR, типовим буде
саме це встановлене значення. Якщо ж це значення не встановлено і
встановлено значення \f(CW\*(C`TMPDIR\*(C'\fR, використовуватиметься це значення. Якщо ж
жодну з цих змінних середовища не встановлено, типово використовуватиметься
\&\fI/var/tmp\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.58)
.SS "guestfs_set_direct"
.IX Subsection "guestfs_set_direct"
.Vb 3
\& int
\& guestfs_set_direct (guestfs_h *g,
\&                     int direct);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_internal_get_console_socket\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Якщо увімкнено прапорець безпосереднього режиму базової системи, вміст stdin
та stdout передаватиметься безпосередньо базовій системі одразу після її
запуску.
.PP
Одним із наслідків цього є те, що повідомлення журналу не
перехоплюватимуться бібліотекою і не оброблятимуться
\&\f(CW\*(C`guestfs_set_log_message_callback\*(C'\fR, а передаватимуться безпосередньо до
stdout.
.PP
Ймовірно, вам не слід використовувати цю команду, якщо ви не впевнені щодо
наслідків ваших дій.
.PP
Типово вимкнено.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.72)
.SS "guestfs_set_e2attrs"
.IX Subsection "guestfs_set_e2attrs"
.Vb 5
\& int
\& guestfs_set_e2attrs (guestfs_h *g,
\&                      const char *file,
\&                      const char *attrs,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_SET_E2ATTRS_CLEAR, int clear,
.Ve
.PP
Ця команда встановлює або знімає атрибути \f(CW\*(C`атрибути\*(C'\fR з inode із назвою
\&\fIфайл\fR.
.PP
Параметр \f(CW\*(C`attrs\*(C'\fR є рядком із символів, які визначають атрибути
файла. Список можливих значень можна знайти у описі
\&\f(CW\*(C`guestfs_get_e2attrs\*(C'\fR. Змінювати можна не усі атрибути.
.PP
Якщо не вказано необов'язковий булевий параметр \f(CW\*(C`clear\*(C'\fR або вказано
значення false, вказані \f(CW\*(C`атрибути\*(C'\fR буде встановлено для inode.
.PP
Якщо встановлено значення \f(CW\*(C`clear\*(C'\fR рівне true, вказані \f(CW\*(C`атрибути\*(C'\fR буде
знято з inode.
.PP
У обох випадках інші атрибути, які не вказано у рядку \f(CW\*(C`атрибути\*(C'\fR, змінено
не буде.
.PP
Ці атрибути є, лише якщо файл зберігається у файловій системі
ext2/3/4. Використання цієї команди для інших типів файлових систем призведе
до помилки.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.17.31)
.SS "guestfs_set_e2attrs_va"
.IX Subsection "guestfs_set_e2attrs_va"
.Vb 5
\& int
\& guestfs_set_e2attrs_va (guestfs_h *g,
\&                         const char *file,
\&                         const char *attrs,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_set_e2attrs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_set_e2attrs_argv"
.IX Subsection "guestfs_set_e2attrs_argv"
.Vb 5
\& int
\& guestfs_set_e2attrs_argv (guestfs_h *g,
\&                           const char *file,
\&                           const char *attrs,
\&                           const struct guestfs_set_e2attrs_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_set_e2attrs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_set_e2generation"
.IX Subsection "guestfs_set_e2generation"
.Vb 4
\& int
\& guestfs_set_e2generation (guestfs_h *g,
\&                           const char *file,
\&                           int64_t generation);
.Ve
.PP
Ця команда встановлює стан створення для файла у ext2.
.PP
Див. \f(CW\*(C`guestfs_get_e2generation\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.17.31)
.SS "guestfs_set_e2label"
.IX Subsection "guestfs_set_e2label"
.Vb 4
\& int
\& guestfs_set_e2label (guestfs_h *g,
\&                      const char *device,
\&                      const char *label);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_set_label\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда встановлює мітку файлової системи ext2/3/4 для файлової системи
на пристрої \f(CW\*(C`пристрій\*(C'\fR. Довжину міток файлових систем обмежено 16
символами.
.PP
Ви можете скористатися \f(CW\*(C`guestfs_tune2fs_l\*(C'\fR або \f(CW\*(C`guestfs_get_e2label\*(C'\fR для
отримання наявної мітки файлової системи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.15)
.SS "guestfs_set_e2uuid"
.IX Subsection "guestfs_set_e2uuid"
.Vb 4
\& int
\& guestfs_set_e2uuid (guestfs_h *g,
\&                     const char *device,
\&                     const char *uuid);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_set_uuid\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда встановлює \s-1UUID\s0 файлової системи ext2/3/4 для файлової системи на
пристрої \f(CW\*(C`пристрій\*(C'\fR у значення \f(CW\*(C`uuid\*(C'\fR. Формат запису \s-1UUID\s0 та альтернативні
варіанти, зокрема \f(CW\*(C`clear\*(C'\fR, \f(CW\*(C`random\*(C'\fR та \f(CW\*(C`time\*(C'\fR, описано на сторінці
підручника \fBtune2fs\fR\|(8).
.PP
Ви можете скористатися \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR для отримання наявного \s-1UUID\s0
файлової системи.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.15)
.SS "guestfs_set_hv"
.IX Subsection "guestfs_set_hv"
.Vb 3
\& int
\& guestfs_set_hv (guestfs_h *g,
\&                 const char *hv);
.Ve
.PP
Встановлює назву виконуваного файла гіпервізору, яким ми
скористаємося. Назва гіпервізору залежить від використаного модуля обробки,
але, зазвичай, це назва гіпервізору qemu/KVM. Для модуля обробки \s-1UML\s0 це
розташування виконуваного файла \f(CW\*(C`linux\*(C'\fR або \f(CW\*(C`vmlinux\*(C'\fR.
.PP
Типовий варіант визначається під час збирання бібліотеки за допомогою
скрипту налаштовування збирання (configure).
.PP
Крім того, ви можете перевизначити цей параметр за допомогою змінної
середовища \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR.
.PP
Зауважте, що вам слід викликати цю функцію якомога ближче до команди
створення дескриптора. Причиною є те, що деякі дії перед запуском системи
залежать від результатів тестування можливостей qemu (шляхом виконання
команди \f(CW\*(C`qemu \-help\*(C'\fR). Якщо виконуваний файл qemu буде змінено, бібліотека
не виконуватиме повторного визначення можливостей, отже, може працювати
некоректно. Використання змінної середовища \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR є
найбезпечнішим способом надати потрібні бібліотеці дані, оскільки
встановлення цієї змінної надає бібліотеці змогу дізнатися усе про
виконуваний файл qemu одночасно зі створенням дескриптора.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.23.17)
.SS "guestfs_set_identifier"
.IX Subsection "guestfs_set_identifier"
.Vb 3
\& int
\& guestfs_set_identifier (guestfs_h *g,
\&                         const char *identifier);
.Ve
.PP
Це інформативний рядок, який функція виклику може, якщо потрібно, встановити
у дескрипторі. Він виводиться у різних місцях, надаючи змогу ідентифікувати
поточний дескриптор у діагностичних повідомленнях.
.PP
Одним із важливих є варіант, коли увімкнено трасування. Якщо рядок
ідентифікатора є непорожнім, повідомлення трасування зміняться з таких:
.PP
.Vb 2
\& libguestfs: trace: get_tmpdir
\& libguestfs: trace: get_tmpdir = "/tmp"
.Ve
.PP
на такі:
.PP
.Vb 2
\& libguestfs: trace: ID: get_tmpdir
\& libguestfs: trace: ID: get_tmpdir = "/tmp"
.Ve
.PP
де \f(CW\*(C`ID\*(C'\fR — рядок ідентифікатор, який було встановлено викликом цієї команди.
.PP
Ідентифікатор має складатися із літер латинської абетки і цифр з \s-1ASCII,\s0 а
також символів підкреслювання або дефісів. Типовим його значенням є порожній
рядок.
.PP
Див. також \f(CW\*(C`guestfs_set_program\*(C'\fR, \f(CW\*(C`guestfs_set_trace\*(C'\fR,
\&\f(CW\*(C`guestfs_get_identifier\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.31.14)
.SS "guestfs_set_label"
.IX Subsection "guestfs_set_label"
.Vb 4
\& int
\& guestfs_set_label (guestfs_h *g,
\&                    const char *mountable,
\&                    const char *label);
.Ve
.PP
Встановлює для файлової системи \f(CW\*(C`монтування\*(C'\fR мітку \f(CW\*(C`мітка\*(C'\fR.
.PP
Підтримку міток передбачено лише у деяких файлових системах, а у libguestfs
передбачено підтримку встановлення міток лише для деякого набору таких
систем.
.IP "ext2, ext3, ext4" 4
.IX Item "ext2, ext3, ext4"
Розмір міток обмежено 16 байтами.
.IP "\s-1NTFS\s0" 4
.IX Item "NTFS"
Мітки обмежено 128 символами unicode.
.IP "\s-1XFS\s0" 4
.IX Item "XFS"
Цю мітку обмежено 12 байтами. Встановлювати мітку можна лише для
незмонтованих файлових систем.
.IP "btrfs" 4
.IX Item "btrfs"
Цю мітку обмежено 255 байтами, у ній не можна використовувати деякі
символи. Встановлення мітки на підтомі btrfs призведе до встановлення мітки
на його батьківській файловій системі. Встановлювати мітку можна лише для
незмонтованих файлових систем.
.IP "fat" 4
.IX Item "fat"
Цю мітку обмежено 11 байтами.
.IP "swap" 4
.IX Item "swap"
Цю мітку обмежено 16 байтами.
.PP
Якщо підтримки зміни мітки для типу вказаної файлової системи не
передбачено, set_label завершить роботу із повідомленням про помилку і
встановити для errno значення \s-1ENOTSUP.\s0
.PP
Для читання мітки файлової системи використовуйте \f(CW\*(C`guestfs_vfs_label\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.17.9)
.SS "guestfs_set_libvirt_requested_credential"
.IX Subsection "guestfs_set_libvirt_requested_credential"
.Vb 5
\& int
\& guestfs_set_libvirt_requested_credential (guestfs_h *g,
\&                                           int index,
\&                                           const char *cred,
\&                                           size_t cred_size);
.Ve
.PP
Після запиту щодо реєстраційних даних із індексом \f(CW\*(C`індекс\*(C'\fR, спрямованого
користувачу, викличте цю функцію для передавання відповіді до libvirt.
.PP
Документацію і приклад коду наведено у розділі \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.52)
.SS "guestfs_set_libvirt_supported_credentials"
.IX Subsection "guestfs_set_libvirt_supported_credentials"
.Vb 3
\& int
\& guestfs_set_libvirt_supported_credentials (guestfs_h *g,
\&                                            char *const *creds);
.Ve
.PP
Викличте цю функцію до встановлення обробника подій для
\&\f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR щоб надати список типів реєстраційних даних,
які може обробляти програма.
.PP
Список \f(CW\*(C`реєстраційні_дані\*(C'\fR має бути непорожнім списком рядків. Можна
використовувати такі рядки:
.ie n .IP """username""" 4
.el .IP "\f(CWusername\fR" 4
.IX Item "username"
.PD 0
.ie n .IP """authname""" 4
.el .IP "\f(CWauthname\fR" 4
.IX Item "authname"
.ie n .IP """language""" 4
.el .IP "\f(CWlanguage\fR" 4
.IX Item "language"
.ie n .IP """cnonce""" 4
.el .IP "\f(CWcnonce\fR" 4
.IX Item "cnonce"
.ie n .IP """passphrase""" 4
.el .IP "\f(CWpassphrase\fR" 4
.IX Item "passphrase"
.ie n .IP """echoprompt""" 4
.el .IP "\f(CWechoprompt\fR" 4
.IX Item "echoprompt"
.ie n .IP """noechoprompt""" 4
.el .IP "\f(CWnoechoprompt\fR" 4
.IX Item "noechoprompt"
.ie n .IP """realm""" 4
.el .IP "\f(CWrealm\fR" 4
.IX Item "realm"
.ie n .IP """external""" 4
.el .IP "\f(CWexternal\fR" 4
.IX Item "external"
.PD
.PP
Опис значення цих типів реєстраційних даних можна знайти у документації до
libvirt.
.PP
Документацію і приклад коду наведено у розділі \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.52)
.SS "guestfs_set_memsize"
.IX Subsection "guestfs_set_memsize"
.Vb 3
\& int
\& guestfs_set_memsize (guestfs_h *g,
\&                      int memsize);
.Ve
.PP
Встановлює розмір у мегабайтах, яку має бути отримано для гіпервізору
пам'яті. Працює, лише якщо викликано до \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
Ви також можете змінити значення цього параметра за допомогою встановлення
змінної середовища \f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR до створення дескриптора.
.PP
Докладніший опис архітектури libguestfs наведено у підручнику з
\&\fBguestfs\fR\|(3).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.55)
.SS "guestfs_set_network"
.IX Subsection "guestfs_set_network"
.Vb 3
\& int
\& guestfs_set_network (guestfs_h *g,
\&                      int network);
.Ve
.PP
Якщо встановлено значення true, у базовій системі libguestfs буде увімкнено
роботу у мережі. Типовим значенням є false.
.PP
Визначає, чи надаватиметься програмам доступ до мережі
(див. \*(L"ЗАПУСК КОМАНД\*(R").
.PP
Цю функцію слід викликати до \f(CW\*(C`guestfs_launch\*(C'\fR, інакше вона не спрацює.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.5.4)
.SS "guestfs_set_path"
.IX Subsection "guestfs_set_path"
.Vb 3
\& int
\& guestfs_set_path (guestfs_h *g,
\&                   const char *searchpath);
.Ve
.PP
Встановлює шлях, за яким libguestfs шукає ядро і initrd.img.
.PP
Типовим значенням є \f(CW\*(C`$libdir/guestfs\*(C'\fR, якщо його не перевизначено за
допомогою змінної середовища \f(CW\*(C`LIBGUESTFS_PATH\*(C'\fR.
.PP
Встановлення для параметра \f(CW\*(C`шлях\*(C'\fR значення \f(CW\*(C`NULL\*(C'\fR відновлює типовий шлях.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_set_pgroup"
.IX Subsection "guestfs_set_pgroup"
.Vb 3
\& int
\& guestfs_set_pgroup (guestfs_h *g,
\&                     int pgroup);
.Ve
.PP
Якщо встановлено значення \f(CW\*(C`pgroup\*(C'\fR рівне true, дочірні процеси буде
розміщено у власній групі процесів.
.PP
Практичним наслідком цього є те, що сигнали, зокрема \f(CW\*(C`SIGINT\*(C'\fR (наслідок
натискання користувачем комбінації \f(CW\*(C`^C\*(C'\fR), не буде отримано дочірнім
процесом.
.PP
Типовим для цього прапорця є значення false, оскільки, зазвичай, \f(CW\*(C`^C\*(C'\fR має
вбивати підпроцеси. Guestfish встановлює для цього прапорця значення true,
якщо програма використовується інтерактивно, щоб за допомогою \f(CW\*(C`^C\*(C'\fR можна
було належно скасувати дії, які виконуються надто довго
(див. \f(CW\*(C`guestfs_user_cancel\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.18)
.SS "guestfs_set_program"
.IX Subsection "guestfs_set_program"
.Vb 3
\& int
\& guestfs_set_program (guestfs_h *g,
\&                      const char *program);
.Ve
.PP
Встановлює назву програми. Це інформативний рядок, який основна програма
може встановлювати у дескрипторі.
.PP
Під час створення дескриптора назва програми у дескрипторі встановлюється у
значення basename з \f(CW\*(C`argv[0]\*(C'\fR. Назвою програми ніколи не може бути \f(CW\*(C`NULL\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.21.29)
.SS "guestfs_set_qemu"
.IX Subsection "guestfs_set_qemu"
.Vb 3
\& int
\& guestfs_set_qemu (guestfs_h *g,
\&                   const char *hv);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_set_hv\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Вказати виконуваний файл гіпервізору (зазвичай qemu), який буде використано.
.PP
Типовий варіант визначається під час збирання бібліотеки за допомогою
скрипту налаштовування збирання (configure).
.PP
Крім того, ви можете перевизначити цей параметр за допомогою змінної
середовища \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR.
.PP
Встановлення для параметра \f(CW\*(C`гіпервізор\*(C'\fR значення \f(CW\*(C`NULL\*(C'\fR відновлює типовий
виконуваний файл qemu.
.PP
Зауважте, що вам слід викликати цю функцію якомога ближче до команди
створення дескриптора. Причиною є те, що деякі дії перед запуском системи
залежать від результатів тестування можливостей qemu (шляхом виконання
команди \f(CW\*(C`qemu \-help\*(C'\fR). Якщо виконуваний файл qemu буде змінено, бібліотека
не виконуватиме повторного визначення можливостей, отже, може працювати
некоректно. Використання змінної середовища \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR є
найбезпечнішим способом надати потрібні бібліотеці дані, оскільки
встановлення цієї змінної надає бібліотеці змогу дізнатися усе про
виконуваний файл qemu одночасно зі створенням дескриптора.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.6)
.SS "guestfs_set_recovery_proc"
.IX Subsection "guestfs_set_recovery_proc"
.Vb 3
\& int
\& guestfs_set_recovery_proc (guestfs_h *g,
\&                            int recoveryproc);
.Ve
.PP
Якщо команда викликається із параметром \f(CW\*(C`false\*(C'\fR, \f(CW\*(C`guestfs_launch\*(C'\fR не
створюватиме процесу відновлення. Призначенням процесу відновлення є
зупинення залишкових процесів гіпервізору, якщо основна програма несподівано
завершує роботу.
.PP
Працює, лише якщо викликано до \f(CW\*(C`guestfs_launch\*(C'\fR, а типовим значенням є
true.
.PP
Майже єдиним випадком, коли у вас може виникнути потреба вимкнути цю
можливість, є випадок, коли основний процес відгалужує себе у фонову версію
(«демонізує» себе). У цьому випадку процес відновлення вважає, що основна
програма зникла і вбиває процес гіпервізору, отже, псує усю справу.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_set_selinux"
.IX Subsection "guestfs_set_selinux"
.Vb 3
\& int
\& guestfs_set_selinux (guestfs_h *g,
\&                      int selinux);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_selinux_relabel\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда встановлює прапорець selinux, який передається базовій системі
під час завантаження. Типовим є прапорець \f(CW\*(C`selinux=0\*(C'\fR (вимкнено).
.PP
Зауважте, що якщо SELinux увімкнено, система завжди перебуває у дозвільному
режимі (Permissive) (\f(CW\*(C`enforcing=0\*(C'\fR).
.PP
Докладніший опис архітектури libguestfs наведено у підручнику з
\&\fBguestfs\fR\|(3).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.67)
.SS "guestfs_set_smp"
.IX Subsection "guestfs_set_smp"
.Vb 3
\& int
\& guestfs_set_smp (guestfs_h *g,
\&                  int smp);
.Ve
.PP
Змінює кількість віртуальних процесорів, які буде призначено на обробку
команд базової системи. Типовим є значення \f(CW1\fR. Збільшення цього значення
може підвищити швидкодію, але часто просто ні на що не впливає.
.PP
Цю функцію слід викликати до \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.13.15)
.SS "guestfs_set_tmpdir"
.IX Subsection "guestfs_set_tmpdir"
.Vb 3
\& int
\& guestfs_set_tmpdir (guestfs_h *g,
\&                     const char *tmpdir);
.Ve
.PP
Встановлює назву каталогу, який використовується дескриптором для зберігання
тимчасових файлів.
.PP
Змінні середовища \f(CW\*(C`LIBGUESTFS_TMPDIR\*(C'\fR і \f(CW\*(C`TMPDIR\*(C'\fR керують типовим
значенням: якщо встановлено значення \f(CW\*(C`LIBGUESTFS_TMPDIR\*(C'\fR, типовим буде саме
це встановлене значення. Якщо ж це значення не встановлено і встановлено
значення \f(CW\*(C`TMPDIR\*(C'\fR, використовуватиметься це значення. Якщо ж жодну з цих
змінних середовища не встановлено, типово використовуватиметься \fI/tmp\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.58)
.SS "guestfs_set_trace"
.IX Subsection "guestfs_set_trace"
.Vb 3
\& int
\& guestfs_set_trace (guestfs_h *g,
\&                    int trace);
.Ve
.PP
Якщо прапорець trace цієї команди встановлено у значення 1, буде
виконуватися трасування викликів, параметрів та повернутих значень
libguestfs.
.PP
Якщо вам потрібно трасувати виклики програмного інтерфейсу мовою C у
libguestfs (та інших бібліотеках), ймовірно, кращим способом буде
використання зовнішньої команди \fBltrace\fR\|(1).
.PP
Трасування команд вимкнено, якщо змінну середовища \f(CW\*(C`LIBGUESTFS_TRACE\*(C'\fR не
визначено і не встановлено для неї значення \f(CW1\fR.
.PP
Повідомлення трасування зазвичай надсилаються до \f(CW\*(C`stderr\*(C'\fR, якщо ви не
зареєструєте зворотного виклику для надсилання цих повідомлень у якесь інше
місце (див. \f(CW\*(C`guestfs_set_event_callback\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.69)
.SS "guestfs_set_uuid"
.IX Subsection "guestfs_set_uuid"
.Vb 4
\& int
\& guestfs_set_uuid (guestfs_h *g,
\&                   const char *device,
\&                   const char *uuid);
.Ve
.PP
Встановлює для \s-1UUID\s0 файлової системи на пристрої \f(CW\*(C`пристрій\*(C'\fR значення
\&\f(CW\*(C`uuid\*(C'\fR. Якщо встановити значення не вдасться, а errno матиме значення
\&\s-1ENOTSUP,\s0 це означатиме, що для типу вказаної файлової системи не передбачено
підтримки зміни \s-1UUID.\s0
.PP
Підтримку встановлення \s-1UUID\s0 передбачено лише у деяких типах файлових систем.
.PP
Для читання \s-1UUID\s0 файлової системи слід викликати \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.23.10)
.SS "guestfs_set_uuid_random"
.IX Subsection "guestfs_set_uuid_random"
.Vb 3
\& int
\& guestfs_set_uuid_random (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Встановлює для \s-1UUID\s0 файлової системи на пристрої \f(CW\*(C`пристрій\*(C'\fR у випадкове
значення. Якщо встановити значення не вдасться, а errno матиме значення
\&\s-1ENOTSUP,\s0 це означатиме, що для типу вказаної файлової системи не передбачено
підтримки зміни \s-1UUID.\s0
.PP
Підтримку встановлення \s-1UUID\s0 передбачено лише у деяких типах файлових систем.
.PP
Для читання \s-1UUID\s0 файлової системи слід викликати \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.29.50)
.SS "guestfs_set_verbose"
.IX Subsection "guestfs_set_verbose"
.Vb 3
\& int
\& guestfs_set_verbose (guestfs_h *g,
\&                      int verbose);
.Ve
.PP
Якщо аргумент \f(CW\*(C`verbose\*(C'\fR матиме значення true, буде увімкнено режим
докладних повідомлень.
.PP
Докладні повідомлення вимкнено, якщо змінну середовища \f(CW\*(C`LIBGUESTFS_DEBUG\*(C'\fR
не визначено і не встановлено для неї значення \f(CW1\fR.
.PP
Докладні повідомлення зазвичай надсилаються до \f(CW\*(C`stderr\*(C'\fR, якщо ви не
зареєструєте зворотного виклику для надсилання цих повідомлень у якесь інше
місце (див. \f(CW\*(C`guestfs_set_event_callback\*(C'\fR).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_setcon"
.IX Subsection "guestfs_setcon"
.Vb 3
\& int
\& guestfs_setcon (guestfs_h *g,
\&                 const char *context);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_selinux_relabel\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда встановлює для контексту безпеки SELinux фонової служби значення
\&\f(CW\*(C`контекст\*(C'\fR.
.PP
Див. документацію щодо \s-1SELINUX\s0 у підручнику з \fBguestfs\fR\|(3).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`selinux\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.67)
.SS "guestfs_setxattr"
.IX Subsection "guestfs_setxattr"
.Vb 6
\& int
\& guestfs_setxattr (guestfs_h *g,
\&                   const char *xattr,
\&                   const char *val,
\&                   int vallen,
\&                   const char *path);
.Ve
.PP
Ця команда встановлює розширений атрибут із назвою \f(CW\*(C`розширений_атрибут\*(C'\fR для
файла \f(CW\*(C`шлях\*(C'\fR у значення \f(CW\*(C`значення\*(C'\fR (довжини
\&\f(CW\*(C`довжина_значення\*(C'\fR). Значенням можуть бути довільні 8\-бітові дані.
.PP
Див. також \f(CW\*(C`guestfs_lsetxattr\*(C'\fR, \fBattr\fR\|(5).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxxattrs\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.59)
.SS "guestfs_sfdisk"
.IX Subsection "guestfs_sfdisk"
.Vb 7
\& int
\& guestfs_sfdisk (guestfs_h *g,
\&                 const char *device,
\&                 int cyls,
\&                 int heads,
\&                 int sectors,
\&                 char *const *lines);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_part_add\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Це безпосередній інтерфейс програми \fBsfdisk\fR\|(8) для створення розділів на
блокових пристроях.
.PP
Значенням параметра \f(CW\*(C`пристрій\*(C'\fR має бути назва блокового пристрою, наприклад
\&\fI/dev/sda\fR.
.PP
Параметри \f(CW\*(C`циліндри\*(C'\fR, \f(CW\*(C`голівки\*(C'\fR та \f(CW\*(C`сектори\*(C'\fR визначають кількості
циліндрів, голівок та секторів на пристрої, які буде безпосередньо передано
sfdisk як аргументи параметрів \fI\-C\fR, \fI\-H\fR і \fI\-S\fR. Якщо ви передаєте \f(CW0\fR
для якогось з цих параметрів, відповідний параметр буде пропущено. Зазвичай,
для «великих» дисків ви можете просто передати \f(CW0\fR для цих параметрів, але
для малих дисків (дискет), sfdisk (або, скоріше, ядро) не може визначити
належну геометрію диска — вам доведеться передати програмі належні значення
параметрів.
.PP
Параметр \f(CW\*(C`рядки\*(C'\fR є списком рядків, які ми передаємо \f(CW\*(C`sfdisk\*(C'\fR. Щоб
дізнатися більше, зверніться до сторінки підручника щодо \fBsfdisk\fR\|(8).
.PP
Щоб створити єдиний розділ, який займатиме увесь диск, вам слід передати
\&\f(CW\*(C`рядки\*(C'\fR як список із одного елемента, коли єдиний елемент, який є рядком
\&\f(CW\*(C`,\*(C'\fR (комою).
.PP
Див. також \f(CW\*(C`guestfs_sfdisk_l\*(C'\fR, \f(CW\*(C`guestfs_sfdisk_N\*(C'\fR, \f(CW\*(C`guestfs_part_init\*(C'\fR
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_sfdiskM"
.IX Subsection "guestfs_sfdiskM"
.Vb 4
\& int
\& guestfs_sfdiskM (guestfs_h *g,
\&                  const char *device,
\&                  char *const *lines);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_part_add\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Це спрощений інтерфейс команди \f(CW\*(C`guestfs_sfdisk\*(C'\fR, де розміри розділів
вказується у лише у мегабайтах (округлений до найближчого циліндра), і вам
не потрібно вказувати параметри циліндрів, голівок і секторів, використання
яких все одно є рідкісним.
.PP
Див. також \f(CW\*(C`guestfs_sfdisk\*(C'\fR, сторінку man \fBsfdisk\fR\|(8) та
\&\f(CW\*(C`guestfs_part_disk\*(C'\fR
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.55)
.SS "guestfs_sfdisk_N"
.IX Subsection "guestfs_sfdisk_N"
.Vb 8
\& int
\& guestfs_sfdisk_N (guestfs_h *g,
\&                   const char *device,
\&                   int partnum,
\&                   int cyls,
\&                   int heads,
\&                   int sectors,
\&                   const char *line);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_part_add\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда додає для програми \fBsfdisk\fR\|(8) параметр, який змінює лише
окремий розділ \f(CW\*(C`n\*(C'\fR (зауваження: відлік \f(CW\*(C`n\*(C'\fR ведеться з 1).
.PP
Опис інший параметрів можна знайти у довідці щодо
\&\f(CW\*(C`guestfs_sfdisk\*(C'\fR. Зазвичай, вам варто передати \f(CW0\fR для параметрів
циліндрів, заголовків та секторів.
.PP
Див. також \f(CW\*(C`guestfs_part_add\*(C'\fR
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.26)
.SS "guestfs_sfdisk_disk_geometry"
.IX Subsection "guestfs_sfdisk_disk_geometry"
.Vb 3
\& char *
\& guestfs_sfdisk_disk_geometry (guestfs_h *g,
\&                               const char *device);
.Ve
.PP
Ця команда показує геометрію диска пристрою \f(CW\*(C`device\*(C'\fR, прочитану з таблиці
розділів. Ці дані можуть відрізнятися від даних щодо геометрії, які відомі
ядру, особливо у випадку, якщо розмір базового пристрою було змінено
(див. \f(CW\*(C`guestfs_sfdisk_kernel_geometry\*(C'\fR).
.PP
Результат буде виведено у зручному для читанні вигляді. Його не призначено
для програмної обробки.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.26)
.SS "guestfs_sfdisk_kernel_geometry"
.IX Subsection "guestfs_sfdisk_kernel_geometry"
.Vb 3
\& char *
\& guestfs_sfdisk_kernel_geometry (guestfs_h *g,
\&                                 const char *device);
.Ve
.PP
Ця команда показує визначені ядром дані щодо геометрії пристрою \f(CW\*(C`пристрій\*(C'\fR.
.PP
Результат буде виведено у зручному для читанні вигляді. Його не призначено
для програмної обробки.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.26)
.SS "guestfs_sfdisk_l"
.IX Subsection "guestfs_sfdisk_l"
.Vb 3
\& char *
\& guestfs_sfdisk_l (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_part_list\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда виводить таблицю розділів на пристрої \f(CW\*(C`пристрій\*(C'\fR у зручному для
читання форматі даних, виведених командою \fBsfdisk\fR\|(8). Ці дані не
призначено для програмної обробки.
.PP
Див. також \f(CW\*(C`guestfs_part_list\*(C'\fR
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.26)
.SS "guestfs_sh"
.IX Subsection "guestfs_sh"
.Vb 3
\& char *
\& guestfs_sh (guestfs_h *g,
\&             const char *command);
.Ve
.PP
Ця команда виконує програму з гостьової системи за допомогою \fI/bin/sh\fR
гостьової системи.
.PP
Подібна до \f(CW\*(C`guestfs_command\*(C'\fR, але передає команду так:
.PP
.Vb 1
\& /bin/sh \-c "команда"
.Ve
.PP
Залежно від командної оболонки гостьової системи, зазвичай, це призводить до
розгортання символів\-замінників, обробки виразів командної оболонки тощо.
.PP
Усі зауваження щодо \f(CW\*(C`guestfs_command\*(C'\fR стосуються і цього виклику.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.50)
.SS "guestfs_sh_lines"
.IX Subsection "guestfs_sh_lines"
.Vb 3
\& char **
\& guestfs_sh_lines (guestfs_h *g,
\&                   const char *command);
.Ve
.PP
Те саме, що і \f(CW\*(C`guestfs_sh\*(C'\fR, але результат буде поділено на список рядків.
.PP
Див. також \f(CW\*(C`guestfs_command_lines\*(C'\fR
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.50)
.SS "guestfs_shutdown"
.IX Subsection "guestfs_shutdown"
.Vb 2
\& int
\& guestfs_shutdown (guestfs_h *g);
.Ve
.PP
Протилежність команди \f(CW\*(C`guestfs_launch\*(C'\fR. Виконує упорядковане вимикання
процесів модуля обробки. Якщо встановлено прапорець autosync (типова
поведінка), буде синхронізовано образ диска.
.PP
Якщо підпроцес завершує роботу із помилкою, ця функція поверне повідомлення
про помилку, яке \fIне\fR слід ігнорувати (воно може свідчити про те, що
належний запис до образу диска неможливий).
.PP
Команду можна безпечно викликати довільну кількість разів. Усі зайві виклики
буде просто проігноровано.
.PP
Ця команда \fIне\fR закриває і не звільняє дескриптор. Вам слід викликати
\&\f(CW\*(C`guestfs_close\*(C'\fR після її виконання.
.PP
\&\f(CW\*(C`guestfs_close\*(C'\fR викличе цю команду, якщо ви не зробите цього явно, але,
слід зауважити, що усі помилки у цьому випадку буде проігноровано.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.19.16)
.SS "guestfs_sleep"
.IX Subsection "guestfs_sleep"
.Vb 3
\& int
\& guestfs_sleep (guestfs_h *g,
\&                int secs);
.Ve
.PP
Призупинити обробку на \f(CW\*(C`час_у_секундах\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.41)
.SS "guestfs_stat"
.IX Subsection "guestfs_stat"
.Vb 3
\& struct guestfs_stat *
\& guestfs_stat (guestfs_h *g,
\&               const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_statns\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Повертає дані щодо файла за вказаним шляхом \f(CW\*(C`шлях\*(C'\fR.
.PP
Це те саме, що системний виклик \fBstat\fR\|(2).
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_stat *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_stat\*(C'\fI\fR.
.PP
(Додано у 1.9.2)
.SS "guestfs_statns"
.IX Subsection "guestfs_statns"
.Vb 3
\& struct guestfs_statns *
\& guestfs_statns (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
Повертає дані щодо файла за вказаним шляхом \f(CW\*(C`шлях\*(C'\fR.
.PP
Це те саме, що системний виклик \fBstat\fR\|(2).
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_statns *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_statns\*(C'\fI\fR.
.PP
(Додано у 1.27.53)
.SS "guestfs_statvfs"
.IX Subsection "guestfs_statvfs"
.Vb 3
\& struct guestfs_statvfs *
\& guestfs_statvfs (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Повертає статистику файлової системи для будь\-якої змонтованої файлової
системи. Параметр \f(CW\*(C`шлях\*(C'\fR має визначати файл або каталог у змонтованій
файловій системі (типово, це сама точка монтування, але не обов'язково саме
вона).
.PP
Це те саме, що системний виклик \fBstatvfs\fR\|(2).
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_statvfs *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_statvfs\*(C'\fI\fR.
.PP
(Додано у 1.9.2)
.SS "guestfs_strings"
.IX Subsection "guestfs_strings"
.Vb 3
\& char **
\& guestfs_strings (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Виконує програму \fBstrings\fR\|(1) для файла і повертає список знайдених у ньому
придатних до друку рядків.
.PP
У минулому у команди \f(CW\*(C`strings\*(C'\fR були проблеми із обробкою файлів, отриманих
від ненадійних джерел. Ці проблеми усунуто у поточній версії libguestfs,
втім, див. \*(L"\s-1CVE\-2014\-8484\*(R"\s0.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.22)
.SS "guestfs_strings_e"
.IX Subsection "guestfs_strings_e"
.Vb 4
\& char **
\& guestfs_strings_e (guestfs_h *g,
\&                    const char *encoding,
\&                    const char *path);
.Ve
.PP
Ця команда подібна до команди \f(CW\*(C`guestfs_strings\*(C'\fR, але надає вам змогу
вказати кодування рядків, які ви шукаєте у файлі даних \f(CW\*(C`path\*(C'\fR.
.PP
Можливими кодуваннями є:
.IP "s" 4
.IX Item "s"
Одинарні 7\-бітові символи, зокрема \s-1ASCII\s0 та сумісні із \s-1ASCII\s0 частини
\&\s-1ISO\-8859\-X\s0 (це кодування використовує \f(CW\*(C`guestfs_strings\*(C'\fR).
.IP "S" 4
.IX Item "S"
Окремі 8\-бітові\-байтові символи.
.IP "b" 4
.IX Item "b"
16\-бітове зі зворотним порядком байтів, зокрема рядки у кодуваннях \s-1UTF\-16BE\s0
та \s-1UCS\-2BE.\s0
.IP "l (мала літера L)" 4
.IX Item "l (мала літера L)"
16\-бітове із прямим порядком байтів, зокрема \s-1UTF\-16LE\s0 і \s-1UCS\-2LE.\s0 Корисно для
вивчення двійкових файлів у гостьових системах Windows.
.IP "B" 4
.IX Item "B"
32\-бітове зі зворотним порядком байтів, зокрема \s-1UCS\-4LE.\s0
.IP "L" 4
.IX Item "L"
32\-бітове із прямим порядком байтів, зокрема \s-1UCS\-4LE.\s0
.PP
Повернуті рядки буде перекодовано до \s-1UTF\-8.\s0
.PP
У минулому у команди \f(CW\*(C`strings\*(C'\fR були проблеми із обробкою файлів, отриманих
від ненадійних джерел. Ці проблеми усунуто у поточній версії libguestfs,
втім, див. \*(L"\s-1CVE\-2014\-8484\*(R"\s0.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.22)
.SS "guestfs_swapoff_device"
.IX Subsection "guestfs_swapoff_device"
.Vb 3
\& int
\& guestfs_swapoff_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Ця команда вимикає резервну пам'ять на диску або розділ із назвою \f(CW\*(C`device\*(C'\fR
у базовій системі libguestfs. Див. \f(CW\*(C`guestfs_swapon_device\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_swapoff_file"
.IX Subsection "guestfs_swapoff_file"
.Vb 3
\& int
\& guestfs_swapoff_file (guestfs_h *g,
\&                       const char *file);
.Ve
.PP
Ця команда вимикає резервну пам'ять у файлі для базової системи libguestfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_swapoff_label"
.IX Subsection "guestfs_swapoff_label"
.Vb 3
\& int
\& guestfs_swapoff_label (guestfs_h *g,
\&                        const char *label);
.Ve
.PP
Ця команда вимикає резервну пам'ять на диску у базовій системі libguestfs на
вказаному за міткою розділі резервної пам'яті.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_swapoff_uuid"
.IX Subsection "guestfs_swapoff_uuid"
.Vb 3
\& int
\& guestfs_swapoff_uuid (guestfs_h *g,
\&                       const char *uuid);
.Ve
.PP
Ця команда вимикає резервну пам'ять на диску у базовій системі libguestfs на
вказаному розділі із вказаним \s-1UUID.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxfsuuid\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_swapon_device"
.IX Subsection "guestfs_swapon_device"
.Vb 3
\& int
\& guestfs_swapon_device (guestfs_h *g,
\&                        const char *device);
.Ve
.PP
Ця команда вмикає резервну пам'ять на диску або розділ із назвою \f(CW\*(C`device\*(C'\fR у
базовій системі libguestfs. Збільшений обсяг пам'яті стає доступним для усіх
команд, зокрема тих, які запускаються за допомогою  \f(CW\*(C`guestfs_command\*(C'\fR або
\&\f(CW\*(C`guestfs_sh\*(C'\fR.
.PP
Зауважте, що вам не варто створювати резервну пам'ять на наявних розділах
резервної пам'яті гостьової системи, якщо ви не впевнені у правильності
своїх дій. На цих розділах можуть міститися дані режиму присипляння системи
або інші дані, які не варто втрачати. Також подібні дії можуть призвести до
небажаного доступу до конфіденційних даних у гостьовій системі. Замість
цього, долучіть до гостьової системи новий пристрій основної системи і
організовуйте резервну пам'ять на ньому.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_swapon_file"
.IX Subsection "guestfs_swapon_file"
.Vb 3
\& int
\& guestfs_swapon_file (guestfs_h *g,
\&                      const char *file);
.Ve
.PP
Ця команда вмикає резервну пам'ять у файлі. Зауваження щодо її використання
є такими самими, що і для \f(CW\*(C`guestfs_swapon_device\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_swapon_label"
.IX Subsection "guestfs_swapon_label"
.Vb 3
\& int
\& guestfs_swapon_label (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
Ця команда вмикає резервну пам'ять на вказаному за міткою розділі резервної
пам'яті. Зауваження щодо її використання є такими самими, що і для
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.66)
.SS "guestfs_swapon_uuid"
.IX Subsection "guestfs_swapon_uuid"
.Vb 3
\& int
\& guestfs_swapon_uuid (guestfs_h *g,
\&                      const char *uuid);
.Ve
.PP
Ця команда вмикає резервну пам'ять на розділі резервної пам'яті, вказаному
за \s-1UUID.\s0 Зауваження щодо її використання є такими самими, що і для
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості
\&\f(CW\*(C`linuxfsuuid\*(C'\fR. Див. також \*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_sync"
.IX Subsection "guestfs_sync"
.Vb 2
\& int
\& guestfs_sync (guestfs_h *g);
.Ve
.PP
Ця команда виконує синхронізацію диска. Усі буфери даних записуються на
базовий образ диска.
.PP
Вам завжди слід викликати цю команду, якщо ви вносили зміни до образу диска,
перед закриттям дескриптора.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_syslinux"
.IX Subsection "guestfs_syslinux"
.Vb 4
\& int
\& guestfs_syslinux (guestfs_h *g,
\&                   const char *device,
\&                   ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_SYSLINUX_DIRECTORY, const char *directory,
.Ve
.PP
Встановлює завантажувач \s-1SYSLINUX\s0 на \f(CW\*(C`пристрій\*(C'\fR.
.PP
Значенням параметра пристрою має бути або увесь диск, форматований у файлову
систему \s-1FAT,\s0 або розділ диска, форматований у файлову систему \s-1FAT.\s0 У
останньому випадку, розділ має бути позначено як «активний»
(\f(CW\*(C`guestfs_part_set_bootable\*(C'\fR), а на перший сектор усього диска має бути
встановлено \s-1MBR\s0 (наприклад, за допомогою \f(CW\*(C`guestfs_pwrite_device\*(C'\fR). До
пакунка \s-1SYSLINUX\s0 включено деякі найпоширеніші варіанти \s-1MBR.\s0 Докладніший опис
можна знайти на сторінці підручника щодо \fBsyslinux\fR\|(1).
.PP
Необов'язковими аргументами є:
.IP "\fIdirectory\fR" 4
.IX Item "directory"
Встановити \s-1SYSLINUX\s0 до вказаного за назвою підкаталогу, замість кореневого
каталогу файлової системи \s-1FAT.\s0
.PP
Додатково налаштувати \s-1SYSLINUX\s0 можна за допомогою файла із назвою
\&\fIsyslinux.cfg\fR на файловій системі \s-1FAT,\s0 у кореневому каталозі або у
каталозі файлової системи \fIкаталог\fR, якщо використано необов'язковий
аргумент команди. Докладніше про це та вміст файла можна дізнатися зі
сторінки підручника \fBsyslinux\fR\|(1).
.PP
Див. також \f(CW\*(C`guestfs_extlinux\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`syslinux\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.21.27)
.SS "guestfs_syslinux_va"
.IX Subsection "guestfs_syslinux_va"
.Vb 4
\& int
\& guestfs_syslinux_va (guestfs_h *g,
\&                      const char *device,
\&                      va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_syslinux\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_syslinux_argv"
.IX Subsection "guestfs_syslinux_argv"
.Vb 4
\& int
\& guestfs_syslinux_argv (guestfs_h *g,
\&                        const char *device,
\&                        const struct guestfs_syslinux_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_syslinux\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tail"
.IX Subsection "guestfs_tail"
.Vb 3
\& char **
\& guestfs_tail (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Ця команда повертає останні 10 рядків файла у форматі списку рядків.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.54)
.SS "guestfs_tail_n"
.IX Subsection "guestfs_tail_n"
.Vb 4
\& char **
\& guestfs_tail_n (guestfs_h *g,
\&                 int nrlines,
\&                 const char *path);
.Ve
.PP
Якщо параметр \f(CW\*(C`к\-ть_рядків\*(C'\fR є додатним числом, повертає останні
\&\f(CW\*(C`к\-ть_рядків\*(C'\fR рядків з файла \f(CW\*(C`шлях\*(C'\fR.
.PP
Якщо значенням параметра \f(CW\*(C`к\-ть_рядків\*(C'\fR є від'ємне число, команда повертає
рядки з файла \f(CW\*(C`шлях\*(C'\fR, починаючи з рядка \f(CW\*(C`\-к\-ть_рядків\*(C'\fR.
.PP
Якщо значенням параметра \f(CW\*(C`к\-ть_рядків\*(C'\fR є нуль, команда повертає порожній
список.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.54)
.SS "guestfs_tar_in"
.IX Subsection "guestfs_tar_in"
.Vb 4
\& int
\& guestfs_tar_in (guestfs_h *g,
\&                 const char *tarfile,
\&                 const char *directory);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_tar_in_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.0.3)
.SS "guestfs_tar_in_opts"
.IX Subsection "guestfs_tar_in_opts"
.Vb 5
\& int
\& guestfs_tar_in_opts (guestfs_h *g,
\&                      const char *tarfile,
\&                      const char *directory,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 4
\& GUESTFS_TAR_IN_OPTS_COMPRESS, const char *compress,
\& GUESTFS_TAR_IN_OPTS_XATTRS, int xattrs,
\& GUESTFS_TAR_IN_OPTS_SELINUX, int selinux,
\& GUESTFS_TAR_IN_OPTS_ACLS, int acls,
.Ve
.PP
Ця команда вивантажує і розпаковує локальний файл \f(CW\*(C`файл_tar\*(C'\fR до каталогу
\&\fIкаталог\fR.
.PP
Необов'язковий прапорець \f(CW\*(C`compress\*(C'\fR керує стисканням. Якщо його не вказано,
вхідні дані мають бути простим, нестисненим файлом tar. Ви також можете
вказати такі рядки для вибору типу стискання: \f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR,
\&\f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR, \f(CW\*(C`lzop\*(C'\fR. (Зауважте, що підтримку усіх цих типів стискання
передбачено не в усіх зібраних пакунках libguestfs).
.PP
Іншими необов'язковими параметрами є такі:
.ie n .IP """xattrs""" 4
.el .IP "\f(CWxattrs\fR" 4
.IX Item "xattrs"
Якщо встановлено значення true, розширені атрибути відновлюватимуться з
файла tar.
.ie n .IP """selinux""" 4
.el .IP "\f(CWselinux\fR" 4
.IX Item "selinux"
Якщо встановлено значення true, контекст SELinux відновлюватиметься з файла
tar.
.ie n .IP """acls""" 4
.el .IP "\f(CWacls\fR" 4
.IX Item "acls"
Якщо встановлено значення true, з файла tar відновлюватимуться \s-1ACL POSIX.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.3)
.SS "guestfs_tar_in_opts_va"
.IX Subsection "guestfs_tar_in_opts_va"
.Vb 5
\& int
\& guestfs_tar_in_opts_va (guestfs_h *g,
\&                         const char *tarfile,
\&                         const char *directory,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_tar_in_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tar_in_opts_argv"
.IX Subsection "guestfs_tar_in_opts_argv"
.Vb 5
\& int
\& guestfs_tar_in_opts_argv (guestfs_h *g,
\&                           const char *tarfile,
\&                           const char *directory,
\&                           const struct guestfs_tar_in_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_tar_in_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tar_out"
.IX Subsection "guestfs_tar_out"
.Vb 4
\& int
\& guestfs_tar_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarfile);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_tar_out_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 1.0.3)
.SS "guestfs_tar_out_opts"
.IX Subsection "guestfs_tar_out_opts"
.Vb 5
\& int
\& guestfs_tar_out_opts (guestfs_h *g,
\&                       const char *directory,
\&                       const char *tarfile,
\&                       ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 6
\& GUESTFS_TAR_OUT_OPTS_COMPRESS, const char *compress,
\& GUESTFS_TAR_OUT_OPTS_NUMERICOWNER, int numericowner,
\& GUESTFS_TAR_OUT_OPTS_EXCLUDES, char *const *excludes,
\& GUESTFS_TAR_OUT_OPTS_XATTRS, int xattrs,
\& GUESTFS_TAR_OUT_OPTS_SELINUX, int selinux,
\& GUESTFS_TAR_OUT_OPTS_ACLS, int acls,
.Ve
.PP
Ця команда пакує вміст каталогу \fIкаталог\fR отримує його до локального файла
\&\f(CW\*(C`файл_tar\*(C'\fR.
.PP
Необов'язковий прапорець \f(CW\*(C`compress\*(C'\fR керує стисканням. Якщо його не вказано,
вихідні дані будуть простим, нестисненим файлом tar. Ви також можете вказати
такі рядки для вибору типу стискання: \f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR,
\&\f(CW\*(C`lzop\*(C'\fR. (Зауважте, що підтримку усіх цих типів стискання передбачено не в
усіх зібраних пакунках libguestfs).
.PP
Іншими необов'язковими параметрами є такі:
.ie n .IP """excludes""" 4
.el .IP "\f(CWexcludes\fR" 4
.IX Item "excludes"
Список шаблонів. Файли буде виключено, якщо вони відповідатимуть якомусь із
вказаних шаблонів.
.ie n .IP """numericowner""" 4
.el .IP "\f(CWnumericowner\fR" 4
.IX Item "numericowner"
Якщо встановлено значення true, у виведеному файлі tar міститимуться номери
\&\s-1UID/GID\s0 замість назв записів користувачів і груп.
.ie n .IP """xattrs""" 4
.el .IP "\f(CWxattrs\fR" 4
.IX Item "xattrs"
Якщо встановлено значення true, у виведеному файлі tar зберігатимуться
розширені атрибути.
.ie n .IP """selinux""" 4
.el .IP "\f(CWselinux\fR" 4
.IX Item "selinux"
Якщо встановлено значення true, у виведеному файлі tar зберігатимуться
контексти SELinux.
.ie n .IP """acls""" 4
.el .IP "\f(CWacls\fR" 4
.IX Item "acls"
Якщо встановлено значення true, у виведеному файлі tar зберігатимуться \s-1ACL
POSIX.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.3)
.SS "guestfs_tar_out_opts_va"
.IX Subsection "guestfs_tar_out_opts_va"
.Vb 5
\& int
\& guestfs_tar_out_opts_va (guestfs_h *g,
\&                          const char *directory,
\&                          const char *tarfile,
\&                          va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_tar_out_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tar_out_opts_argv"
.IX Subsection "guestfs_tar_out_opts_argv"
.Vb 5
\& int
\& guestfs_tar_out_opts_argv (guestfs_h *g,
\&                            const char *directory,
\&                            const char *tarfile,
\&                            const struct guestfs_tar_out_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_tar_out_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tgz_in"
.IX Subsection "guestfs_tgz_in"
.Vb 4
\& int
\& guestfs_tgz_in (guestfs_h *g,
\&                 const char *tarball,
\&                 const char *directory);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_tar_in\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда вивантажує і розпаковує локальний файл \f(CW\*(C`архів_tar\*(C'\fR (\fIстиснений
gzip\fR файл tar) до каталогу \fIкаталог\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.3)
.SS "guestfs_tgz_out"
.IX Subsection "guestfs_tgz_out"
.Vb 4
\& int
\& guestfs_tgz_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarball);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_tar_out\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда пакує вміст каталогу \fIкаталог\fR отримує його до локального файла
\&\f(CW\*(C`архів_tar\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.3)
.SS "guestfs_touch"
.IX Subsection "guestfs_touch"
.Vb 3
\& int
\& guestfs_touch (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Touch працює як команда \fBtouch\fR\|(1). Цією командою можна скористатися для
оновлення часових позначок файла або, якщо файла не існує, створення нового
файла нульової довжини.
.PP
Ця команда працює лише для звичайних файлів і завершує роботу повідомленням
про помилку, якщо її використовують для інших об'єктів файлової системи,
зокрема каталогів, символічних посилань, спеціальних блоків.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_truncate"
.IX Subsection "guestfs_truncate"
.Vb 3
\& int
\& guestfs_truncate (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
Ця команда обрізає файл \f(CW\*(C`шлях\*(C'\fR до нульової довжини. Для її успішного
виконання файл має існувати.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_truncate_size"
.IX Subsection "guestfs_truncate_size"
.Vb 4
\& int
\& guestfs_truncate_size (guestfs_h *g,
\&                        const char *path,
\&                        int64_t size);
.Ve
.PP
Ця команда обрізає файл \f(CW\*(C`шлях\*(C'\fR до розміру у \f(CW\*(C`розмір\*(C'\fR байтів. Для її
успішного виконання файл має існувати.
.PP
Якщо поточний розмір файла є меншим за \f(CW\*(C`розмір\*(C'\fR, файл буде розширено до
вказаного розміру доповненням його вмісту нульовими байтами. Команда створює
розріджений файл (тобто блоки диска не розподіляються під файл, доки ви не
виконаєте запис до нього). Для створення файла заповненого нулями, який не
буде розрідженим, скористайтеся командою \f(CW\*(C`guestfs_fallocate64\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_tune2fs"
.IX Subsection "guestfs_tune2fs"
.Vb 4
\& int
\& guestfs_tune2fs (guestfs_h *g,
\&                  const char *device,
\&                  ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 10
\& GUESTFS_TUNE2FS_FORCE, int force,
\& GUESTFS_TUNE2FS_MAXMOUNTCOUNT, int maxmountcount,
\& GUESTFS_TUNE2FS_MOUNTCOUNT, int mountcount,
\& GUESTFS_TUNE2FS_ERRORBEHAVIOR, const char *errorbehavior,
\& GUESTFS_TUNE2FS_GROUP, int64_t group,
\& GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS, int intervalbetweenchecks,
\& GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
\& GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY, const char *lastmounteddirectory,
\& GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT, int64_t reservedblockscount,
\& GUESTFS_TUNE2FS_USER, int64_t user,
.Ve
.PP
За допомогою цієї команди ви можете скоригувати різноманітні параметри
файлової системи ext2/ext3/ext4 із назвою \f(CW\*(C`пристрій\*(C'\fR.
.PP
Додатковими параметрами є:
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
Змусити tune2fs завершити виконання дії, навіть якщо буде виявлено
помилки. Те саме, що і параметр \f(CW\*(C`\-f\*(C'\fR у tune2fs.
.ie n .IP """maxmountcount""" 4
.el .IP "\f(CWmaxmountcount\fR" 4
.IX Item "maxmountcount"
Встановлює кількість монтувань, за досягнення якої файлова система
перевіряється за допомогою \fBe2fsck\fR\|(8). Якщо встановлено значення \f(CW0\fR,
кількість монтувань не братиметься до уваги. Те саме, що і параметр \f(CW\*(C`\-c\*(C'\fR
tune2fs.
.ie n .IP """mountcount""" 4
.el .IP "\f(CWmountcount\fR" 4
.IX Item "mountcount"
Встановлює кількість монтувань файлової системи. Те саме, що і параметр
\&\f(CW\*(C`\-C\*(C'\fR tune2fs.
.ie n .IP """errorbehavior""" 4
.el .IP "\f(CWerrorbehavior\fR" 4
.IX Item "errorbehavior"
Змінює поведінку коду ядра, якщо стануться помилки. Можливі значення у
поточній версії: \f(CW\*(C`continue\*(C'\fR, \f(CW\*(C`remount\-ro\*(C'\fR, \f(CW\*(C`panic\*(C'\fR. На практиці,
відмінність між цими варіантами є незначною, зокрема при появі помилок
запису.
.Sp
Те саме, що і параметр \f(CW\*(C`\-e\*(C'\fR у tune2fs.
.ie n .IP """group""" 4
.el .IP "\f(CWgroup\fR" 4
.IX Item "group"
Встановлює групу, яка може використовувати зарезервовані блоки файлової
системи. Те саме, що і параметр \f(CW\*(C`\-g\*(C'\fR tune2fs, але групу тут можна вказати
лише за номером.
.ie n .IP """intervalbetweenchecks""" 4
.el .IP "\f(CWintervalbetweenchecks\fR" 4
.IX Item "intervalbetweenchecks"
Коригує максимальний час між двома послідовними перевірками файлової системи
(у секундах). Якщо буде передано значення \f(CW0\fR, залежність перевірок від
часу буде вимкнено.
.Sp
Те саме, що і параметр \f(CW\*(C`\-i\*(C'\fR у tune2fs.
.ie n .IP """reservedblockspercentage""" 4
.el .IP "\f(CWreservedblockspercentage\fR" 4
.IX Item "reservedblockspercentage"
Встановлює частку у відсотках файлової системи, яку може бути розподілено
привілейованими процесами. Те саме, що і параметр \f(CW\*(C`\-m\*(C'\fR tune2fs.
.ie n .IP """lastmounteddirectory""" 4
.el .IP "\f(CWlastmounteddirectory\fR" 4
.IX Item "lastmounteddirectory"
Встановлює останній змонтований каталог. Те саме, що і параметр \f(CW\*(C`\-M\*(C'\fR
tune2fs.
.ie n .IP """reservedblockscount"" Встановлює кількість зарезервованих блоків файлової системи. Те саме, що і параметр ""\-r"" tune2fs." 4
.el .IP "\f(CWreservedblockscount\fR Встановлює кількість зарезервованих блоків файлової системи. Те саме, що і параметр \f(CW\-r\fR tune2fs." 4
.IX Item "reservedblockscount Встановлює кількість зарезервованих блоків файлової системи. Те саме, що і параметр -r tune2fs."
.PD 0
.ie n .IP """user""" 4
.el .IP "\f(CWuser\fR" 4
.IX Item "user"
.PD
Встановлює користувача, який може використовувати зарезервовані блоки
файлової системи. Те саме, що і параметр \f(CW\*(C`\-u\*(C'\fR tune2fs, але користувача тут
можна вказати лише за номером.
.PP
Якщо вам потрібно отримати поточні значення параметрів файлової системи,
скористайтеся \f(CW\*(C`guestfs_tune2fs_l\*(C'\fR. Докладний опис роботи tune2fs наведено
на сторінці підручника \fBtune2fs\fR\|(8).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.15.4)
.SS "guestfs_tune2fs_va"
.IX Subsection "guestfs_tune2fs_va"
.Vb 4
\& int
\& guestfs_tune2fs_va (guestfs_h *g,
\&                     const char *device,
\&                     va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_tune2fs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tune2fs_argv"
.IX Subsection "guestfs_tune2fs_argv"
.Vb 4
\& int
\& guestfs_tune2fs_argv (guestfs_h *g,
\&                       const char *device,
\&                       const struct guestfs_tune2fs_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_tune2fs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_tune2fs_l"
.IX Subsection "guestfs_tune2fs_l"
.Vb 3
\& char **
\& guestfs_tune2fs_l (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
Ця команда повертає вміст суперблоку файлової системи ext2, ext3 або ext4 на
пристрої \f(CW\*(C`пристрій\*(C'\fR.
.PP
Результат буде таким самим як результат виконання команди \f(CW\*(C`tune2fs \-l
пристрій\*(C'\fR. Див. сторінку підручника \fBtune2fs\fR\|(8), щоб дізнатися
більше. Список повернутих полів не є точно визначеним і залежить від версії
\&\f(CW\*(C`tune2fs\*(C'\fR, з якою було зібрано libguestfs, та самої файлової системи.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. Масив рядків завжди матиме
довжину \f(CW\*(C`2n+1\*(C'\fR, значення \f(CW\*(C`n\*(C'\fR ключів і значень йтимуть одне за одним
послідовно, завершуючись кінцевим записом \s-1NULL.\s0 \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.9.2)
.SS "guestfs_txz_in"
.IX Subsection "guestfs_txz_in"
.Vb 4
\& int
\& guestfs_txz_in (guestfs_h *g,
\&                 const char *tarball,
\&                 const char *directory);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_tar_in\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда вивантажує і розпаковує локальний файл \f(CW\*(C`архів_tar\*(C'\fR (\fIстиснений
xz\fR файл tar) до каталогу \fIкаталог\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`xz\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.3.2)
.SS "guestfs_txz_out"
.IX Subsection "guestfs_txz_out"
.Vb 4
\& int
\& guestfs_txz_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarball);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_tar_out\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда пакує вміст каталогу \fIкаталог\fR отримує його до локального файла
\&\f(CW\*(C`архів_tar\*(C'\fR (у форматі стисненого xz архіву tar).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`xz\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.3.2)
.SS "guestfs_umask"
.IX Subsection "guestfs_umask"
.Vb 3
\& int
\& guestfs_umask (guestfs_h *g,
\&                int mask);
.Ve
.PP
Ця функція встановлює маску, яка використовується для створення нових файлів
і вузлів пристрою, у значення \f(CW\*(C`mask & 0777\*(C'\fR.
.PP
Типовими значеннями umask мають бути \f(CW022\fR, використання якої призводить до
прав доступу «\-rw\-r\*(--r\-\-» або «\-rwxr\-xr\-x», та \f(CW002\fR, використання якої
призводить до прав доступу «\-rw\-rw\-r\-\-» або «\-rwxrwxr\-x».
.PP
Типовим значенням umask є \f(CW022\fR. Це важливо, оскільки означає, що каталоги
і вузли пристрою створюватимуться із правами доступу \f(CW0644\fR або \f(CW0755\fR,
навіть якщо ви вкажете права доступу \f(CW0777\fR.
.PP
Див. також \f(CW\*(C`guestfs_get_umask\*(C'\fR, \fBumask\fR\|(2), \f(CW\*(C`guestfs_mknod\*(C'\fR,
\&\f(CW\*(C`guestfs_mkdir\*(C'\fR.
.PP
Цей виклик повертає попередню umask.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.55)
.SS "guestfs_umount"
.IX Subsection "guestfs_umount"
.Vb 3
\& int
\& guestfs_umount (guestfs_h *g,
\&                 const char *pathordevice);
.Ve
.PP
Цю функцію реалізовано для зворотної сумісності із ранішими версіями
libguestfs. Вона просто викликає \*(L"guestfs_umount_opts\*(R" без додаткових
аргументів.
.PP
(Додано у 0.8)
.SS "guestfs_umount_opts"
.IX Subsection "guestfs_umount_opts"
.Vb 4
\& int
\& guestfs_umount_opts (guestfs_h *g,
\&                      const char *pathordevice,
\&                      ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 2
\& GUESTFS_UMOUNT_OPTS_FORCE, int force,
\& GUESTFS_UMOUNT_OPTS_LAZYUNMOUNT, int lazyunmount,
.Ve
.PP
Ця команда демонтує вказану файлову систему. Файлову систему можна вказати
або як точку монтування (шлях) або як пристрій, на якому міститься файлова
система.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_umount_opts_va"
.IX Subsection "guestfs_umount_opts_va"
.Vb 4
\& int
\& guestfs_umount_opts_va (guestfs_h *g,
\&                         const char *pathordevice,
\&                         va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_umount_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_umount_opts_argv"
.IX Subsection "guestfs_umount_opts_argv"
.Vb 4
\& int
\& guestfs_umount_opts_argv (guestfs_h *g,
\&                           const char *pathordevice,
\&                           const struct guestfs_umount_opts_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_umount_opts\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_umount_all"
.IX Subsection "guestfs_umount_all"
.Vb 2
\& int
\& guestfs_umount_all (guestfs_h *g);
.Ve
.PP
Демонтує усі змонтовані файлові системи.
.PP
Деякі із внутрішніх монтувань не демонтуються цим викликом.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.8)
.SS "guestfs_umount_local"
.IX Subsection "guestfs_umount_local"
.Vb 3
\& int
\& guestfs_umount_local (guestfs_h *g,
\&                       ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 1
\& GUESTFS_UMOUNT_LOCAL_RETRY, int retry,
.Ve
.PP
Якщо libguestfs експортує файлову систему на локальну точку монтування, цей
виклик демонтує її.
.PP
Із повною документацією можна ознайомитися у розділі \*(L"ЛОКАЛЬНЕ
МОНТУВАННЯ\*(R".
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.17.22)
.SS "guestfs_umount_local_va"
.IX Subsection "guestfs_umount_local_va"
.Vb 3
\& int
\& guestfs_umount_local_va (guestfs_h *g,
\&                          va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_umount_local\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_umount_local_argv"
.IX Subsection "guestfs_umount_local_argv"
.Vb 3
\& int
\& guestfs_umount_local_argv (guestfs_h *g,
\&                            const struct guestfs_umount_local_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_umount_local\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_upload"
.IX Subsection "guestfs_upload"
.Vb 4
\& int
\& guestfs_upload (guestfs_h *g,
\&                 const char *filename,
\&                 const char *remotefilename);
.Ve
.PP
Вивантажує локальний файл \fIназва_файла\fR до віддаленого файла
\&\fIназва_віддаленого_файла\fR у файловій системі.
.PP
Значенням параметра \fIназва_файла\fR також може бути іменований канал обробки
даних.
.PP
Див. також \f(CW\*(C`guestfs_download\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.0.2)
.SS "guestfs_upload_offset"
.IX Subsection "guestfs_upload_offset"
.Vb 5
\& int
\& guestfs_upload_offset (guestfs_h *g,
\&                        const char *filename,
\&                        const char *remotefilename,
\&                        int64_t offset);
.Ve
.PP
Вивантажує локальний файл \fIназва_файла\fR до віддаленого файла
\&\fIназва_віддаленого_файла\fR у файловій системі.
.PP
Віддалений файл \fIназва_віддаленого_файла\fR буде перезаписано, починаючи з
байта \f(CW\*(C`відступ\*(C'\fR. Призначенням команди є перезапис частин наявних файлів або
пристроїв, хоча, якщо буде задано файл, якого не існує, команда створить
його із «діркою» до байта \f(CW\*(C`відступ\*(C'\fR. Розмір записаних даних неявним чином
визначається розміром файла\-джерела \fIназва_файла\fR.
.PP
Зауважте, що немає обмеження на обсяг даних, які може бути вивантажено за
допомогою цього виклику, на відміну від команди \f(CW\*(C`guestfs_pwrite\*(C'\fR, і цей
виклик завжди записує дані до кінця, якщо не станеться помилки.
.PP
Див. також \f(CW\*(C`guestfs_upload\*(C'\fR, \f(CW\*(C`guestfs_pwrite\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.5.17)
.SS "guestfs_user_cancel"
.IX Subsection "guestfs_user_cancel"
.Vb 2
\& int
\& guestfs_user_cancel (guestfs_h *g);
.Ve
.PP
За допомогою цієї функції можна скасувати поточну дію із отримання або
вивантаження даних.
.PP
На відміну від більшості інших викликів libguestfs, цю функцію захищено від
сигналів та потоків обробки. Ви можете викликати її із обробника сигналів
або іншого потоку обробки без потреби у блокуванні хоч чогось.
.PP
Передавання даних, яке не було завершено (якщо таке існує), буде зупинено
невдовзі після виконання цієї команди, і буде повернуто повідомлення про
помилку. Для errno (див. \*(L"guestfs_last_errno\*(R") буде встановлено значення
\&\f(CW\*(C`EINTR\*(C'\fR, отже ви можете просто перевірити це значення, щоб визначити дію,
яку було скасовано або яка завершилася помилкою через інші причини.
.PP
Чищення після виконання команди не виконуватиметься. Наприклад, якщо на
момент скасовування виконувалося вивантаження файла, результатом буде
частково вивантажений файл. Про належне чищення має подбати функція, з якої
було викликано команду.
.PP
Існує два типових місця, звідки ви варто викликати \f(CW\*(C`guestfs_user_cancel\*(C'\fR:
.PP
У інтерактивній текстовій програмі ви можете викликати функцію із обробника
сигналу \f(CW\*(C`SIGINT\*(C'\fR, щоб натискання комбінації клавіш \f(CW\*(C`^C\*(C'\fR скасовувало
поточну дію. (Вам також слід викликати \*(L"guestfs_set_pgroup\*(R", щоб дочірні
процеси не отримували сигналу \f(CW\*(C`^C\*(C'\fR).
.PP
У графічних програмах, якщо основний потік обробки даних показує смужку
поступу із кнопкою скасовування дії, подію натискання кнопки скасовування
дії слід пов'язувати із викликом цієї функції.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.18)
.SS "guestfs_utimens"
.IX Subsection "guestfs_utimens"
.Vb 7
\& int
\& guestfs_utimens (guestfs_h *g,
\&                  const char *path,
\&                  int64_t atsecs,
\&                  int64_t atnsecs,
\&                  int64_t mtsecs,
\&                  int64_t mtnsecs);
.Ve
.PP
Ця команда встановлює часову позначку для файла з точністю до наносекунди.
.PP
\&\f(CW\*(C`atsecs, atnsecs\*(C'\fR — час останнього доступу (atime) у секундах та
наносекундах від моменту початку епохи.
.PP
\&\f(CW\*(C`mtsecs, mtnsecs\*(C'\fR — час останнього внесення змін (mtime) у секундах та
наносекундах від моменту початку епохи.
.PP
Якщо якесь із полів \f(CW*nsecs\fR містить спеціальне значення \f(CW\*(C`\-1\*(C'\fR, відповідну
часову позначку буде встановлено у поточний момент часу. (У цьому випадку
поле \f(CW*secs\fR буде проігноровано.)
.PP
Якщо якесь із полів \f(CW*nsecs\fR містить спеціальне значення \f(CW\*(C`\-2\*(C'\fR, відповідну
часову позначку не буде змінено. (У цьому випадку поле \f(CW*secs\fR буде
проігноровано.)
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.77)
.SS "guestfs_utsname"
.IX Subsection "guestfs_utsname"
.Vb 2
\& struct guestfs_utsname *
\& guestfs_utsname (guestfs_h *g);
.Ve
.PP
Ця команда повертає версію ядра базової системи, якщо таку версію можна
встановити. Отримані дані корисні лише для діагностики. У повернутій
структурі жодна з частин не визначається програмним інтерфейсом.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_utsname *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_utsname\*(C'\fI\fR.
.PP
(Додано у 1.19.27)
.SS "guestfs_version"
.IX Subsection "guestfs_version"
.Vb 2
\& struct guestfs_version *
\& guestfs_version (guestfs_h *g);
.Ve
.PP
Повертає номер версії libguestfs, з якою скомпоновано програму.
.PP
Зауважте, що через динамічне компонування, це може бути зовсім не та версія
libguestfs, з якою виконувалося збирання. Ви можете зібрати програму, а
потім у динамічному режимі скомпонувати її із зовсім іншою бібліотекою
\&\fIlibguestfs.so\fR.
.PP
Цей виклик було додано у версії \f(CW1.0.58\fR. У попередніх версіях libguestfs
не було можливості отримати номер версії. З коду мовою C ви можете
використовувати функції динамічного компонування для визначення того, чи
існує символ (якщо символу не існує, це давня версія, до версії 1.0.58).
.PP
Цей виклик повертає структуру із чотирьох елементів. Перші три (\f(CW\*(C`major\*(C'\fR,
\&\f(CW\*(C`minor\*(C'\fR і \f(CW\*(C`release\*(C'\fR) є числами, які відповідають звичній трійці частин
версії. Четвертий елемент (\f(CW\*(C`extra\*(C'\fR) є рядком, який зазвичай є порожнім, але
його може бути використано для специфічної для дистрибутива інформації.
.PP
Для побудови початкового рядка версії: \f(CW\*(C`$major.$minor.$release$extra\*(C'\fR
.PP
Див також: \*(L"НУМЕРАЦІЯ ВЕРСІЙ \s-1LIBGUESTFS\*(R"\s0.
.PP
\&\fIЗауваження:\fR не користуйтеся цим викликом для визначення доступності
якихось можливостей. У промислових дистрибутивах ми виконуємо зворотне
портування можливостей з пізніших версій на раніші. Це робить визначення за
версією ненадійною справою. Замість цього, користуйтеся командами
\&\f(CW\*(C`guestfs_available\*(C'\fR і \f(CW\*(C`guestfs_feature_available\*(C'\fR.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_version *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_version\*(C'\fI\fR.
.PP
(Додано у 1.0.58)
.SS "guestfs_vfs_label"
.IX Subsection "guestfs_vfs_label"
.Vb 3
\& char *
\& guestfs_vfs_label (guestfs_h *g,
\&                    const char *mountable);
.Ve
.PP
Повертає мітку файлової системи на розділі \f(CW\*(C`монтований_розділ\*(C'\fR.
.PP
Якщо у файлової системи немає мітки, буде повернуто порожній рядок.
.PP
Пошук файлової системи за міткою можна здійснити за допомогою
\&\f(CW\*(C`guestfs_findfs_label\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.3.18)
.SS "guestfs_vfs_minimum_size"
.IX Subsection "guestfs_vfs_minimum_size"
.Vb 3
\& int64_t
\& guestfs_vfs_minimum_size (guestfs_h *g,
\&                           const char *mountable);
.Ve
.PP
Отримати мінімальний розмір файлової системи у байтах. Це мінімальний
можливий розмір файлової системи після стискання.
.PP
Якщо отримання мінімального розміру для файлової системи не передбачено, ця
команда завершить роботи повідомленням про помилку, встановивши для errno
значення \s-1ENOTSUP.\s0
.PP
Див. також \fBntfsresize\fR\|(8), \fBresize2fs\fR\|(8), \fBbtrfs\fR\|(8), \fBxfs_info\fR\|(8).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.31.18)
.SS "guestfs_vfs_type"
.IX Subsection "guestfs_vfs_type"
.Vb 3
\& char *
\& guestfs_vfs_type (guestfs_h *g,
\&                   const char *mountable);
.Ve
.PP
Ця команда отримує тип файлової системи, відповідний до файлової системи у
\&\f(CW\*(C`монтуванні\*(C'\fR.
.PP
Для більшості файлових систем результатом виконання є назва модуля \s-1VFS\s0
Linux, який буде використано для монтування цієї системи, якщо ви змонтуєте
її без явного задання типу файлової системи. Наприклад, може бути повернуто
рядок \f(CW\*(C`ext3\*(C'\fR або \f(CW\*(C`ntfs\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.75)
.SS "guestfs_vfs_uuid"
.IX Subsection "guestfs_vfs_uuid"
.Vb 3
\& char *
\& guestfs_vfs_uuid (guestfs_h *g,
\&                   const char *mountable);
.Ve
.PP
Ця команда повертає \s-1UUID\s0 файлової системи для файлової системи
\&\f(CW\*(C`монтування\*(C'\fR.
.PP
Якщо у файлової системи немає \s-1UUID,\s0 буде повернуто порожній рядок.
.PP
Пошук файлової системи за \s-1UUID\s0 можна здійснити за допомогою
\&\f(CW\*(C`guestfs_findfs_uuid\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.3.18)
.SS "guestfs_vg_activate"
.IX Subsection "guestfs_vg_activate"
.Vb 4
\& int
\& guestfs_vg_activate (guestfs_h *g,
\&                      int activate,
\&                      char *const *volgroups);
.Ve
.PP
Ця команда активує або (якщо параметром є false) деактивує усі логічні томи
у вказаних групах томів \f(CW\*(C`групи_томів\*(C'\fR.
.PP
Ця команда дає ті самі результати, що і \f(CW\*(C`vgchange \-a y|n групи томів...\*(C'\fR
.PP
Зауважте, що якщо \f(CW\*(C`групи_томів\*(C'\fR є порожнім списком, буде активовано або
деактивовано \fBусі\fR групи томів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.26)
.SS "guestfs_vg_activate_all"
.IX Subsection "guestfs_vg_activate_all"
.Vb 3
\& int
\& guestfs_vg_activate_all (guestfs_h *g,
\&                          int activate);
.Ve
.PP
Ця команда активує або (якщо параметром є false) деактивує усі логічні томи
в усіх групах томів.
.PP
Ця команда дає ті самі результати, що і \f(CW\*(C`vgchange \-a y|n\*(C'\fR
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.26)
.SS "guestfs_vgchange_uuid"
.IX Subsection "guestfs_vgchange_uuid"
.Vb 3
\& int
\& guestfs_vgchange_uuid (guestfs_h *g,
\&                        const char *vg);
.Ve
.PP
Створити новий випадковий \s-1UUID\s0 для групи томів \f(CW\*(C`vg\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.26)
.SS "guestfs_vgchange_uuid_all"
.IX Subsection "guestfs_vgchange_uuid_all"
.Vb 2
\& int
\& guestfs_vgchange_uuid_all (guestfs_h *g);
.Ve
.PP
Створити нові випадкові \s-1UUID\s0 для всіх груп томів.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.26)
.SS "guestfs_vgcreate"
.IX Subsection "guestfs_vgcreate"
.Vb 4
\& int
\& guestfs_vgcreate (guestfs_h *g,
\&                   const char *volgroup,
\&                   char *const *physvols);
.Ve
.PP
Ця команда створює групу томів \s-1LVM\s0 із назвою \f(CW\*(C`група_томів\*(C'\fR на основі
непорожнього списку фізичних томів \f(CW\*(C`фізичні_томи\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.8)
.SS "guestfs_vglvuuids"
.IX Subsection "guestfs_vglvuuids"
.Vb 3
\& char **
\& guestfs_vglvuuids (guestfs_h *g,
\&                    const char *vgname);
.Ve
.PP
За вказаною групою томів \f(CW\*(C`назва_vg\*(C'\fR ця команда повертає \s-1UUID\s0 усіх логічних
томів, створених у вказаній групі томів.
.PP
Цією командою можна скористатися у поєднанні із командами \f(CW\*(C`guestfs_lvs\*(C'\fR і
\&\f(CW\*(C`guestfs_lvuuid\*(C'\fR для пов'язування логічних томів і груп томів.
.PP
Див. також \f(CW\*(C`guestfs_vgpvuuids\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.87)
.SS "guestfs_vgmeta"
.IX Subsection "guestfs_vgmeta"
.Vb 4
\& char *
\& guestfs_vgmeta (guestfs_h *g,
\&                 const char *vgname,
\&                 size_t *size_r);
.Ve
.PP
Значенням параметра \f(CW\*(C`назва_vg\*(C'\fR є назва групи томів \s-1LVM.\s0 Ця команда виконує
вивчення групи томів і повертає її метадані.
.PP
Зауважте, що метадані є внутрішньою структурою, яка використовується \s-1LVM\s0 і
яку може бути будь\-коли змінено. Її дані надаються лише з інформаційною
метою.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. Розмір
повернутого буфера буд записано до \f(CW*size_r\fR. \fIПісля використання функція,
яка викликає цю функцію, має звільнити повернутий буфер\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.20)
.SS "guestfs_vgpvuuids"
.IX Subsection "guestfs_vgpvuuids"
.Vb 3
\& char **
\& guestfs_vgpvuuids (guestfs_h *g,
\&                    const char *vgname);
.Ve
.PP
За вказаною групою томів \f(CW\*(C`назва_vg\*(C'\fR ця команда повертає \s-1UUID\s0 усіх фізичних
томів, на яких розміщено вказану групу томів.
.PP
Цією командою можна скористатися у поєднанні із командами \f(CW\*(C`guestfs_pvs\*(C'\fR і
\&\f(CW\*(C`guestfs_pvuuid\*(C'\fR для пов'язування фізичних томів і груп томів.
.PP
Див. також \f(CW\*(C`guestfs_vglvuuids\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
(Додано у 1.0.87)
.SS "guestfs_vgremove"
.IX Subsection "guestfs_vgremove"
.Vb 3
\& int
\& guestfs_vgremove (guestfs_h *g,
\&                   const char *vgname);
.Ve
.PP
Вилучає групу томів \s-1LVM\s0 \f(CW\*(C`назва_vg\*(C'\fR (наприклад \f(CW\*(C`VG\*(C'\fR).
.PP
Крім того, ця команда у примусовому порядку вилучає усі логічні томи у групі
томів (якщо такі існують).
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.13)
.SS "guestfs_vgrename"
.IX Subsection "guestfs_vgrename"
.Vb 4
\& int
\& guestfs_vgrename (guestfs_h *g,
\&                   const char *volgroup,
\&                   const char *newvolgroup);
.Ve
.PP
Перейменовує групу томів \f(CW\*(C`група_томів\*(C'\fR на групу томів \f(CW\*(C`нова_група_томів\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.0.83)
.SS "guestfs_vgs"
.IX Subsection "guestfs_vgs"
.Vb 2
\& char **
\& guestfs_vgs (guestfs_h *g);
.Ve
.PP
Виводить список усіх виявлених груп томів. Є еквівалентом команди \fBvgs\fR\|(8).
.PP
Ця команда повертає список лише тих груп томів, які вдасться виявити
(наприклад \f(CW\*(C`VolGroup00\*(C'\fR).
.PP
Див. також \f(CW\*(C`guestfs_vgs_full\*(C'\fR.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.4)
.SS "guestfs_vgs_full"
.IX Subsection "guestfs_vgs_full"
.Vb 2
\& struct guestfs_lvm_vg_list *
\& guestfs_vgs_full (guestfs_h *g);
.Ve
.PP
Виводить список усіх виявлених груп томів. Є еквівалентом команди
\&\fBvgs\fR\|(8). До «повної» версії включено усі поля.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_lvm_vg_list *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_lvm_vg_list\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`lvm2\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 0.4)
.SS "guestfs_vgscan"
.IX Subsection "guestfs_vgscan"
.Vb 2
\& int
\& guestfs_vgscan (guestfs_h *g);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_lvm_scan\*(R"
call instead.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда виконує повторне сканування усіх блокових пристроїв і повторно
будує список фізичних томів, груп томів та логічних томів \s-1LVM.\s0
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.2)
.SS "guestfs_vguuid"
.IX Subsection "guestfs_vguuid"
.Vb 3
\& char *
\& guestfs_vguuid (guestfs_h *g,
\&                 const char *vgname);
.Ve
.PP
Ця команда повертає \s-1UUID\s0 групи томів \s-1LVM\s0 із назвою \f(CW\*(C`назва_vg\*(C'\fR.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.87)
.SS "guestfs_wait_ready"
.IX Subsection "guestfs_wait_ready"
.Vb 2
\& int
\& guestfs_wait_ready (guestfs_h *g);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR Замінника не передбачено. Зверніться до
документації із програмного інтерфейсу у підручнику з \fBguestfs\fR\|(3), щоб
дізнатися більше.
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця функція не виконує ніяких дій.
.PP
У версіях програмного інтерфейсу < 1.0.71 вам слід було викликати цю
функцію одразу після виклику \f(CW\*(C`guestfs_launch\*(C'\fR, щоб дочекатися кінця
запуску.  Втім, тепер це робити не обов'язково, оскільки очікування тепер
виконується у \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
Якщо ви побачите у коді якісь виклики цієї функції, можете просто вилучити
їх, якщо вам не потрібна сумісність із застарілими версіями програмного
інтерфейсу.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 0.3)
.SS "guestfs_wc_c"
.IX Subsection "guestfs_wc_c"
.Vb 3
\& int
\& guestfs_wc_c (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Ця команда лічить символи у файлі за допомогою зовнішньої програми \f(CW\*(C`wc \-c\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.54)
.SS "guestfs_wc_l"
.IX Subsection "guestfs_wc_l"
.Vb 3
\& int
\& guestfs_wc_l (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Ця команда лічить рядки у файлі за допомогою зовнішньої програми \f(CW\*(C`wc \-l\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.54)
.SS "guestfs_wc_w"
.IX Subsection "guestfs_wc_w"
.Vb 3
\& int
\& guestfs_wc_w (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Ця команда лічить слова у файлі за допомогою зовнішньої програми \f(CW\*(C`wc \-w\*(C'\fR.
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
(Додано у 1.0.54)
.SS "guestfs_wipefs"
.IX Subsection "guestfs_wipefs"
.Vb 3
\& int
\& guestfs_wipefs (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
Ця команда витирає файлову систему або підписи \s-1RAID\s0 з вказаного пристрою
\&\f(CW\*(C`пристрій\*(C'\fR з метою зробити файлову систему невидимою для libblkid.
.PP
Ця команда не витирає самої файлової системи або інших даних з пристрою
\&\f(CW\*(C`пристрій\*(C'\fR.
.PP
Порівняйте із \f(CW\*(C`guestfs_zero\*(C'\fR, яка записує нулі у перші декілька блоків
пристрою.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`wipefs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.17.6)
.SS "guestfs_write"
.IX Subsection "guestfs_write"
.Vb 5
\& int
\& guestfs_write (guestfs_h *g,
\&                const char *path,
\&                const char *content,
\&                size_t content_size);
.Ve
.PP
Цей виклик створює файл із назвою \f(CW\*(C`шлях\*(C'\fR. Вмістом файла буде рядок \f(CW\*(C`дані\*(C'\fR
(який може складатися з будь\-яких 8\-бітовий даних).
.PP
Див. також \f(CW\*(C`guestfs_write_append\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.3.14)
.SS "guestfs_write_append"
.IX Subsection "guestfs_write_append"
.Vb 5
\& int
\& guestfs_write_append (guestfs_h *g,
\&                       const char *path,
\&                       const char *content,
\&                       size_t content_size);
.Ve
.PP
Цей виклик дописує \f(CW\*(C`дані\*(C'\fR наприкінці файла \f(CW\*(C`шлях\*(C'\fR. Якщо файла \f(CW\*(C`шлях\*(C'\fR не
існує, його буде створено.
.PP
Див. також \f(CW\*(C`guestfs_write\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
(Додано у 1.11.18)
.SS "guestfs_write_file"
.IX Subsection "guestfs_write_file"
.Vb 5
\& int
\& guestfs_write_file (guestfs_h *g,
\&                     const char *path,
\&                     const char *content,
\&                     int size);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_write\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Цей виклик створює файл із назвою \f(CW\*(C`шлях\*(C'\fR. Вмістом файла буде рядок \f(CW\*(C`дані\*(C'\fR
(який може складатися з будь\-яких 8\-бітовий даних), а розмір файла буде
визначено значенням \f(CW\*(C`розмір\*(C'\fR.
.PP
У особливому випадку, якщо \f(CW\*(C`розмір\*(C'\fR дорівнює \f(CW0\fR, довжину файла буде
обчислено за допомогою \f(CW\*(C`strlen\*(C'\fR (тому у цьому випадку «дані» не повинні
містити вбудованих символів \s-1NUL ASCII\s0).
.PP
\&\fI\s-1NB.\s0\fR Через ваду запис даних, які містять символи \s-1NUL ASCII\s0 \fIне\fR працює,
навіть якщо явним чином вказати довжину.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 0.8)
.SS "guestfs_xfs_admin"
.IX Subsection "guestfs_xfs_admin"
.Vb 4
\& int
\& guestfs_xfs_admin (guestfs_h *g,
\&                    const char *device,
\&                    ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 7
\& GUESTFS_XFS_ADMIN_EXTUNWRITTEN, int extunwritten,
\& GUESTFS_XFS_ADMIN_IMGFILE, int imgfile,
\& GUESTFS_XFS_ADMIN_V2LOG, int v2log,
\& GUESTFS_XFS_ADMIN_PROJID32BIT, int projid32bit,
\& GUESTFS_XFS_ADMIN_LAZYCOUNTER, int lazycounter,
\& GUESTFS_XFS_ADMIN_LABEL, const char *label,
\& GUESTFS_XFS_ADMIN_UUID, const char *uuid,
.Ve
.PP
Змінює параметри файлової системи \s-1XFS\s0 на пристрої \f(CW\*(C`пристрій\*(C'\fR.
.PP
До пристроїв, які змонтовано, внесення змін неможливе. Перед цим викликом
для зміни параметрів адміністратор має демонтувати відповідні файлові
системи.
.PP
Деякі з параметрів змонтованих файлових систем можна визначати та вносити до
них зміни за допомогою викликів \f(CW\*(C`guestfs_xfs_info\*(C'\fR і \f(CW\*(C`guestfs_xfs_growfs\*(C'\fR.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`xfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.33)
.SS "guestfs_xfs_admin_va"
.IX Subsection "guestfs_xfs_admin_va"
.Vb 4
\& int
\& guestfs_xfs_admin_va (guestfs_h *g,
\&                       const char *device,
\&                       va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_xfs_admin\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_xfs_admin_argv"
.IX Subsection "guestfs_xfs_admin_argv"
.Vb 4
\& int
\& guestfs_xfs_admin_argv (guestfs_h *g,
\&                         const char *device,
\&                         const struct guestfs_xfs_admin_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_xfs_admin\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_xfs_growfs"
.IX Subsection "guestfs_xfs_growfs"
.Vb 4
\& int
\& guestfs_xfs_growfs (guestfs_h *g,
\&                     const char *path,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 8
\& GUESTFS_XFS_GROWFS_DATASEC, int datasec,
\& GUESTFS_XFS_GROWFS_LOGSEC, int logsec,
\& GUESTFS_XFS_GROWFS_RTSEC, int rtsec,
\& GUESTFS_XFS_GROWFS_DATASIZE, int64_t datasize,
\& GUESTFS_XFS_GROWFS_LOGSIZE, int64_t logsize,
\& GUESTFS_XFS_GROWFS_RTSIZE, int64_t rtsize,
\& GUESTFS_XFS_GROWFS_RTEXTSIZE, int64_t rtextsize,
\& GUESTFS_XFS_GROWFS_MAXPCT, int maxpct,
.Ve
.PP
Збільшує файлову систему \s-1XFS,\s0 яку змонтовано як \f(CW\*(C`шлях\*(C'\fR.
.PP
Повернута структура має містити дані щодо геометрії. Пропущені поля буде
повернуто як \f(CW\*(C`\-1\*(C'\fR (для числових значень) або як порожні рядки.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`xfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.28)
.SS "guestfs_xfs_growfs_va"
.IX Subsection "guestfs_xfs_growfs_va"
.Vb 4
\& int
\& guestfs_xfs_growfs_va (guestfs_h *g,
\&                        const char *path,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_xfs_growfs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_xfs_growfs_argv"
.IX Subsection "guestfs_xfs_growfs_argv"
.Vb 4
\& int
\& guestfs_xfs_growfs_argv (guestfs_h *g,
\&                          const char *path,
\&                          const struct guestfs_xfs_growfs_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_xfs_growfs\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_xfs_info"
.IX Subsection "guestfs_xfs_info"
.Vb 3
\& struct guestfs_xfsinfo *
\& guestfs_xfs_info (guestfs_h *g,
\&                   const char *pathordevice);
.Ve
.PP
\&\f(CW\*(C`шлях_або_пристрій\*(C'\fR — змонтована файлова система \s-1XFS\s0 або пристрій, на якому
міститься файлова система \s-1XFS.\s0 Ця команда повертає дані щодо геометрії
файлової системи.
.PP
Повернута структура має містити дані щодо геометрії. Пропущені поля буде
повернуто як \f(CW\*(C`\-1\*(C'\fR (для числових значень) або як порожні рядки.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_xfsinfo *\*(C'\fR або \s-1NULL,\s0 якщо сталася
помилка. \fIПісля використання слід викликати \f(CI\*(C`guestfs_free_xfsinfo\*(C'\fI\fR.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`xfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.21)
.SS "guestfs_xfs_repair"
.IX Subsection "guestfs_xfs_repair"
.Vb 4
\& int
\& guestfs_xfs_repair (guestfs_h *g,
\&                     const char *device,
\&                     ...);
.Ve
.PP
У цьому виклику можна вказати список необов'язкових аргументів. Ви можете не
використати жодного або використати декілька з вказаних нижче пар параметрів
і завершити список за допомогою \f(CW\*(C`\-1\*(C'\fR. Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ
АРГУМЕНТАМИ\*(R".
.PP
.Vb 10
\& GUESTFS_XFS_REPAIR_FORCELOGZERO, int forcelogzero,
\& GUESTFS_XFS_REPAIR_NOMODIFY, int nomodify,
\& GUESTFS_XFS_REPAIR_NOPREFETCH, int noprefetch,
\& GUESTFS_XFS_REPAIR_FORCEGEOMETRY, int forcegeometry,
\& GUESTFS_XFS_REPAIR_MAXMEM, int64_t maxmem,
\& GUESTFS_XFS_REPAIR_IHASHSIZE, int64_t ihashsize,
\& GUESTFS_XFS_REPAIR_BHASHSIZE, int64_t bhashsize,
\& GUESTFS_XFS_REPAIR_AGSTRIDE, int64_t agstride,
\& GUESTFS_XFS_REPAIR_LOGDEV, const char *logdev,
\& GUESTFS_XFS_REPAIR_RTDEV, const char *rtdev,
.Ve
.PP
Відновлює пошкоджену файлову систему \s-1XFS\s0 на пристрої \f(CW\*(C`пристрій\*(C'\fR.
.PP
Файлова система задається за допомогою аргументу \f(CW\*(C`пристрій\*(C'\fR, який має бути
або назвою пристрою розділу диска або томом, на якому міститься файлова
система. Якщо вказано назву блокового пристрою, \f(CW\*(C`xfs_repair\*(C'\fR спробує знайти
простий пристрій, пов'язаний із вказаним блоковим пристроєм і скористається
цим простим пристроєм.
.PP
За будь\-яких умов, файлову систему, яку слід відновити, має бути
демонтовано. Якщо цього не зробити, після обробки файлова система може
виявитися некоректною або пошкодженою.
.PP
Повернуте значення стану вказує на те, було виявлено пошкодження файлової
системи (повернуте значення \f(CW1\fR) чи ні (повернуте значення \f(CW0\fR).
.PP
У разі помилки цією функцією буде повернуто \-1.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`xfs\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.19.36)
.SS "guestfs_xfs_repair_va"
.IX Subsection "guestfs_xfs_repair_va"
.Vb 4
\& int
\& guestfs_xfs_repair_va (guestfs_h *g,
\&                        const char *device,
\&                        va_list args);
.Ve
.PP
Це «варіант з va_list» \*(L"guestfs_xfs_repair\*(R"
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_xfs_repair_argv"
.IX Subsection "guestfs_xfs_repair_argv"
.Vb 4
\& int
\& guestfs_xfs_repair_argv (guestfs_h *g,
\&                          const char *device,
\&                          const struct guestfs_xfs_repair_argv *optargs);
.Ve
.PP
Це «варіант з argv» \*(L"guestfs_xfs_repair\*(R".
.PP
Див. \*(L"ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ\*(R".
.SS "guestfs_yara_destroy"
.IX Subsection "guestfs_yara_destroy"
.Vb 2
\& int
\& guestfs_yara_destroy (guestfs_h *g);
.Ve
.PP
Знищує попередньо завантажені правила Yara з метою звільнити ресурси
libguestfs.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`libyara\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.37.13)
.SS "guestfs_yara_load"
.IX Subsection "guestfs_yara_load"
.Vb 3
\& int
\& guestfs_yara_load (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
Вивантажити набір правил Yara з локального файла \fIназва_файла\fR.
.PP
Правила Yara надають змогу категоризувати файли на основі текстових або
двійкових взірців у даних цих файлів. Див. \f(CW\*(C`guestfs_yara_scan\*(C'\fR, щоб
дізнатися про те, як виконати сканування файлів на основі завантажених
правил.
.PP
Правила може бути вказано у двійковому форматі, створеному програмою yarac,
або у форматі початкового коду. У останньому випадку правила має бути
спочатку скомпільовано, а потім завантажено.
.PP
Правила у форматі початкового коду не можуть включати зовнішні файли. Якщо у
вас є файли з такими включеннями, рекомендуємо їх спочатку скомпілювати.
.PP
Раніше завантажені правила буде знищено.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`libyara\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.37.13)
.SS "guestfs_yara_scan"
.IX Subsection "guestfs_yara_scan"
.Vb 3
\& struct guestfs_yara_detection_list *
\& guestfs_yara_scan (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
Сканує файл на основі попереднього завантажених правил Yara.
.PP
Для кожного правила відповідності повертається окрема структура
\&\f(CW\*(C`yara_detection\*(C'\fR.
.PP
Структура \f(CW\*(C`yara_detection\*(C'\fR містить вказані нижче поля.
.ie n .IP """yara_name""" 4
.el .IP "\f(CWyara_name\fR" 4
.IX Item "yara_name"
Шлях до файла, який відповідає правилу Yara.
.ie n .IP """yara_rule""" 4
.el .IP "\f(CWyara_rule\fR" 4
.IX Item "yara_rule"
Ідентифікатор правила Yara, відповідність якого було встановлено для
заданого файла.
.PP
Ця функція повертає \f(CW\*(C`struct guestfs_yara_detection_list *\*(C'\fR або \s-1NULL,\s0 якщо
сталася помилка. \fIПісля використання слід викликати
\&\f(CI\*(C`guestfs_free_yara_detection_list\*(C'\fI\fR.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`libyara\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.37.13)
.SS "guestfs_zegrep"
.IX Subsection "guestfs_zegrep"
.Vb 4
\& char **
\& guestfs_zegrep (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`zegrep\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_zegrepi"
.IX Subsection "guestfs_zegrepi"
.Vb 4
\& char **
\& guestfs_zegrepi (guestfs_h *g,
\&                  const char *regex,
\&                  const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця функція викликає зовнішню програму \f(CW\*(C`zegrep \-i\*(C'\fR і повертає відповідні
рядки.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_zero"
.IX Subsection "guestfs_zero"
.Vb 3
\& int
\& guestfs_zero (guestfs_h *g,
\&               const char *device);
.Ve
.PP
Ця команда заповнює нулями перші декілька блоків пристрою \f(CW\*(C`пристрій\*(C'\fR.
.PP
Кількість занулених блоків не вказується (але вона все одно \fIне є
достатньою\fR для гарантованого витирання вмісту пристрою). Для утруднення
отримання вмісту пристрою достатньо вилучити таблиці розділів, суперблоки
файлової системи тощо.
.PP
Якщо у блоках вже містяться нулі, ця команда не перезаписуватиме їх нулями
ще раз. Таким чином можна запобігти втраті стану розрідженості для базового
пристрою, а також його непотрібному зростанню у розмірі.
.PP
Див. також \f(CW\*(C`guestfs_zero_device\*(C'\fR, \f(CW\*(C`guestfs_scrub_device\*(C'\fR,
\&\f(CW\*(C`guestfs_is_zero_device\*(C'\fR
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.0.16)
.SS "guestfs_zero_device"
.IX Subsection "guestfs_zero_device"
.Vb 3
\& int
\& guestfs_zero_device (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
Ця команда перезаписує нулями увесь пристрій  \f(CW\*(C`device\*(C'\fR. Порівняйте її із
командою \f(CW\*(C`guestfs_zero\*(C'\fR, яка перезаписує нулями перші декілька блоків
пристрою.
.PP
Якщо у блоках вже містяться нулі, ця команда не перезаписуватиме їх нулями
ще раз. Таким чином можна запобігти втраті стану розрідженості для базового
пристрою, а також його непотрібному зростанню у розмірі.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.3.1)
.SS "guestfs_zero_free_space"
.IX Subsection "guestfs_zero_free_space"
.Vb 3
\& int
\& guestfs_zero_free_space (guestfs_h *g,
\&                          const char *directory);
.Ve
.PP
Записує нулями вільне місце на файловій системі, змонтованій до точки
монтування \f(CW\*(C`каталог\*(C'\fR. Файлову систему має бути змонтовано для читання і
запису.
.PP
Вміст файлової системи не буде змінено, але усе вільне місце у файловій
системі буде звільнено.
.PP
Вільне місце не буде «обрізано». Для обрізання вам слід викликати
\&\f(CW\*(C`guestfs_fstrim\*(C'\fR або скористатися відповідною командою після цієї, залежно
від ваших потреб.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Команда, виконання якої триває довго, може створювати повідомлення щодо
поступу виконання, які програма, яка викликає команду, може показувати за
допомогою панелі або індикатора поступу. Щоб отримувати такі повідомлення,
програма має зареєструвати зворотний виклик події
поступу. Див. \*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Додано у 1.17.18)
.SS "guestfs_zerofree"
.IX Subsection "guestfs_zerofree"
.Vb 3
\& int
\& guestfs_zerofree (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Ця команда виконує програму \fIzerofree\fR для пристрою \f(CW\*(C`пристрій\*(C'\fR. Програма
заповнює нулями невикористані inode та блоки диска на файловій системі
ext2/3. Таке занулення уможливлює ефективніше стискання файлової системи.
.PP
\&\fBНе\fR запускайте цю програму для обробки змонтованої файлової системи.
.PP
Використання цієї програми може призвести до пошкодження файлової системи
або даних на файловій системі.
.PP
Ця функція повертає 0 у разі успіху і \-1 у разі помилки.
.PP
Працездатність цієї функції залежить від можливості \f(CW\*(C`zerofree\*(C'\fR. Див. також
\&\*(L"guestfs_feature_available\*(R".
.PP
(Додано у 1.0.26)
.SS "guestfs_zfgrep"
.IX Subsection "guestfs_zfgrep"
.Vb 4
\& char **
\& guestfs_zfgrep (guestfs_h *g,
\&                 const char *pattern,
\&                 const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`zfgrep\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_zfgrepi"
.IX Subsection "guestfs_zfgrepi"
.Vb 4
\& char **
\& guestfs_zfgrepi (guestfs_h *g,
\&                  const char *pattern,
\&                  const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`zfgrep \-i\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_zfile"
.IX Subsection "guestfs_zfile"
.Vb 4
\& char *
\& guestfs_zfile (guestfs_h *g,
\&                const char *meth,
\&                const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_file\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця команда запускає \fIfile\fR після розпаковування шляху \f(CW\*(C`шлях\*(C'\fR за допомогою
методу \f(CW\*(C`метод\*(C'\fR.
.PP
Значенням параметра \f(CW\*(C`метод\*(C'\fR має бути \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`compress\*(C'\fR або \f(CW\*(C`bzip2\*(C'\fR.
.PP
Починаючи з версії 1.0.63, можна використовувати замість цієї команди
\&\f(CW\*(C`guestfs_file\*(C'\fR, оскільки у сучасних версіях ця команда може обробляти
стиснені файли.
.PP
Ця функція повертає рядок або \s-1NULL,\s0 якщо станеться помилка. \fIПісля
використання функція, яка викликає цю функцію, має звільнити повернутий
рядок\fR.
.PP
(Додано у 1.0.59)
.SS "guestfs_zgrep"
.IX Subsection "guestfs_zgrep"
.Vb 4
\& char **
\& guestfs_zgrep (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Викликає зовнішню програму \f(CW\*(C`zgrep\*(C'\fR і повертає рядки\-відповідники.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SS "guestfs_zgrepi"
.IX Subsection "guestfs_zgrepi"
.Vb 4
\& char **
\& guestfs_zgrepi (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
\&\fIЦя функція вважається застарілою.\fR У новому коді замість неї слід
використовувати \*(L"guestfs_grep\*(R".
.PP
Застарілі функції не буде вилучено з програмного інтерфейсу, але той факт,
що їх визнано застарілими, вказує на проблеми із належним використанням цих
функцій.
.PP
Ця функція викликає зовнішню програму \f(CW\*(C`zgrep \-i\*(C'\fR і повертає відповідні
рядки.
.PP
Ця функція повертає масив рядків із завершальним \s-1NULL\s0 (подібно до
\&\fBenviron\fR\|(3)) або \s-1NULL,\s0 якщо сталася помилка. \fIПісля використання слід
звільнити рядки і масив\fR.
.PP
Через обмеження протоколу передавання повідомлень існує граничний об'єм
повідомлення, щось у діапазоні від 2 МБ до 4 МБ. Див. \*(L"ОБМЕЖЕННЯ
ПРОТОКОЛУ\*(R".
.PP
(Додано у 1.0.66)
.SH "СТРУКТУРИ"
.IX Header "СТРУКТУРИ"
.SS "guestfs_int_bool"
.IX Subsection "guestfs_int_bool"
.Vb 4
\& struct guestfs_int_bool {
\&   int32_t i;
\&   int32_t b;
\& };
\& 
\& struct guestfs_int_bool_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_int_bool *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_int_bool (const struct guestfs_int_bool *, const struct guestfs_int_bool *);
\& int guestfs_compare_int_bool_list (const struct guestfs_int_bool_list *, const struct guestfs_int_bool_list *);
\& 
\& struct guestfs_int_bool *guestfs_copy_int_bool (const struct guestfs_int_bool *);
\& struct guestfs_int_bool_list *guestfs_copy_int_bool_list (const struct guestfs_int_bool_list *);
\& 
\& void guestfs_free_int_bool (struct guestfs_int_bool *);
\& void guestfs_free_int_bool_list (struct guestfs_int_bool_list *);
.Ve
.SS "guestfs_lvm_pv"
.IX Subsection "guestfs_lvm_pv"
.Vb 10
\& struct guestfs_lvm_pv {
\&   char *pv_name;
\&   /* Наступне поле не завершується нульовим байтом, будьте обережні під час виведення цього поля: */
\&   char pv_uuid[32];
\&   char *pv_fmt;
\&   uint64_t pv_size;
\&   uint64_t dev_size;
\&   uint64_t pv_free;
\&   uint64_t pv_used;
\&   char *pv_attr;
\&   int64_t pv_pe_count;
\&   int64_t pv_pe_alloc_count;
\&   char *pv_tags;
\&   uint64_t pe_start;
\&   int64_t pv_mda_count;
\&   uint64_t pv_mda_free;
\& };
\& 
\& struct guestfs_lvm_pv_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_lvm_pv *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_lvm_pv (const struct guestfs_lvm_pv *, const struct guestfs_lvm_pv *);
\& int guestfs_compare_lvm_pv_list (const struct guestfs_lvm_pv_list *, const struct guestfs_lvm_pv_list *);
\& 
\& struct guestfs_lvm_pv *guestfs_copy_lvm_pv (const struct guestfs_lvm_pv *);
\& struct guestfs_lvm_pv_list *guestfs_copy_lvm_pv_list (const struct guestfs_lvm_pv_list *);
\& 
\& void guestfs_free_lvm_pv (struct guestfs_lvm_pv *);
\& void guestfs_free_lvm_pv_list (struct guestfs_lvm_pv_list *);
.Ve
.SS "guestfs_lvm_vg"
.IX Subsection "guestfs_lvm_vg"
.Vb 10
\& struct guestfs_lvm_vg {
\&   char *vg_name;
\&   /* Текстове поле НЕ завершується нульовим байтом: будьте обережні з його виведенням: */
\&   char vg_uuid[32];
\&   char *vg_fmt;
\&   char *vg_attr;
\&   uint64_t vg_size;
\&   uint64_t vg_free;
\&   char *vg_sysid;
\&   uint64_t vg_extent_size;
\&   int64_t vg_extent_count;
\&   int64_t vg_free_count;
\&   int64_t max_lv;
\&   int64_t max_pv;
\&   int64_t pv_count;
\&   int64_t lv_count;
\&   int64_t snap_count;
\&   int64_t vg_seqno;
\&   char *vg_tags;
\&   int64_t vg_mda_count;
\&   uint64_t vg_mda_free;
\& };
\& 
\& struct guestfs_lvm_vg_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_lvm_vg *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_lvm_vg (const struct guestfs_lvm_vg *, const struct guestfs_lvm_vg *);
\& int guestfs_compare_lvm_vg_list (const struct guestfs_lvm_vg_list *, const struct guestfs_lvm_vg_list *);
\& 
\& struct guestfs_lvm_vg *guestfs_copy_lvm_vg (const struct guestfs_lvm_vg *);
\& struct guestfs_lvm_vg_list *guestfs_copy_lvm_vg_list (const struct guestfs_lvm_vg_list *);
\& 
\& void guestfs_free_lvm_vg (struct guestfs_lvm_vg *);
\& void guestfs_free_lvm_vg_list (struct guestfs_lvm_vg_list *);
.Ve
.SS "guestfs_lvm_lv"
.IX Subsection "guestfs_lvm_lv"
.Vb 10
\& struct guestfs_lvm_lv {
\&   char *lv_name;
\&   /* The next field is NOT nul\-terminated, be careful when printing it: */
\&   char lv_uuid[32];
\&   char *lv_attr;
\&   int64_t lv_major;
\&   int64_t lv_minor;
\&   int64_t lv_kernel_major;
\&   int64_t lv_kernel_minor;
\&   uint64_t lv_size;
\&   int64_t seg_count;
\&   char *origin;
\&   /* The next field is [0..100] or \-1 meaning \*(Aqnot present\*(Aq: */
\&   float snap_percent;
\&   /* The next field is [0..100] or \-1 meaning \*(Aqnot present\*(Aq: */
\&   float copy_percent;
\&   char *move_pv;
\&   char *lv_tags;
\&   char *mirror_log;
\&   char *modules;
\& };
\& 
\& struct guestfs_lvm_lv_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_lvm_lv *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_lvm_lv (const struct guestfs_lvm_lv *, const struct guestfs_lvm_lv *);
\& int guestfs_compare_lvm_lv_list (const struct guestfs_lvm_lv_list *, const struct guestfs_lvm_lv_list *);
\& 
\& struct guestfs_lvm_lv *guestfs_copy_lvm_lv (const struct guestfs_lvm_lv *);
\& struct guestfs_lvm_lv_list *guestfs_copy_lvm_lv_list (const struct guestfs_lvm_lv_list *);
\& 
\& void guestfs_free_lvm_lv (struct guestfs_lvm_lv *);
\& void guestfs_free_lvm_lv_list (struct guestfs_lvm_lv_list *);
.Ve
.SS "guestfs_stat"
.IX Subsection "guestfs_stat"
.Vb 10
\& struct guestfs_stat {
\&   int64_t dev;
\&   int64_t ino;
\&   int64_t mode;
\&   int64_t nlink;
\&   int64_t uid;
\&   int64_t gid;
\&   int64_t rdev;
\&   int64_t size;
\&   int64_t blksize;
\&   int64_t blocks;
\&   int64_t atime;
\&   int64_t mtime;
\&   int64_t ctime;
\& };
\& 
\& struct guestfs_stat_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_stat *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_stat (const struct guestfs_stat *, const struct guestfs_stat *);
\& int guestfs_compare_stat_list (const struct guestfs_stat_list *, const struct guestfs_stat_list *);
\& 
\& struct guestfs_stat *guestfs_copy_stat (const struct guestfs_stat *);
\& struct guestfs_stat_list *guestfs_copy_stat_list (const struct guestfs_stat_list *);
\& 
\& void guestfs_free_stat (struct guestfs_stat *);
\& void guestfs_free_stat_list (struct guestfs_stat_list *);
.Ve
.SS "guestfs_statns"
.IX Subsection "guestfs_statns"
.Vb 10
\& struct guestfs_statns {
\&   int64_t st_dev;
\&   int64_t st_ino;
\&   int64_t st_mode;
\&   int64_t st_nlink;
\&   int64_t st_uid;
\&   int64_t st_gid;
\&   int64_t st_rdev;
\&   int64_t st_size;
\&   int64_t st_blksize;
\&   int64_t st_blocks;
\&   int64_t st_atime_sec;
\&   int64_t st_atime_nsec;
\&   int64_t st_mtime_sec;
\&   int64_t st_mtime_nsec;
\&   int64_t st_ctime_sec;
\&   int64_t st_ctime_nsec;
\&   int64_t st_spare1;
\&   int64_t st_spare2;
\&   int64_t st_spare3;
\&   int64_t st_spare4;
\&   int64_t st_spare5;
\&   int64_t st_spare6;
\& };
\& 
\& struct guestfs_statns_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_statns *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_statns (const struct guestfs_statns *, const struct guestfs_statns *);
\& int guestfs_compare_statns_list (const struct guestfs_statns_list *, const struct guestfs_statns_list *);
\& 
\& struct guestfs_statns *guestfs_copy_statns (const struct guestfs_statns *);
\& struct guestfs_statns_list *guestfs_copy_statns_list (const struct guestfs_statns_list *);
\& 
\& void guestfs_free_statns (struct guestfs_statns *);
\& void guestfs_free_statns_list (struct guestfs_statns_list *);
.Ve
.SS "guestfs_statvfs"
.IX Subsection "guestfs_statvfs"
.Vb 10
\& struct guestfs_statvfs {
\&   int64_t bsize;
\&   int64_t frsize;
\&   int64_t blocks;
\&   int64_t bfree;
\&   int64_t bavail;
\&   int64_t files;
\&   int64_t ffree;
\&   int64_t favail;
\&   int64_t fsid;
\&   int64_t flag;
\&   int64_t namemax;
\& };
\& 
\& struct guestfs_statvfs_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_statvfs *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_statvfs (const struct guestfs_statvfs *, const struct guestfs_statvfs *);
\& int guestfs_compare_statvfs_list (const struct guestfs_statvfs_list *, const struct guestfs_statvfs_list *);
\& 
\& struct guestfs_statvfs *guestfs_copy_statvfs (const struct guestfs_statvfs *);
\& struct guestfs_statvfs_list *guestfs_copy_statvfs_list (const struct guestfs_statvfs_list *);
\& 
\& void guestfs_free_statvfs (struct guestfs_statvfs *);
\& void guestfs_free_statvfs_list (struct guestfs_statvfs_list *);
.Ve
.SS "guestfs_dirent"
.IX Subsection "guestfs_dirent"
.Vb 5
\& struct guestfs_dirent {
\&   int64_t ino;
\&   char ftyp;
\&   char *name;
\& };
\& 
\& struct guestfs_dirent_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_dirent *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_dirent (const struct guestfs_dirent *, const struct guestfs_dirent *);
\& int guestfs_compare_dirent_list (const struct guestfs_dirent_list *, const struct guestfs_dirent_list *);
\& 
\& struct guestfs_dirent *guestfs_copy_dirent (const struct guestfs_dirent *);
\& struct guestfs_dirent_list *guestfs_copy_dirent_list (const struct guestfs_dirent_list *);
\& 
\& void guestfs_free_dirent (struct guestfs_dirent *);
\& void guestfs_free_dirent_list (struct guestfs_dirent_list *);
.Ve
.SS "guestfs_version"
.IX Subsection "guestfs_version"
.Vb 6
\& struct guestfs_version {
\&   int64_t major;
\&   int64_t minor;
\&   int64_t release;
\&   char *extra;
\& };
\& 
\& struct guestfs_version_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_version *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_version (const struct guestfs_version *, const struct guestfs_version *);
\& int guestfs_compare_version_list (const struct guestfs_version_list *, const struct guestfs_version_list *);
\& 
\& struct guestfs_version *guestfs_copy_version (const struct guestfs_version *);
\& struct guestfs_version_list *guestfs_copy_version_list (const struct guestfs_version_list *);
\& 
\& void guestfs_free_version (struct guestfs_version *);
\& void guestfs_free_version_list (struct guestfs_version_list *);
.Ve
.SS "guestfs_xattr"
.IX Subsection "guestfs_xattr"
.Vb 6
\& struct guestfs_xattr {
\&   char *attrname;
\&   /* Наступні два поля описують масив байтів. */
\&   uint32_t attrval_len;
\&   char *attrval;
\& };
\& 
\& struct guestfs_xattr_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_xattr *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_xattr (const struct guestfs_xattr *, const struct guestfs_xattr *);
\& int guestfs_compare_xattr_list (const struct guestfs_xattr_list *, const struct guestfs_xattr_list *);
\& 
\& struct guestfs_xattr *guestfs_copy_xattr (const struct guestfs_xattr *);
\& struct guestfs_xattr_list *guestfs_copy_xattr_list (const struct guestfs_xattr_list *);
\& 
\& void guestfs_free_xattr (struct guestfs_xattr *);
\& void guestfs_free_xattr_list (struct guestfs_xattr_list *);
.Ve
.SS "guestfs_inotify_event"
.IX Subsection "guestfs_inotify_event"
.Vb 6
\& struct guestfs_inotify_event {
\&   int64_t in_wd;
\&   uint32_t in_mask;
\&   uint32_t in_cookie;
\&   char *in_name;
\& };
\& 
\& struct guestfs_inotify_event_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_inotify_event *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_inotify_event (const struct guestfs_inotify_event *, const struct guestfs_inotify_event *);
\& int guestfs_compare_inotify_event_list (const struct guestfs_inotify_event_list *, const struct guestfs_inotify_event_list *);
\& 
\& struct guestfs_inotify_event *guestfs_copy_inotify_event (const struct guestfs_inotify_event *);
\& struct guestfs_inotify_event_list *guestfs_copy_inotify_event_list (const struct guestfs_inotify_event_list *);
\& 
\& void guestfs_free_inotify_event (struct guestfs_inotify_event *);
\& void guestfs_free_inotify_event_list (struct guestfs_inotify_event_list *);
.Ve
.SS "guestfs_partition"
.IX Subsection "guestfs_partition"
.Vb 6
\& struct guestfs_partition {
\&   int32_t part_num;
\&   uint64_t part_start;
\&   uint64_t part_end;
\&   uint64_t part_size;
\& };
\& 
\& struct guestfs_partition_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_partition *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_partition (const struct guestfs_partition *, const struct guestfs_partition *);
\& int guestfs_compare_partition_list (const struct guestfs_partition_list *, const struct guestfs_partition_list *);
\& 
\& struct guestfs_partition *guestfs_copy_partition (const struct guestfs_partition *);
\& struct guestfs_partition_list *guestfs_copy_partition_list (const struct guestfs_partition_list *);
\& 
\& void guestfs_free_partition (struct guestfs_partition *);
\& void guestfs_free_partition_list (struct guestfs_partition_list *);
.Ve
.SS "guestfs_application"
.IX Subsection "guestfs_application"
.Vb 10
\& struct guestfs_application {
\&   char *app_name;
\&   char *app_display_name;
\&   int32_t app_epoch;
\&   char *app_version;
\&   char *app_release;
\&   char *app_install_path;
\&   char *app_trans_path;
\&   char *app_publisher;
\&   char *app_url;
\&   char *app_source_package;
\&   char *app_summary;
\&   char *app_description;
\& };
\& 
\& struct guestfs_application_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_application *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_application (const struct guestfs_application *, const struct guestfs_application *);
\& int guestfs_compare_application_list (const struct guestfs_application_list *, const struct guestfs_application_list *);
\& 
\& struct guestfs_application *guestfs_copy_application (const struct guestfs_application *);
\& struct guestfs_application_list *guestfs_copy_application_list (const struct guestfs_application_list *);
\& 
\& void guestfs_free_application (struct guestfs_application *);
\& void guestfs_free_application_list (struct guestfs_application_list *);
.Ve
.SS "guestfs_application2"
.IX Subsection "guestfs_application2"
.Vb 10
\& struct guestfs_application2 {
\&   char *app2_name;
\&   char *app2_display_name;
\&   int32_t app2_epoch;
\&   char *app2_version;
\&   char *app2_release;
\&   char *app2_arch;
\&   char *app2_install_path;
\&   char *app2_trans_path;
\&   char *app2_publisher;
\&   char *app2_url;
\&   char *app2_source_package;
\&   char *app2_summary;
\&   char *app2_description;
\&   char *app2_spare1;
\&   char *app2_spare2;
\&   char *app2_spare3;
\&   char *app2_spare4;
\& };
\& 
\& struct guestfs_application2_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_application2 *val; /* Елементи.  */
\& };
\&
\& int guestfs_compare_application2 (const struct guestfs_application2 *, const struct guestfs_application2 *);
\& int guestfs_compare_application2_list (const struct guestfs_application2_list *, const struct guestfs_application2_list *);
\& 
\& struct guestfs_application2 *guestfs_copy_application2 (const struct guestfs_application2 *);
\& struct guestfs_application2_list *guestfs_copy_application2_list (const struct guestfs_application2_list *);
\& 
\& void guestfs_free_application2 (struct guestfs_application2 *);
\& void guestfs_free_application2_list (struct guestfs_application2_list *);
.Ve
.SS "guestfs_isoinfo"
.IX Subsection "guestfs_isoinfo"
.Vb 10
\& struct guestfs_isoinfo {
\&   char *iso_system_id;
\&   char *iso_volume_id;
\&   uint32_t iso_volume_space_size;
\&   uint32_t iso_volume_set_size;
\&   uint32_t iso_volume_sequence_number;
\&   uint32_t iso_logical_block_size;
\&   char *iso_volume_set_id;
\&   char *iso_publisher_id;
\&   char *iso_data_preparer_id;
\&   char *iso_application_id;
\&   char *iso_copyright_file_id;
\&   char *iso_abstract_file_id;
\&   char *iso_bibliographic_file_id;
\&   int64_t iso_volume_creation_t;
\&   int64_t iso_volume_modification_t;
\&   int64_t iso_volume_expiration_t;
\&   int64_t iso_volume_effective_t;
\& };
\& 
\& struct guestfs_isoinfo_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_isoinfo *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_isoinfo (const struct guestfs_isoinfo *, const struct guestfs_isoinfo *);
\& int guestfs_compare_isoinfo_list (const struct guestfs_isoinfo_list *, const struct guestfs_isoinfo_list *);
\& 
\& struct guestfs_isoinfo *guestfs_copy_isoinfo (const struct guestfs_isoinfo *);
\& struct guestfs_isoinfo_list *guestfs_copy_isoinfo_list (const struct guestfs_isoinfo_list *);
\& 
\& void guestfs_free_isoinfo (struct guestfs_isoinfo *);
\& void guestfs_free_isoinfo_list (struct guestfs_isoinfo_list *);
.Ve
.SS "guestfs_mdstat"
.IX Subsection "guestfs_mdstat"
.Vb 5
\& struct guestfs_mdstat {
\&   char *mdstat_device;
\&   int32_t mdstat_index;
\&   char *mdstat_flags;
\& };
\& 
\& struct guestfs_mdstat_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_mdstat *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_mdstat (const struct guestfs_mdstat *, const struct guestfs_mdstat *);
\& int guestfs_compare_mdstat_list (const struct guestfs_mdstat_list *, const struct guestfs_mdstat_list *);
\& 
\& struct guestfs_mdstat *guestfs_copy_mdstat (const struct guestfs_mdstat *);
\& struct guestfs_mdstat_list *guestfs_copy_mdstat_list (const struct guestfs_mdstat_list *);
\& 
\& void guestfs_free_mdstat (struct guestfs_mdstat *);
\& void guestfs_free_mdstat_list (struct guestfs_mdstat_list *);
.Ve
.SS "guestfs_btrfssubvolume"
.IX Subsection "guestfs_btrfssubvolume"
.Vb 5
\& struct guestfs_btrfssubvolume {
\&   uint64_t btrfssubvolume_id;
\&   uint64_t btrfssubvolume_top_level_id;
\&   char *btrfssubvolume_path;
\& };
\& 
\& struct guestfs_btrfssubvolume_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_btrfssubvolume *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_btrfssubvolume (const struct guestfs_btrfssubvolume *, const struct guestfs_btrfssubvolume *);
\& int guestfs_compare_btrfssubvolume_list (const struct guestfs_btrfssubvolume_list *, const struct guestfs_btrfssubvolume_list *);
\& 
\& struct guestfs_btrfssubvolume *guestfs_copy_btrfssubvolume (const struct guestfs_btrfssubvolume *);
\& struct guestfs_btrfssubvolume_list *guestfs_copy_btrfssubvolume_list (const struct guestfs_btrfssubvolume_list *);
\& 
\& void guestfs_free_btrfssubvolume (struct guestfs_btrfssubvolume *);
\& void guestfs_free_btrfssubvolume_list (struct guestfs_btrfssubvolume_list *);
.Ve
.SS "guestfs_btrfsqgroup"
.IX Subsection "guestfs_btrfsqgroup"
.Vb 5
\& struct guestfs_btrfsqgroup {
\&   char *btrfsqgroup_id;
\&   uint64_t btrfsqgroup_rfer;
\&   uint64_t btrfsqgroup_excl;
\& };
\& 
\& struct guestfs_btrfsqgroup_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_btrfsqgroup *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_btrfsqgroup (const struct guestfs_btrfsqgroup *, const struct guestfs_btrfsqgroup *);
\& int guestfs_compare_btrfsqgroup_list (const struct guestfs_btrfsqgroup_list *, const struct guestfs_btrfsqgroup_list *);
\& 
\& struct guestfs_btrfsqgroup *guestfs_copy_btrfsqgroup (const struct guestfs_btrfsqgroup *);
\& struct guestfs_btrfsqgroup_list *guestfs_copy_btrfsqgroup_list (const struct guestfs_btrfsqgroup_list *);
\& 
\& void guestfs_free_btrfsqgroup (struct guestfs_btrfsqgroup *);
\& void guestfs_free_btrfsqgroup_list (struct guestfs_btrfsqgroup_list *);
.Ve
.SS "guestfs_btrfsbalance"
.IX Subsection "guestfs_btrfsbalance"
.Vb 7
\& struct guestfs_btrfsbalance {
\&   char *btrfsbalance_status;
\&   uint64_t btrfsbalance_total;
\&   uint64_t btrfsbalance_balanced;
\&   uint64_t btrfsbalance_considered;
\&   uint64_t btrfsbalance_left;
\& };
\& 
\& struct guestfs_btrfsbalance_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_btrfsbalance *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_btrfsbalance (const struct guestfs_btrfsbalance *, const struct guestfs_btrfsbalance *);
\& int guestfs_compare_btrfsbalance_list (const struct guestfs_btrfsbalance_list *, const struct guestfs_btrfsbalance_list *);
\& 
\& struct guestfs_btrfsbalance *guestfs_copy_btrfsbalance (const struct guestfs_btrfsbalance *);
\& struct guestfs_btrfsbalance_list *guestfs_copy_btrfsbalance_list (const struct guestfs_btrfsbalance_list *);
\& 
\& void guestfs_free_btrfsbalance (struct guestfs_btrfsbalance *);
\& void guestfs_free_btrfsbalance_list (struct guestfs_btrfsbalance_list *);
.Ve
.SS "guestfs_btrfsscrub"
.IX Subsection "guestfs_btrfsscrub"
.Vb 10
\& struct guestfs_btrfsscrub {
\&   uint64_t btrfsscrub_data_extents_scrubbed;
\&   uint64_t btrfsscrub_tree_extents_scrubbed;
\&   uint64_t btrfsscrub_data_bytes_scrubbed;
\&   uint64_t btrfsscrub_tree_bytes_scrubbed;
\&   uint64_t btrfsscrub_read_errors;
\&   uint64_t btrfsscrub_csum_errors;
\&   uint64_t btrfsscrub_verify_errors;
\&   uint64_t btrfsscrub_no_csum;
\&   uint64_t btrfsscrub_csum_discards;
\&   uint64_t btrfsscrub_super_errors;
\&   uint64_t btrfsscrub_malloc_errors;
\&   uint64_t btrfsscrub_uncorrectable_errors;
\&   uint64_t btrfsscrub_unverified_errors;
\&   uint64_t btrfsscrub_corrected_errors;
\&   uint64_t btrfsscrub_last_physical;
\& };
\& 
\& struct guestfs_btrfsscrub_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_btrfsscrub *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_btrfsscrub (const struct guestfs_btrfsscrub *, const struct guestfs_btrfsscrub *);
\& int guestfs_compare_btrfsscrub_list (const struct guestfs_btrfsscrub_list *, const struct guestfs_btrfsscrub_list *);
\& 
\& struct guestfs_btrfsscrub *guestfs_copy_btrfsscrub (const struct guestfs_btrfsscrub *);
\& struct guestfs_btrfsscrub_list *guestfs_copy_btrfsscrub_list (const struct guestfs_btrfsscrub_list *);
\& 
\& void guestfs_free_btrfsscrub (struct guestfs_btrfsscrub *);
\& void guestfs_free_btrfsscrub_list (struct guestfs_btrfsscrub_list *);
.Ve
.SS "guestfs_xfsinfo"
.IX Subsection "guestfs_xfsinfo"
.Vb 10
\& struct guestfs_xfsinfo {
\&   char *xfs_mntpoint;
\&   uint32_t xfs_inodesize;
\&   uint32_t xfs_agcount;
\&   uint32_t xfs_agsize;
\&   uint32_t xfs_sectsize;
\&   uint32_t xfs_attr;
\&   uint32_t xfs_blocksize;
\&   uint64_t xfs_datablocks;
\&   uint32_t xfs_imaxpct;
\&   uint32_t xfs_sunit;
\&   uint32_t xfs_swidth;
\&   uint32_t xfs_dirversion;
\&   uint32_t xfs_dirblocksize;
\&   uint32_t xfs_cimode;
\&   char *xfs_logname;
\&   uint32_t xfs_logblocksize;
\&   uint32_t xfs_logblocks;
\&   uint32_t xfs_logversion;
\&   uint32_t xfs_logsectsize;
\&   uint32_t xfs_logsunit;
\&   uint32_t xfs_lazycount;
\&   char *xfs_rtname;
\&   uint32_t xfs_rtextsize;
\&   uint64_t xfs_rtblocks;
\&   uint64_t xfs_rtextents;
\& };
\& 
\& struct guestfs_xfsinfo_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_xfsinfo *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_xfsinfo (const struct guestfs_xfsinfo *, const struct guestfs_xfsinfo *);
\& int guestfs_compare_xfsinfo_list (const struct guestfs_xfsinfo_list *, const struct guestfs_xfsinfo_list *);
\& 
\& struct guestfs_xfsinfo *guestfs_copy_xfsinfo (const struct guestfs_xfsinfo *);
\& struct guestfs_xfsinfo_list *guestfs_copy_xfsinfo_list (const struct guestfs_xfsinfo_list *);
\& 
\& void guestfs_free_xfsinfo (struct guestfs_xfsinfo *);
\& void guestfs_free_xfsinfo_list (struct guestfs_xfsinfo_list *);
.Ve
.SS "guestfs_utsname"
.IX Subsection "guestfs_utsname"
.Vb 6
\& struct guestfs_utsname {
\&   char *uts_sysname;
\&   char *uts_release;
\&   char *uts_version;
\&   char *uts_machine;
\& };
\& 
\& struct guestfs_utsname_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_utsname *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_utsname (const struct guestfs_utsname *, const struct guestfs_utsname *);
\& int guestfs_compare_utsname_list (const struct guestfs_utsname_list *, const struct guestfs_utsname_list *);
\& 
\& struct guestfs_utsname *guestfs_copy_utsname (const struct guestfs_utsname *);
\& struct guestfs_utsname_list *guestfs_copy_utsname_list (const struct guestfs_utsname_list *);
\& 
\& void guestfs_free_utsname (struct guestfs_utsname *);
\& void guestfs_free_utsname_list (struct guestfs_utsname_list *);
.Ve
.SS "guestfs_hivex_node"
.IX Subsection "guestfs_hivex_node"
.Vb 3
\& struct guestfs_hivex_node {
\&   int64_t hivex_node_h;
\& };
\& 
\& struct guestfs_hivex_node_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_hivex_node *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_hivex_node (const struct guestfs_hivex_node *, const struct guestfs_hivex_node *);
\& int guestfs_compare_hivex_node_list (const struct guestfs_hivex_node_list *, const struct guestfs_hivex_node_list *);
\& 
\& struct guestfs_hivex_node *guestfs_copy_hivex_node (const struct guestfs_hivex_node *);
\& struct guestfs_hivex_node_list *guestfs_copy_hivex_node_list (const struct guestfs_hivex_node_list *);
\& 
\& void guestfs_free_hivex_node (struct guestfs_hivex_node *);
\& void guestfs_free_hivex_node_list (struct guestfs_hivex_node_list *);
.Ve
.SS "guestfs_hivex_value"
.IX Subsection "guestfs_hivex_value"
.Vb 3
\& struct guestfs_hivex_value {
\&   int64_t hivex_value_h;
\& };
\& 
\& struct guestfs_hivex_value_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_hivex_value *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_hivex_value (const struct guestfs_hivex_value *, const struct guestfs_hivex_value *);
\& int guestfs_compare_hivex_value_list (const struct guestfs_hivex_value_list *, const struct guestfs_hivex_value_list *);
\& 
\& struct guestfs_hivex_value *guestfs_copy_hivex_value (const struct guestfs_hivex_value *);
\& struct guestfs_hivex_value_list *guestfs_copy_hivex_value_list (const struct guestfs_hivex_value_list *);
\& 
\& void guestfs_free_hivex_value (struct guestfs_hivex_value *);
\& void guestfs_free_hivex_value_list (struct guestfs_hivex_value_list *);
.Ve
.SS "guestfs_internal_mountable"
.IX Subsection "guestfs_internal_mountable"
.Vb 5
\& struct guestfs_internal_mountable {
\&   int32_t im_type;
\&   char *im_device;
\&   char *im_volume;
\& };
\& 
\& struct guestfs_internal_mountable_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_internal_mountable *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_internal_mountable (const struct guestfs_internal_mountable *, const struct guestfs_internal_mountable *);
\& int guestfs_compare_internal_mountable_list (const struct guestfs_internal_mountable_list *, const struct guestfs_internal_mountable_list *);
\& 
\& struct guestfs_internal_mountable *guestfs_copy_internal_mountable (const struct guestfs_internal_mountable *);
\& struct guestfs_internal_mountable_list *guestfs_copy_internal_mountable_list (const struct guestfs_internal_mountable_list *);
\& 
\& void guestfs_free_internal_mountable (struct guestfs_internal_mountable *);
\& void guestfs_free_internal_mountable_list (struct guestfs_internal_mountable_list *);
.Ve
.SS "guestfs_tsk_dirent"
.IX Subsection "guestfs_tsk_dirent"
.Vb 10
\& struct guestfs_tsk_dirent {
\&   uint64_t tsk_inode;
\&   char tsk_type;
\&   int64_t tsk_size;
\&   char *tsk_name;
\&   uint32_t tsk_flags;
\&   int64_t tsk_atime_sec;
\&   int64_t tsk_atime_nsec;
\&   int64_t tsk_mtime_sec;
\&   int64_t tsk_mtime_nsec;
\&   int64_t tsk_ctime_sec;
\&   int64_t tsk_ctime_nsec;
\&   int64_t tsk_crtime_sec;
\&   int64_t tsk_crtime_nsec;
\&   int64_t tsk_nlink;
\&   char *tsk_link;
\&   int64_t tsk_spare1;
\& };
\& 
\& struct guestfs_tsk_dirent_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_tsk_dirent *val; /* Elements. */
\& };
\&
\& int guestfs_compare_tsk_dirent (const struct guestfs_tsk_dirent *, const struct guestfs_tsk_dirent *);
\& int guestfs_compare_tsk_dirent_list (const struct guestfs_tsk_dirent_list *, const struct guestfs_tsk_dirent_list *);
\& 
\& struct guestfs_tsk_dirent *guestfs_copy_tsk_dirent (const struct guestfs_tsk_dirent *);
\& struct guestfs_tsk_dirent_list *guestfs_copy_tsk_dirent_list (const struct guestfs_tsk_dirent_list *);
\& 
\& void guestfs_free_tsk_dirent (struct guestfs_tsk_dirent *);
\& void guestfs_free_tsk_dirent_list (struct guestfs_tsk_dirent_list *);
.Ve
.SS "guestfs_yara_detection"
.IX Subsection "guestfs_yara_detection"
.Vb 4
\& struct guestfs_yara_detection {
\&   char *yara_name;
\&   char *yara_rule;
\& };
\& 
\& struct guestfs_yara_detection_list {
\&   uint32_t len; /* Кількість елементів у списку. */
\&   struct guestfs_yara_detection *val; /* Елементи. */
\& };
\&
\& int guestfs_compare_yara_detection (const struct guestfs_yara_detection *, const struct guestfs_yara_detection *);
\& int guestfs_compare_yara_detection_list (const struct guestfs_yara_detection_list *, const struct guestfs_yara_detection_list *);
\& 
\& struct guestfs_yara_detection *guestfs_copy_yara_detection (const struct guestfs_yara_detection *);
\& struct guestfs_yara_detection_list *guestfs_copy_yara_detection_list (const struct guestfs_yara_detection_list *);
\& 
\& void guestfs_free_yara_detection (struct guestfs_yara_detection *);
\& void guestfs_free_yara_detection_list (struct guestfs_yara_detection_list *);
.Ve
.SH "ДОСТУПНІСТЬ"
.IX Header "ДОСТУПНІСТЬ"
.SS "ГРУПИ ФУНКЦІОНАЛЬНИХ МОЖЛИВОСТЕЙ У ОБРАЗІ ОСНОВНОЇ СИСТЕМИ"
.IX Subsection "ГРУПИ ФУНКЦІОНАЛЬНИХ МОЖЛИВОСТЕЙ У ОБРАЗІ ОСНОВНОЇ СИСТЕМИ"
За допомогою \*(L"guestfs_available\*(R" ви можете перевірити доступність вказаних
нижче груп функцій. Засіб тестування опитає базову систему для визначення,
чи передбачено у ній підтримку функціональних можливостей.
.IP "\fBacl\fR" 4
.IX Item "acl"
Такі функції: \*(L"guestfs_acl_delete_def_file\*(R" \*(L"guestfs_acl_get_file\*(R"
\&\*(L"guestfs_acl_set_file\*(R"
.IP "\fBblkdiscard\fR" 4
.IX Item "blkdiscard"
Такі функції: \*(L"guestfs_blkdiscard\*(R"
.IP "\fBblkdiscardzeroes\fR" 4
.IX Item "blkdiscardzeroes"
Такі функції: \*(L"guestfs_blkdiscardzeroes\*(R"
.IP "\fBbtrfs\fR" 4
.IX Item "btrfs"
Такі функції: \*(L"guestfs_btrfs_balance_cancel\*(R"
\&\*(L"guestfs_btrfs_balance_pause\*(R" \*(L"guestfs_btrfs_balance_resume\*(R"
\&\*(L"guestfs_btrfs_balance_status\*(R" \*(L"guestfs_btrfs_device_add\*(R"
\&\*(L"guestfs_btrfs_device_delete\*(R" \*(L"guestfs_btrfs_filesystem_balance\*(R"
\&\*(L"guestfs_btrfs_filesystem_defragment\*(R" \*(L"guestfs_btrfs_filesystem_resize\*(R"
\&\*(L"guestfs_btrfs_filesystem_show\*(R" \*(L"guestfs_btrfs_filesystem_sync\*(R"
\&\*(L"guestfs_btrfs_fsck\*(R" \*(L"guestfs_btrfs_image\*(R"
\&\*(L"guestfs_btrfs_qgroup_assign\*(R" \*(L"guestfs_btrfs_qgroup_create\*(R"
\&\*(L"guestfs_btrfs_qgroup_destroy\*(R" \*(L"guestfs_btrfs_qgroup_limit\*(R"
\&\*(L"guestfs_btrfs_qgroup_remove\*(R" \*(L"guestfs_btrfs_qgroup_show\*(R"
\&\*(L"guestfs_btrfs_quota_enable\*(R" \*(L"guestfs_btrfs_quota_rescan\*(R"
\&\*(L"guestfs_btrfs_replace\*(R" \*(L"guestfs_btrfs_rescue_chunk_recover\*(R"
\&\*(L"guestfs_btrfs_rescue_super_recover\*(R" \*(L"guestfs_btrfs_scrub_cancel\*(R"
\&\*(L"guestfs_btrfs_scrub_resume\*(R" \*(L"guestfs_btrfs_scrub_start\*(R"
\&\*(L"guestfs_btrfs_scrub_status\*(R" \*(L"guestfs_btrfs_set_seeding\*(R"
\&\*(L"guestfs_btrfs_subvolume_create\*(R" \*(L"guestfs_btrfs_subvolume_delete\*(R"
\&\*(L"guestfs_btrfs_subvolume_get_default\*(R" \*(L"guestfs_btrfs_subvolume_list\*(R"
\&\*(L"guestfs_btrfs_subvolume_set_default\*(R" \*(L"guestfs_btrfs_subvolume_show\*(R"
\&\*(L"guestfs_btrfs_subvolume_snapshot\*(R"
\&\*(L"guestfs_btrfstune_enable_extended_inode_refs\*(R"
\&\*(L"guestfs_btrfstune_enable_skinny_metadata_extent_refs\*(R"
\&\*(L"guestfs_btrfstune_seeding\*(R" \*(L"guestfs_mkfs_btrfs\*(R"
.IP "\fBextlinux\fR" 4
.IX Item "extlinux"
Такі функції: \*(L"guestfs_extlinux\*(R"
.IP "\fBf2fs\fR" 4
.IX Item "f2fs"
The following functions: \*(L"guestfs_f2fs_expand\*(R"
.IP "\fBfstrim\fR" 4
.IX Item "fstrim"
Такі функції: \*(L"guestfs_fstrim\*(R"
.IP "\fBgdisk\fR" 4
.IX Item "gdisk"
Такі функції: \*(L"guestfs_part_expand_gpt\*(R" \*(L"guestfs_part_get_disk_guid\*(R"
\&\*(L"guestfs_part_get_gpt_attributes\*(R" \*(L"guestfs_part_get_gpt_guid\*(R"
\&\*(L"guestfs_part_get_gpt_type\*(R" \*(L"guestfs_part_set_disk_guid\*(R"
\&\*(L"guestfs_part_set_disk_guid_random\*(R" \*(L"guestfs_part_set_gpt_attributes\*(R"
\&\*(L"guestfs_part_set_gpt_guid\*(R" \*(L"guestfs_part_set_gpt_type\*(R"
.IP "\fBgrub\fR" 4
.IX Item "grub"
Такі функції: \*(L"guestfs_grub_install\*(R"
.IP "\fBhivex\fR" 4
.IX Item "hivex"
Такі функції: \*(L"guestfs_hivex_close\*(R" \*(L"guestfs_hivex_commit\*(R"
\&\*(L"guestfs_hivex_node_add_child\*(R" \*(L"guestfs_hivex_node_children\*(R"
\&\*(L"guestfs_hivex_node_delete_child\*(R" \*(L"guestfs_hivex_node_get_child\*(R"
\&\*(L"guestfs_hivex_node_get_value\*(R" \*(L"guestfs_hivex_node_name\*(R"
\&\*(L"guestfs_hivex_node_parent\*(R" \*(L"guestfs_hivex_node_set_value\*(R"
\&\*(L"guestfs_hivex_node_values\*(R" \*(L"guestfs_hivex_open\*(R" \*(L"guestfs_hivex_root\*(R"
\&\*(L"guestfs_hivex_value_key\*(R" \*(L"guestfs_hivex_value_string\*(R"
\&\*(L"guestfs_hivex_value_type\*(R" \*(L"guestfs_hivex_value_utf8\*(R"
\&\*(L"guestfs_hivex_value_value\*(R"
.IP "\fBinotify\fR" 4
.IX Item "inotify"
Такі функції: \*(L"guestfs_inotify_add_watch\*(R" \*(L"guestfs_inotify_close\*(R"
\&\*(L"guestfs_inotify_files\*(R" \*(L"guestfs_inotify_init\*(R" \*(L"guestfs_inotify_read\*(R"
\&\*(L"guestfs_inotify_rm_watch\*(R"
.IP "\fBjournal\fR" 4
.IX Item "journal"
Такі функції: \*(L"guestfs_internal_journal_get\*(R" \*(L"guestfs_journal_close\*(R"
\&\*(L"guestfs_journal_get_data_threshold\*(R" \*(L"guestfs_journal_get_realtime_usec\*(R"
\&\*(L"guestfs_journal_next\*(R" \*(L"guestfs_journal_open\*(R"
\&\*(L"guestfs_journal_set_data_threshold\*(R" \*(L"guestfs_journal_skip\*(R"
.IP "\fBldm\fR" 4
.IX Item "ldm"
Такі функції: \*(L"guestfs_ldmtool_create_all\*(R"
\&\*(L"guestfs_ldmtool_diskgroup_disks\*(R" \*(L"guestfs_ldmtool_diskgroup_name\*(R"
\&\*(L"guestfs_ldmtool_diskgroup_volumes\*(R" \*(L"guestfs_ldmtool_remove_all\*(R"
\&\*(L"guestfs_ldmtool_scan\*(R" \*(L"guestfs_ldmtool_scan_devices\*(R"
\&\*(L"guestfs_ldmtool_volume_hint\*(R" \*(L"guestfs_ldmtool_volume_partitions\*(R"
\&\*(L"guestfs_ldmtool_volume_type\*(R" \*(L"guestfs_list_ldm_partitions\*(R"
\&\*(L"guestfs_list_ldm_volumes\*(R"
.IP "\fBlibtsk\fR" 4
.IX Item "libtsk"
Такі функції: \*(L"guestfs_internal_filesystem_walk\*(R"
\&\*(L"guestfs_internal_find_inode\*(R"
.IP "\fBlibyara\fR" 4
.IX Item "libyara"
Такі функції: \*(L"guestfs_internal_yara_scan\*(R" \*(L"guestfs_yara_destroy\*(R"
\&\*(L"guestfs_yara_load\*(R"
.IP "\fBlinuxcaps\fR" 4
.IX Item "linuxcaps"
Такі функції: \*(L"guestfs_cap_get_file\*(R" \*(L"guestfs_cap_set_file\*(R"
.IP "\fBlinuxfsuuid\fR" 4
.IX Item "linuxfsuuid"
Такі функції: \*(L"guestfs_mke2fs_JU\*(R" \*(L"guestfs_mke2journal_U\*(R"
\&\*(L"guestfs_mkswap_U\*(R" \*(L"guestfs_swapoff_uuid\*(R" \*(L"guestfs_swapon_uuid\*(R"
.IP "\fBlinuxmodules\fR" 4
.IX Item "linuxmodules"
Такі функції: \*(L"guestfs_modprobe\*(R"
.IP "\fBlinuxxattrs\fR" 4
.IX Item "linuxxattrs"
Такі функції: \*(L"guestfs_getxattr\*(R" \*(L"guestfs_getxattrs\*(R"
\&\*(L"guestfs_internal_lxattrlist\*(R" \*(L"guestfs_lgetxattr\*(R" \*(L"guestfs_lgetxattrs\*(R"
\&\*(L"guestfs_lremovexattr\*(R" \*(L"guestfs_lsetxattr\*(R" \*(L"guestfs_removexattr\*(R"
\&\*(L"guestfs_setxattr\*(R"
.IP "\fBluks\fR" 4
.IX Item "luks"
Такі функції: \*(L"guestfs_luks_add_key\*(R" \*(L"guestfs_luks_close\*(R"
\&\*(L"guestfs_luks_format\*(R" \*(L"guestfs_luks_format_cipher\*(R"
\&\*(L"guestfs_luks_kill_slot\*(R" \*(L"guestfs_luks_open\*(R" \*(L"guestfs_luks_open_ro\*(R"
.IP "\fBlvm2\fR" 4
.IX Item "lvm2"
Такі функції: \*(L"guestfs_lvcreate\*(R" \*(L"guestfs_lvcreate_free\*(R"
\&\*(L"guestfs_lvm_remove_all\*(R" \*(L"guestfs_lvm_set_filter\*(R" \*(L"guestfs_lvremove\*(R"
\&\*(L"guestfs_lvresize\*(R" \*(L"guestfs_lvresize_free\*(R" \*(L"guestfs_lvs\*(R"
\&\*(L"guestfs_lvs_full\*(R" \*(L"guestfs_pvchange_uuid\*(R" \*(L"guestfs_pvchange_uuid_all\*(R"
\&\*(L"guestfs_pvcreate\*(R" \*(L"guestfs_pvremove\*(R" \*(L"guestfs_pvresize\*(R"
\&\*(L"guestfs_pvresize_size\*(R" \*(L"guestfs_pvs\*(R" \*(L"guestfs_pvs_full\*(R"
\&\*(L"guestfs_vg_activate\*(R" \*(L"guestfs_vg_activate_all\*(R"
\&\*(L"guestfs_vgchange_uuid\*(R" \*(L"guestfs_vgchange_uuid_all\*(R" \*(L"guestfs_vgcreate\*(R"
\&\*(L"guestfs_vgmeta\*(R" \*(L"guestfs_vgremove\*(R" \*(L"guestfs_vgs\*(R" \*(L"guestfs_vgs_full\*(R"
.IP "\fBmdadm\fR" 4
.IX Item "mdadm"
Такі функції: \*(L"guestfs_md_create\*(R" \*(L"guestfs_md_detail\*(R"
\&\*(L"guestfs_md_stat\*(R" \*(L"guestfs_md_stop\*(R"
.IP "\fBmknod\fR" 4
.IX Item "mknod"
Такі функції: \*(L"guestfs_mkfifo\*(R" \*(L"guestfs_mknod\*(R" \*(L"guestfs_mknod_b\*(R"
\&\*(L"guestfs_mknod_c\*(R"
.IP "\fBntfs3g\fR" 4
.IX Item "ntfs3g"
Такі функції: \*(L"guestfs_ntfs_3g_probe\*(R" \*(L"guestfs_ntfsclone_in\*(R"
\&\*(L"guestfs_ntfsclone_out\*(R" \*(L"guestfs_ntfsfix\*(R"
.IP "\fBntfsprogs\fR" 4
.IX Item "ntfsprogs"
Такі функції: \*(L"guestfs_ntfsresize\*(R" \*(L"guestfs_ntfsresize_size\*(R"
.IP "\fBrsync\fR" 4
.IX Item "rsync"
Такі функції: \*(L"guestfs_rsync\*(R" \*(L"guestfs_rsync_in\*(R" \*(L"guestfs_rsync_out\*(R"
.IP "\fBscrub\fR" 4
.IX Item "scrub"
Такі функції: \*(L"guestfs_scrub_device\*(R" \*(L"guestfs_scrub_file\*(R"
\&\*(L"guestfs_scrub_freespace\*(R"
.IP "\fBselinux\fR" 4
.IX Item "selinux"
Такі функції: \*(L"guestfs_getcon\*(R" \*(L"guestfs_setcon\*(R"
.IP "\fBselinuxrelabel\fR" 4
.IX Item "selinuxrelabel"
Такі функції: \*(L"guestfs_selinux_relabel\*(R"
.IP "\fBsleuthkit\fR" 4
.IX Item "sleuthkit"
Такі функції: \*(L"guestfs_download_blocks\*(R"
.IP "\fBsquashfs\fR" 4
.IX Item "squashfs"
Такі функції: \*(L"guestfs_mksquashfs\*(R"
.IP "\fBsyslinux\fR" 4
.IX Item "syslinux"
Такі функції: \*(L"guestfs_syslinux\*(R"
.IP "\fBwipefs\fR" 4
.IX Item "wipefs"
Такі функції: \*(L"guestfs_wipefs\*(R"
.IP "\fBxfs\fR" 4
.IX Item "xfs"
Такі функції: \*(L"guestfs_xfs_admin\*(R" \*(L"guestfs_xfs_growfs\*(R"
\&\*(L"guestfs_xfs_info\*(R" \*(L"guestfs_xfs_repair\*(R"
.IP "\fBxz\fR" 4
.IX Item "xz"
Такі функції: \*(L"guestfs_txz_in\*(R" \*(L"guestfs_txz_out\*(R"
.IP "\fBzerofree\fR" 4
.IX Item "zerofree"
Такі функції: \*(L"guestfs_zerofree\*(R"
.SS "ДОСТУПНІ ФАЙЛОВІ СИСТЕМИ"
.IX Subsection "ДОСТУПНІ ФАЙЛОВІ СИСТЕМИ"
Функція \*(L"guestfs_filesystem_available\*(R" викликає засоби тестування для
визначення, чи доступна підтримка певного типу файлової системи у ядрі
базової операційної системи.
.PP
Головним чином корисне для перевірки того, що підтримки не передбачено. Те,
що команда повертає true, ще не означає, що певну файлову систему може бути
змонтовано, оскільки помилки можуть траплятися через інші причини, зокрема
невідповідність версії файлової системи, несумісність можливостей.
.SS "КОМАНДА \s-1GUESTFISH\s0 supported"
.IX Subsection "КОМАНДА GUESTFISH supported"
У \fBguestfish\fR\|(3) передбачено зручну інтерактивну команду \f(CW\*(C`supported\*(C'\fR, яка
виводить доступні групи, а також дані щодо їхньої підтримки у збірці
libguestfs. Втім, слід зауважити, спочатку слід виконати команду \f(CW\*(C`run\*(C'\fR.
.SS "ОКРЕМІ ВИКЛИКИ ПІД ЧАС КОМПІЛЯЦІЇ"
.IX Subsection "ОКРЕМІ ВИКЛИКИ ПІД ЧАС КОМПІЛЯЦІЇ"
Починаючи з версії 1.5.8, \f(CW\*(C`<guestfs.h>\*(C'\fR визначає символи для кожної
функції програмного інтерфейсу C, зокрема:
.PP
.Vb 1
\& #define GUESTFS_HAVE_DD 1
.Ve
.PP
якщо доступна \*(L"guestfs_dd\*(R".
.PP
До версії 1.5.8, якщо вам потрібно було перевірити, чи доступна окрема
функція libguestfs під час компіляції, ми рекомендували скористатися
засобами збирання, зокрема autoconf або cmake. Наприклад, у autotools ви
могли скористатися таким кодом:
.PP
.Vb 2
\& AC_CHECK_LIB([guestfs],[guestfs_create])
\& AC_CHECK_FUNCS([guestfs_dd])
.Ve
.PP
який призводив до того, що \f(CW\*(C`HAVE_GUESTFS_DD\*(C'\fR було або визначено, або не
визначено у вашій програмі.
.SS "ОКРЕМІ ВИКЛИКИ ПІД ЧАС РОБОТИ"
.IX Subsection "ОКРЕМІ ВИКЛИКИ ПІД ЧАС РОБОТИ"
Перевірка під час компіляції не гарантує існування функції у
бібліотеці. Причиною є те, що можливе динамічне компонування із попереднім
варіантом \fIlibguestfs.so\fR (динамічної бібліотеки), у якому немає потрібного
виклику. На жаль, така ситуація призводить до помилки сегментації, що є
загальним недоліком системи динамічного компонування у C.
.PP
Під час роботи програми ви можете скористатися \fBdlopen\fR\|(3) для перевірки
того, чи доступна функція. Ось приклад програми (зауважте, що вам все одно
слід виконати перевірку під час компіляції):
.PP
.Vb 5
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <unistd.h>
\& #include <dlfcn.h>
\& #include <guestfs.h>
\& 
\& main ()
\& {
\& #ifdef GUESTFS_HAVE_DD
\&   void *dl;
\&   int has_function;
\& 
\&   /* Перевіряємо, чи дійсно функція guestfs_dd є доступною. */
\&   dl = dlopen (NULL, RTLD_LAZY);
\&   if (!dl) {
\&     fprintf (stderr, "dlopen: %s\en", dlerror ());
\&     exit (EXIT_FAILURE);
\&   }
\&   has_function = dlsym (dl, "guestfs_dd") != NULL;
\&   dlclose (dl);
\& 
\&   if (!has_function)
\&     printf ("this libguestfs.so does NOT have guestfs_dd function\en");
\&   else {
\&     printf ("this libguestfs.so has guestfs_dd function\en");
\&     /* Now it\*(Aqs safe to call
\&     guestfs_dd (g, "foo", "bar");
\&     */
\&   }
\& #else
\&   printf ("guestfs_dd function was not found at compile time\en");
\& #endif
\&  }
.Ve
.PP
Вам може здатися, що у наведеному вище прикладі реалізовано доволі марудну
перевірку, і це насправді так. Існують інші способи поза системою
компонування C, які надають змогу гарантувати те, що такого роду
несумісність ніколи не трапиться. Зокрема, можна скористатися системою
визначення версій пакунків:
.PP
.Vb 1
\& Потрібна версія: libguestfs >= 1.0.80
.Ve
.SH "ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ"
.IX Header "ВИКЛИКИ ІЗ НЕОБОВ'ЯЗКОВИМИ АРГУМЕНТАМИ"
Нещодавно реалізованою у програмному інтерфейсі можливістю є впровадження
викликів, які приймають необов'язкові аргументи. У C такі виклики
оголошуються у 3 способи. Основним способом є виклик, який приймає змінні
аргументи (тобто \f(CW\*(C`...\*(C'\fR), як у цьому прикладі:
.PP
.Vb 1
\& int guestfs_add_drive_opts (guestfs_h *g, const char *filename, ...);
.Ve
.PP
Викличте цю функцію зі списком необов'язкових аргументів, який
завершуватиметься \f(CW\*(C`\-1\*(C'\fR. Отже, щоб викликати функцію без необов'язкових
аргументів, зробіть так:
.PP
.Vb 1
\& guestfs_add_drive_opts (g, filename, \-1);
.Ve
.PP
З одним додатковим аргументом:
.PP
.Vb 3
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
\&                         \-1);
.Ve
.PP
З двома аргументами:
.PP
.Vb 4
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
\&                         GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
\&                         \-1);
.Ve
.PP
і так далі. Не забувайте завершувати список \f(CW\*(C`\-1\*(C'\fR, інакше можливі дуже
печальні наслідки!
.SS "ВИКОРИСТАННЯ va_list ДЛЯ НЕОБОВ'ЯЗКОВИХ АРГУМЕНТІВ"
.IX Subsection "ВИКОРИСТАННЯ va_list ДЛЯ НЕОБОВ'ЯЗКОВИХ АРГУМЕНТІВ"
Другий варіант має ту саму назву із суфіксом \f(CW\*(C`_va\*(C'\fR. Він працює так само,
але отримує \f(CW\*(C`va_list\*(C'\fR. Див. підручник з C, щоб дізнатися більше. Приклад
функції з оголошенням:
.PP
.Vb 2
\& int guestfs_add_drive_opts_va (guestfs_h *g, const char *filename,
\&                                va_list args);
.Ve
.SS "ПОБУДОВА ДОДАТКОВИХ АРГУМЕНТІВ"
.IX Subsection "ПОБУДОВА ДОДАТКОВИХ АРГУМЕНТІВ"
Третій варіант корисний там, де вам потрібно побудувати ці виклики. Ви
передаєте структуру, у якій ви заповнюєте необов'язкові поля. Структура
містить бітову маску як перший елемент. Ви маєте встановити цю маску для
позначення того, які поля вам слід заповнити. У нашому прикладі функції
оголошено структуру і виклик:
.PP
.Vb 8
\& struct guestfs_add_drive_opts_argv {
\&   uint64_t bitmask;
\&   int readonly;
\&   const char *format;
\&   /* ... */
\& };
\& int guestfs_add_drive_opts_argv (guestfs_h *g, const char *filename,
\&              const struct guestfs_add_drive_opts_argv *optargs);
.Ve
.PP
Ви можете викликати її ось так:
.PP
.Vb 6
\& struct guestfs_add_drive_opts_argv optargs = {
\&   .bitmask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK |
\&              GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK,
\&   .readonly = 1,
\&   .format = "qcow2"
\& };
\& 
\& guestfs_add_drive_opts_argv (g, filename, &optargs);
.Ve
.PP
Нотатки:
.IP "\(bu" 4
Суфікс \f(CW\*(C`_BITMASK\*(C'\fR при назві кожного параметр, якщо вказуємо бітову маску.
.IP "\(bu" 4
Вам не слід заповнювати усі поля структури.
.IP "\(bu" 4
Має існувати однозначна відповідність між полями структури, які
заповнюються, і набором бітів у бітовій масці.
.SS "ДОДАТКОВІ АРГУМЕНТИ ІНШИМИ МОВАМИ"
.IX Subsection "ДОДАТКОВІ АРГУМЕНТИ ІНШИМИ МОВАМИ"
У інших мовах необов'язкові аргументи виражаються у спосіб, який є природним
для цієї мови. Закликаємо вас звернутися до специфічної для мови
документації, щоб дізнатися більше про це.
.PP
Щодо guestfish, див. \*(L"НЕОБОВ'ЯЗКОВІ АРГУМЕНТИ\*(R" in \fBguestfish\fR\|(1).
.SH "ПОДІЇ"
.IX Header "ПОДІЇ"
.SS "ВСТАНОВЛЕННЯ ЗВОРОТНИХ ВИКЛИКІВ ДЛЯ ОБРОБКИ ПОДІЙ"
.IX Subsection "ВСТАНОВЛЕННЯ ЗВОРОТНИХ ВИКЛИКІВ ДЛЯ ОБРОБКИ ПОДІЙ"
\&\fBЗауваження:\fR у цьому розділі наведено документацію загальний механізм
обробки подій, впроваджений у libguestfs 1.10, яким ви маєте користуватися у
новому коді, якщо це можливо. Застарілі функції
\&\f(CW\*(C`guestfs_set_log_message_callback\*(C'\fR,
\&\f(CW\*(C`guestfs_set_subprocess_quit_callback\*(C'\fR,
\&\f(CW\*(C`guestfs_set_launch_done_callback\*(C'\fR, \f(CW\*(C`guestfs_set_close_callback\*(C'\fR і
\&\f(CW\*(C`guestfs_set_progress_callback\*(C'\fR більше не документуються на цій сторінці
підручника. Оскільки сталість \s-1ABI\s0 гарантовано, застарілі функції лишаються
працездатнними.
.PP
Дескриптори породжують події, коли трапляються певні речі, зокрема
створюються повідомлення журналу, повідомлення щодо поступу під час
довготривалих дій або закривається дескриптор. Виклики програмного
інтерфейсу, описані нижче, надають вам змогу реєструвати зворотні виклики,
які викликатимуться, коли трапляються події. Ви можете зареєструвати
декілька зворотних викликів (для тих самих, інших або перекритих наборів
подій) і окремо вилучати зворотні виклики. Якщо зворотні виклики не
вилучено, тоді вони лишаються працездатними, аж доки дескриптор не буде
закрито.
.PP
У поточній реалізації події створюються лише синхронно: це означає, що події
(а отже, зворотні виклики) можуть траплятися, доки ви перебуваєте у іншому
виклику libguestfs. Зворотний виклик викликається у тому самому потоці
обробки.
.PP
Записи подій можуть містити дані, зазвичай, нічого (void), масив 64\-бітових
цілих чисел без знаку або буфер повідомлень. Дані вмісту обговорено нижче.
.SS "КЛАСИ ПОДІЙ"
.IX Subsection "КЛАСИ ПОДІЙ"
.IP "\s-1GUESTFS_EVENT_CLOSE\s0 (тип вмісту: void)" 4
.IX Item "GUESTFS_EVENT_CLOSE (тип вмісту: void)"
Функцію зворотного виклику буде викликано під час закриття дескриптора
(синхронно з \*(L"guestfs_close\*(R").
.Sp
Зауважте, що libguestfs встановлює обробник \fBatexit\fR\|(3) для виконання
спроби вилучення дескрипторів, які було відкрито, під час завершення роботи
програми. Це означає, що цей зворотний виклик може бути викликано
опосередковано з \fBexit\fR\|(3), що може спричинити неочікувані проблеми у
високорівневих мовах програмування (наприклад, якщо ваш інтерпретатор
високорівневої мови програмування вже було очищено на час виклику і якщо
зворотний виклик переводить до якоїсь функції високорівневої мови
програмування).
.Sp
Якщо зворотних викликів не зареєстровано: дескриптор закривається без
будь\-яких зворотних викликів.
.IP "\s-1GUESTFS_EVENT_SUBPROCESS_QUIT\s0 (тип вмісту: void)" 4
.IX Item "GUESTFS_EVENT_SUBPROCESS_QUIT (тип вмісту: void)"
Функцію зворотного виклику буде викликано, коли завершує роботу дочірній
процес, або асинхронно, або внаслідок роботи
\&\*(L"guestfs_kill_subprocess\*(R". (Це відповідає переходу з будь\-якого стану до
стану \s-1CONFIG\s0).
.Sp
Якщо зворотних викликів не зареєстровано: подія ігнорується.
.IP "\s-1GUESTFS_EVENT_LAUNCH_DONE\s0 (тип вмісту: void)" 4
.IX Item "GUESTFS_EVENT_LAUNCH_DONE (тип вмісту: void)"
Функцію зворотного виклику буде викликано, коли дочірній процес буде готовим
вперше після його запуску. (Це відповідає переходу зі стану \s-1LAUNCHING\s0 до
стану \s-1READY.\s0)
.Sp
Якщо зворотних викликів не зареєстровано: подія ігнорується.
.IP "\s-1GUESTFS_EVENT_PROGRESS\s0 (тип вмісту: масив з 4\-х uint64_t)" 4
.IX Item "GUESTFS_EVENT_PROGRESS (тип вмісту: масив з 4-х uint64_t)"
Частина довготривалих дій може створювати повідомлення про поступ. Якщо цей
зворотний виклик зареєстровано, його буде викликано кожного разу при
створенні повідомлення про поступ (зазвичай, за дві секунди після початку
виконання дії і три рази за секунду після цього, аж доки виконання дії не
буде завершено, хоча частоту може буде змінено у майбутніх версіях).
.Sp
Зворотний виклик отримує у даних вмісту чотири 64\-бітових чисел без знаку,
якими є (саме у такому порядку): \f(CW\*(C`proc_nr\*(C'\fR, \f(CW\*(C`serial\*(C'\fR, \f(CW\*(C`position\*(C'\fR,
\&\f(CW\*(C`total\*(C'\fR.
.Sp
Одиниці \f(CW\*(C`total\*(C'\fR не визначено, хоча для деяких дій \f(CW\*(C`total\*(C'\fR може бути певним
чином пов'язано із обсягом даних, які передаються (наприклад, у байтах або
мегабайтах), і \f(CW\*(C`position\*(C'\fR може бути часткою даних, які передаються.
.Sp
Єдиними визначеними і стабільними частинами програмного інтерфейсу є:
.RS 4
.IP "\(bu" 4
Зворотний виклик може показувати користувачеві певний тип смужки поступу або
індикатора, який показуватиме відношення \f(CW\*(C`position\*(C'\fR:\f(CW\*(C`total\*(C'\fR.
.IP "\(bu" 4
0 <= \f(CW\*(C`position\*(C'\fR <= \f(CW\*(C`total\*(C'\fR
.IP "\(bu" 4
Якщо під час виклику надсилаються якість сповіщення щодо поступу, остаточне
сповіщення щодо поступу завжди надсилається, коли \f(CW\*(C`position\*(C'\fR = \f(CW\*(C`total\*(C'\fR
(\fIякщо\fR виклик не завершується помилкою).
.Sp
Так зроблено для спрощення коду функції виклику, отже функції виклику можуть
просто встановити для індикатора поступу «100%» наприкінці виконання дії,
без потреби у реалізації у коді виявлення цієї ситуації.
.IP "\(bu" 4
Для деяких викликів неможливо оцінити поступ виклику, але ми можемо
створювати повідомлення щодо поступу для позначення виконання дії. Такий
режим відомий як «режим пульсації», підтримку якого безпосередньо
передбачено у деяких реалізаціях смужок поступу (наприклад GtkProgressBar).
.Sp
Для цих викликів нуль або декілька повідомлень поступу створюються для
\&\f(CW\*(C`position = 0\*(C'\fR і \f(CW\*(C`total = 1\*(C'\fR, за якими слідує остаточне повідомлення з
\&\f(CW\*(C`position = total = 1\*(C'\fR.
.Sp
Як зауважено вище, якщо виклик завершується помилкою, остаточне повідомлення
може бути не створено.
.RE
.RS 4
.Sp
Крім того, зворотний виклик отримує номер процедури (\f(CW\*(C`proc_nr\*(C'\fR) і серійний
номер (\f(CW\*(C`serial\*(C'\fR) виклику. Ці дані корисні лише для діагностики проблем із
протоколом, а зворотний виклик, за звичайних умов, може їх
ігнорувати. Зворотний виклик може вивести ці числові дані у повідомленнях
про помилки або діагностичних повідомленнях.
.Sp
Якщо зворотних викликів не зареєстровано, повідомлення про поступ
відкидаються.
.RE
.IP "\s-1GUESTFS_EVENT_APPLIANCE\s0 (тип вмісту: буфер повідомлень)" 4
.IX Item "GUESTFS_EVENT_APPLIANCE (тип вмісту: буфер повідомлень)"
Функція зворотного виклику викликається кожного разу, коли qemu, ядро
базової системи, guestfsd (фонова служба) або допоміжні програми створюють
повідомлення журналу.
.Sp
Якщо перед запуском (\*(L"guestfs_launch\*(R") встановлено прапорець докладних
повідомлень (\*(L"guestfs_set_verbose\*(R"), буде створено додаткові діагностичні
повідомлення.
.Sp
Якщо зворотний виклик не зареєстровано: повідомлення відкидаються, якщо не
встановлено прапорець докладних повідомлень. У цьому випадку повідомлення
надсилаються до stderr. Ви можете перевизначити виведення докладних
повідомлень до stderr встановленням зворотного виклику.
.IP "\s-1GUESTFS_EVENT_LIBRARY\s0 (тип вмісту: буфер повідомлень)" 4
.IX Item "GUESTFS_EVENT_LIBRARY (тип вмісту: буфер повідомлень)"
Функція зворотного виклику викликається кожного разу, коли бібліотечна
частина libguestfs створює повідомлення журналу.
.Sp
Якщо встановлено прапорець докладних повідомлень (\*(L"guestfs_set_verbose\*(R"),
буде створено додаткові діагностичні повідомлення.
.Sp
Якщо зворотний виклик не зареєстровано: повідомлення відкидаються, якщо не
встановлено прапорець докладних повідомлень. У цьому випадку повідомлення
надсилаються до stderr. Ви можете перевизначити виведення докладних
повідомлень до stderr встановленням зворотного виклику.
.IP "\s-1GUESTFS_EVENT_WARNING\s0 (тип вмісту: буфер повідомлень)" 4
.IX Item "GUESTFS_EVENT_WARNING (тип вмісту: буфер повідомлень)"
Функція зворотного виклику викликається кожного разу, коли бібліотечна
частина libguestfs створює повідомлення із попередженням.
.Sp
Якщо зворотний виклик не зареєстровано: повідомлення виводяться до
stderr. Ви можете перевизначити виведення повідомлень із попередженнями до
stderr встановленням зворотного виклику.
.IP "\s-1GUESTFS_EVENT_TRACE\s0 (тип вмісту: буфер повідомлень)" 4
.IX Item "GUESTFS_EVENT_TRACE (тип вмісту: буфер повідомлень)"
Функція зворотного виклику викликається кожного разу, коли створюється
повідомлення трасування. Це стосується лише випадків, коли встановлено
прапорець трасування (\*(L"guestfs_set_trace\*(R").
.Sp
Якщо зворотний виклик не зареєстровано: повідомлення виводяться до
stderr. Ви можете перевизначити виведення повідомлень трасування до stderr
встановленням зворотного виклику.
.IP "\s-1GUESTFS_EVENT_ENTER\s0 (тип вмісту: назва функції)" 4
.IX Item "GUESTFS_EVENT_ENTER (тип вмісту: назва функції)"
Функція зворотного виклику викликається кожного разу, коли відбувається вхід
до функції libguestfs.
.Sp
Дані вмісту є рядком, який містить назву функції, до якої було здійснено
вхід (без префікса \f(CW\*(C`guestfs_\*(C'\fR).
.Sp
Зауважте, що функції libguestfs можуть викликати самі себе, отже, ви можете
побачити багато подій від одного виклику. Деякі функції libguestfs не
створюють цієї події.
.Sp
Якщо зворотних викликів не зареєстровано: подія ігнорується.
.IP "\s-1GUESTFS_EVENT_LIBVIRT_AUTH\s0 (тип вмісту: адреса libvirt)" 4
.IX Item "GUESTFS_EVENT_LIBVIRT_AUTH (тип вмісту: адреса libvirt)"
Для будь\-якої функції програмного інтерфейсу, яка відкриває з'єднання
libvirt, цю подію може бути створено для позначення того, що libvirt
потрібні дані для розпізнавання користувача. Див. \*(L"РОЗПІЗНАВАННЯ ЗА
ДОПОМОГОЮ \s-1LIBVIRT\*(R"\s0 нижче.
.Sp
Якщо зворотних викликів не зареєстровано: використовується
\&\f(CW\*(C`virConnectAuthPtrDefault\*(C'\fR (пасує лише для команд, які керуються з
командного рядка).
.SS "ПРОГРАМНИЙ ІНТЕРФЕЙС ПОДІЙ"
.IX Subsection "ПРОГРАМНИЙ ІНТЕРФЕЙС ПОДІЙ"
\fIguestfs_set_event_callback\fR
.IX Subsection "guestfs_set_event_callback"
.PP
.Vb 5
\& int guestfs_set_event_callback (guestfs_h *g,
\&                                 guestfs_event_callback cb,
\&                                 uint64_t event_bitmask,
\&                                 int flags,
\&                                 void *opaque);
.Ve
.PP
Ця функція реєструє зворотний виклик (\f(CW\*(C`cb\*(C'\fR) для усіх класів подій у
\&\f(CW\*(C`event_bitmask\*(C'\fR.
.PP
Наприклад, щоб зареєструвати зворотний виклик для усіх подій повідомлень
журналу, ви можете викликати цю функцію із маскою бітів
\&\f(CW\*(C`GUESTFS_EVENT_APPLIANCE|GUESTFS_EVENT_LIBRARY|GUESTFS_EVENT_WARNING\*(C'\fR. Щоб
зареєструвати єдиний зворотний виклик для усіх можливих класів подій,
скористайтеся \f(CW\*(C`GUESTFS_EVENT_ALL\*(C'\fR.
.PP
\&\f(CW\*(C`flags\*(C'\fR слід завжди передавати як 0.
.PP
\&\f(CW\*(C`opaque\*(C'\fR — непрозорий вказівник, який передається зворотному виклику. Ви
можете використовувати його із будь\-якою метою.
.PP
Повернутим значенням є дескриптор події (ціле число), яким ви можете
скористатися для вилучення зворотного виклику (див. нижче).
.PP
Якщо сталася помилка, ця функція повертає \f(CW\*(C`\-1\*(C'\fR і встановлює стан помилки у
дескрипторі у звичний спосіб (див. \*(L"guestfs_last_error\*(R" тощо)
.PP
Зворотні виклики діють до їхнього вилучення або до закриття дескриптора.
.PP
У випадку, коли зареєстровано декілька зворотних викликів для певного класу
подій, буде викликано усі ці виклики. Порядок виклику зворотних викликів не
визначено.
.PP
\fIguestfs_delete_event_callback\fR
.IX Subsection "guestfs_delete_event_callback"
.PP
.Vb 1
\& void guestfs_delete_event_callback (guestfs_h *g, int event_handle);
.Ve
.PP
Вилучити раніше зареєстрований зворотний виклик. Значенням параметра
\&\f(CW\*(C`event_handle\*(C'\fR має бути ціле число, яке було повернуто попереднім викликом
\&\f(CW\*(C`guestfs_set_event_callback\*(C'\fR для того самого дескриптора.
.PP
\fIguestfs_event_to_string\fR
.IX Subsection "guestfs_event_to_string"
.PP
.Vb 1
\& char *guestfs_event_to_string (uint64_t event);
.Ve
.PP
\&\f(CW\*(C`event\*(C'\fR — окрема подія або бітова маска подій. Ця функція повертає рядкове
представлення (корисно для діагностики або виведення подій).
.PP
Окремі події повертаються як назви у нижньому регістрі, наприклад
\&\f(CW"close"\fR.
.PP
Бітова маска декількох подій повертається як список значень, які
відокремлено комами, наприклад \f(CW"close,progress"\fR.
.PP
Якщо буде передано нуль, буде повернуто порожній рядок \f(CW""\fR.
.PP
Якщо виконано успішно, повертає рядок. Якщо сталася помилка, повертає \s-1NULL\s0 і
встановлює значення \f(CW\*(C`errno\*(C'\fR.
.PP
Повернутий рядок має бути вивільнено функцією, яка викликає цю функцію.
.PP
\fIguestfs_event_callback\fR
.IX Subsection "guestfs_event_callback"
.PP
.Vb 8
\& typedef void (*guestfs_event_callback) (
\&                  guestfs_h *g,
\&                  void *opaque,
\&                  uint64_t event,
\&                  int event_handle,
\&                  int flags,
\&                  const char *buf, size_t buf_len,
\&                  const uint64_t *array, size_t array_len);
.Ve
.PP
Це тип функції зворотного виклику події, яку вам слід надати.
.PP
Базові параметри: дескриптор (\f(CW\*(C`g\*(C'\fR), непрозорий вказівник користувача
(\f(CW\*(C`opaque\*(C'\fR), клас подій (наприклад \f(CW\*(C`GUESTFS_EVENT_PROGRESS\*(C'\fR), дескриптор
події та \f(CW\*(C`flags\*(C'\fR, які у поточній версії програмного інтерфейсу ви можете
ігнорувати.
.PP
Решта параметрів містить дані вмісту події (якщо такі є). У кожному записі
події можуть міститися дані вмісту, які, зазвичай, пов'язано із класом
події, але з міркувань забезпечення сумісності у майбутньому ваш код має
бути записано так, щоб він міг обробити будь\-які дані вмісту для будь\-якого
класу подій.
.PP
\&\f(CW\*(C`buf\*(C'\fR і \f(CW\*(C`buf_len\*(C'\fR містять буфер повідомлень (якщо \f(CW\*(C`buf_len == 0\*(C'\fR, буфера
повідомлень не існує). Зауважте, що цей буфер повідомлень може містити
довільні 8\-бітові дані, зокрема байти \s-1NUL.\s0
.PP
\&\f(CW\*(C`array\*(C'\fR і \f(CW\*(C`array_len\*(C'\fR — масив з 64\-бітових цілих чисел без знаку. У
поточній версії використовується лише для повідомлень щодо поступу.
.SS "ПРИКЛАД: ЗАХОПЛЮЄМО ПОВІДОМЛЕННЯ ЖУРНАЛУ"
.IX Subsection "ПРИКЛАД: ЗАХОПЛЮЄМО ПОВІДОМЛЕННЯ ЖУРНАЛУ"
Робочу програму, яка демонструє це, можна знайти у
\&\fIexamples/debug\-logging.c\fR у початковому коді libguestfs.
.PP
Однією з мотивацій для створення загального програмного інтерфейсу подій
було уможливлення для програм із графічним інтерфейсом перехоплення
діагностичних повідомлень та інших повідомлень. У libguestfs ≤ 1.8 ці
повідомлення безумовно надсилалися до \f(CW\*(C`stderr\*(C'\fR.
.PP
Подіями, пов'язаними із повідомленнями журналу, є такі:
\&\f(CW\*(C`GUESTFS_EVENT_LIBRARY\*(C'\fR, \f(CW\*(C`GUESTFS_EVENT_APPLIANCE\*(C'\fR,
\&\f(CW\*(C`GUESTFS_EVENT_WARNING\*(C'\fR і \f(CW\*(C`GUESTFS_EVENT_TRACE\*(C'\fR. (Зауважте, що
повідомлення про помилки не є подіями; вам слід перехоплювати повідомлення
про помилки окремо).
.PP
Програмам слід встановити зворотний виклик для цікавих для них класів подій:
.PP
.Vb 9
\& int eh =
\&   guestfs_set_event_callback
\&     (g, message_callback,
\&      GUESTFS_EVENT_LIBRARY | GUESTFS_EVENT_APPLIANCE |
\&      GUESTFS_EVENT_WARNING | GUESTFS_EVENT_TRACE,
\&      0, NULL) == \-1)
\& if (eh == \-1) {
\&   // обробка помилки у звичний спосіб
\& }
.Ve
.PP
Далі, зворотний виклик може спрямувати повідомлення до відповідного місця. У
цьому прикладі повідомлення спрямовуються до syslog:
.PP
.Vb 10
\& static void
\& message_callback (
\&         guestfs_h *g,
\&         void *opaque,
\&         uint64_t event,
\&         int event_handle,
\&         int flags,
\&         const char *buf, size_t buf_len,
\&         const uint64_t *array, size_t array_len)
\& {
\&   const int priority = LOG_USER|LOG_INFO;
\&   if (buf_len > 0)
\&     syslog (priority, "event 0x%lx: %s", event, buf);
\& }
.Ve
.SS "РОЗПІЗНАВАННЯ ЗА ДОПОМОГОЮ \s-1LIBVIRT\s0"
.IX Subsection "РОЗПІЗНАВАННЯ ЗА ДОПОМОГОЮ LIBVIRT"
Деякі виклики програмного інтерфейсу libguestfs можуть відкривати з'єднання
із libvirt. У поточній версії єдиними такими викликами є
\&\*(L"guestfs_add_domain\*(R" і \*(L"guestfs_launch\*(R", якщо вибрано модуль обробки
libvirt. З'єднання libvirt можуть потребувати проходження розпізнавання,
наприклад, якщо вони потребують доступу до віддаленого сервера або доступу
до служб адміністратора (root) від імені неадміністративного
користувача. Розпізнавання libvirt відбувається за допомогою механізму
зворотного виклику,
див.
http://libvirt.org/guide/html/Application_Development_Guide\-Connections.html
.PP
Ви можете надавати дані розпізнавання libvirt, зареєструвавши зворотний
виклик для подій типу \f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR.
.PP
Якщо такої події не зареєстровано, libguestfs використовує функцію libvirt,
яка надає запити командного рядка (\f(CW\*(C`virConnectAuthPtrDefault\*(C'\fR). Пасує для
програм libguestfs, які керуються за допомогою командного рядка.
.PP
Для забезпечення розпізнавання спочатку викличте
\&\*(L"guestfs_set_libvirt_supported_credentials\*(R" зі списком реєстраційних
даних, які ваша програма має вміти надавати. Далі, зареєструйте зворотний
виклик для події \f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR. Обробник подій буде
викликано, коли libvirt надішле запит щодо даних для розпізнавання.
.PP
У обробнику подій викличте \*(L"guestfs_get_libvirt_requested_credentials\*(R" для
отримання списку реєстраційних даних, які потрібні libvirt. Далі, вам слід
запитати (наприклад, користувача) щодо кожного комплекту реєстраційних даних
і викликати \*(L"guestfs_set_libvirt_requested_credential\*(R" із
відповіддю. Зауважте, що для кожного комплекту реєстраційних даних можуть
бути доступними додаткові відомості через виклики
\&\*(L"guestfs_get_libvirt_requested_credential_prompt\*(R",
\&\*(L"guestfs_get_libvirt_requested_credential_challenge\*(R" та
\&\*(L"guestfs_get_libvirt_requested_credential_defresult\*(R".
.PP
Наведений нижче приклад програми має зробити це яснішим.
.PP
Також існує суттєвіший робочий приклад програми. Він постачається із
початковими кодами libguestfs і називається \fIlibvirt\-auth.c\fR.
.PP
.Vb 5
\& main ()
\& {
\&   guestfs_h *g;
\&   char *creds[] = { "authname", "passphrase", NULL };
\&   int r, eh;
\& 
\&   g = guestfs_create ();
\&   if (!g) exit (EXIT_FAILURE);
\& 
\&   /* Повідомляємо libvirt, підтримку яких реєстраційних даних передбачено у програмі. */
\&   r = guestfs_set_libvirt_supported_credentials (g, creds);
\&   if (r == \-1)
\&     exit (EXIT_FAILURE);
\& 
\&   /* Встановлюємо обробник подій. */
\&   eh = guestfs_set_event_callback (
\&       g, do_auth,
\&       GUESTFS_EVENT_LIBVIRT_AUTH, 0, NULL);
\&   if (eh == \-1)
\&     exit (EXIT_FAILURE);
\& 
\&   /* Приклад виклику, який може призвести до запиту щодо реєстраційних даних. */
\&   r = guestfs_add_domain (
\&       g, "dom",
\&       GUESTFS_ADD_DOMAIN_LIBVIRTURI, "qemu:///system",
\&       \-1);
\&   if (r == \-1)
\&     exit (EXIT_FAILURE);
\& 
\&   exit (EXIT_SUCCESS);
\& }
\& 
\& static void
\& do_auth (guestfs_h *g,
\&          void *opaque,
\&          uint64_t event,
\&          int event_handle,
\&          int flags,
\&          const char *buf, size_t buf_len,
\&          const uint64_t *array, size_t array_len)
\& {
\&   char **creds;
\&   size_t i;
\&   char *prompt;
\&   char *reply;
\&   size_t replylen;
\&   int r;
\& 
\&   // buf буде адресою libvirt. buf_len можна ігнорувати.
\&   printf ("Authentication required for libvirt conn \*(Aq%s\*(Aq\en",
\&           buf);
\& 
\&   // Питаємо libguestfs, які реєстраційні дані потрібні libvirt.
\&   creds = guestfs_get_libvirt_requested_credentials (g);
\&   if (creds == NULL)
\&     exit (EXIT_FAILURE);
\& 
\&   // Тепер просимо користувача відповісти на питання.
\&   for (i = 0; creds[i] != NULL; ++i)
\&   {
\&     if (strcmp (creds[i], "authname") == 0 ||
\&         strcmp (creds[i], "passphrase") == 0)
\&     {
\&       prompt =
\&         guestfs_get_libvirt_requested_credential_prompt (g, i);
\&       if (prompt && strcmp (prompt, "") != 0)
\&         printf ("%s: ", prompt);
\&       free (prompt);
\& 
\&       // Тут має бути якийсь код запитів щодо реєстраційних даних.
\&       // ...
\&       // Записуємо відповідь до «reply» зі довжиною «replylen» (у байтах).
\& 
\&      r = guestfs_set_libvirt_requested_credential (g, i,
\&          reply, replylen);
\&      if (r == \-1)
\&        exit (EXIT_FAILURE);
\&     }
\& 
\&     free (creds[i]);
\&   }
\& 
\&   free (creds);
\& }
.Ve
.SH "СКАСОВУВАННЯ ДОВГОТРИВАЛОГО ПЕРЕДАВАННЯ ДАНИХ"
.IX Header "СКАСОВУВАННЯ ДОВГОТРИВАЛОГО ПЕРЕДАВАННЯ ДАНИХ"
Деякі дії може бути скасовано функцією виклику, доки вони виконуються. У
поточній версії може бути скасовано лише дії із вивантаження або отримання
даних (технічно: дії, які мають параметри \f(CW\*(C`FileIn\*(C'\fR або \f(CW\*(C`FileOut\*(C'\fR у
генераторі).
.PP
Щоб скасувати передавання даних, викличте \*(L"guestfs_user_cancel\*(R". Щоб
дізнатися більше, ознайомтеся із описом \*(L"guestfs_user_cancel\*(R".
.SH "ОБЛАСТЬ ПРИВАТНИХ ДАНИХ"
.IX Header "ОБЛАСТЬ ПРИВАТНИХ ДАНИХ"
Ви можете долучати іменовані частини приватних даних до дескриптора
libguestfs, отримувати їх за назвою і обходити їх протягом часу життя
дескриптора. Ця область даних називається областю приватних даних, доступ до
неї можна отримувати лише за допомогою програмного інтерфейсу мовою C.
.PP
Щоб долучити іменовані дані, скористайтеся таким викликом:
.PP
.Vb 1
\& void guestfs_set_private (guestfs_h *g, const char *key, void *data);
.Ve
.PP
\&\f(CW\*(C`key\*(C'\fR — назва, яку слід пов'язати з цими даними, а \f(CW\*(C`data\*(C'\fR — довільний
вказівник (який може бути \f(CW\*(C`NULL\*(C'\fR). Будь\-який попередній запис із тим самим
ключем буде перезаписано.
.PP
Ви можете скористатися будь\-яким рядком \f(CW\*(C`key\*(C'\fR, але уникайте ключів, назви
яких починаються з символу підкреслювання (libguestfs використовує такі
ключі для власних внутрішніх потреб, зокрема реалізації прив'язок до мов
програмування). Рекомендуємо додавати до таких ключів якийсь унікальний
рядок\-префікс, щоб уникнути конфліктів із ключами інших користувачів.
.PP
Щоб отримати вказівник, скористайтеся таким:
.PP
.Vb 1
\& void *guestfs_get_private (guestfs_h *g, const char *key);
.Ve
.PP
Ця функція повертає \f(CW\*(C`NULL\*(C'\fR, якщо або не буде знайдено пов'язаних \f(CW\*(C`key\*(C'\fR
даних, або користувачем раніше буде встановлено  для вказівника \f(CW\*(C`data\*(C'\fR
ключа \f(CW\*(C`key\*(C'\fR значення \f(CW\*(C`NULL\*(C'\fR.
.PP
Libguestfs не намагається переходити чи обробляти у будь\-який спосіб
вказівник \f(CW\*(C`data\*(C'\fR. У межах libguestfs це значення взагалі не повинне бути
чинним вказівником. Зокрема, libguestfs \fIне\fR намагатиметься звільнити
пам'ять від data, коли дескриптор буде закриватися. Якщо data слід
звільнити, функція виклику має зробити це або до виклику \*(L"guestfs_close\*(R",
або має встановити зворотний виклик закриття для цього
(див. \*(L"\s-1GUESTFS_EVENT_CLOSE\*(R"\s0).
.PP
Для обходу усіх записів скористайтеся цими двома функціями:
.PP
.Vb 1
\& void *guestfs_first_private (guestfs_h *g, const char **key_rtn);
\&
\& void *guestfs_next_private (guestfs_h *g, const char **key_rtn);
.Ve
.PP
\&\f(CW\*(C`guestfs_first_private\*(C'\fR повертає першу пару ключ, вказівник (слово «перша»
тут немає певного точного змісту — ключі повертаються без якогось
визначеного порядку). Функцією повертається вказівник на ключ у \f(CW*key_rtn\fR
і відповідний вказівник на дані. Якщо у дескрипторі не зберігається ніяких
ключів, буде повернуто \f(CW\*(C`NULL\*(C'\fR.
.PP
\&\f(CW\*(C`guestfs_next_private\*(C'\fR повертає наступну пару ключ, вказівник. Ця функція
поверне \f(CW\*(C`NULL\*(C'\fR, якщо подальших записів у списку ключів не існує.
.PP
Нотатки щодо обходу записів:
.IP "\(bu" 4
Викликати \f(CW\*(C`guestfs_set_private\*(C'\fR під час обходу списку записів не можна.
.IP "\(bu" 4
Дескриптор супроводжує внутрішній ітератор, значення якого буде скинуто, як
ви викличете \f(CW\*(C`guestfs_first_private\*(C'\fR. Внутрішній ітератор втратить
чинність, якщо буде викликано \f(CW\*(C`guestfs_set_private\*(C'\fR.
.IP "\(bu" 4
Якщо вами встановлено для вказівника на дані, пов'язаного із ключем,
значення \f(CW\*(C`NULL\*(C'\fR, тобто:
.Sp
.Vb 1
\& guestfs_set_private (g, key, NULL);
.Ve
.Sp
цей ключ \f(CW\*(C`key\*(C'\fR не буде повернуто під час обходу списку.
.IP "\(bu" 4
\&\f(CW*key_rtn\fR є чинним лише до наступного виклику \f(CW\*(C`guestfs_first_private\*(C'\fR,
\&\f(CW\*(C`guestfs_next_private\*(C'\fR або \f(CW\*(C`guestfs_set_private\*(C'\fR.
.PP
У наведеному нижче прикладі коду показано, як вивести усі ключі і вказівники
на дані, які пов'язано із дескриптором \f(CW\*(C`g\*(C'\fR:
.PP
.Vb 7
\& const char *key;
\& void *data = guestfs_first_private (g, &key);
\& while (data != NULL)
\&   {
\&     printf ("key = %s, data = %p\en", key, data);
\&     data = guestfs_next_private (g, &key);
\&   }
.Ve
.PP
Типово, вам потрібні будуть лише ключі, кі починаються зі специфічного для
програми префікса \f(CW\*(C`foo_\*(C'\fR. Змініть цикл ось так:
.PP
.Vb 8
\& const char *key;
\& void *data = guestfs_first_private (g, &key);
\& while (data != NULL)
\&   {
\&     if (strncmp (key, "foo_", strlen ("foo_")) == 0)
\&       printf ("key = %s, data = %p\en", key, data);
\&     data = guestfs_next_private (g, &key);
\&   }
.Ve
.PP
Якщо під час обходу ви хочете змінювати ключі, вам слід перестрибувати до
початку циклу. Наприклад, щоб вилучити усі ключі з префіксом \f(CW\*(C`foo_\*(C'\fR,
зробіть так:
.PP
.Vb 10
\&  const char *key;
\&  void *data;
\& again:
\&  data = guestfs_first_private (g, &key);
\&  while (data != NULL)
\&    {
\&      if (strncmp (key, "foo_", strlen ("foo_")) == 0)
\&        {
\&          guestfs_set_private (g, key, NULL);
\&          /* зауважте, що вказівник \*(Aqkey\*(Aq тепер є некоректним, як і
\&             внутрішній ітератор */
\&          goto again;
\&        }
\&      data = guestfs_next_private (g, &key);
\&    }
.Ve
.PP
Зауважте, що наведений вище цикл завжди завершуватиметься, оскільки ключі
вилучаються. Втім, інші дії з ключами у циклі можуть призвести до того, що
програма не зможе вийти з циклу, якщо не вестиметься супровід списку вже
відвіданих ключів.
.SH "SYSTEMTAP"
.IX Header "SYSTEMTAP"
Бібліотеку C libguestfs можна зондувати за допомогою systemtap або
DTrace. Це стосується будь\-якої бібліотеки, не лише libguestfs. Втім, у
libguestfs також є статичні позначки, які спрощують зондування внутрішніх
дій.
.PP
Отримати список статичних позначок можна такою командою:
.PP
.Vb 2
\& stap \-l \*(Aqprocess("/usr/lib*/libguestfs.so.0")
\&              .provider("guestfs").mark("*")\*(Aq
.Ve
.PP
\&\fBЗауваження:\fR ці статичні позначки \fIне\fR є частиною стабільного програмного
інтерфейсу, їх може бути змінено у майбутніх версіях.
.SS "ПРИКЛАД СКРИПТУ \s-1SYSTEMTAP\s0"
.IX Subsection "ПРИКЛАД СКРИПТУ SYSTEMTAP"
Цей скрипт містить приклади показу статичних позначок і деяких звичайних
точок входу C:
.PP
.Vb 1
\& global last;
\& 
\& function display_time () {
\&       now = gettimeofday_us ();
\&       delta = 0;
\&       if (last > 0)
\&             delta = now \- last;
\&       last = now;
\& 
\&       printf ("%d (+%d):", now, delta);
\& }
\& 
\& probe begin {
\&       last = 0;
\&       printf ("ready\en");
\& }
\& 
\& /* Показати усі виклики статичних маркерів. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .provider("guestfs").mark("*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", $$name, $$parms);
\& }
\& 
\& /* Показати усі виклики функцій guestfs_mkfs*. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .function("guestfs_mkfs*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", probefunc(), $$parms);
\& }
.Ve
.PP
Наведений вище скрипт можна зберегти із назвою \fItest.stap\fR і запустити його
за допомогою програми \fBstap\fR\|(1). Зауважте, що вам знадобляться або права
доступу root, або треба буде додати вашого користувача до декількох
спеціалізованих груп stap. Зверніться до документації із systemtap, щоб
дізнатися більше.
.PP
.Vb 2
\& # stap /tmp/test.stap
\& ready
.Ve
.PP
У іншому терміналі запустіть програму guestfish ось так:
.PP
.Vb 1
\& guestfish \-N fs
.Ve
.PP
У першому терміналі виведені stap дані трасування будуть подібними до таких:
.PP
.Vb 6
\& 1318248056692655 (+0): launch_start
\& 1318248056692850 (+195):       launch_build_appliance_start
\& 1318248056818285 (+125435):    launch_build_appliance_end
\& 1318248056838059 (+19774):     launch_run_qemu
\& 1318248061071167 (+4233108):   launch_end
\& 1318248061280324 (+209157):    guestfs_mkfs g=0x1024ab0 fstype=0x46116f device=0x1024e60
.Ve
.SH "НУМЕРАЦІЯ ВЕРСІЙ LIBGUESTFS"
.IX Header "НУМЕРАЦІЯ ВЕРСІЙ LIBGUESTFS"
З квітня 2010 року розпочалася окрема історія розробки libguestfs і
стабільні випуски бібліотеки, які позначалися відповідними гілками у нашому
сховищі коду git. Ці окремі випуски можна визначити за номерами версій:
.PP
.Vb 10
\&                 парні номери для стабільних: 1.2.x, 1.4.x, ...
\&       .\-\-\-\-\-\-\-\- непарні номери для тестових: 1.3.x, 1.5.x, ...
\&       |
\&       v
\& 1  .  3  .  5
\& ^           ^
\& |           |
\& |           \`\-\-\-\-\-\-\-\- підверсія
\& |
\& \`\-\-\-\-\-\- завжди «1», оскільки ми не міняємо ABI
.Ve
.PP
Таким чином, «1.3.5» — це п'яте оновлення у гілці для розробки «1.3».
.PP
З часом ми переносимо виправлення із гілки для розробки і портуємо їх на
стабільну гілку. У результаті з часом стабільна гілка стає стабільнішою, у
ній стає менше вад. Отже, стабільні випуски ідеальні для тих, кому не
потрібні нові можливості, а потрібне лише завжди працездатне програмне
забезпечення.
.PP
Наші критерії для зворотного портування змін:
.IP "\(bu" 4
Зміни до документації, які не змінюють код, портуються до попередніх версій,
якщо документація стосується не майбутніх можливостей, якщо таких
можливостей немає у стабільній гілці.
.IP "\(bu" 4
Портуються до попередніх версій виправлення вад, які не є суперечливими,
виправляють очевидні проблеми і є належним чином перевіреними.
.IP "\(bu" 4
Портуються до попередніх версії прості переупорядкування коду, які не
стосуються його працездатності. Це ми робимо для того, щоб дві гілки
розробки не дуже різнилися між собою. Це спрощує зворотне портування
майбутніх виправлень.
.IP "\(bu" 4
Ми \fIне\fR портуємо до попередніх версій нові можливості, нові інструменти
тощо, окрім одного виключного випадку: нова можливість потрібна для
реалізації виправлення важливої вади.
.PP
Нова стабільна гілка започатковується тоді, коли ми вважаємо нові можливості
у розробці суттєвими і достатньо новаторськими щодо поточної стабільної
гілки. Коли виконуються ці умови, ми створюємо нову стабільну гілку і нову
гілку для розробки із версіями 1.N.0 і 1.(N+1).0, відповідно [N — парне
число]. На цьому етапі новий стабільний випуск із нуликом наприкінці номера
версії не обов'язково є аж надто стабільним, але з портуванням виправлень із
гілки для розробки стабільна гілка стає все стабільнішою з часом.
.SH "ОБМЕЖЕННЯ"
.IX Header "ОБМЕЖЕННЯ"
.SS "ОБМЕЖЕННЯ ПРОТОКОЛУ"
.IX Subsection "ОБМЕЖЕННЯ ПРОТОКОЛУ"
На внутрішньому рівні libguestfs використовує заснований на повідомленнях
протокол для передавання викликів програмного інтерфейсу і відповідей на них
до малої «базової системи» та з неї (на сторінці підручника
\&\fBguestfs\-internals\fR\|(1) наведено докладний опис цього). Максимальний розмір
повідомлення, яке використовується у протоколі, трохи менший за 4 МБ. Для
деяких викликів програмного інтерфейсу слід зважати на це обмеження. Виклики
програмного інтерфейсу, яких це стосується, документовано окремо зі
зворотним посиланням на цей розділ документації.
.PP
У libguestfs < 1.19.32 декільком викликам доводилося або кодувати увесь
список аргументів, або кодувати усе повернуте значення (а іноді, і обидва
цих елементи виклику) у єдине повідомлення протоколу. Це призводило до
довільного обмеження щодо об'єму даних, з яким могли впоратися ці
виклики. Наприклад, функція \*(L"guestfs_cat\*(R" могла отримати файл, лише якщо
його розмір був меншим за близьке до 4 МБ значення. У пізніших версіях
libguestfs деякі з цих обмежень було знято. Програмні інтерфейси, які раніше
було обмежено, а тепер не обмежено (окрім, можливо, доступної пам'яті у
системі), наведено у списку нижче. Щоб визначити, чи підлягає певний
програмний інтерфейс обмеженням за протоколом, пошукайте у документації із
програмного інтерфейсу попередження із посиланням на цей розділ. Не
забувайте також користуватися версією документації, яка збігається із
версією libguestfs, якою ви користуєтеся.
.PP
\&\*(L"guestfs_cat\*(R", \*(L"guestfs_find\*(R", \*(L"guestfs_read_file\*(R",
\&\*(L"guestfs_read_lines\*(R", \*(L"guestfs_write\*(R", \*(L"guestfs_write_append\*(R",
\&\*(L"guestfs_lstatlist\*(R", \*(L"guestfs_lxattrlist\*(R", \*(L"guestfs_readlinklist\*(R",
\&\*(L"guestfs_ls\*(R".
.PP
Див. також розділи \*(L"ВИВАНТАЖЕННЯ\*(R" і \*(L"ОТРИМАННЯ\*(R", щоб дізнатися більше
про копіювання значних обсягів даних до файлової системи та з неї.
.SS "МАКСИМАЛЬНА КІЛЬКІСТЬ ДИСКІВ"
.IX Subsection "МАКСИМАЛЬНА КІЛЬКІСТЬ ДИСКІВ"
У libguestfs ≥ 1.19.7 ви можете отримати максимальну кількість дисків,
які може бути додано, за допомогою команди \*(L"guestfs_max_disks\*(R". У
попередніх версіях libguestfs (тобто версіях, де цієї команди не було) вам
слід користуватися типовим значенням цієї кількості — 25.
.PP
Решта цього розділу стосується подробиць реалізації, які може бути змінено у
майбутніх версіях.
.PP
Якщо використовуються диски virtio-scsi (типовий режим, якщо він доступний,
у qemu), поточним обмеженням є кількість у \fB255\fR дисків. Якщо
використовуються диски virtio-blk (типовий режим у застарілих версіях)
кількість дисків обмежено \fB27\fR. Останнє обмеження може бути іншим, залежно
від подробиць реалізації та того, чи увімкнено роботу у мережі.
.PP
Virtio-scsi, як воно використовується у libguestfs, налаштовано на
використання одного диска призначення, доступними є 256 призначень.
.PP
Virtio-blk споживає 1 віртуальний слот \s-1PCI\s0 на диск, а кількість слотів \s-1PCI\s0
обмежено значенням 31, але деякі зі слотів використовуються для інших
потреб.
.PP
Один віртуальний диск використовується libguestfs для виконання внутрішніх
завдань.
.PP
До версії libguestfs 1.19.7 назви дисків мали складатися із одного символу
(наприклад, від \fI/dev/sda\fR до \fI/dev/sdz\fR), а оскільки один диск було
зарезервовано, це означало, що дисків могло бути не більше 25. Цю ваду
виправлено у новіших версіях бібліотеки.
.PP
У libguestfs ≥ 1.20 передбачено можливість з'єднання дисків у «гарячому»
режимі. Див. \*(L"З'ЄДНАННЯ У «ГАРЯЧОМУ» РЕЖИМІ\*(R".
.SS "МАКСИМАЛЬНА КІЛЬКІСТЬ РОЗДІЛІВ НА ОДНОМУ ДИСКУ"
.IX Subsection "МАКСИМАЛЬНА КІЛЬКІСТЬ РОЗДІЛІВ НА ОДНОМУ ДИСКУ"
Virtio обмежує максимальну кількість розділів на диску значенням \fB15\fR.
.PP
Причиною є те, що інтерфейс резервує 4 біти для номера підлеглого пристрою
(отже, \fI/dev/vda\fR може містити розділи від \fI/dev/vda1\fR до \fI/dev/vda15\fR).
.PP
Якщо ви долучите диски, на яких понад 15 розділів, «зайві» розділи
ігноруватимуться у libguestfs.
.SS "МАКСИМАЛЬНИЙ РОЗМІР ДИСКА"
.IX Subsection "МАКСИМАЛЬНИЙ РОЗМІР ДИСКА"
Ймовірно, верхня межа перебуває між 2**63\-1 і 2**64\-1 байтами.
.PP
Нами було перевірено працездатність блокових пристроїв аж до 1 ексабайта
(2**60 або 1.152.921.504.606.846.976 байтів) із використанням розріджених
файлів, що зберігалися на файловій системі \s-1XFS\s0 основної операційної системи.
.PP
Хоча, ймовірно, libguestfs не накладає жодних обмежень, базове сховище даних
у основній операційній системі може накладати такі обмеження. Якщо ви
зберігаєте образи дисків на файловій системі ext4 у основній операційній
системі, максимальний розмір образу буде обмежено максимальним розміром
файла у ext4 (у поточній версії — 16 ТБ). Якщо ви зберігаєте образи дисків
як логічні томи у основній операційній системі, розмір образу буде обмежено
максимальним розміром логічного тому.
.PP
Для величезних файлів образів дисків ми рекомендуємо використовувати \s-1XFS\s0 для
збереження даних у основній операційній системі.
.SS "МАКСИМАЛЬНИЙ РОЗМІР РОЗДІЛУ"
.IX Subsection "МАКСИМАЛЬНИЙ РОЗМІР РОЗДІЛУ"
Схема поділу на розділи \s-1MBR\s0 (тобто класична для MS-DOS схема) використовує
32\-бітові номери секторів. Якщо розмір сектору дорівнює 512 байтів, у \s-1MBR\s0 не
можна буде записати адреси розділів, розташовані за межею у  2 ТБ на диску.
.PP
Якщо розмір диска перевищує 2 ТБ, рекомендуємо вам використовувати таблицю
розділів \s-1GPT.\s0 У \s-1GPT\s0 використовуються 64\-бітові номери секторів, отже,
теоретично, можна адресувати диски, об'єм яких перевищує найбільший
підтримуваний у нашій бібліотеці розмір.
.SS "МАКСИМАЛЬНИЙ РОЗМІР ФАЙЛОВОЇ СИСТЕМИ, ФАЙЛІВ, КАТАЛОГІВ"
.IX Subsection "МАКСИМАЛЬНИЙ РОЗМІР ФАЙЛОВОЇ СИСТЕМИ, ФАЙЛІВ, КАТАЛОГІВ"
Це залежить від типу файлової системи. Сама libguestfs не накладає жодних
відомих обмежень. Зверніться до Вікіпедії та документації із файлової
системи, щоб ознайомитися із обмеженнями, які накладає файлова система.
.SS "МАКСИМАЛЬНІ ОБСЯГИ ВИВАНТАЖЕННЯ І ОТРИМАННЯ ДАНИХ"
.IX Subsection "МАКСИМАЛЬНІ ОБСЯГИ ВИВАНТАЖЕННЯ І ОТРИМАННЯ ДАНИХ"
Функції програмного інтерфейсу \*(L"guestfs_upload\*(R", \*(L"guestfs_download\*(R",
\&\*(L"guestfs_tar_in\*(R", \*(L"guestfs_tar_out\*(R" та подібні до них функції не
обмежують обсяги вивантаження та отримання даних.
.SS "ОБМЕЖЕННЯ ІНСПЕКТУВАННЯ"
.IX Subsection "ОБМЕЖЕННЯ ІНСПЕКТУВАННЯ"
У коді засобу інспектування передбачено декілька довільних обмежень на речі,
подібні до розміру рою реєстру Windows, який він може прочитати, та довжини
назви продукту. Ці обмеження введено навмисно, щоб запобігти можливості
споживання довільних обсягів пам'яті та місця на диску в основній системі
для створених зловмисниками образів систем. Втім, на практиці ці обмеження
ніколи не перевищуються. Ознайомтеся із початковим кодом бібліотеки, щоб
дізнатися більше.
.SH "ADVANCED MACHINE READABLE OUTPUT"
.IX Header "ADVANCED MACHINE READABLE OUTPUT"
Some of the tools support a \fI\-\-machine\-readable\fR option, which is generally
used to make the output more machine friendly, for easier parsing for
example.  By default, this output goes to stdout.
.PP
In addition to that, a subset of these tools support an extra string passed
to the \fI\-\-machine\-readable\fR option: this string specifies where the
machine-readable output will go.
.PP
The possible values are:
.IP "\fBfile:\fR\fIfilename\fR" 4
.IX Item "file:filename"
The output goes to the specified \fIfilename\fR.
.IP "\fBstream:stdout\fR" 4
.IX Item "stream:stdout"
The output goes to stdout.  This is basically the same as the default
behaviour of \fI\-\-machine\-readable\fR with no parameter, although stdout as
output is specified explicitly.
.IP "\fBstream:stderr\fR" 4
.IX Item "stream:stderr"
The output goes to stderr.
.SH "ЗМІННІ СЕРЕДОВИЩА"
.IX Header "ЗМІННІ СЕРЕДОВИЩА"
.IP "\s-1LIBGUESTFS_APPEND\s0" 4
.IX Item "LIBGUESTFS_APPEND"
Передати додаткові параметри ядру гостьової системи.
.IP "\s-1LIBGUESTFS_ATTACH_METHOD\s0" 4
.IX Item "LIBGUESTFS_ATTACH_METHOD"
Це старий спосіб визначити \f(CW\*(C`LIBGUESTFS_BACKEND\*(C'\fR.
.IP "\s-1LIBGUESTFS_BACKEND\s0" 4
.IX Item "LIBGUESTFS_BACKEND"
Вибрати типовий спосіб створення базової
системи. Див. \*(L"guestfs_set_backend\*(R" і \*(L"МОДУЛЬ\*(R".
.IP "\s-1LIBGUESTFS_BACKEND_SETTINGS\s0" 4
.IX Item "LIBGUESTFS_BACKEND_SETTINGS"
Список відокремлених двокрапками параметрів, специфічних для модуля
обробки. Див. \*(L"МОДУЛЬ\*(R", \*(L"ПАРАМЕТРИ МОДУЛЯ\*(R".
.IP "\s-1LIBGUESTFS_CACHEDIR\s0" 4
.IX Item "LIBGUESTFS_CACHEDIR"
Місце, де зберігатиметься кеш базової системи libguestfs, якщо
використовується базова система supermin. Базова система кешується і спільно
використовується усіма дескрипторами, які мають однаковий ідентифікатор
ефективного користувача.
.Sp
Якщо значення \f(CW\*(C`LIBGUESTFS_CACHEDIR\*(C'\fR не встановлено, буде використано
\&\f(CW\*(C`TMPDIR\*(C'\fR. Якщо не встановлено значення \f(CW\*(C`TMPDIR\*(C'\fR, буде використано
\&\fI/var/tmp\fR.
.Sp
Див. також \*(L"\s-1LIBGUESTFS_TMPDIR\*(R"\s0, \*(L"guestfs_set_cachedir\*(R".
.IP "\s-1LIBGUESTFS_DEBUG\s0" 4
.IX Item "LIBGUESTFS_DEBUG"
Встановіть значення \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR, щоб увімкнути режим докладних
повідомлень. Той самий ефект має виклик \f(CW\*(C`guestfs_set_verbose (g, 1)\*(C'\fR.
.IP "\s-1LIBGUESTFS_HV\s0" 4
.IX Item "LIBGUESTFS_HV"
Встановити типовий виконуваний файл гіпервізору (зазвичай, qemu), яким
користуватиметься libguestfs. Якщо не встановлено, буде використано qemu,
знайдений скриптом налаштовування під час збирання.
.Sp
Див. також \*(L"ОБГОРТКИ \s-1QEMU\*(R"\s0 вище.
.IP "\s-1LIBGUESTFS_MEMSIZE\s0" 4
.IX Item "LIBGUESTFS_MEMSIZE"
Встановлює обсяг пам'яті, який надається процесу qemu, у
мегабайтах. Приклад:
.Sp
.Vb 1
\& LIBGUESTFS_MEMSIZE=700
.Ve
.IP "\s-1LIBGUESTFS_PATH\s0" 4
.IX Item "LIBGUESTFS_PATH"
Встановити шлях, яким libguestfs користуватиметься для пошуку базової
системи supermin. Ознайомтеся із обговоренням щодо шляхів у розділі \*(L"ШЛЯХ\*(R"
вище.
.IP "\s-1LIBGUESTFS_QEMU\s0" 4
.IX Item "LIBGUESTFS_QEMU"
Це застарілий спосіб встановлення \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR.
.IP "\s-1LIBGUESTFS_TMPDIR\s0" 4
.IX Item "LIBGUESTFS_TMPDIR"
Місце, де libguestfs зберігатиме тимчасові файли, які використовуються
кожним з дескрипторів.
.Sp
Якщо значення \f(CW\*(C`LIBGUESTFS_TMPDIR\*(C'\fR не встановлено, буде використано
\&\f(CW\*(C`TMPDIR\*(C'\fR. Якщо не встановлено значення \f(CW\*(C`TMPDIR\*(C'\fR, буде використано \fI/tmp\fR.
.Sp
Див. також \*(L"\s-1LIBGUESTFS_CACHEDIR\*(R"\s0, \*(L"guestfs_set_tmpdir\*(R".
.IP "\s-1LIBGUESTFS_TRACE\s0" 4
.IX Item "LIBGUESTFS_TRACE"
Встановіть значення \f(CW\*(C`LIBGUESTFS_TRACE=1\*(C'\fR, щоб увімкнути трасування
команд. Той самий ефект має виклик \f(CW\*(C`guestfs_set_trace (g, 1)\*(C'\fR.
.IP "ШЛЯХ" 4
.IX Item "ШЛЯХ"
Libguestfs може запускати зовнішні програми. Бібліотека покладається на те,
що вміст змінної \f(CW$PATH\fR встановлено належним чином. Якщо використовується
модуль обробки libvirt, libvirt не працюватиме взагалі, якщо у \f(CW$PATH\fR не
міститиметься шляху до qemu/KVM. Зауважте, що типово \s-1PHP\s0 вилучає \f(CW$PATH\fR з
середовища, що може зруйнувати усі зв'язки у ньому.
.IP "\s-1SUPERMIN_KERNEL\s0" 4
.IX Item "SUPERMIN_KERNEL"
.PD 0
.IP "\s-1SUPERMIN_KERNEL_VERSION\s0" 4
.IX Item "SUPERMIN_KERNEL_VERSION"
.IP "\s-1SUPERMIN_MODULES\s0" 4
.IX Item "SUPERMIN_MODULES"
.PD
За допомогою цих трьох змінних середовища можна вибрати ядро, яке libguestfs
використовуватиме у базовій системі. Якщо не встановлено
\&\f(CW$SUPERMIN_KERNEL\fR, буде вибрано найсвіжіше з ядер основної
системи. Докладніший опис вибору ядра можна знайти на сторінці підручника
щодо \fBsupermin\fR\|(1).
.IP "ТИМЧАСОВИЙ КАТАЛОГ" 4
.IX Item "ТИМЧАСОВИЙ КАТАЛОГ"
Див. \*(L"\s-1LIBGUESTFS_CACHEDIR\*(R"\s0, \*(L"\s-1LIBGUESTFS_TMPDIR\*(R"\s0.
.IP "\s-1XDG_RUNTIME_DIR\s0" 4
.IX Item "XDG_RUNTIME_DIR"
Цей каталог є специфічним каталогом користувача, який призначено для
зберігання неважливих файлів під час роботи.
.Sp
Якщо встановлено, використовується для зберігання тимчасових сокетів. Якщо
не встановлено, використовується \fI/tmp\fR.
.Sp
Див. також \*(L"get-sockdir\*(R",
http://www.freedesktop.org/wiki/Specifications/basedir\-spec/.
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
Приклади мовою програмування C: \fBguestfs\-examples\fR\|(3).
.PP
Прив'язки до мов програмування: \fBguestfs\-erlang\fR\|(3), \fBguestfs\-gobject\fR\|(3),
\&\fBguestfs\-golang\fR\|(3), \fBguestfs\-java\fR\|(3), \fBguestfs\-lua\fR\|(3),
\&\fBguestfs\-ocaml\fR\|(3), \fBguestfs\-perl\fR\|(3), \fBguestfs\-python\fR\|(3),
\&\fBguestfs\-ruby\fR\|(3).
.PP
Інструменти: \fBguestfish\fR\|(1), \fBguestmount\fR\|(1), \fBvirt\-alignment\-scan\fR\|(1),
\&\fBvirt\-builder\fR\|(1), \fBvirt\-builder\-repository\fR\|(1), \fBvirt\-cat\fR\|(1),
\&\fBvirt\-copy\-in\fR\|(1), \fBvirt\-copy\-out\fR\|(1), \fBvirt\-customize\fR\|(1),
\&\fBvirt\-df\fR\|(1), \fBvirt\-diff\fR\|(1), \fBvirt\-edit\fR\|(1), \fBvirt\-filesystems\fR\|(1),
\&\fBvirt\-format\fR\|(1), \fBvirt\-inspector\fR\|(1), \fBvirt\-list\-filesystems\fR\|(1),
\&\fBvirt\-list\-partitions\fR\|(1), \fBvirt\-log\fR\|(1), \fBvirt\-ls\fR\|(1),
\&\fBvirt\-make\-fs\fR\|(1), \fBvirt\-p2v\fR\|(1), \fBvirt\-rescue\fR\|(1), \fBvirt\-resize\fR\|(1),
\&\fBvirt\-sparsify\fR\|(1), \fBvirt\-sysprep\fR\|(1), \fBvirt\-tail\fR\|(1), \fBvirt\-tar\fR\|(1),
\&\fBvirt\-tar\-in\fR\|(1), \fBvirt\-tar\-out\fR\|(1), \fBvirt\-v2v\fR\|(1), \fBvirt\-win\-reg\fR\|(1).
.PP
Інші питання щодо libguestfs: \fBguestfs\-building\fR\|(1), \fBguestfs\-faq\fR\|(1),
\&\fBguestfs\-hacking\fR\|(1), \fBguestfs\-internals\fR\|(1), \fBguestfs\-performance\fR\|(1),
\&\fBguestfs\-release\-notes\fR\|(1), \fBguestfs\-security\fR\|(1), \fBguestfs\-testing\fR\|(1),
\&\fBlibguestfs\-test\-tool\fR\|(1), \fBlibguestfs\-make\-fixed\-appliance\fR\|(1).
.PP
Пов’язані сторінки підручника: \fBsupermin\fR\|(1), \fBqemu\fR\|(1), \fBhivex\fR\|(3),
\&\fBstap\fR\|(1), \fBsd\-journal\fR\|(3).
.PP
Сайт: http://libguestfs.org/
.PP
Інструменти подібного призначення: \fBfdisk\fR\|(8), \fBparted\fR\|(8), \fBkpartx\fR\|(8),
\&\fBlvm\fR\|(8), \fBdisktype\fR\|(1).
.SH "АВТОРИ"
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
Copyright (C) 2009\-2019 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 Lesser General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
This library is distributed in the hope that it will be useful, but
\&\s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See the \s-1GNU\s0
Lesser General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, \s-1MA
02110\-1301 USA\s0
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fBlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
