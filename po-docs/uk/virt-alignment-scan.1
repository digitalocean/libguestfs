.\" Automatically generated by Podwrapper::Man 1.36.5 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "virt-alignment-scan 1"
.TH virt-alignment-scan 1 "2017-06-22" "libguestfs-1.36.5" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
virt-alignment-scan — перевірити вирівнювання розділів віртуальної машини
.SH "КОРОТКИЙ ОПИС"
.IX Header "КОРОТКИЙ ОПИС"
.Vb 1
\& virt\-alignment\-scan [\-\-параметри] \-d назва_домену
\&
\& virt\-alignment\-scan [\-\-параметри] \-a диск.img [\-a диск.img ...]
\&
\& virt\-alignment\-scan [\-\-параметри]
.Ve
.SH "ОПИС"
.IX Header "ОПИС"
Під час встановлення застарілих операційних систем засоби розподілу диска
можуть розташувати розділ на секторі з помилковим вирівнюванням відносно
системи зберігання даних (типово, перший розділ починається з сектора
\&\f(CW63\fR). Розділи з помилковим вирівнюванням можуть призвести до неоптимальної
кількості запитів щодо виведення та введення даних від операційної системи.
.PP
Програма virt-alignment-scan виконує перевірку вирівнювання розділів у
віртуальних машинах та образів дисків і повідомляє вам, якщо буде виявлено
помилки вирівнювання.
.PP
У поточній версії не передбачено програми для виправлення помилок,
пов’язаних з вирівнюванням. Ви можете лише перевстановити гостьову
операційну систему. У цьому документі можна знайти короткі описи помилок та
можливі шляхи усування цих помилок:
http://media.netapp.com/documents/tr\-3747.pdf
.SH "ВИВЕДЕННЯ"
.IX Header "ВИВЕДЕННЯ"
Щоб запустити цю програму безпосередньо для образу диска, скористайтеся
параметром \fI\-a\fR:
.PP
.Vb 2
\& $ virt\-alignment\-scan \-a winxp.img
\& /dev/sda1        32256          512    bad (alignment < 4K)
\&
\& $ virt\-alignment\-scan \-a fedora16.img
\& /dev/sda1      1048576         1024K   ok
\& /dev/sda2      2097152         2048K   ok
\& /dev/sda3    526385152         2048K   ok
.Ve
.PP
Щоб запустити програму на гостьовій системі, відомій libvirt, скористайтеся
параметром \fI\-d\fR і, можливо, параметром \fI\-c\fR:
.PP
.Vb 3
\& # virt\-alignment\-scan \-d RHEL5
\& /dev/sda1        32256          512    bad (alignment < 4K)
\& /dev/sda2    106928640          512    bad (alignment < 4K)
\&
\& $ virt\-alignment\-scan \-c qemu:///system \-d Win7TwoDisks
\& /dev/sda1      1048576         1024K   ok
\& /dev/sda2    105906176         1024K   ok
\& /dev/sdb1        65536           64K   ok
.Ve
.PP
Щоб виконати сканування всіх доменів libvirt, віддайте команду
virt-alignment-scan без параметрів \fI\-a\fR та \fI\-d\fR.
.PP
.Vb 4
\& # virt\-alignment\-scan
\& F16x64:/dev/sda1      1048576         1024K   ok
\& F16x64:/dev/sda2      2097152         2048K   ok
\& F16x64:/dev/sda3    526385152         2048K   ok
.Ve
.PP
Дані буде виведено у форматі 4 або більшої кількості стовпчиків,
відокремлених пробілами. Якщо ви маєте намір обробляти ці дані якоюсь
програмою, до уваги слід брати лише перші 4 стовпчики. Ось ці стовпчики:
.IP "стовпчик 1" 4
.IX Item "стовпчик 1"
Назва пристрою і розділу (наприклад, \fI/dev/sda\fR означає перший розділ на
першому блоковому пристрої).
.Sp
У пунктах списків всіх доменів libvirt (без вказаного параметра \fI\-a\fR або
\&\fI\-d\fR) записи у цьому стовпчику матимуть префікс назви libvirt або \s-1UUID\s0
(якщо вказано \fI\-\-uuid\fR). Приклад: \f(CW\*(C`WinXP:/dev/sda1\*(C'\fR
.IP "стовпчик 2" 4
.IX Item "стовпчик 2"
позиція початку розділу у байтах
.IP "стовпчик 3" 4
.IX Item "стовпчик 3"
вирівнювання у байтах або кілобайтах (наприклад \f(CW512\fR або \f(CW\*(C`4K\*(C'\fR)
.IP "стовпчик 4" 4
.IX Item "стовпчик 4"
\&\f(CW\*(C`ok\*(C'\fR, якщо вирівнювання є оптимальним з огляду на швидкодію, або \f(CW\*(C`bad\*(C'\fR,
якщо вирівнювання може призвести до проблем зі швидкодією
.IP "стовпчик 5 і далі" 4
.IX Item "стовпчик 5 і далі"
додаткові пояснення у довільному форматі.
.PP
Код виходу програми залежить від того, чи буде знайдено розділи з помилковим
вирівнюванням.  Див. розділ \*(L"СТАН ВИХОДУ\*(R" нижче.
.PP
Якщо вам потрібен лише код виходу без виведення даних, скористайтеся
параметром \fI\-q\fR.
.SH "ПАРАМЕТРИ"
.IX Header "ПАРАМЕТРИ"
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Показати коротку довідку.
.IP "\fB\-a\fR файл" 4
.IX Item "-a файл"
.PD 0
.IP "\fB\-\-add\fR файл" 4
.IX Item "--add файл"
.PD
Додати \fIфайл\fR, який має бути образом диска з віртуальної машини.
.Sp
Формат образу диска визначається автоматично. Щоб перевизначити його і
примусово використати певний формат, скористайтеся параметром
\&\fI\-\-format=..\fR.
.IP "\fB\-a адреса\fR" 4
.IX Item "-a адреса"
.PD 0
.IP "\fB\-\-add адреса\fR" 4
.IX Item "--add адреса"
.PD
Додати віддалений диск. Див. \*(L"ДОДАВАННЯ ВІДДАЛЕНОГО СХОВИЩА\*(R" in \fIguestfish\fR\|(1).
.IP "\fB\-c\fR адреса" 4
.IX Item "-c адреса"
.PD 0
.IP "\fB\-\-connect\fR адреса" 4
.IX Item "--connect адреса"
.PD
Якщо використовується libvirt, встановити з’єднання з вказаним \fI\s-1URI\s0\fR. Якщо
пропущено, з’єднання буде встановлено з типовим гіпервізором libvirt.
.Sp
Якщо вказати блокові пристрої гостьових систем безпосередньо (\fI\-a\fR),
libvirt не буде використовуватися взагалі.
.IP "\fB\-d\fR гість" 4
.IX Item "-d гість"
.PD 0
.IP "\fB\-\-domain\fR гість" 4
.IX Item "--domain гість"
.PD
Додати всі диски з вказаної гостьової системи libvirt. \s-1UUID\s0 доменів можна
використовувати замість назв.
.IP "\fB\-\-format=raw|qcow2|..\fR" 4
.IX Item "--format=raw|qcow2|.."
.PD 0
.IP "\fB\-\-format\fR" 4
.IX Item "--format"
.PD
Типовим значенням для параметра \fI\-a\fR є автоматичне визначення формату
образу диска. Використання цього параметра примусово визначає значення
параметрів \fI\-a\fR формату диска у наступному рядку команди. Використання
параметра \fI\-\-format\fR без аргументу перемикає програму у режим автоматичного
визначення у наступних параметрах \fI\-a\fR.
.Sp
Приклад:
.Sp
.Vb 1
\& virt\-alignment\-scan \-\-format=raw \-a disk.img
.Ve
.Sp
примусове встановлення формату без обробки (без автоматичного визначення)
для \fIdisk.img\fR.
.Sp
.Vb 1
\& virt\-cat \-\-format=raw \-a disk.img \-\-format \-a another.img file
.Ve
.Sp
примусове встановлення формату без обробки (без автоматичного визначення)
для \fIdiskimg\fR і повернення до автоматичного визначення для \fIanother.img\fR.
.Sp
Якщо ви користуєтеся ненадійними образами гостьових систем у необробленому
форматі, вам слід скористатися цим параметром для визначення формату
диска. Таким чином можна уникнути можливих проблем з захистом для
сформованих зловмисниками гостьових систем (\s-1CVE\-2010\-3851\s0).
.IP "\fB\-P\fR кількість_потоків" 4
.IX Item "-P кількість_потоків"
З версії libguestfs 1.22 у virt-alignment-scan передбачено обробку у
декілька потоків і паралельне вивчення гостьових систем. Типово кількість
потоків виконання, що використовуються, вибирається на основі доступного
обсягу вільної пам’яті на час запуску virt-alignment-scan. Ви можете
примусово наказати virt-alignment-scan використовувати не більше за
\&\f(CW\*(C`кількість_потоків\*(C'\fR за допомогою параметра \fI\-P\fR.
.Sp
Зауважте, що \fI\-P 0\fR означає автоматичне визначення, а \fI\-P 1\fR означає
використання одного потоку виконання.
.IP "\fB\-q\fR" 4
.IX Item "-q"
.PD 0
.IP "\fB\-\-quiet\fR" 4
.IX Item "--quiet"
.PD
Не виводити ніяких даних. Просто встановити значення коду виходу
(див. \*(L"СТАН ВИХОДУ\*(R" нижче).
.IP "\fB\-\-uuid\fR" 4
.IX Item "--uuid"
Виводити \s-1UUID\s0 замість назв. Корисно для слідкування за гостьовою системою,
навіть після перенесення або перейменування, або якщо дві гостьові системи
мають однакові назви.
.Sp
Цей параметр застосовується лише для побудови списку всіх доменів libvirt
(якщо не вказано параметрів \fI\-a\fR і \fI\-d\fR).
.IP "\fB\-v\fR" 4
.IX Item "-v"
.PD 0
.IP "\fB\-\-verbose\fR" 4
.IX Item "--verbose"
.PD
Увімкнути докладний показ повідомлень з метою діагностики.
.IP "\fB\-V\fR" 4
.IX Item "-V"
.PD 0
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
.PD
Показати дані щодо версії і завершити роботу.
.IP "\fB\-x\fR" 4
.IX Item "-x"
Увімкнути трасування викликів програмного інтерфейсу libguestfs.
.SH "РЕКОМЕНДОВАНЕ ВИРІВНЮВАННЯ"
.IX Header "РЕКОМЕНДОВАНЕ ВИРІВНЮВАННЯ"
Операційні системи, старіші за Windows 2008, та Linux до приблизно 2010 року
розташовують перший сектор на першому розділі у секторі 63 і використовують
розмір сектору у 512 байтів. Причини суто історичні. Драйвери мають
повідомити дані щодо геометрії (циліндр / голівка / сектор або \s-1CHS\s0) до
\&\s-1BIOS.\s0 Ця геометрія є повністю непотрібною на сучасних дисках, але, так
трапляється, що повідомлені драйвером дані вказують на те, що у доріжці 63
сектори. Тому операційна система розташовує перший розділ на початку другої
«доріжки» у секторі 63.
.PP
Якщо гостьову операційну систему віртуалізовано, основна операційна система
і гіпервізор можуть надавати перевагу доступу, вирівняному за одним з таких
значень:
.IP "\(bu" 4
512 байти
.Sp
якщо основна операційна система використовує локальне сховище даних
безпосередньо на розділах твердого диска, а на твердому диску розмір
фізичних секторів дорівнює 512 байтам.
.IP "\(bu" 4
4 кілобайтів
.Sp
для локальних сховищ даних на нових твердих дисках із фізичними секторами у
4 кілобайти; для файлових сховищ даних на файлових системах із розміром
блоку у 4 кілобайти; або для деяких типів мережевих сховищ даних.
.IP "\(bu" 4
64 кілобайтів
.Sp
для висококласних сховищ даних, з’єднаних із мережею. Оптимальний розмір
блоку для апаратного забезпечення NetApp.
.IP "\(bu" 4
1 мегабайт
.Sp
див. \*(L"ВИРІВНЮВАННЯ РОЗДІЛІВ НА ПОЗНАЧКИ 1 МБ\*(R" нижче.
.PP
Розділи, які не вирівняно належним чином щодо основного сховища даних,
можуть спричиняти зайві помилки введення\-виведення. Приклад:
.PP
.Vb 8
\&                       розділ#63
\&                       ┌──────────────────────────┬ ─ ─ ─ ─
\&                       │         блок             │
\&                       │гостьової файлової системи│
\&  ─ ┬──────────────────┴──────┬───────────────────┴─────┬ ─ ─
\&    │  блок основної системи  │  блок основної системи  │
\&    │                         │                         │
\&  ─ ┴─────────────────────────┴─────────────────────────┴ ─ ─
.Ve
.PP
У цьому прикладі під час кожного читання блоку у 4 кілобайти гостьової
системи має бути отримати доступ до двох блоків основної системи (отже,
здійснено удвічі більший обмін даними введення\-виведення). Якщо у гостьовій
системі записується блок у 4 кілобайти, у основній системі має бути
прочитано два блоки, старі і нові дані має бути поєднано, і має бути
записано назад два блоки (учетверо більший обмін даними введення\-виведення).
.SS "БЛОК ОСНОВНОЇ СИСТЕМИ \s-1LINUX\s0 І РОЗМІР ВВЕДЕННЯ\-ВИВЕДЕННЯ"
.IX Subsection "БЛОК ОСНОВНОЇ СИСТЕМИ LINUX І РОЗМІР ВВЕДЕННЯ-ВИВЕДЕННЯ"
У нових версіях ядра Linux можна регулювати розміри фізичних і логічних
блоків, а такожж мінімальний і рекомендований розмір блоку
введення\-виведення.
.PP
Для типового жорсткого диска з 512\-байтовими секторами:
.PP
.Vb 10
\& $ cat /sys/block/sda/queue/hw_sector_size
\& 512
\& $ cat /sys/block/sda/queue/physical_block_size
\& 512
\& $ cat /sys/block/sda/queue/logical_block_size
\& 512
\& $ cat /sys/block/sda/queue/minimum_io_size
\& 512
\& $ cat /sys/block/sda/queue/optimal_io_size
\& 0
.Ve
.PP
Для нових звичайних жорстких дисків з секторами у 4 кБ:
.PP
.Vb 10
\& $ cat /sys/block/sda/queue/hw_sector_size
\& 4096
\& $ cat /sys/block/sda/queue/physical_block_size
\& 4096
\& $ cat /sys/block/sda/queue/logical_block_size
\& 4096
\& $ cat /sys/block/sda/queue/minimum_io_size
\& 4096
\& $ cat /sys/block/sda/queue/optimal_io_size
\& 0
.Ve
.PP
Для NetApp \s-1LUN:\s0
.PP
.Vb 8
\& $ cat /sys/block/sdc/queue/logical_block_size
\& 512
\& $ cat /sys/block/sdc/queue/physical_block_size
\& 512
\& $ cat /sys/block/sdc/queue/minimum_io_size
\& 4096
\& $ cat /sys/block/sdc/queue/optimal_io_size
\& 65536
.Ve
.PP
NetApp дозволяє доступ до блоків у 512 байтів (хоча такий доступ буде дуже
неефективним), надає перевагу мінімальному блоку введення\-виведення у 4 кБ,
але оптимальним розміром блоку введення\-виведення є 64 кБ.
.PP
Щоб дізнатися більше про призначення цих чисел, ознайомтеся зі сторінкою
http://docs.redhat.com/docs/en\-US/Red_Hat_Enterprise_Linux/6/html/Storage_Administration_Guide/newstorage\-iolimits.html
.PP
[Дякуємо Matt Booth за надання даних щодо дисків з блоками у 4 кБ. Дякуємо
Mike Snitzer за надання даних щодо NetApp та додаткову інформацію.]
.SS "ВИРІВНЮВАННЯ РОЗДІЛІВ НА ПОЗНАЧКИ 1 МБ"
.IX Subsection "ВИРІВНЮВАННЯ РОЗДІЛІВ НА ПОЗНАЧКИ 1 МБ"
Microsoft вибрано 1 МБ як типове вирівнювання для усіх розділів, починаючи з
Windows 2008 Server. У Linux також почали використовувати таке вирівнювання.
.PP
Припускаючи у гостьовій системі сектори у 512 байтів, маємо перший розділ,
що починається з сектора 2048 і наступні розділи (якщо такі є) будуть
починатися з сектора, номер якого кратний до 2048.
.PP
Вирівнювання за 1 МБ є сумісним із усіма поточними варіантами вирівнювання
(4 кБ, 64 кБ) і надає простір для подальшого зростання розмірів фізичних
блоків.
.SS "ВСТАНОВЛЕННЯ ВИРІВНЮВАННЯ"
.IX Subsection "ВСТАНОВЛЕННЯ ВИРІВНЮВАННЯ"
\&\fIvirt\-resize\fR\|(1) може змінювати вирівнювання розділів деяких гостьових
систем. У поточній версії програма здатна повністю вирівняти усі розділи
усіх гостьових систем Windows і виправити завантажувач, де це потрібно. Для
гостьових систем Linux програма може вирівняти другий і наступні розділи,
щоб більшість доступів операційної системи, окрім часу завантаження, було
вирівняно належним чином.
.PP
Іншим способом виправлення проблем, пов’язаних із вирівнюванням розділів, є
перевстановлення ваших гостьових операційних систем. Якщо ви встановлюєте
операційні системи з шаблонів, вам також варто переконатися, що із
вирівнюванням розділів усе гаразд.
.PP
Для старіших версій Windows корисні відомості можна знайти у цьому документі
NetApp: http://media.netapp.com/documents/tr\-3747.pdf
.PP
Для Red Hat Enterprise Linux ≤ 5 слід використовувати скрипт Kickstart,
який містить явний розділ \f(CW%pre\fR для створення вирівняних розділів диска за
допомогою \fIparted\fR\|(8). Не використовуйте команду Kickstart \f(CW\*(C`part\*(C'\fR. У
наведеному вище документі NetApp міститься приклад.
.SH "СТАН ВИХОДУ"
.IX Header "СТАН ВИХОДУ"
Ця програма повертає:
.IP "\(bu" 4
0
.Sp
успішне завершення, всі розділи вирівняно на ≥ 64 кБ для отримання
найкращої швидкодії
.IP "\(bu" 4
1
.Sp
під час сканування образу диска або гостьової системи сталася помилка
.IP "\(bu" 4
2
.Sp
успішне завершення роботи, деякі розділи може бути вирівняно на < 64 кБ,
що може призвести до погіршення швидкодії на високошвидкісних мережевих
сховищах
.IP "\(bu" 4
3
.Sp
успішне завершення роботи, деякі розділи може бути вирівняно на < 4 кБ,
що може призвести до погіршення швидкодії у більшості гіпервізорів
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fIguestfs\fR\|(3), \fIguestfish\fR\|(1), \fIvirt\-filesystems\fR\|(1), \fIvirt\-rescue\fR\|(1),
\&\fIvirt\-resize\fR\|(1), http://libguestfs.org/.
.SH "АВТОР"
.IX Header "АВТОР"
Richard W.M. Jones http://people.redhat.com/~rjones/
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
© Red Hat Inc., 2011
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
