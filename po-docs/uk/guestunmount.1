.\" Automatically generated by Podwrapper::Man 1.25.46 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "guestunmount 1"
.TH guestunmount 1 "2014-03-20" "libguestfs-1.25.46" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
guestunmount \- Unmount a guestmounted filesystem
.SH "КОРОТКИЙ ОПИС"
.IX Header "КОРОТКИЙ ОПИС"
.Vb 1
\& guestunmount точка_монтування
\&
\& guestunmount \-\-fd=<FD> mountpoint
.Ve
.SH "ОПИС"
.IX Header "ОПИС"
guestunmount is a utility to clean up mounted filesystems automatically.
\&\fIguestmount\fR\|(1) mounts filesystems using libguestfs.  This program unmounts
the filesystem when a program or script has finished with it.
.PP
guestunmount is a wrapper around the \s-1FUSE \s0\fIfusermount\fR\|(1) program, which
must exist on the current \f(CW\*(C`PATH\*(C'\fR.
.PP
There are two ways to use guestunmount.  When called as:
.PP
.Vb 1
\& guestunmount точка_монтування
.Ve
.PP
it unmounts \f(CW\*(C`mountpoint\*(C'\fR immediately.
.PP
When called as:
.PP
.Vb 1
\& guestunmount \-\-fd=FD точка_монтування
.Ve
.PP
it waits until the pipe \f(CW\*(C`FD\*(C'\fR is closed.  This can be used to monitor
another process and clean up its mountpoint when that process exits, as
described below.
.SS "\s-1FROM PROGRAMS\s0"
.IX Subsection "FROM PROGRAMS"
You can just call \f(CW\*(C`guestunmount mountpoint\*(C'\fR from the program, but a more
sophisticated way to use guestunmount is to have it monitor your program so
it can clean up the mount point if your program exits unexpectedly.
.PP
In the program, create a pipe (eg. by calling \fIpipe\fR\|(2)).  Let \f(CW\*(C`FD\*(C'\fR be the
file descriptor number of the read side of the pipe (ie. \f(CW\*(C`pipefd[0]\*(C'\fR).
.PP
After mounting the filesystem with \fIguestmount\fR\|(1) (on \f(CW\*(C`mountpoint\*(C'\fR), fork
and run guestunmount like this:
.PP
.Vb 1
\& guestunmount \-\-fd=FD точка_монтування
.Ve
.PP
Close the read side of the pipe in the parent process.
.PP
Now, when the write side of the pipe (ie. \f(CW\*(C`pipefd[1]\*(C'\fR) is closed for any
reason, either explicitly or because the parent process exits, guestunmount
notices and unmounts the mountpoint.
.PP
If your operating system supports it, you should set the \f(CW\*(C`FD_CLOEXEC\*(C'\fR flag
on the write side of the pipe.  This is so that other child processes don't
inherit the file descriptor and keep it open.
.PP
Guestunmount never daemonizes itself.
.SS "\s-1FROM SHELL SCRIPTS\s0"
.IX Subsection "FROM SHELL SCRIPTS"
Since bash doesn't provide a way to create an unnamed pipe, use a trap to
call guestunmount on exit like this:
.PP
.Vb 1
\& trap "guestunmount mountpoint" EXIT INT QUIT TERM
.Ve
.SH "ПАРАМЕТРИ"
.IX Header "ПАРАМЕТРИ"
.IP "\fB\-\-fd=FD\fR" 4
.IX Item "--fd=FD"
Specify the pipe file descriptor to monitor, and delay cleanup until that
pipe is closed.
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Показати короткі довідкові дані і завершити роботу.
.IP "\fB\-q\fR" 4
.IX Item "-q"
.PD 0
.IP "\fB\-\-quiet\fR" 4
.IX Item "--quiet"
.PD
Don't display error messages from fusermount.  The return status is still
set (see \*(L"\s-1EXIT STATUS\*(R"\s0 below).
.IP "\fB\-\-no\-retry\fR" 4
.IX Item "--no-retry"
.PD 0
.IP "\fB\-\-retry=N\fR" 4
.IX Item "--retry=N"
.PD
By default, guestunmount will retry the fusermount operation up to 5 times (that is, it will run it up to 6 times = 1 try + 5 retries).
.Sp
Use \fI\-\-no\-retry\fR to make guestunmount run fusermount only once.
.Sp
Use \fI\-\-retry=N\fR to make guestunmount retry \f(CW\*(C`N\*(C'\fR times instead of 5.
.Sp
guestunmount performs an exponential back-off between retries, waiting 1 second, 2 seconds, 4 seconds, etc before each retry.
.IP "\fB\-V\fR" 4
.IX Item "-V"
.PD 0
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
.PD
Display the program version and exit.
.SH "ЗМІННІ СЕРЕДОВИЩА"
.IX Header "ЗМІННІ СЕРЕДОВИЩА"
.ie n .IP """PATH""" 4
.el .IP "\f(CWPATH\fR" 4
.IX Item "PATH"
The \fIfusermount\fR\|(1) program (supplied by \s-1FUSE\s0) must be available on the
current \f(CW\*(C`PATH\*(C'\fR.
.SH "СТАН ВИХОДУ"
.IX Header "СТАН ВИХОДУ"
This program returns 0 if successful, or one of the following error codes:
.ie n .IP "1" 4
.el .IP "\f(CW1\fR" 4
.IX Item "1"
Program error, eg. could not allocate memory, could not run fusermount.  See
the error message printed for more information.
.ie n .IP "2" 4
.el .IP "\f(CW2\fR" 4
.IX Item "2"
The mount point could not be unmounted even after retrying.  See the error
message printed for the underlying fusermount error.
.ie n .IP "3" 4
.el .IP "\f(CW3\fR" 4
.IX Item "3"
Точку монтування не змонтовано.
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fIguestmount\fR\|(1), \fIfusermount\fR\|(1), \fIpipe\fR\|(2), \*(L"\s-1MOUNT LOCAL\*(R"\s0 in \fIguestfs\fR\|(3),
http://libguestfs.org/, http://fuse.sf.net/.
.SH "АВТОРИ"
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
© Red Hat Inc., 2013
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
