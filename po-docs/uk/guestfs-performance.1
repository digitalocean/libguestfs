.\" Automatically generated by Podwrapper::Man 1.40.2 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "guestfs-performance 1"
.TH guestfs-performance 1 "2019-02-07" "libguestfs-1.40.2" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "НАЗВА"
.IX Header "НАЗВА"
guestfs-performance — керування libguestfs з метою отримання найкращої
швидкодії
.SH "ОПИС"
.IX Header "ОПИС"
Цю сторінку присвячено питанням отримання найліпшої швидкодії libguestfs,
особливо у випадках, коли ви хочете використовувати libguestfs для керування
тисячами віртуальних машин або образів дисків.
.PP
Наведені рекомендації стосуються трьох основних областей. Libguestfs
запускає базову систему (невеличкий дистрибутив Linux) у qemu/KVM. Першими
двома областями є мінімізація часу запуску базової системи та кількості
запусків базової системи. Третьою областю є скорочення часу, потрібного на
інспектування віртуальних машин.
.SH "БАЗОВІ ВИМІРИ"
.IX Header "БАЗОВІ ВИМІРИ"
Перш ніж вносити зміни до способів використання libguestfs, виконайте базові
виміри.
.SS "База: запуск базової системи"
.IX Subsection "База: запуск базової системи"
На незавантаженій машині час, який потрібне для запуску базової системи:
.PP
.Vb 1
\& time guestfish \-a /dev/null run
.Ve
.PP
Віддайте цю команду декілька разів послідовно і відкиньте результати перших
декількох запусків, щоб виміряти типовий випадок із «гарячим кешем».
.PP
\&\fIПримітка для розробників:\fR якщо ви збираєте libguestfs з початкових кодів,
у них можна знайти програму із назвою
\&\fIutils/boot\-benchmark/boot\-benchmark\fR, яка виконує те саме, але виконує
декілька запусків і виводить математичне сподівання та стандартне
відхилення. Щоб запустити цю програму, віддайте таку команду:
.PP
.Vb 2
\& make
\& ./run utils/boot\-benchmark/boot\-benchmark
.Ve
.PP
Передбачено окрему сторінку підручника для
\&\fIutils/boot\-benchmark/boot\-benchmark.1\fR
.PP
\fIПояснення\fR
.IX Subsection "Пояснення"
.PP
Наведена вище команда guestfish запускає базову систему libguestfs для
порожнього диска, а потім одразу вимикає її. Під час першого виконання
команди програма створить базову систему і виконає її кешування (зазвичай, у
\&\fI/var/tmp/.guestfs\-*\fR). Під час наступних запусків програма просто повторно
використовуватиме кешовану базову систему.
.PP
\fIОчікувані результати\fR
.IX Subsection "Очікувані результати"
.PP
Слід очікувати значень тривалості виконання дії, менших за 6 секунд. Якщо
для ненавантаженої машини ви спостерігаєте значення тривалості, яке є вищим
за вказане, вам слід ознайомитися із вмістом розділу \*(L"БОРОТЬБА ІЗ
ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ\*(R", наведеного нижче.
.SS "База: виконання інспектування гостьової системи"
.IX Subsection "База: виконання інспектування гостьової системи"
Для цього тесту вам потрібна буде ненавантажена машина і принаймні одна
справжня гостьова система або образ диска. Якщо ви плануєте використовувати
libguestfs лише для гостьових систем X (наприклад, X = Windows), тоді у
цьому тесті варто використати саме гостьову систему X. Якщо ж ви плануєте
використовувати libguestfs для різних гостьових систем, скористайтеся у
цьому тесті різними гостьовими системами.
.PP
Визначте тривалість інспектування і монтування дисків гостьової
системи. Скористайтеся першою з команд, якщо ви використовуватимете образи
дисків, і другою із команд, якщо ви використовуватимете libvirt.
.PP
.Vb 1
\& time guestfish \-\-ro \-a диск.img \-i exit
\&
\& time guestfish \-\-ro \-d НазваГостьовоїСистеми \-i exit
.Ve
.PP
Віддайте цю команду декілька разів послідовно і відкиньте результати перших
декількох запусків, щоб виміряти типовий випадок із «гарячим кешем».
.PP
\fIПояснення\fR
.IX Subsection "Пояснення"
.PP
Ця команда запускає базову систему libguestfs для іменованого образу диска
або гостьової системи libvirt, виконує її інспектування за допомогою
libguestfs (див. \*(L"ІНСПЕКТУВАННЯ\*(R" in \fBguestfs\fR\|(3)), монтує диски гостьової
системи, а потім відкидає усі ці результати і завершує роботу.
.PP
Під час першого виконання команди програма створить базову систему і виконає
її кешування (зазвичай, у \fI/var/tmp/.guestfs\-*\fR). Під час наступних
запусків програма просто повторно використовуватиме кешовану базову систему.
.PP
\fIОчікувані результати\fR
.IX Subsection "Очікувані результати"
.PP
Слід очікувати на тривалість виконання, яка на ≤ 5 секунд перевищує
виміряну у першому базовому тесті вище. (Наприклад, якщо перший базовий тест
було виконано за 5 секунд, цей тест має виконуватися за ≤ 10 секунд.)
.SH "ДОКЛАДНІШЕ ПРО БАЗОВУ СИСТЕМУ ТА ПРО ТЕ, КОЛИ ЇЇ ЗБИРАЮТЬ ТА КОЛИ ВОНА ПОТРАПЛЯЄ ДО КЕШУ"
.IX Header "ДОКЛАДНІШЕ ПРО БАЗОВУ СИСТЕМУ ТА ПРО ТЕ, КОЛИ ЇЇ ЗБИРАЮТЬ ТА КОЛИ ВОНА ПОТРАПЛЯЄ ДО КЕШУ"
Під час першої спроби скористатися libguestfs бібліотека збирає і надсилає
до кешу базову систему. Зазвичай, така базова система має адресу
\&\fI/var/tmp/.guestfs\-*\fR, якщо вами не було встановлено значень для змінних
середовища \f(CW$TMPDIR\fR або \f(CW$LIBGUESTFS_CACHEDIR\fR. Якщо було встановлено
такі значення, базова система зберігатиметься у відповідному тимчасовому
каталозі.
.PP
Щоб дізнатися більше про побудову базової системи, див. \*(L"БАЗОВІ
СИСТЕМИ \s-1SUPERMIN\*(R"\s0 in \fBsupermin\fR\|(1).
.PP
Під час кожного запуску libguestfs намагається визначити, чи не було змінено
якість файли основної системи, які використовуються базовою системою. Якщо
було змінено хоч один такий файл, базову систему буде перезібрано. Таке,
зазвичай, трапляється, якщо у основній системі встановлюється або
оновлюється якийсь пакунок (наприклад, за допомогою програм, подібних до
\&\f(CW\*(C`yum\*(C'\fR або \f(CW\*(C`apt\-get\*(C'\fR). Причиною повторного збирання базової системи є
забезпечення захисту: нова програма, яку було встановлено, може містити
виправлення захисту, тому нам варто включити виправлену програму до базової
системи автоматично.
.PP
Ось речі, які пов'язано із швидкодією:
.IP "\(bu" 4
Процес побудови (або повторної побудови) кешованої базової системи є
повільним. Ви можете уникнути його, якщо скористаєтеся фіксованою базовою
системою (див. нижче).
.IP "\(bu" 4
Якщо ви не користуєтеся фіксованою базовою системою, майте на увазі, що
оновлення програмного забезпечення основної системи призведе до одноразового
повторного збирання базової системи.
.IP "\(bu" 4
\&\fI/var/tmp\fR (або \f(CW$TMPDIR\fR, \f(CW$LIBGUESTFS_CACHEDIR\fR) має зберігатися на
швидкому диску і мати достатньо місця для базової системи.
.SH "ВИКОРИСТАННЯ ФІКСОВАНОЇ БАЗОВОЇ СИСТЕМИ"
.IX Header "ВИКОРИСТАННЯ ФІКСОВАНОЇ БАЗОВОЇ СИСТЕМИ"
Щоб мати повний контроль над тим, коли збирається базова система, ви можете
зібрати фіксовану базову систему. Ця базова система має зберігатися на
швидкому локальному диску.
.PP
Щоб зібрати образ системи для розгортання, віддайте таку команду:
.PP
.Vb 1
\& libguestfs\-make\-fixed\-appliance <каталог>
.Ve
.PP
замінивши рядок \f(CW\*(C`<каталог>\*(C'\fR на назву каталогу, у якому
зберігатиметься базова система (зазвичай, вам слід вказати підкаталог,
наприклад: \fI/usr/local/lib/guestfs/appliance\fR або \fI/dev/shm/appliance\fR).
.PP
Далі, встановіть значення для \f(CW$LIBGUESTFS_PATH\fR (і переконайтеся, що цю
змінну середовища встановлено у вашій програмі libguestfs) або внесіть зміни
до вашої програми так, щоб вона викликала \f(CW\*(C`guestfs_set_path\*(C'\fR. Приклад:
.PP
.Vb 1
\& export LIBGUESTFS_PATH=/usr/local/lib/guestfs/appliance
.Ve
.PP
Тепер ви можете запускати програми libguestfs, засоби віртуалізації,
guestfish тощо у звичний спосіб. Програми використовуватимуть вашу фіксовану
базову систему і ніколи не збиратимуть, не перезбиратимуть і не кешуватимуть
власну базову систему.
.PP
(Докладніші відомості з цієї теми можна знайти тут:
\&\fBlibguestfs\-make\-fixed\-appliance\fR\|(1)).
.SS "Швидкодія фіксованої базової системи"
.IX Subsection "Швидкодія фіксованої базової системи"
Наші тестування показали, що використання фіксованої базової системи не дає
ніяких помітних переваг у швидкодії, навіть якщо розташувати базову систему
у оперативній пам'яті (тобто на пристрої \fI/dev/shm\fR). Втім, слід зважити
ось на що:
.IP "1." 4
Використання фіксованої базової системи запобігатиме спробам libguestfs
повторно зібрати базову систему, що означатиме, що тривалість запуску
libguestfs буде легше передбачити.
.IP "2." 4
Базова система завантажується на вимогу. Простий тест, наприклад такий:
.Sp
.Vb 1
\& time guestfish \-a /dev/null run
.Ve
.Sp
не дуже навантажує базову систему. Справжня програма libguestfs, де
використовуватимуться складні виклики програмного інтерфейсу,
навантажуватиме базову систему набагато більше. Можливість зберігати базову
систему у вказаному місці робить швидкодію значно передбачуванішою.
.SH "ЗМЕНШЕННЯ КІЛЬКОСТІ ЗАПУСКІВ БАЗОВОЇ СИСТЕМИ"
.IX Header "ЗМЕНШЕННЯ КІЛЬКОСТІ ЗАПУСКІВ БАЗОВОЇ СИСТЕМИ"
Набагато ефективнішим, але не завжди найпростішим способом дістати добру
швидкодію є забезпечення якомога меншої кількості запусків базової
системи. Це, ймовірно, включає внесення змін до самої вашої програми
libguestfs.
.PP
Намагайтеся викликати \f(CW\*(C`guestfs_launch\*(C'\fR не більше одного разу на одну
віртуальну машину або образ диска.
.PP
Замість використання окремого екземпляра \fBguestfish\fR\|(1) для внесення змін
до тієї самої гостьової системи, скористайтеся єдиним екземпляром guestfish
і/або використовуйте параметр guestfish \fI\-\-listen\fR.
.PP
Спробуйте написати вашу програму у формі фонової служби, яка підтримує
зв'язок із гостьовою системою відкритим протягом усього сеансу внесення
послідовності змін. Крім того, можете скерувати усі дії, які ви хочете
виконати, до відкриття зв'язку із гостьовою системою.
.PP
Ви також можете спробувати додавати диски з декількох гостьових систем до
єдиної базової системи. Перш ніж намагатися це зробити, врахуйте ось що:
.IP "1." 4
Додавання декількох гостьових системи до однієї базової системи створює
проблему із захистом, оскільки може уможливити для однієї гостьової системи
втручання до дисків іншої гостьової системи. Робіть це, лише якщо ви
довіряєте усім гостьовим системам або якщо ви можете згрупувати гостьові
системи за рівнем довіри.
.IP "2." 4
Існує жорстке обмеження для кількості дисків, які ви можете додати до однієї
базової системи. Щоб отримати максимальне можливе значення, скористайтеся
викликом \*(L"guestfs_max_disks\*(R" in \fBguestfs\fR\|(3). Докладнішу інформацію можна знайти
у розділі \*(L"ОБМЕЖЕННЯ\*(R" in \fBguestfs\fR\|(3).
.IP "3." 4
Використання libguestfs у цей спосіб є ускладненим. Диски можуть взаємодіяти
у несподіваний спосіб: наприклад, якщо у двох гостьових системах
використовуються однакові \s-1UUID\s0 для файлової системи (оскільки ці системи
було клоновано) або існують групи томів із однаковими назвами (але
див. \f(CW\*(C`guestfs_lvm_set_filter\*(C'\fR).
.PP
\&\fBvirt\-df\fR\|(1), типово, додає одразу декілька дисків, тому код цієї програми
є чудовим прикладом для ваших власних розробок.
.SH "СКОРОЧЕННЯ ЧАСУ, ПОТРІБНОГО ДЛЯ ІНСПЕКТУВАННЯ ВІРТУАЛЬНИХ МАШИН"
.IX Header "СКОРОЧЕННЯ ЧАСУ, ПОТРІБНОГО ДЛЯ ІНСПЕКТУВАННЯ ВІРТУАЛЬНИХ МАШИН"
Основна порада очевидна: не виконуйте інспектування (це дуже витратна
операція), якщо вам не потрібні його результати.
.PP
Якщо гостьова система інспектується декілька разів, варто створити кеш
результатів першого інспектування і повторно скористатися ними для наступних
дій.
.PP
Деякі диски взагалі не потребують інспектування. Наприклад, якщо ви
створюєте образ диска, або якщо образ диска не є віртуальною машиною, або
якщо образ диска має заздалегідь відоме компонування.
.PP
Навіть якщо базове інспектування (\f(CW\*(C`guestfs_inspect_os\*(C'\fR) є обов'язковим,
можна обійтися без допоміжних операцій з інспектування:
.IP "\(bu" 4
Монтування дисків є необхідним, лише якщо потрібно отримати докладніші дані
щодо файлової системи.
.IP "\(bu" 4
Отримання списку програм (\f(CW\*(C`guestfs_inspect_list_applications\*(C'\fR) є витратною
операцією для Linux, яка, втім, виконується дуже швидко для Windows.
.IP "\(bu" 4
Створення піктограми гостьової системи (\f(CW\*(C`guestfs_inspect_get_icon\*(C'\fR)
виконується дуже швидко для Linux, але є витратною операцією для Windows.
.SH "ПАРАЛЕЛЬНІ БАЗОВІ СИСТЕМИ"
.IX Header "ПАРАЛЕЛЬНІ БАЗОВІ СИСТЕМИ"
Базові системи libguestfs є здебільшого зв'язками введення\-виведення даних,
отже ви можете паралельно запускати одразу декілька базових систем.  Якщо у
основній системі достатньо багато вільної оперативної пам'яті, між запуском
1 базової системи і паралельним запуском багатьох базових систем відмінність
є незначною.
.PP
На 2\-ядерному (4 потоки обробки) ноутбуці із 16 ГБ оперативної пам'яті,
використання (не дуже реалістичного) тестового скрипту мовою Perl,
наведеного нижче, дало вказані нижче результати, які свідчать про чудову
масштабованість у запуску 1 базової системи і паралельному запуску 20
базових систем:
.PP
.Vb 10
\&  12 ++\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-++
\&     +    +    +    +    +     +    +    +    +    +    *
\&     |                                                  |
\&     |                                               *  |
\&  11 ++                                                ++
\&     |                                                  |
\&     |                                                  |
\&     |                                          *  *    |
\&  10 ++                                                ++
\&     |                                        *         |
\&     |                                                  |
\& s   |                                                  |
\&   9 ++                                                ++
\& e   |                                                  |
\&     |                                     *            |
\& c   |                                                  |
\&   8 ++                                  *             ++
\& o   |                                *                 |
\&     |                                                  |
\& n 7 ++                                                ++
\&     |                              *                   |
\& d   |                           *                      |
\&     |                                                  |
\& s 6 ++                                                ++
\&     |                      *  *                        |
\&     |                   *                              |
\&     |                                                  |
\&   5 ++                                                ++
\&     |                                                  |
\&     |                 *                                |
\&     |            * *                                   |
\&   4 ++                                                ++
\&     |                                                  |
\&     |                                                  |
\&     +    *  * *    +    +     +    +    +    +    +    +
\&   3 ++\-*\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-\-+\-\-\-++
\&     0    2    4    6    8     10   12   14   16   18   20
\&               кількість паралельних базових систем
.Ve
.PP
Можна запустити і набагато більше за 20 базових систем паралельно, але вам
слід мати на увазі, що якщо ви використовуєте модуль обробки libvirt,
типово, libvirt обмежує кількість з'єднань із клієнтами двадцятьма.
.PP
Для отримання даних, наведених на рисунку вище, було використано простий
скрипт мовою Perl, наведений нижче. Втім, набагато більше відомостей з цього
питання, зокрема досконаліші скрипти для тестування та графіки, можна знайти
у наступних дописах у блогах:
.PP
http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-1/
http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-2/
http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-3/
http://rwmj.wordpress.com/2013/02/25/multiple\-libguestfs\-appliances\-in\-parallel\-part\-4/
.PP
.Vb 1
\& #!/usr/bin/env perl
\& 
\& use strict;
\& use threads;
\& use warnings;
\& use Sys::Guestfs;
\& use Time::HiRes qw(time);
\& 
\& sub test {
\&     my $g = Sys::Guestfs\->new;
\&     $g\->add_drive_ro ("/dev/null");
\&     $g\->launch ();
\&     
\&     # Тут можна виконати якісь завдання за допомогою libguestfs.
\&     
\&     $g\->close ();
\& }
\& 
\& # Отримати усе до кешу.
\& test (); test (); test ();
\& 
\& for my $nr_threads (1..20) {
\&     my $start_t = time ();
\&     my @threads;
\&     foreach (1..$nr_threads) {
\&         push @threads, threads\->create (\e&test)
\&     }
\&     foreach (@threads) {
\&         $_\->join ();
\&         if (my $err = $_\->error ()) {
\&             die "launch failed with $nr_threads threads: $err"
\&         }
\&     }
\&     my $end_t = time ();
\&     printf ("%d %.2f\en", $nr_threads, $end_t \- $start_t);
\& }
.Ve
.SH "ВИКОРИСТАННЯ USER-MODE LINUX"
.IX Header "ВИКОРИСТАННЯ USER-MODE LINUX"
Починаючи з libguestfs 1.24, стало можливим використання модуля обробки
User-Mode Linux (uml) замість \s-1KVM\s0 (див. \*(L"МОДУЛЬ USER-MODE
\&\s-1LINUX\*(R"\s0 in \fBguestfs\fR\|(3)). У цьому розділі наведено деякі загальні зауваження щодо цього
модуля, але ми \fBнаполегливо рекомендуємо\fR вам виміряти навантаження з \s-1UML\s0 у
вашій системі, а не сліпо довірятися коментарям або інтуїції.
.IP "\(bu" 4
\&\s-1UML,\s0 зазвичай, працює із тією самою швидкістю, що і \s-1KVM,\s0 або трохи
повільніше на типовій системі.
.IP "\(bu" 4
Втім, \s-1UML\s0 часто працює так само швидко в умовах віртуалізації, як і у
звичайному апаратному середовищі, тоді як \s-1KVM\s0 може працювати набагато
повільніше в умовах віртуалізації (оскільки там недоступне апаратне
прискорення віртуалізації).
.IP "\(bu" 4
Вивантаження і отримання даних у \s-1UML\s0 удесятеро повільніше за такі самі
операції у \s-1KVM.\s0 Libguestfs надсилає дані крізь емульований послідовний порт
\&\s-1UML,\s0 який є набагато менш ефективним за virtio-serial у \s-1KVM.\s0
.IP "\(bu" 4
В \s-1UML\s0 недоступні деякі можливості (наприклад, підтримка qcow2), тому іноді
цей варіант взагалі не є придатним.
.PP
Самі графіки можна знайти тут:
http://rwmj.wordpress.com/2013/08/14/performance\-of\-user\-mode\-linux\-as\-a\-libguestfs\-backend/#content
.SH "БОРОТЬБА ІЗ ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ"
.IX Header "БОРОТЬБА ІЗ ПРОБЛЕМАМИ ЗІ ШВИДКОДІЄЮ"
.SS "Переконайтеся, що увімкнено апаратну віртуалізацію"
.IX Subsection "Переконайтеся, що увімкнено апаратну віртуалізацію"
Use \fI/proc/cpuinfo\fR to ensure that hardware virtualization is available.
Note that you may need to enable it in your \s-1BIOS.\s0
.PP
Усередині віртуальних машин апаратна віртуалізація зазвичай недоступна,
тому, щоб ви не робили, у віртуальній машині libguestfs працюватиме
повільно. Наш досвід свідчить про те, що вкладена віртуалізація працює
погано, і, напевне, альтернативи запуску libguestfs у основній системі
немає.
.SS "Переконайтеся, що \s-1KVM\s0 є доступним"
.IX Subsection "Переконайтеся, що KVM є доступним"
Переконайтеся, що \s-1KVM\s0 увімкнено і доступний користувачеві, який запускає
libguestfs. Безпечним є встановлення прав доступу 0666 для \fI/dev/kvm\fR, як
це робиться у більшості сучасних дистрибутивів.
.SS "Процесори, яких слід уникати"
.IX Subsection "Процесори, яких слід уникати"
Не використовуйте процесори, у яких немає апаратної віртуалізації, та
процесорів, які просто дуже повільні (чудовим прикладом такого процесора є
\&\s-1AMD\s0 Geode).
.SS "Xen dom0"
.IX Subsection "Xen dom0"
У Xen dom0 є віртуальною машиною, отже на ньому апаратна віртуалізація
недоступна.
.SS "Скористайтеся libguestfs ≥ 1.34 і qemu ≥ 2.7"
.IX Subsection "Скористайтеся libguestfs ≥ 1.34 і qemu ≥ 2.7"
Під час циклу розробки libguestfs 1.33 ми приділяли багато часу швидкодії,
зосередившись на швидкості завантаження, і додали декілька латок до
libguestfs, qemu та Linux, що у певних випадках зменшило час завантаження до
значень, менших за 1 секунду. Тому, ви можете спостерігати набагато швидшу
роботу версій libguestfs та qemu, згаданих у заголовку розділу.
.SH "ДОКЛАДНИЙ АНАЛІЗ"
.IX Header "ДОКЛАДНИЙ АНАЛІЗ"
.SS "Аналіз завантаження"
.IX Subsection "Аналіз завантаження"
У каталозі з початковим кодом libguestfs за адресою \fIutils/boot\-analysis\fR
можна знайти програму, яка називається \f(CW\*(C`boot\-analysis\*(C'\fR. Ця програма може
виводити дуже докладні дані щодо кроків завантаження (наприклад, qemu, \s-1BIOS,\s0
ядра, скрипту ініціалізації libguestfs) і вимірювати тривалість виконання
кожного з кроків.
.PP
Щоб запустити цю програму, віддайте таку команду:
.PP
.Vb 2
\& make
\& ./run utils/boot\-analysis/boot\-analysis
.Ve
.PP
Передбачено окрему сторінку підручника для
\&\fIutils/boot\-benchmark/boot\-analysis.1\fR
.SS "Докладний таймінг з використанням ts"
.IX Subsection "Докладний таймінг з використанням ts"
Скористайтеся програмою \fBts\fR\|(1) (з moreutils), щоб переглянути докладну
картину:
.PP
.Vb 10
\& $ guestfish \-a /dev/null run \-v |& ts \-i \*(Aq%.s\*(Aq
\& 0.000022 libguestfs: launch: program=guestfish
\& 0.000134 libguestfs: launch: version=1.29.31fedora=23,release=2.fc23,libvirt
\& 0.000044 libguestfs: launch: backend registered: unix
\& 0.000035 libguestfs: launch: backend registered: uml
\& 0.000035 libguestfs: launch: backend registered: libvirt
\& 0.000032 libguestfs: launch: backend registered: direct
\& 0.000030 libguestfs: launch: backend=libvirt
\& 0.000031 libguestfs: launch: tmpdir=/tmp/libguestfsw18rBQ
\& 0.000029 libguestfs: launch: umask=0002
\& 0.000031 libguestfs: launch: euid=1000
\& 0.000030 libguestfs: libvirt version = 1002012 (1.2.12)
\& [etc]
.Ve
.PP
Часові позначки вказано у секундах (з нарощуванням щодо попереднього рядка).
.SS "Докладний таймінг з використанням SystemTap"
.IX Subsection "Докладний таймінг з використанням SystemTap"
Для отримання докладної інформації щодо часових параметрів обробки у
програмах libguestfs можете скористатися SystemTap (\fBstap\fR\|(1)).
.PP
Збережіть такий скрипт із назвою \fItime.stap\fR:
.PP
.Vb 1
\& global last;
\& 
\& function display_time () {
\&       now = gettimeofday_us ();
\&       delta = 0;
\&       if (last > 0)
\&             delta = now \- last;
\&       last = now;
\& 
\&       printf ("%d (+%d):", now, delta);
\& }
\& 
\& probe begin {
\&       last = 0;
\&       printf ("ready\en");
\& }
\& 
\& /* Показати усі виклики статичних маркерів. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .provider("guestfs").mark("*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", $$name, $$parms);
\& }
\& 
\& /* Показати усі виклики функцій guestfs_*. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .function("guestfs_[a\-z]*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", probefunc(), $$parms);
\& }
.Ve
.PP
Запустіть його у одному вікні від імені користувача root:
.PP
.Vb 2
\& # stap time.stap
\& ready
.Ve
.PP
Скрипт виведе рядок «ready», коли SystemTap завантажить програму. Запустіть
вашу програму libguestfs, guestfish або програму засобів віртуалізації у
іншому вікні. Приклад:
.PP
.Vb 1
\& $ guestfish \-a /dev/null run
.Ve
.PP
У вікні stap ви побачити багато даних, зокрема, буде показано дані щодо
часу, потрібного на виконання кожного з кроків (у форматі кількості
мілісекунд у дужках). Приклад:
.PP
.Vb 9
\& xxxx (+0):     guestfs_create 
\& xxxx (+29):    guestfs_set_pgroup g=0x17a9de0 pgroup=0x1
\& xxxx (+9):     guestfs_add_drive_opts_argv g=0x17a9de0 [...]
\& xxxx (+8):     guestfs_int_safe_strdup g=0x17a9de0 str=0x7f8a153bed5d
\& xxxx (+19):    guestfs_int_safe_malloc g=0x17a9de0 nbytes=0x38
\& xxxx (+5):     guestfs_int_safe_strdup g=0x17a9de0 str=0x17a9f60
\& xxxx (+10):    guestfs_launch g=0x17a9de0
\& xxxx (+4):     launch_start 
\& [etc]
.Ve
.PP
Вам слід звернутися до початкового коду libguestfs або навіть трохи змінити
його, щоб повністю розібратися у виведених даних.
.SS "Докладна діагностика з використанням gdb"
.IX Subsection "Докладна діагностика з використанням gdb"
Ви можете керувати \s-1BIOS\s0 або ядром базової системи за допомогою gdb. Якщо ви
добре знаєтеся на процесі діагностики за допомогою gdb, це може бути
корисним інструментом для виявлення і усування регресій у процесі
завантаження.
.PP
По\-перше, вам слід змінити qemu так, щоб програма запускалася із параметрами
\&\f(CW\*(C`\-S\*(C'\fR і \f(CW\*(C`\-s\*(C'\fR. Ці параметри наказують qemu призупинити процес завантаження і
уможливити долучення до нього засобу діагностики. Щоб дізнатися більше,
ознайомтеся із підручником щодо \fBqemu\fR\|(1). Libguestfs викликає qemu
декілька разів (для сканування допоміжних виведених даних тощо). Вам
потрібен лише кінцевий виклик qemu, тому скористайтеся скриптом\-обгорткою,
подібним до такого:
.PP
.Vb 1
\& #!/bin/bash \-
\& 
\& # Встановіть значення, яке вказуватиме на справжній виконуваний файл qemu.
\& qemu=/usr/bin/qemu\-kvm
\& 
\& if [ "$1" != "\-global" ]; then
\&     # Scanning help output etc.
\&     exec $qemu "$@"
\& else 
\&     # Really running qemu.
\&     exec $qemu \-S \-s "$@"
\& fi
.Ve
.PP
Далі, запустіть guestfish або інший інструмент libguestfs із обгорткою qemu
(див. \*(L"ОБГОРТКИ \s-1QEMU\*(R"\s0 in \fBguestfs\fR\|(3), щоб зрозуміти, які дії виконуються):
.PP
.Vb 1
\& LIBGUESTFS_HV=/шлях/до/qemu\-wrapper guestfish \-a /dev/null \-v run
.Ve
.PP
Виконання має призупинитися після запуску qemu. У іншому вікні з'єднайтеся
із qemu за допомогою gdb:
.PP
.Vb 7
\& $ gdb
\& (gdb) set architecture i8086
\& The target architecture is assumed to be i8086
\& (gdb) target remote :1234
\& Remote debugging using :1234
\& 0x0000fff0 in ?? ()
\& (gdb) cont
.Ve
.PP
Після цього ви можете використовувати стандартні методики gdb, наприклад,
натискати \f(CW\*(C`^C\*(C'\fR, щоб перервати завантаження, або \f(CW\*(C`bt\*(C'\fR, щоб отримати
трасування стека, встановлювати точки зупину тощо. Зауважте, що після
проходження \s-1BIOS\s0 і потрапляння до ядра Linux вам варто знову змінити
архітектуру на 32 або 64\-бітову.
.SH "ПРОБЛЕМИ ЗІ ШВИДКОДІЄЮ У ІНШИХ ПРОГРАМАХ"
.IX Header "ПРОБЛЕМИ ЗІ ШВИДКОДІЄЮ У ІНШИХ ПРОГРАМАХ"
Іноді регресії у швидкодії трапляються у інших програмах (наприклад, у qemu
або ядрі системи), що спричиняє проблеми і у libguestfs.
.PP
У початковому коді libguestfs є файл
\&\fIutils/boot\-benchmark/boot\-benchmark\-range.pl\fR. Це скрипт, яким можна
скористатися для вимірювання параметрів роботи libguestfs на діапазоні
внесків git у іншому проекті, щоб визначити внесок, який спричинив
уповільнення роботи (або її пришвидшення).
.PP
Щоб дізнатися більше про те, як користуватися цим скриптом, зверніться до
підручника:
.PP
.Vb 1
\& ./utils/boot\-benchmark/boot\-benchmark\-range.pl \-\-man
.Ve
.SH "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
.IX Header "ТАКОЖ ПЕРЕГЛЯНЬТЕ"
\&\fBsupermin\fR\|(1), \fBguestfish\fR\|(1), \fBguestfs\fR\|(3), \fBguestfs\-examples\fR\|(3),
\&\fBguestfs\-internals\fR\|(1), \fBlibguestfs\-make\-fixed\-appliance\fR\|(1), \fBstap\fR\|(1),
\&\fBqemu\fR\|(1), \fBgdb\fR\|(1), http://libguestfs.org/.
.SH "АВТОРИ"
.IX Header "АВТОРИ"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "АВТОРСЬКІ ПРАВА"
.IX Header "АВТОРСЬКІ ПРАВА"
Copyright (C) 2012\-2019 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fBlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
