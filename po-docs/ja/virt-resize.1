.\" Automatically generated by Podwrapper::Man 1.36.5 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "virt-resize 1"
.TH virt-resize 1 "2017-06-22" "libguestfs-1.36.5" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "名前"
.IX Header "名前"
virt-resize \- 仮想マシンのディスクの容量変更
.SH "書式"
.IX Header "書式"
.Vb 3
\& virt\-resize [\-\-resize /dev/sdaN=[+/\-]<size>[%]]
\&   [\-\-expand /dev/sdaN] [\-\-shrink /dev/sdaN]
\&   [\-\-ignore /dev/sdaN] [\-\-delete /dev/sdaN] [...] indisk outdisk
.Ve
.SH "説明"
.IX Header "説明"
Virt-resize is a tool which can resize a virtual machine disk, making it
larger or smaller overall, and resizing or deleting any partitions contained
within.
.PP
Virt-resize \fBcannot\fR resize disk images in-place.  Virt-resize \fBshould
not\fR be used on live virtual machines \- for consistent results, shut the
virtual machine down before resizing it.
.PP
If you are not familiar with the associated tools: \fIvirt\-filesystems\fR\|(1)
and \fIvirt\-df\fR\|(1), we recommend you go and read those manual pages first.
.SH "例"
.IX Header "例"
.IP "1." 4
Copy \f(CW\*(C`olddisk\*(C'\fR to \f(CW\*(C`newdisk\*(C'\fR, extending one of the guest's partitions to
fill the extra 5GB of space.
.Sp
.Vb 1
\& virt\-filesystems \-\-long \-h \-\-all \-a olddisk
\& 
\& truncate \-r olddisk newdisk
\& truncate \-s +5G newdisk
\& 
\& # "/dev/sda2" は "olddisk" ファイルの中にあるパーティションであることに注意してください。
\& virt\-resize \-\-expand /dev/sda2 olddisk newdisk
.Ve
.IP "2." 4
As above, but make the /boot partition 200MB bigger, while giving the
remaining space to /dev/sda2:
.Sp
.Vb 2
\& virt\-resize \-\-resize /dev/sda1=+200M \-\-expand /dev/sda2 \e
\&   olddisk newdisk
.Ve
.IP "3." 4
As in the first example, but expand a logical volume as the final step.
This is what you would typically use for Linux guests that use \s-1LVM:\s0
.Sp
.Vb 2
\& virt\-resize \-\-expand /dev/sda2 \-\-LV\-expand /dev/vg_guest/lv_root \e
\&   olddisk newdisk
.Ve
.IP "4." 4
As in the first example, but the output format will be qcow2 instead of a
raw disk:
.Sp
.Vb 2
\& qemu\-img create \-f qcow2 \-o preallocation=metadata newdisk.qcow2 15G
\& virt\-resize \-\-expand /dev/sda2 olddisk newdisk.qcow2
.Ve
.SH "詳細な使用法"
.IX Header "詳細な使用法"
.SS "仮想マシンのディスクの拡張方法"
.IX Subsection "仮想マシンのディスクの拡張方法"
.IP "1. 仮想マシンをシャットダウンします" 4
.IX Item "1. 仮想マシンをシャットダウンします"
.PD 0
.IP "2. 入力ディスクイメージの位置を探します" 4
.IX Item "2. 入力ディスクイメージの位置を探します"
.PD
Locate the input disk image (ie. the file or device on the host containing
the guest's disk).  If the guest is managed by libvirt, you can use \f(CW\*(C`virsh
dumpxml\*(C'\fR like this to find the disk image name:
.Sp
.Vb 4
\& # virsh dumpxml guestname | xpath /domain/devices/disk/source
\& Found 1 nodes:
\& \-\- NODE \-\-
\& <source dev="/dev/vg/lv_guest" />
.Ve
.IP "3. 現在の容量を確認します" 4
.IX Item "3. 現在の容量を確認します"
現在のパーティションおよび容量を表示するには \fIvirt\-filesystems\fR\|(1) を使用します:
.Sp
.Vb 5
\& # virt\-filesystems \-\-long \-\-parts \-\-blkdevs \-h \-a /dev/vg/lv_guest
\& Name       Type       Size  Parent
\& /dev/sda1  partition  101M  /dev/sda
\& /dev/sda2  partition  7.9G  /dev/sda
\& /dev/sda   device     8.0G  \-
.Ve
.Sp
(This example is a virtual machine with an 8 \s-1GB\s0 disk which we would like to
expand up to 10 \s-1GB\s0).
.IP "4. 出力ディスクを作成します" 4
.IX Item "4. 出力ディスクを作成します"
Virt-resize cannot do in-place disk modifications.  You have to have space
to store the resized output disk.
.Sp
To store the resized disk image in a file, create a file of a suitable size:
.Sp
.Vb 2
\& # rm \-f outdisk
\& # truncate \-s 10G outdisk
.Ve
.Sp
または、論理ボリュームを作成するために \fIlvcreate\fR\|(1) を使用します:
.Sp
.Vb 1
\& # lvcreate \-L 10G \-n lv_name vg_name
.Ve
.Sp
Or use \fIvirsh\fR\|(1) vol-create-as to create a libvirt storage volume:
.Sp
.Vb 2
\& # virsh pool\-list
\& # virsh vol\-create\-as poolname newvol 10G
.Ve
.IP "5. 容量を変更します" 4
.IX Item "5. 容量を変更します"
virt-resize takes two mandatory parameters, the input disk and the output
disk (both can be e.g. a device, a file, or a \s-1URI\s0 to a remote disk).  The
output disk is the one created in the previous step.
.Sp
.Vb 1
\& # virt\-resize indisk outdisk
.Ve
.Sp
This command just copies disk image \f(CW\*(C`indisk\*(C'\fR to disk image \f(CW\*(C`outdisk\*(C'\fR
\&\fIwithout\fR resizing or changing any existing partitions.  If \f(CW\*(C`outdisk\*(C'\fR is
larger, then an extra, empty partition is created at the end of the disk
covering the extra space.  If \f(CW\*(C`outdisk\*(C'\fR is smaller, then it will give an
error.
.Sp
More realistically you'd want to expand existing partitions in the disk
image by passing extra options (for the full list see the \*(L"\s-1OPTIONS\*(R"\s0
section below).
.Sp
\&\*(L"\-\-expand\*(R" is the most useful option.  It expands the named partition
within the disk to fill any extra space:
.Sp
.Vb 1
\& # virt\-resize \-\-expand /dev/sda2 indisk outdisk
.Ve
.Sp
(In this case, an extra partition is \fInot\fR created at the end of the disk,
because there will be no unused space).
.Sp
\&\*(L"\-\-resize\*(R" is the other commonly used option.  The following would
increase the size of /dev/sda1 by 200M, and expand /dev/sda2 to fill the
rest of the available space:
.Sp
.Vb 2
\& # virt\-resize \-\-resize /dev/sda1=+200M \-\-expand /dev/sda2 \e
\&     indisk outdisk
.Ve
.Sp
If the expanded partition in the image contains a filesystem or \s-1LVM PV,\s0 then
if virt-resize knows how, it will resize the contents, the equivalent of
calling a command such as \fIpvresize\fR\|(8), \fIresize2fs\fR\|(8), \fIntfsresize\fR\|(8),
\&\fIbtrfs\fR\|(8) or \fIxfs_growfs\fR\|(8).  However virt-resize does not know how to
resize some filesystems, so you would have to online resize them after
booting the guest.
.Sp
.Vb 1
\& # virt\-resize \-\-expand /dev/sda2 nbd://example.com outdisk
.Ve
.Sp
The input disk can be a \s-1URI,\s0 in order to use a remote disk as the source.
The \s-1URI\s0 format is compatible with guestfish.  See \*(L"\s-1ADDING
REMOTE STORAGE\*(R"\s0 in \fIguestfish\fR\|(1).
.Sp
他のオプションは以下に記載しています。
.IP "6. テストします" 4
.IX Item "6. テストします"
Thoroughly test the new disk image \fIbefore\fR discarding the old one.
.Sp
libvirt を使用しているならば、新しいディスクを指し示すよう \s-1XML\s0 を編集します:
.Sp
.Vb 1
\& # virsh edit guestname
.Ve
.Sp
<source ...>
を変更します、http://libvirt.org/formatdomain.html#elementsDisks を参照してください。
.Sp
Then start up the domain with the new, resized disk:
.Sp
.Vb 1
\& # virsh start guestname
.Ve
.Sp
and check that it still works.  See also the \*(L"\s-1NOTES\*(R"\s0 section below for
additional information.
.IP "7. Resize LVs etc inside the guest" 4
.IX Item "7. Resize LVs etc inside the guest"
(This can also be done offline using \fIguestfish\fR\|(1))
.Sp
Once the guest has booted you should see the new space available, at least
for filesystems that virt-resize knows how to resize, and for PVs.  The user
may need to resize LVs inside PVs, and also resize filesystem types that
virt-resize does not know how to expand.
.SS "仮想マシンのディスクの縮小"
.IX Subsection "仮想マシンのディスクの縮小"
縮小は拡張よりもいくらか複雑です。ここでは概要のみを示します。
.PP
Firstly virt-resize will not attempt to shrink any partition content (PVs,
filesystems).  The user has to shrink content before passing the disk image
to virt-resize, and virt-resize will check that the content has been shrunk
properly.
.PP
(Shrinking can also be done offline using \fIguestfish\fR\|(1))
.PP
After shrinking PVs and filesystems, shut down the guest, and proceed with
steps 3 and 4 above to allocate a new disk image.
.PP
Then run virt-resize with any of the \fI\-\-shrink\fR and/or \fI\-\-resize\fR options.
.SS "\s-1IGNORING OR DELETING PARTITIONS\s0"
.IX Subsection "IGNORING OR DELETING PARTITIONS"
virt-resize also gives a convenient way to ignore or delete partitions when
copying from the input disk to the output disk.  Ignoring a partition speeds
up the copy where you don't care about the existing contents of a
partition.  Deleting a partition removes it completely, but note that it
also renumbers any partitions after the one which is deleted, which can
leave some guests unbootable.
.SS "\s-1QCOW2 AND\s0 NON-SPARSE \s-1RAW FORMATS\s0"
.IX Subsection "QCOW2 AND NON-SPARSE RAW FORMATS"
If the input disk is in qcow2 format, then you may prefer that the output is
in qcow2 format as well.  Alternately, virt-resize can convert the format on
the fly.  The output format is simply determined by the format of the empty
output container that you provide.  Thus to create qcow2 output, use:
.PP
.Vb 1
\& qemu\-img create \-f qcow2 \-o preallocation=metadata outdisk [size]
.Ve
.PP
instead of the truncate command.
.PP
Similarly, to get non-sparse raw output use:
.PP
.Vb 1
\& fallocate \-l size outdisk
.Ve
.PP
(on older systems that don't have the \fIfallocate\fR\|(1) command use \f(CW\*(C`dd
if=/dev/zero of=outdisk bs=1M count=..\*(C'\fR)
.SS "論理パーティション"
.IX Subsection "論理パーティション"
Logical partitions (a.k.a. \fI/dev/sda5+\fR on disks using \s-1DOS\s0 partition
tables) cannot be resized.
.PP
To understand what is going on, firstly one of the four partitions
\&\fI/dev/sda1\-4\fR will have \s-1MBR\s0 partition type \f(CW05\fR or \f(CW\*(C`0f\*(C'\fR.  This is called
the \fBextended partition\fR.  Use \fIvirt\-filesystems\fR\|(1) to see the \s-1MBR\s0
partition type.
.PP
Logical partitions live inside the extended partition.
.PP
The extended partition can be expanded, but not shrunk (unless you force it,
which is not advisable).  When the extended partition is copied across, all
the logical partitions contained inside are copied over implicitly.
Virt-resize does not look inside the extended partition, so it copies the
logical partitions blindly.
.PP
You cannot specify a logical partition (\fI/dev/sda5+\fR) at all on the command
line.  Doing so will give an error.
.SH "オプション"
.IX Header "オプション"
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
ヘルプを表示します。
.IP "\fB\-\-align\-first\fR \fBauto\fR" 4
.IX Item "--align-first auto"
.PD 0
.IP "\fB\-\-align\-first\fR \fBnever\fR" 4
.IX Item "--align-first never"
.IP "\fB\-\-align\-first\fR \fBalways\fR" 4
.IX Item "--align-first always"
.PD
Align the first partition for improved performance (see also the
\&\fI\-\-alignment\fR option).
.Sp
The default is \fI\-\-align\-first auto\fR which only aligns the first partition
if it is safe to do so.  That is, only when we know how to fix the
bootloader automatically, and at the moment that can only be done for
Windows guests.
.Sp
\&\fI\-\-align\-first never\fR means we never move the first partition.  This is the
safest option.  Try this if the guest does not boot after resizing.
.Sp
\&\fI\-\-align\-first always\fR means we always align the first partition (if it
needs to be aligned).  For some guests this will break the bootloader,
making the guest unbootable.
.IP "\fB\-\-alignment\fR N" 4
.IX Item "--alignment N"
Set the alignment of partitions to \f(CW\*(C`N\*(C'\fR sectors.  The default in virt-resize
< 1.13.19 was 64 sectors, and after that is 128 sectors.
.Sp
Assuming 512 byte sector size inside the guest, here are some suitable
values for this:
.RS 4
.IP "\fI\-\-alignment 1\fR (512 バイト)" 4
.IX Item "--alignment 1 (512 バイト)"
The partitions would be packed together as closely as possible, but would be
completely unaligned.  In some cases this can cause very poor performance.
See \fIvirt\-alignment\-scan\fR\|(1) for further details.
.IP "\fI\-\-alignment 8\fR (4K)" 4
.IX Item "--alignment 8 (4K)"
This would be the minimum acceptable alignment for reasonable performance on
modern hosts.
.IP "\fI\-\-alignment 128\fR (64K)" 4
.IX Item "--alignment 128 (64K)"
This alignment provides good performance when the host is using high end
network storage.
.IP "\fI\-\-alignment 2048\fR (1M)" 4
.IX Item "--alignment 2048 (1M)"
This is the standard alignment used by all newly installed guests since
around 2008.
.RE
.RS 4
.RE
.IP "\fB\-\-colors\fR" 4
.IX Item "--colors"
.PD 0
.IP "\fB\-\-colours\fR" 4
.IX Item "--colours"
.PD
Use \s-1ANSI\s0 colour sequences to colourize messages.  This is the default when
the output is a tty.  If the output of the program is redirected to a file,
\&\s-1ANSI\s0 colour sequences are disabled unless you use this option.
.IP "\fB\-d\fR" 4
.IX Item "-d"
.PD 0
.IP "\fB\-\-debug\fR" 4
.IX Item "--debug"
.PD
(Deprecated: use \fI\-v\fR option instead)
.Sp
デバッグメッセージを有効にします。
.IP "\fB\-\-delete\fR \s-1PART\s0" 4
.IX Item "--delete PART"
Delete the named partition.  It would be more accurate to describe this as
\&\*(L"don't copy it over\*(R", since virt-resize doesn't do in-place changes and the
original disk image is left intact.
.Sp
Note that when you delete a partition, then anything contained in the
partition is also deleted.  Furthermore, this causes any partitions that
come after to be \fIrenumbered\fR, which can easily make your guest unbootable.
.Sp
このオプションは複数回指定できます。
.IP "\fB\-\-expand\fR \s-1PART\s0" 4
.IX Item "--expand PART"
Expand the named partition so it uses up all extra space (space left over
after any other resize changes that you request have been done).
.Sp
If virt-resize knows how, it will expand the direct content of the
partition.  For example, if the partition is an \s-1LVM PV,\s0 it will expand the
\&\s-1PV\s0 to fit (like calling \fIpvresize\fR\|(8)).  Virt-resize leaves any other
content it doesn't know about alone.
.Sp
Currently virt-resize can resize:
.RS 4
.IP "\(bu" 4
ext2, ext3, ext4 ファイルシステム。
.IP "\(bu" 4
\&\s-1NTFS\s0 filesystems, if libguestfs was compiled with support for \s-1NTFS.\s0
.Sp
The filesystem must have been shut down consistently last time it was used.
Additionally, \fIntfsresize\fR\|(8) marks the resized filesystem as requiring a
consistency check, so at the first boot after resizing Windows will check
the disk.
.IP "\(bu" 4
\&\s-1LVM\s0 PVs (physical volumes).  virt-resize does not usually resize anything
inside the \s-1PV,\s0 but see the \fI\-\-LV\-expand\fR option.  The user could also
resize LVs as desired after boot.
.IP "\(bu" 4
Btrfs filesystems, if libguestfs was compiled with support for btrfs.
.IP "\(bu" 4
\&\s-1XFS\s0 filesystems, if libguestfs was compiled with support for \s-1XFS.\s0
.IP "\(bu" 4
Linux swap partitions.
.Sp
Please note that libguestfs \fIdestroys\fR the existing swap content by
recreating it with \f(CW\*(C`mkswap\*(C'\fR, so this should not be used when the guest is
suspended.
.RE
.RS 4
.Sp
Note that you cannot use \fI\-\-expand\fR and \fI\-\-shrink\fR together.
.RE
.IP "\fB\-\-format\fR \fBraw\fR" 4
.IX Item "--format raw"
Specify the format of the input disk image.  If this flag is not given then
it is auto-detected from the image itself.
.Sp
If working with untrusted raw-format guest disk images, you should ensure
the format is always specified.
.Sp
Note that this option \fIdoes not\fR affect the output format.  See \*(L"\s-1QCOW2
AND\s0 NON-SPARSE \s-1RAW FORMATS\*(R"\s0.
.IP "\fB\-\-ignore\fR \s-1PART\s0" 4
.IX Item "--ignore PART"
Ignore the named partition.  Effectively this means the partition is
allocated on the destination disk, but the content is not copied across from
the source disk.  The content of the partition will be blank (all zero
bytes).
.Sp
このオプションは複数回指定できます。
.IP "\fB\-\-LV\-expand\fR \s-1LOGVOL\s0" 4
.IX Item "--LV-expand LOGVOL"
This takes the logical volume and, as a final step, expands it to fill all
the space available in its volume group.  A typical usage, assuming a Linux
guest with a single \s-1PV\s0 \fI/dev/sda2\fR and a root device called
\&\fI/dev/vg_guest/lv_root\fR would be:
.Sp
.Vb 2
\& virt\-resize indisk outdisk \e
\&   \-\-expand /dev/sda2 \-\-LV\-expand /dev/vg_guest/lv_root
.Ve
.Sp
This would first expand the partition (and \s-1PV\s0), and then expand the root
device to fill the extra space in the \s-1PV.\s0
.Sp
The contents of the \s-1LV\s0 are also resized if virt-resize knows how to do
that.  You can stop virt-resize from trying to expand the content by using
the option \fI\-\-no\-expand\-content\fR.
.Sp
仮想マシンにあるファイルシステムを一覧表示するには \fIvirt\-filesystems\fR\|(1) を使用します。
.Sp
You can give this option multiple times, \fIbut\fR it doesn't make sense to do
this unless the logical volumes you specify are all in different volume
groups.
.IP "\fB\-\-machine\-readable\fR" 4
.IX Item "--machine-readable"
このオプションは、他のプログラムにより解析されるときに、よりマシンに易しい出力を作成するために使用されます。以下の \*(L"マシン可読な出力\*(R" 参照。
.IP "\fB\-n\fR" 4
.IX Item "-n"
.PD 0
.IP "\fB\-\-dry\-run\fR" 4
.IX Item "--dry-run"
.PD
Print a summary of what would be done, but don't do anything.
.IP "\fB\-\-no\-copy\-boot\-loader\fR" 4
.IX Item "--no-copy-boot-loader"
By default, virt-resize copies over some sectors at the start of the disk
(up to the beginning of the first partition).  Commonly these sectors
contain the Master Boot Record (\s-1MBR\s0) and the boot loader, and are required
in order for the guest to boot correctly.
.Sp
If you specify this flag, then this initial copy is not done.  You may need
to reinstall the boot loader in this case.
.IP "\fB\-\-no\-extra\-partition\fR" 4
.IX Item "--no-extra-partition"
By default, virt-resize creates an extra partition if there is any extra,
unused space after all resizing has happened.  Use this option to prevent
the extra partition from being created.  If you do this then the extra space
will be inaccessible until you run fdisk, parted, or some other partitioning
tool in the guest.
.Sp
Note that if the surplus space is smaller than 10 \s-1MB,\s0 no extra partition
will be created.
.IP "\fB\-\-no\-expand\-content\fR" 4
.IX Item "--no-expand-content"
By default, virt-resize will try to expand the direct contents of
partitions, if it knows how (see \fI\-\-expand\fR option above).
.Sp
\&\fI\-\-no\-expand\-content\fR オプションを指定すると、virt\-resize はこれを試行しません。
.IP "\fB\-\-no\-sparse\fR" 4
.IX Item "--no-sparse"
Turn off sparse copying.  See \*(L"\s-1SPARSE COPYING\*(R"\s0 below.
.IP "\fB\-\-ntfsresize\-force\fR" 4
.IX Item "--ntfsresize-force"
\&\fIntfsresize\fR\|(8) に \fI\-\-force\fR オプションを渡します。これにより、NTFS
ディスクが整合性の確認が必要であるという印をつけたときでも、容量の変更を許可します。Windows
仮想マシンを各容量において起動することなく、何回も容量変更したいならば、このオプションを使用する必要があります。
.IP "\fB\-\-output\-format\fR \fBraw\fR" 4
.IX Item "--output-format raw"
Specify the format of the output disk image.  If this flag is not given then
it is auto-detected from the image itself.
.Sp
If working with untrusted raw-format guest disk images, you should ensure
the format is always specified.
.Sp
Note that this option \fIdoes not create\fR the output format.  This option
just tells libguestfs what it is so it doesn't try to guess it.  You still
need to create the output disk with the right format.  See \*(L"\s-1QCOW2 AND\s0
NON-SPARSE \s-1RAW FORMATS\*(R"\s0.
.IP "\fB\-q\fR" 4
.IX Item "-q"
.PD 0
.IP "\fB\-\-quiet\fR" 4
.IX Item "--quiet"
.PD
概要を表示しません。
.IP "\fB\-\-resize\fR PART=SIZE" 4
.IX Item "--resize PART=SIZE"
Resize the named partition (expanding or shrinking it) so that it has the
given size.
.Sp
\&\f(CW\*(C`SIZE\*(C'\fR can be expressed as an absolute number followed by b/K/M/G to mean
bytes, Kilobytes, Megabytes, or Gigabytes; or as a percentage of the current
size; or as a relative number or percentage.  For example:
.Sp
.Vb 1
\& \-\-resize /dev/sda2=10G
\&
\& \-\-resize /dev/sda4=90%
\&
\& \-\-resize /dev/sda2=+1G
\&
\& \-\-resize /dev/sda2=\-200M
\&
\& \-\-resize /dev/sda1=+128K
\&
\& \-\-resize /dev/sda1=+10%
\&
\& \-\-resize /dev/sda1=\-10%
.Ve
.Sp
You can increase the size of any partition.  Virt-resize will expand the
direct content of the partition if it knows how (see \fI\-\-expand\fR above).
.Sp
You can only \fIdecrease\fR the size of partitions that contain filesystems or
PVs which have already been shrunk.  Virt-resize will check this has been
done before proceeding, or else will print an error (see also
\&\fI\-\-resize\-force\fR).
.Sp
このオプションは複数回指定できます。
.IP "\fB\-\-resize\-force\fR PART=SIZE" 4
.IX Item "--resize-force PART=SIZE"
This is the same as \fI\-\-resize\fR except that it will let you decrease the
size of any partition.  Generally this means you will lose any data which
was at the end of the partition you shrink, but you may not care about that
(eg. if shrinking an unused partition, or if you can easily recreate it such
as a swap partition).
.Sp
\&\fI\-\-ignore\fR オプション参照。
.IP "\fB\-\-shrink\fR \s-1PART\s0" 4
.IX Item "--shrink PART"
Shrink the named partition until the overall disk image fits in the
destination.  The named partition \fBmust\fR contain a filesystem or \s-1PV\s0 which
has already been shrunk using another tool (eg. \fIguestfish\fR\|(1) or other
online tools).  Virt-resize will check this and give an error if it has not
been done.
.Sp
The amount by which the overall disk must be shrunk (after carrying out all
other operations requested by the user) is called the \*(L"deficit\*(R".  For
example, a straight copy (assume no other operations)  from a 5GB disk image
to a 4GB disk image results in a 1GB deficit.  In this case, virt-resize
would give an error unless the user specified a partition to shrink and that
partition had more than a gigabyte of free space.
.Sp
Note that you cannot use \fI\-\-expand\fR and \fI\-\-shrink\fR together.
.IP "\fB\-\-unknown\-filesystems\fR \fBignore\fR" 4
.IX Item "--unknown-filesystems ignore"
.PD 0
.IP "\fB\-\-unknown\-filesystems\fR \fBwarn\fR" 4
.IX Item "--unknown-filesystems warn"
.IP "\fB\-\-unknown\-filesystems\fR \fBerror\fR" 4
.IX Item "--unknown-filesystems error"
.PD
Configure the behaviour of virt-resize when asking to expand a filesystem,
and neither libguestfs has the support it, nor virt-resize knows how to
expand the content of the filesystem.
.Sp
\&\fI\-\-unknown\-filesystems ignore\fR will cause virt-resize to silently ignore
such filesystems, and nothing is printed about them.
.Sp
\&\fI\-\-unknown\-filesystems warn\fR (the default behaviour) will cause virt-resize
to warn for each of the filesystem that cannot be expanded, but still
continuing to resize the disk.
.Sp
\&\fI\-\-unknown\-filesystems error\fR will cause virt-resize to error out at the
first filesystem that cannot be expanded.
.Sp
See also \*(L"unknown/unavailable method for expanding the \s-1TYPE\s0 filesystem on
\&\s-1DEVICE/LV\*(R"\s0.
.IP "\fB\-v\fR" 4
.IX Item "-v"
.PD 0
.IP "\fB\-\-verbose\fR" 4
.IX Item "--verbose"
.PD
デバッグメッセージを有効にします。
.IP "\fB\-V\fR" 4
.IX Item "-V"
.PD 0
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
.PD
バージョン番号を表示して、終了します。
.IP "\fB\-x\fR" 4
.IX Item "-x"
libguestfs \s-1API\s0 呼び出しのトレースを有効にします。
.SH "マシン可読な出力"
.IX Header "マシン可読な出力"
\&\fI\-\-machine\-readable\fR オプションはよりマシンに易しい出力を作成するために使用できます。これは他のプログラムや \s-1GUI\s0 などから
virt-resize を呼び出すときに有用です。
.PP
このオプションを使用するには 2 通りの方法があります。
.PP
Firstly use the option on its own to query the capabilities of the
virt-resize binary.  Typical output looks like this:
.PP
.Vb 6
\& $ virt\-resize \-\-machine\-readable
\& virt\-resize
\& ntfsresize\-force
\& 32bitok
\& ntfs
\& btrfs
.Ve
.PP
A list of features is printed, one per line, and the program exits with
status 0.
.PP
Secondly use the option in conjunction with other options to make the
regular program output more machine friendly.
.PP
At the moment this means:
.IP "1." 4
Progress bar messages can be parsed from stdout by looking for this regular
expression:
.Sp
.Vb 1
\& ^[0\-9]+/[0\-9]+$
.Ve
.IP "2." 4
The calling program should treat messages sent to stdout (except for
progress bar messages) as status messages.  They can be logged and/or
displayed to the user.
.IP "3." 4
The calling program should treat messages sent to stderr as error messages.
In addition, virt-resize exits with a non-zero status code if there was a
fatal error.
.PP
Versions of the program prior to 1.13.9 did not support the
\&\fI\-\-machine\-readable\fR option and will return an error.
.SH "注記"
.IX Header "注記"
.ie n .SS """Partition 1 does not end on cylinder boundary."""
.el .SS "``Partition 1 does not end on cylinder boundary.''"
.IX Subsection "Partition 1 does not end on cylinder boundary."
Virt-resize aligns partitions to multiples of 128 sectors (see the
\&\fI\-\-alignment\fR parameter).  Usually this means the partitions will not be
aligned to the ancient \s-1CHS\s0 geometry.  However \s-1CHS\s0 geometry is meaningless
for disks manufactured since the early 1990s, and doubly so for virtual hard
drives.  Alignment of partitions to cylinders is not required by any modern
operating system.
.ie n .SS "\s-1GUEST BOOT STUCK AT ""GRUB""\s0"
.el .SS "\s-1GUEST BOOT STUCK AT ``GRUB''\s0"
.IX Subsection "GUEST BOOT STUCK AT GRUB"
If a Linux guest does not boot after resizing, and the boot is stuck after
printing \f(CW\*(C`GRUB\*(C'\fR on the console, try reinstalling grub.
.PP
.Vb 6
\& guestfish \-i \-a newdisk
\& ><fs> cat /boot/grub/device.map
\& # check the contents of this file are sensible or
\& # edit the file if necessary
\& ><fs> grub\-install / /dev/vda
\& ><fs> exit
.Ve
.PP
For more flexible guest reconfiguration, including if you need to specify
other parameters to grub-install, use \fIvirt\-rescue\fR\|(1).
.SS "\s-1RESIZING WINDOWS BOOT PARTITIONS\s0"
.IX Subsection "RESIZING WINDOWS BOOT PARTITIONS"
In Windows Vista and later versions, Microsoft switched to using a separate
boot partition.  In these VMs, typically \fI/dev/sda1\fR is the boot partition
and \fI/dev/sda2\fR is the main (C:) drive.  Resizing the first (boot)
partition causes the bootloader to fail with \f(CW0xC0000225\fR error.  Resizing
the second partition (ie. C: drive)  should work.
.SS "\s-1WINDOWS CHKDSK\s0"
.IX Subsection "WINDOWS CHKDSK"
Windows disks which use \s-1NTFS\s0 must be consistent before virt-resize can be
used.  If the ntfsresize operation fails, try booting the original \s-1VM\s0 and
running \f(CW\*(C`chkdsk /f\*(C'\fR on all \s-1NTFS\s0 partitions, then shut down the \s-1VM\s0 cleanly.
For further information see:
https://bugzilla.redhat.com/show_bug.cgi?id=975753
.PP
\&\fIAfter resize\fR Windows may initiate a lengthy \*(L"chkdsk\*(R" on first boot if
\&\s-1NTFS\s0 partitions have been expanded.  This is just a safety check and (unless
it find errors) is nothing to worry about.
.SS "Windows \s-1UNMOUNTABLE_BOOT_VOLUME BSOD\s0"
.IX Subsection "Windows UNMOUNTABLE_BOOT_VOLUME BSOD"
Windows 仮想マシンを sysprep して、virt\-resize を用いて容量を変更した後、仮想マシンが
\&\f(CW\*(C`UNMOUNTABLE_BOOT_VOLUME\*(C'\fR \s-1BSOD\s0 で起動に失敗するかもしれません。このエラーは sysprep.inf ファイルに
\&\f(CW\*(C`ExtendOemPartition=1\*(C'\fR があることにより引き起こされます。sysprep
する前にこの行を削除することにより、この問題を解決できます。
.SS "\s-1WINDOWS 8\s0"
.IX Subsection "WINDOWS 8"
Windows 8 \*(L"fast startup\*(R" can prevent virt-resize from resizing \s-1NTFS\s0
partitions.  See \*(L"\s-1WINDOWS HIBERNATION AND WINDOWS 8 FAST
STARTUP\*(R"\s0 in \fIguestfs\fR\|(3).
.SS "\s-1SPARSE COPYING\s0"
.IX Subsection "SPARSE COPYING"
You should create a fresh, zeroed target disk image for virt-resize to use.
.PP
Virt-resize by default performs sparse copying.  This means that it does not
copy blocks from the source disk which are all zeroes.  This improves speed
and efficiency, but will produce incorrect results if the target disk image
contains unzeroed data.
.PP
The main time this can be a problem is if the target is a host partition
(eg. \f(CW\*(C`virt\-resize source.img /dev/sda4\*(C'\fR) because the usual partitioning
tools tend to leave whatever data happened to be on the disk before.
.PP
If you have to reuse a target which contains data already, you should use
the \fI\-\-no\-sparse\fR option.  Note this can be much slower.
.ie n .SS """unknown/unavailable method for expanding the \s-1TYPE\s0 filesystem on \s-1DEVICE/LV""\s0"
.el .SS "``unknown/unavailable method for expanding the \s-1TYPE\s0 filesystem on \s-1DEVICE/LV''\s0"
.IX Subsection "unknown/unavailable method for expanding the TYPE filesystem on DEVICE/LV"
Virt-resize was asked to expand a partition or a logical volume containing a
filesystem with the type \f(CW\*(C`TYPE\*(C'\fR, but there is no available nor known
expanding method for that filesystem.
.PP
This may be due to either of the following:
.IP "1." 4
There corresponding filesystem is not available in libguestfs, because there
is no proper package in the host with utilities for it.  This is usually the
case for \f(CW\*(C`btrfs\*(C'\fR, \f(CW\*(C`ntfs\*(C'\fR, and \f(CW\*(C`xfs\*(C'\fR filesystems.
.Sp
Check the results of:
.Sp
.Vb 3
\& virt\-resize \-\-machine\-readable
\& guestfish \-a /dev/null run : available
\& guestfish \-a /dev/null run : filesystem_available TYPE
.Ve
.Sp
In this case, it is enough to install the proper packages adding support for
them.  For example, \f(CW\*(C`libguestfs\-xfs\*(C'\fR on Red Hat Enterprise Linux, CentOS,
Debian, Ubuntu, and distributions derived from them, for supporting the
\&\f(CW\*(C`xfs\*(C'\fR filesystem.
.IP "2." 4
Virt-resize has no support for expanding that type of filesystem.
.Sp
In this case, there's nothing that can be done to let virt-resize expand
that type of filesystem.
.PP
In both cases, virt-resize will not expand the mentioned filesystem; the
result (unless \fI\-\-unknown\-filesystems error\fR is specified)  is that the
partitions containing such filesystems will be actually bigger as requested,
but the filesystems will still be usable at the their older sizes.
.SH "代替ツール"
.IX Header "代替ツール"
There are several proprietary tools for resizing partitions.  We won't
mention any here.
.PP
\&\fIparted\fR\|(8) and its graphical shell gparted can do some types of resizing
operations on disk images.  They can resize and move partitions, but I don't
think they can do anything with the contents, and they certainly don't
understand \s-1LVM.\s0
.PP
\&\fIguestfish\fR\|(1) can do everything that virt-resize can do and a lot more,
but at a much lower level.  You will probably end up hand-calculating sector
offsets, which is something that virt-resize was designed to avoid.  If you
want to see the guestfish-equivalent commands that virt-resize runs, use the
\&\fI\-\-debug\fR flag.
.PP
\&\fIdracut\fR\|(8) includes a module called \f(CW\*(C`dracut\-modules\-growroot\*(C'\fR which can
be used to grow the root partition when the guest first boots up.  There is
documentation for this module in an associated \s-1README\s0 file.
.SH "終了ステータス"
.IX Header "終了ステータス"
このプログラムは、成功すると 0 を、エラーがあると 0 以外を返します。
.SH "関連項目"
.IX Header "関連項目"
\&\fIvirt\-filesystems\fR\|(1), \fIvirt\-df\fR\|(1), \fIguestfs\fR\|(3), \fIguestfish\fR\|(1),
\&\fIlvm\fR\|(8), \fIpvresize\fR\|(8), \fIlvresize\fR\|(8), \fIresize2fs\fR\|(8),
\&\fIntfsresize\fR\|(8), \fIbtrfs\fR\|(8), \fIxfs_growfs\fR\|(8), \fIvirsh\fR\|(1), \fIparted\fR\|(8),
\&\fItruncate\fR\|(1), \fIfallocate\fR\|(1), \fIgrub\fR\|(8), \fIgrub\-install\fR\|(8),
\&\fIvirt\-rescue\fR\|(1), \fIvirt\-sparsify\fR\|(1), \fIvirt\-alignment\-scan\fR\|(1),
http://libguestfs.org/.
.SH "著者"
.IX Header "著者"
Richard W.M. Jones http://people.redhat.com/~rjones/
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2010\-2012 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
