.\" Automatically generated by Podwrapper::Man 1.36.9 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "guestfs 3"
.TH guestfs 3 "2017-10-18" "libguestfs-1.36.9" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "名前"
.IX Header "名前"
guestfs \- 仮想マシンイメージのアクセスまたは変更のためのライブラリ
.SH "書式"
.IX Header "書式"
#include <guestfs.h>
 guestfs_h *g = guestfs_create ();
 guestfs_add_drive (g, \*(L"guest.img\*(R");
 guestfs_launch (g);
 guestfs_mount (g, \*(L"/dev/sda1\*(R", \*(L"/\*(R");
 guestfs_touch (g, \*(L"/hello\*(R");
 guestfs_umount (g, \*(L"/\*(R");
 guestfs_shutdown (g);
 guestfs_close (g);
.PP
.Vb 3
\& cc prog.c \-o prog \-lguestfs
\&or:
\& cc prog.c \-o prog \`pkg\-config libguestfs \-\-cflags \-\-libs\`
.Ve
.SH "説明"
.IX Header "説明"
Libguestfs is a library for accessing and modifying disk images and virtual
machines.
.PP
This manual page documents the C \s-1API.\s0
.PP
If you are looking for an introduction to libguestfs, see the web site:
http://libguestfs.org/
.PP
Each virt tool has its own man page (for a full list, go to \*(L"\s-1SEE ALSO\*(R"\s0 at
the end of this file).
.PP
Other libguestfs manual pages:
.IP "\fIguestfs\-faq\fR\|(1)" 4
.IX Item "guestfs-faq"
Frequently Asked Questions (\s-1FAQ\s0).
.IP "\fIguestfs\-examples\fR\|(3)" 4
.IX Item "guestfs-examples"
Examples of using the \s-1API\s0 from C.  For examples in other languages, see
\&\*(L"\s-1USING LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES\*(R"\s0 below.
.IP "\fIguestfs\-recipes\fR\|(1)" 4
.IX Item "guestfs-recipes"
Tips and recipes.
.IP "\fIguestfs\-performance\fR\|(1)" 4
.IX Item "guestfs-performance"
Performance tips and solutions.
.IP "\fIlibguestfs\-test\-tool\fR\|(1)" 4
.IX Item "libguestfs-test-tool"
.PD 0
.IP "\fIguestfs\-testing\fR\|(1)" 4
.IX Item "guestfs-testing"
.PD
Help testing libguestfs.
.IP "\fIguestfs\-building\fR\|(1)" 4
.IX Item "guestfs-building"
How to build libguestfs from source.
.IP "\fIguestfs\-hacking\fR\|(1)" 4
.IX Item "guestfs-hacking"
Contribute code to libguestfs.
.IP "\fIguestfs\-internals\fR\|(1)" 4
.IX Item "guestfs-internals"
How libguestfs works.
.IP "\fIguestfs\-security\fR\|(1)" 4
.IX Item "guestfs-security"
Security information, including CVEs affecting libguestfs.
.SH "API 概要"
.IX Header "API 概要"
このセクションは libguestfs \s-1API\s0 の簡単な概要を示します。  一緒に呼ばれるグループ \s-1API\s0
を試みます。これは、このマニュアルのメインセクションにおいて個々の呼び出しに関して読む必要が無くなります。
.SS "ハンドル"
.IX Subsection "ハンドル"
libguestfs 呼び出しを使用する前に、ハンドルを作成する必要があります。そして、少なくとも 1
つのディスクイメージをハンドルを追加する必要があります。続けて、ハンドルを開始して、好きな操作を実行します。最後に、ハンドルを閉じます。利便性のため、ハンドル変数の名前を
1 文字の \f(CW\*(C`g\*(C'\fR を使用します。もちろん、好きな名前を使うことができます。
.PP
libguestfs を使用しているすべてのプログラムの一般的な構造はこのようなものです:
.PP
.Vb 1
\& guestfs_h *g = guestfs_create ();
\& 
\& /* 複数のディスクイメージがあれば、その回数だけ
\&  * guestfs_add_drive を呼び出します。
\&  */
\& guestfs_add_drive (g, "guest.img");
\& 
\& /* 大抵の操作呼び出しはハンドル \*(Aqg\*(Aq を開始するまでうまく
\&  * 機能しません。ドライブを追加した「後」、他のコマンド
\&  * を実行する「前」にこれを行う必要があります。
\&  */
\& guestfs_launch (g);
\& 
\& /* Either: examine what partitions, LVs etc are available: */
\& char **partitions = guestfs_list_partitions (g);
\& char **logvols = guestfs_lvs (g);
\& 
\& /* Or: ask libguestfs to find filesystems for you: */
\& char **filesystems = guestfs_list_filesystems (g);
\& 
\& /* Or: use inspection (see INSPECTION section below). */
\& 
\& /* To access a filesystem in the image, you must mount it. */
\& guestfs_mount (g, "/dev/sda1", "/");
\& 
\& /* これで、仮想マシンのイメージにおいて、ファイルシステムの
\&  * アクションを実行できます。
\&  */
\& guestfs_touch (g, "/hello");
\& 
\& /* ディスクを同期します。これは guestfs_launch の反対です。 */
\& guestfs_shutdown (g);
\& 
\& /* ハンドル \*(Aqg\*(Aq を閉じて開放します。 */
\& guestfs_close (g);
.Ve
.PP
The code above doesn't include any error checking.  In real code you should
check return values carefully for errors.  In general all functions that
return integers return \f(CW\*(C`\-1\*(C'\fR on error, and all functions that return
pointers return \f(CW\*(C`NULL\*(C'\fR on error.  See section \*(L"\s-1ERROR HANDLING\*(R"\s0 below for
how to handle errors, and consult the documentation for each function call
below to see precisely how they return error indications.
.PP
The code above does not \fIfree\fR\|(3) the strings and arrays returned from
functions.  Consult the documentation for each function to find out how to
free the return value.
.PP
See \fIguestfs\-examples\fR\|(3) for fully worked examples.
.SS "ディスクイメージ"
.IX Subsection "ディスクイメージ"
イメージファイル名 (上の例では \f(CW"guest.img"\fR) は、仮想マシンのディスクイメージ、物理ハードディスクの \fIdd\fR\|(1)
コピー、実際のブロックデバイス、単に \fIposix_fallocate\fR\|(3) から作成した 0 の空ファイルがありえます。libguestfs
はこれらすべてに役に立つことをさせます。
.PP
近代的なコードにおいてドライブを追加するために使用する呼び出しは \*(L"guestfs_add_drive_opts\*(R" です。書き込み許可、raw
形式指定にて、ディスクイメージを追加するには、次を実行します:
.PP
.Vb 3
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         \-1);
.Ve
.PP
以下を使用して、読み込み専用のディスクを追加できます:
.PP
.Vb 4
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
\&                         \-1);
.Ve
.PP
or by calling the older function \*(L"guestfs_add_drive_ro\*(R".  If you use the
readonly flag, libguestfs won't modify the file.  (See also \*(L"\s-1DISK IMAGE
FORMATS\*(R"\s0 below).
.PP
ディスクイメージが使用中ならば、たとえば仮想マシンにより使用されているならば、特に注意してください。読み書き可能で追加することにより、ほぼ確実にディスク破損を引き起こします。一方、読み込み専用で追加することは安全です。
.PP
You should usually add at least one disk image, and you may add multiple
disk images.  If adding multiple disk images, they usually have to be
\&\*(L"related\*(R", ie. from the same guest.  In the \s-1API,\s0 the disk images are usually
referred to as \fI/dev/sda\fR (for the first one you added), \fI/dev/sdb\fR (for
the second one you added), etc.
.PP
一度 \*(L"guestfs_launch\*(R"
が呼び出されると、これ以上イメージを追加することはできません。それらを追加するためには、デバイス名の一覧を取得するために
\&\*(L"guestfs_list_devices\*(R" を呼び出せます。以下の \*(L"ブロックデバイス命名法\*(R" を参照してください。
.PP
There are slightly different rules when hotplugging disks (in libguestfs
≥ 1.20).  See \*(L"\s-1HOTPLUGGING\*(R"\s0 below.
.SS "マウント"
.IX Subsection "マウント"
Before you can read or write files, create directories and so on in a disk
image that contains filesystems, you have to mount those filesystems using
\&\*(L"guestfs_mount\*(R" or \*(L"guestfs_mount_ro\*(R".  If you already know that a disk
image contains (for example) one partition with a filesystem on that
partition, then you can mount it directly:
.PP
.Vb 1
\& guestfs_mount (g, "/dev/sda1", "/");
.Ve
.PP
where \fI/dev/sda1\fR means literally the first partition (\f(CW1\fR) of the first
disk image that we added (\fI/dev/sda\fR).  If the disk contains Linux \s-1LVM2\s0
logical volumes you could refer to those instead (eg. \fI/dev/VG/LV\fR).  Note
that these are libguestfs virtual devices, and are nothing to do with host
devices.
.PP
ディスクイメージを与えられていますが、何が含まれているかわからないならば、理解する必要があります。 libguestfs はそれもできます:
利用可能なパーティションおよび論理ボリュームを一覧表示するために \*(L"guestfs_list_partitions\*(R" および
\&\*(L"guestfs_lvs\*(R" を使用します。そして、マウント可能なものを確認するためにそれぞれマウントを試します。もしくは
\&\*(L"guestfs_vfs_type\*(R" または \*(L"guestfs_file\*(R" を用いて検査します。単にファイルシステムを一覧表示するには
\&\*(L"guestfs_list_filesystems\*(R" を使用します。
.PP
Libguestfs also has a set of APIs for inspection of unknown disk images (see
\&\*(L"\s-1INSPECTION\*(R"\s0 below).  You might also want to look at higher level programs
built on top of libguestfs, in particular \fIvirt\-inspector\fR\|(1).
.PP
ファイルシステムを読み込み専用でマウントするには \*(L"guestfs_mount_ro\*(R" を使用します。いくつかの他の変種
\&\f(CW\*(C`guestfs_mount_*\*(C'\fR 呼び出しがあります。
.SS "ファイルシステムのアクセスおよび変更"
.IX Subsection "ファイルシステムのアクセスおよび変更"
libguestfs \s-1API\s0
の大半は、マウントされたファイルシステムにあるファイル、ディレクトリー、シンボリックリンクなどを参照および変更するためのかなり低レベルな関数呼び出しから構成されます。このマニュアルページにおいて以下に詳細に一覧化されている、そのような呼び出しは
100 以上あります。この概要においてすべてを取り扱うことは考えていません。
.PP
\&\f(CW"/"\fR から始まり、マウントポイントを含む完全パスとしてファイル名を指定します。
.PP
たとえば、\f(CW"/"\fR にファイルシステムをマウントして、\f(CW"etc/passwd"\fR というファイルを読み込みたければ、次のようにできます:
.PP
.Vb 1
\& char *data = guestfs_cat (g, "/etc/passwd");
.Ve
.PP
これは、ファイルの完全な内容を含む（いくつかの条件とともに: 以下の \*(L"ダウンロード\*(R" 参照）新しく割り当てられたバッファーとして \f(CW\*(C`data\*(C'\fR
を返します。もしくは、エラーがあれば \f(CW\*(C`NULL\*(C'\fR を返します。
.PP
もう 1 つの例として、ファイルシステムに \f(CW"var"\fR という名前の最上位ディレクトリーを作成するには、次のようにします:
.PP
.Vb 1
\& guestfs_mkdir (g, "/var");
.Ve
.PP
シンボリックリンクを作成するには次のようにできます:
.PP
.Vb 2
\& guestfs_ln_s (g, "/etc/init.d/portmap",
\&               "/etc/rc3.d/S30portmap");
.Ve
.PP
libguestfs は相対パスの使用を拒否します。現在の作業ディレクトリーという概念がありません。
.PP
libguestfs
は多くの状況においてエラーを返します。たとえば、ファイルシステムが書き込みできない場合です。または、要求したファイルやディレクトリーが存在しない場合です。
C \s-1API\s0 (ここにドキュメント化されています)
を使用しているならば、各呼び出しの後でそれらのエラー条件を確認する必要があります。（他の言語バインドは、これらのエラーを例外の中に含めてください。）
.PP
ファイルの書き込みはハンドルごとの umask により影響されます。\*(L"guestfs_umask\*(R" を呼び出すことにより設定され、初期値は 022
です。 \*(L"\s-1UMASK\*(R"\s0 参照。
.PP
Since libguestfs 1.18, it is possible to mount the libguestfs filesystem on
a local directory, subject to some restrictions.  See \*(L"\s-1MOUNT LOCAL\*(R"\s0 below.
.SS "パーティション"
.IX Subsection "パーティション"
libguestfs はディスクイメージにあるパーティションテーブルを読み込み、作成、変更するための \s-1API\s0 呼び出しがあります。
.PP
ディスク全体に単一のパーティションを作成したいという一般的な場合、 \*(L"guestfs_part_disk\*(R" 呼び出しを使用できます:
.PP
.Vb 4
\& const char *parttype = "mbr";
\& if (disk_is_larger_than_2TB)
\&   parttype = "gpt";
\& guestfs_part_disk (g, "/dev/sda", parttype);
.Ve
.PP
以前ディスクイメージにあったものを明示的にすべて効果的に完全消去します。
.SS "\s-1LVM2\s0"
.IX Subsection "LVM2"
libguestfs は \*(L"guestfs_lvcreate\*(R" および \*(L"guestfs_vgremove\*(R" のような、大部分の \s-1LVM2
API\s0 にアクセスできます。物理ボリューム、ボリュームグループ、論理ボリュームの概念になじみがなければ、役に立たないかもしれません。
.PP
この著者はオンラインで http://tldp.org/HOWTO/LVM\-HOWTO/ にある  \s-1LVM HOWTO\s0
を読むことを強く推奨します。
.SS "ダウンロード"
.IX Subsection "ダウンロード"
Use \*(L"guestfs_cat\*(R" to download small, text only files.  This call cannot
handle files containing any \s-1ASCII NUL\s0 (\f(CW\*(C`\e0\*(C'\fR) characters.  However the \s-1API\s0
is very simple to use.
.PP
\&\*(L"guestfs_read_file\*(R" can be used to read files which contain arbitrary 8
bit data, since it returns a (pointer, size) pair.
.PP
\&\*(L"guestfs_download\*(R" can be used to download any file, with no limits on
content or size.
.PP
複数のファイルをダウンロードするには \*(L"guestfs_tar_out\*(R" および \*(L"guestfs_tgz_out\*(R" を参照してください。
.SS "アップロード方法"
.IX Subsection "アップロード方法"
固定的な内容を持つ小さなファイルを書き込むには、\*(L"guestfs_write\*(R" を使用します。すべて 0
のファイルを作成するには、\*(L"guestfs_truncate_size\*(R" (スパース) または \*(L"guestfs_fallocate64\*(R"
(すべてのブロックを割り当て済み) を使用します。テストファイルを作成するためのさまざまな他の関数があります。たとえば、
\&\*(L"guestfs_fill\*(R" や \*(L"guestfs_fill_pattern\*(R" があります。
.PP
To upload a single file, use \*(L"guestfs_upload\*(R".  This call has no limits on
file content or size.
.PP
複数のファイルをアップロードするには、\*(L"guestfs_tar_in\*(R" および \*(L"guestfs_tgz_in\*(R" を参照してください。
.PP
However the fastest way to upload \fIlarge numbers of arbitrary files\fR is to
turn them into a squashfs or \s-1CD ISO\s0 (see \fImksquashfs\fR\|(8) and
\&\fImkisofs\fR\|(8)), then attach this using \*(L"guestfs_add_drive_ro\*(R".  If you add
the drive in a predictable way (eg. adding it last after all other drives)
then you can get the device name from \*(L"guestfs_list_devices\*(R" and mount it
directly using \*(L"guestfs_mount_ro\*(R".  Note that squashfs images are
sometimes non-portable between kernel versions, and they don't support
labels or UUIDs.  If you want to pre-build an image or you need to mount it
using a label or \s-1UUID,\s0 use an \s-1ISO\s0 image instead.
.SS "コピー方法"
.IX Subsection "コピー方法"
ファイルとデバイスの間でコピーして、仮想マシンのファイルシステムと入出力するための、さまざまなコマンドがあります。以下の表はその概要です。
.IP "\fBファイル\fRから\fBファイル\fR" 4
.IX Item "ファイルからファイル"
単一のファイルをコピーするには \*(L"guestfs_cp\*(R" を使用します、またはディレクトリーを再帰的にコピーするには
\&\*(L"guestfs_cp_a\*(R" を使用します。
.Sp
To copy part of a file (offset and size) use \*(L"guestfs_copy_file_to_file\*(R".
.IP "\fBファイル\fRから\fBデバイス\fR" 4
.IX Item "ファイルからデバイス"
.PD 0
.IP "\fBデバイス\fRから\fBファイル\fR" 4
.IX Item "デバイスからファイル"
.IP "\fBデバイス\fRから\fBデバイス\fR" 4
.IX Item "デバイスからデバイス"
.PD
\&\*(L"guestfs_copy_file_to_device\*(R", \*(L"guestfs_copy_device_to_file\*(R", または
\&\*(L"guestfs_copy_device_to_device\*(R" を使用してください。
.Sp
例: 論理ボリュームの内容の複製:
.Sp
.Vb 4
\& guestfs_copy_device_to_device (g,
\&         "/dev/VG/Original", "/dev/VG/Copy",
\&         /* \-1 marks the end of the list of optional parameters */
\&         \-1);
.Ve
.Sp
The destination (\fI/dev/VG/Copy\fR) must be at least as large as the source
(\fI/dev/VG/Original\fR).  To copy less than the whole source device, use the
optional \f(CW\*(C`size\*(C'\fR parameter:
.Sp
.Vb 4
\& guestfs_copy_device_to_device (g,
\&         "/dev/VG/Original", "/dev/VG/Copy",
\&         GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, 10000,
\&         \-1);
.Ve
.IP "\fBホストのファイル\fRから\fBファイルまたはデバイス\fR" 4
.IX Item "ホストのファイルからファイルまたはデバイス"
\&\*(L"guestfs_upload\*(R" を使用します。上の \*(L"アップロード方法\*(R" 参照。
.IP "\fBファイルまたはデバイス\fRから\fBホストのファイル\fR" 4
.IX Item "ファイルまたはデバイスからホストのファイル"
\&\*(L"guestfs_download\*(R" を使用します。上の \*(L"ダウンロード方法\*(R" 参照。
.SS "\s-1UPLOADING AND DOWNLOADING TO PIPES AND FILE DESCRIPTORS\s0"
.IX Subsection "UPLOADING AND DOWNLOADING TO PIPES AND FILE DESCRIPTORS"
Calls like \*(L"guestfs_upload\*(R", \*(L"guestfs_download\*(R", \*(L"guestfs_tar_in\*(R",
\&\*(L"guestfs_tar_out\*(R" etc appear to only take filenames as arguments, so it
appears you can only upload and download to files.  However many Un*x\-like
hosts let you use the special device files \fI/dev/stdin\fR, \fI/dev/stdout\fR,
\&\fI/dev/stderr\fR and \fI/dev/fd/N\fR to read and write from stdin, stdout,
stderr, and arbitrary file descriptor N.
.PP
たとえば、\fIvirt\-cat\fR\|(1) は次のようにすることにより、出力を標準出力に書き込みます:
.PP
.Vb 1
\& guestfs_download (g, filename, "/dev/stdout");
.Ve
.PP
and you can write tar output to a file descriptor \f(CW\*(C`fd\*(C'\fR by doing:
.PP
.Vb 3
\& char devfd[64];
\& snprintf (devfd, sizeof devfd, "/dev/fd/%d", fd);
\& guestfs_tar_out (g, "/", devfd);
.Ve
.SS "ファイルの一覧表示方法"
.IX Subsection "ファイルの一覧表示方法"
\&\*(L"guestfs_ll\*(R" は人間が読みやすいよう設計されています（おもに \fIguestfish\fR\|(1) の同等なコマンド \f(CW\*(C`ll\*(C'\fR
を使用するとき）。
.PP
\&\*(L"guestfs_ls\*(R" は文字列の平らな一覧のように、ディレクトリーにあるファイルの一覧をプログラムから取得する素早い方法です。
.PP
\&\*(L"guestfs_readdir\*(R"
はディレクトリーにあるファイルの一覧、さらにそれぞれに関する追加の情報を取得するためのプログラム的な方法です。ローカルシステムにおける
\&\fIreaddir\fR\|(3) 呼び出しを使用することとほぼ同様です。
.PP
\&\*(L"guestfs_find\*(R" と \*(L"guestfs_find0\*(R" は再帰的にファイルを一覧表示するために使用できます。
.SS "コマンドの実行法"
.IX Subsection "コマンドの実行法"
libguestfs はおもに仮想マシンの中にあるファイルを操作するための \s-1API\s0
です。さらに、仮想マシンの中にあるコマンドを実行するために、限定された機能がいくつかあります。
.PP
これには多くの制限があります:
.IP "\(bu" 4
コマンドを実行するカーネルのバージョンは、期待するものにより異なります。
.IP "\(bu" 4
コマンドがデーモンと通信する必要があれば、ほとんど動作しないでしょう。
.IP "\(bu" 4
コマンドは制限されたメモリーにおいて実行されます。
.IP "\(bu" 4
ネットワークは有効にしなければ利用できません（\*(L"guestfs_set_network\*(R" 参照）。
.IP "\(bu" 4
Linux ゲストのみがサポートされます（Windows, \s-1BSD\s0 など）。
.IP "\(bu" 4
アーキテクチャーの制限（例: x86 ホストにおいて \s-1PPC\s0 ゲストは動作しません）。
.IP "\(bu" 4
For SELinux guests, you may need to relabel the guest after creating new
files.  See \*(L"\s-1SELINUX\*(R"\s0 below.
.IP "\(bu" 4
\&\fISecurity:\fR It is not safe to run commands from untrusted, possibly
malicious guests.  These commands may attempt to exploit your program by
sending unexpected output.  They could also try to exploit the Linux kernel
or qemu provided by the libguestfs appliance.  They could use the network
provided by the libguestfs appliance to bypass ordinary network partitions
and firewalls.  They could use the elevated privileges or different SELinux
context of your program to their advantage.
.Sp
A secure alternative is to use libguestfs to install a \*(L"firstboot\*(R" script (a
script which runs when the guest next boots normally), and to have this
script run the commands you want in the normal context of the running guest,
network security and so on.  For information about other security issues,
see \fIguestfs\-security\fR\|(1).
.PP
The two main \s-1API\s0 calls to run commands are \*(L"guestfs_command\*(R" and
\&\*(L"guestfs_sh\*(R" (there are also variations).
.PP
The difference is that \*(L"guestfs_sh\*(R" runs commands using the shell, so any
shell globs, redirections, etc will work.
.SS "設定ファイル"
.IX Subsection "設定ファイル"
To read and write configuration files in Linux guest filesystems, we
strongly recommend using Augeas.  For example, Augeas understands how to
read and write, say, a Linux shadow password file or X.org configuration
file, and so avoids you having to write that code.
.PP
The main Augeas calls are bound through the \f(CW\*(C`guestfs_aug_*\*(C'\fR APIs.  We don't
document Augeas itself here because there is excellent documentation on the
http://augeas.net/ website.
.PP
If you don't want to use Augeas (you fool!) then try calling
\&\*(L"guestfs_read_lines\*(R" to get the file as a list of lines which you can
iterate over.
.SS "\s-1SYSTEMD JOURNAL FILES\s0"
.IX Subsection "SYSTEMD JOURNAL FILES"
To read the systemd journal from a Linux guest, use the \f(CW\*(C`guestfs_journal_*\*(C'\fR
APIs starting with \*(L"guestfs_journal_open\*(R".
.PP
Consult the journal documentation here: \fIsd\-journal\fR\|(3),
\&\fIsd_journal_open\fR\|(3).
.SS "SELinux"
.IX Subsection "SELinux"
We support SELinux guests.  However it is not possible to load the SELinux
policy of the guest into the appliance kernel.  Therefore the strategy for
dealing with SELinux guests is to relabel them after making changes.
.PP
In libguestfs ≥ 1.34 there is a new \s-1API,\s0 \*(L"guestfs_setfiles\*(R", which can
be used for this.  To properly use this \s-1API\s0 you have to parse the guest
SELinux configuration.  See the \fIvirt\-customize\fR\|(1) module
\&\fIcustomize/SELinux_relabel.ml\fR for how to do this.
.PP
A simpler but slower alternative is to touch \fI/.autorelabel\fR in the guest,
which means that the guest will relabel itself at next boot.
.PP
Libguestfs ≤ 1.32 had APIs \f(CW\*(C`guestfs_set_selinux\*(C'\fR,
\&\f(CW\*(C`guestfs_get_selinux\*(C'\fR, \f(CW\*(C`guestfs_setcon\*(C'\fR and \f(CW\*(C`guestfs_getcon\*(C'\fR.  These did
not work properly, are deprecated, and should not be used in new code.
.SS "umask"
.IX Subsection "umask"
Certain calls are affected by the current file mode creation mask (the
\&\*(L"umask\*(R").  In particular ones which create files or directories, such as
\&\*(L"guestfs_touch\*(R", \*(L"guestfs_mknod\*(R" or \*(L"guestfs_mkdir\*(R".  This affects
either the default mode that the file is created with or modifies the mode
that you supply.
.PP
umask の初期値は \f(CW022\fR です、そのためファイルは \f(CW0644\fR のようなモードで作成され、ディレクトリーは \f(CW0755\fR です。
.PP
umask による影響を避けるには 2 つの方法があります。1 つは umask を 0 に設定することです（開始後の早いうちに
\&\f(CW\*(C`guestfs_umask (g, 0)\*(C'\fR を呼び出します）。もう 1 つは各ファイルまたはディレクトリーを作成した後に
\&\*(L"guestfs_chmod\*(R" を呼び出すことです。
.PP
umask に関する詳細は \fIumask\fR\|(2) を参照してください。
.SS "\s-1LABELS AND UUIDS\s0"
.IX Subsection "LABELS AND UUIDS"
Many filesystems, devices and logical volumes support either labels (short
strings like \*(L"\s-1BOOT\*(R"\s0 which might not be unique) and/or UUIDs (globally unique
IDs).
.PP
For filesystems, use \*(L"guestfs_vfs_label\*(R" or \*(L"guestfs_vfs_uuid\*(R" to read
the label or \s-1UUID.\s0  Some filesystems let you call \*(L"guestfs_set_label\*(R" or
\&\*(L"guestfs_set_uuid\*(R" to change the label or \s-1UUID.\s0
.PP
You can locate a filesystem by its label or \s-1UUID\s0 using
\&\*(L"guestfs_findfs_label\*(R" or \*(L"guestfs_findfs_uuid\*(R".
.PP
For \s-1LVM2\s0 (which supports only UUIDs), there is a rich set of APIs for
fetching UUIDs, fetching UUIDs of the contained objects, and changing
UUIDs.  See: \*(L"guestfs_lvuuid\*(R", \*(L"guestfs_vguuid\*(R", \*(L"guestfs_pvuuid\*(R",
\&\*(L"guestfs_vglvuuids\*(R", \*(L"guestfs_vgpvuuids\*(R", \*(L"guestfs_vgchange_uuid\*(R",
\&\*(L"guestfs_vgchange_uuid_all\*(R", \*(L"guestfs_pvchange_uuid\*(R",
\&\*(L"guestfs_pvchange_uuid_all\*(R".
.PP
Note when cloning a filesystem, device or whole guest, it is a good idea to
set new randomly generated UUIDs on the copy.
.SS "暗号化ディスク"
.IX Subsection "暗号化ディスク"
Libguestfs allows you to access Linux guests which have been encrypted using
whole disk encryption that conforms to the Linux Unified Key Setup (\s-1LUKS\s0)
standard.  This includes nearly all whole disk encryption systems used by
modern Linux guests.
.PP
\&\s-1LUKS\s0 暗号化ブロックデバイス（それは文字列 \f(CW\*(C`crypto_LUKS\*(C'\fR を返します）を識別するには \*(L"guestfs_vfs_type\*(R"
を使用します。
.PP
そして \*(L"guestfs_luks_open\*(R" を呼び出すことにより、これらのデバイスを開きます。明示的にパスフレーズが必要です。
.PP
Opening a \s-1LUKS\s0 device creates a new device mapper device called
\&\fI/dev/mapper/mapname\fR (where \f(CW\*(C`mapname\*(C'\fR is the string you supply to
\&\*(L"guestfs_luks_open\*(R").  Reads and writes to this mapper device are
decrypted from and encrypted to the underlying block device respectively.
.PP
\&\s-1LVM\s0 volume groups on the device can be made visible by calling
\&\*(L"guestfs_vgscan\*(R" followed by \*(L"guestfs_vg_activate_all\*(R".  The logical
volume(s) can now be mounted in the usual way.
.PP
Use the reverse process to close a \s-1LUKS\s0 device.  Unmount any logical volumes
on it, deactivate the volume groups by calling \f(CW\*(C`guestfs_vg_activate (g, 0,
["/dev/VG"])\*(C'\fR.  Then close the mapper device by calling
\&\*(L"guestfs_luks_close\*(R" on the \fI/dev/mapper/mapname\fR device (\fInot\fR the
underlying encrypted block device).
.SS "\s-1MOUNT LOCAL\s0"
.IX Subsection "MOUNT LOCAL"
In libguestfs ≥ 1.18, it is possible to mount the libguestfs filesystem
on a local directory and access it using ordinary \s-1POSIX\s0 calls and programs.
.PP
Availability of this is subject to a number of restrictions: it requires
\&\s-1FUSE\s0 (the Filesystem in USErspace), and libfuse must also have been
available when libguestfs was compiled.  \s-1FUSE\s0 may require that a kernel
module is loaded, and it may be necessary to add the current user to a
special \f(CW\*(C`fuse\*(C'\fR group.  See the documentation for your distribution and
http://fuse.sf.net for further information.
.PP
The call to mount the libguestfs filesystem on a local directory is
\&\*(L"guestfs_mount_local\*(R" (q.v.) followed by \*(L"guestfs_mount_local_run\*(R".  The
latter does not return until you unmount the filesystem.  The reason is that
the call enters the \s-1FUSE\s0 main loop and processes kernel requests, turning
them into libguestfs calls.  An alternative design would have been to create
a background thread to do this, but libguestfs doesn't require pthreads.
This way is also more flexible: for example the user can create another
thread for \*(L"guestfs_mount_local_run\*(R".
.PP
\&\*(L"guestfs_mount_local\*(R" needs a certain amount of time to set up the
mountpoint.  The mountpoint is not ready to use until the call returns.  At
this point, accesses to the filesystem will block until the main loop is
entered (ie. \*(L"guestfs_mount_local_run\*(R").  So if you need to start another
process to access the filesystem, put the fork between
\&\*(L"guestfs_mount_local\*(R" and \*(L"guestfs_mount_local_run\*(R".
.PP
\fI\s-1MOUNT LOCAL COMPATIBILITY\s0\fR
.IX Subsection "MOUNT LOCAL COMPATIBILITY"
.PP
Since local mounting was only added in libguestfs 1.18, and may not be
available even in these builds, you should consider writing code so that it
doesn't depend on this feature, and can fall back to using libguestfs file
system calls.
.PP
If libguestfs was compiled without support for \*(L"guestfs_mount_local\*(R" then
calling it will return an error with errno set to \f(CW\*(C`ENOTSUP\*(C'\fR (see
\&\*(L"guestfs_last_errno\*(R").
.PP
\fI\s-1MOUNT LOCAL PERFORMANCE\s0\fR
.IX Subsection "MOUNT LOCAL PERFORMANCE"
.PP
Libguestfs on top of \s-1FUSE\s0 performs quite poorly.  For best performance do
not use it.  Use ordinary libguestfs filesystem calls, upload, download
etc. instead.
.SS "\s-1HOTPLUGGING\s0"
.IX Subsection "HOTPLUGGING"
In libguestfs ≥ 1.20, you may add drives and remove after calling
\&\*(L"guestfs_launch\*(R".  There are some restrictions, see below.  This is called
\&\fIhotplugging\fR.
.PP
Only a subset of the backends support hotplugging (currently only the
libvirt backend has support).  It also requires that you use libvirt ≥
0.10.3 and qemu ≥ 1.2.
.PP
To hot-add a disk, simply call \*(L"guestfs_add_drive_opts\*(R" after
\&\*(L"guestfs_launch\*(R".  It is mandatory to specify the \f(CW\*(C`label\*(C'\fR parameter so
that the newly added disk has a predictable name.  For example:
.PP
.Vb 2
\& if (guestfs_launch (g) == \-1)
\&   error ("launch failed");
\& 
\& if (guestfs_add_drive_opts (g, filename,
\&                             GUESTFS_ADD_DRIVE_OPTS_LABEL, "newdisk",
\&                             \-1) == \-1)
\&   error ("hot\-add of disk failed");
\& 
\& if (guestfs_part_disk ("/dev/disk/guestfs/newdisk", "mbr") == \-1)
\&   error ("partitioning of hot\-added disk failed");
.Ve
.PP
To hot-remove a disk, call \*(L"guestfs_remove_drive\*(R".  You can call this
before or after \*(L"guestfs_launch\*(R".  You can only remove disks that were
previously added with a label.
.PP
Backends that support hotplugging do not require that you add ≥ 1 disk
before calling launch.  When hotplugging is supported you don't need to add
any disks.
.SS "\s-1REMOTE STORAGE\s0"
.IX Subsection "REMOTE STORAGE"
\fI\s-1CEPH\s0\fR
.IX Subsection "CEPH"
.PP
Libguestfs can access Ceph (librbd/RBD) disks.
.PP
To do this, set the optional \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR parameters of
\&\*(L"guestfs_add_drive_opts\*(R" like this:
.PP
.Vb 8
\& char **servers = { "ceph1.example.org:3000", /* ... */, NULL };
\& guestfs_add_drive_opts (g, "pool/image",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "rbd",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         GUESTFS_ADD_DRIVE_OPTS_USERNAME, "rbduser",
\&                         GUESTFS_ADD_DRIVE_OPTS_SECRET, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
\&                         \-1);
.Ve
.PP
\&\f(CW\*(C`servers\*(C'\fR (the \f(CW\*(C`server\*(C'\fR parameter) is a list of one or more Ceph servers.
The server string is documented in \*(L"guestfs_add_drive_opts\*(R". The
\&\f(CW\*(C`username\*(C'\fR and \f(CW\*(C`secret\*(C'\fR parameters are also optional, and if not given,
then no authentication will be used.
.PP
\fI\s-1FTP, HTTP AND TFTP\s0\fR
.IX Subsection "FTP, HTTP AND TFTP"
.PP
Libguestfs can access remote disks over \s-1FTP, FTPS, HTTP, HTTPS\s0 or \s-1TFTP\s0
protocols.
.PP
To do this, set the optional \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR parameters of
\&\*(L"guestfs_add_drive_opts\*(R" like this:
.PP
.Vb 6
\& char **servers = { "www.example.org", NULL };
\& guestfs_add_drive_opts (g, "/disk.img",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "http",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         \-1);
.Ve
.PP
The \f(CW\*(C`protocol\*(C'\fR can be one of \f(CW"ftp"\fR, \f(CW"ftps"\fR, \f(CW"http"\fR, \f(CW"https"\fR or
\&\f(CW"tftp"\fR.
.PP
\&\f(CW\*(C`servers\*(C'\fR (the \f(CW\*(C`server\*(C'\fR parameter) is a list which must have a single
element.  The single element is a string defining the web, \s-1FTP\s0 or \s-1TFTP\s0
server.  The format of this string is documented in
\&\*(L"guestfs_add_drive_opts\*(R".
.PP
\fI\s-1GLUSTER\s0\fR
.IX Subsection "GLUSTER"
.PP
Libguestfs can access Gluster disks.
.PP
To do this, set the optional \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR parameters of
\&\*(L"guestfs_add_drive_opts\*(R" like this:
.PP
.Vb 6
\& char **servers = { "gluster.example.org:24007", NULL };
\& guestfs_add_drive_opts (g, "volname/image",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "gluster",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         \-1);
.Ve
.PP
\&\f(CW\*(C`servers\*(C'\fR (the \f(CW\*(C`server\*(C'\fR parameter) is a list which must have a single
element.  The single element is a string defining the Gluster server.  The
format of this string is documented in \*(L"guestfs_add_drive_opts\*(R".
.PP
Note that gluster usually requires the client process (ie. libguestfs)  to
run as \fBroot\fR and will give unfathomable errors if it is not (eg. \*(L"No data
available\*(R").
.PP
\fI\s-1ISCSI\s0\fR
.IX Subsection "ISCSI"
.PP
Libguestfs can access iSCSI disks remotely.
.PP
To do this, set the optional \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR parameters like this:
.PP
.Vb 6
\& char **server = { "iscsi.example.org:3000", NULL };
\& guestfs_add_drive_opts (g, "target\-iqn\-name/lun",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "iscsi",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
\&                         \-1);
.Ve
.PP
The \f(CW\*(C`server\*(C'\fR parameter is a list which must have a single element.  The
single element is a string defining the iSCSI server.  The format of this
string is documented in \*(L"guestfs_add_drive_opts\*(R".
.PP
\fI\s-1NETWORK BLOCK DEVICE\s0\fR
.IX Subsection "NETWORK BLOCK DEVICE"
.PP
Libguestfs can access Network Block Device (\s-1NBD\s0) disks remotely.
.PP
To do this, set the optional \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR parameters of
\&\*(L"guestfs_add_drive_opts\*(R" like this:
.PP
.Vb 6
\& char **server = { "nbd.example.org:3000", NULL };
\& guestfs_add_drive_opts (g, "" /* export name \- see below */,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "nbd",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
\&                         \-1);
.Ve
.PP
注:
.IP "\(bu" 4
\&\f(CW\*(C`server\*(C'\fR is in fact a list of servers.  For \s-1NBD\s0 you must always supply a
list with a single element.  (Other remote protocols require zero or more
than one server, hence the requirement for this parameter to be a list).
.IP "\(bu" 4
The \f(CW\*(C`server\*(C'\fR string is documented in \*(L"guestfs_add_drive_opts\*(R".  To
connect to a local qemu-nbd instance over a Unix domain socket, use
\&\f(CW"unix:/path/to/socket"\fR.
.IP "\(bu" 4
The \f(CW\*(C`filename\*(C'\fR parameter is the \s-1NBD\s0 export name.  Use an empty string to
mean the default export.  Many \s-1NBD\s0 servers, including qemu-nbd, do not
support export names.
.IP "\(bu" 4
If using qemu-nbd as your server, you should always specify the \f(CW\*(C`\-t\*(C'\fR
option.  The reason is that libguestfs may open several connections to the
server.
.IP "\(bu" 4
The libvirt backend requires that you set the \f(CW\*(C`format\*(C'\fR parameter of
\&\*(L"guestfs_add_drive_opts\*(R" accurately when you use writable \s-1NBD\s0 disks.
.IP "\(bu" 4
The libvirt backend has a bug that stops Unix domain socket connections from
working: https://bugzilla.redhat.com/show_bug.cgi?id=922888
.IP "\(bu" 4
The direct backend does not support readonly connections because of a bug in
qemu: https://bugs.launchpad.net/qemu/+bug/1155677
.PP
\fI\s-1SHEEPDOG\s0\fR
.IX Subsection "SHEEPDOG"
.PP
Libguestfs can access Sheepdog disks.
.PP
To do this, set the optional \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR parameters of
\&\*(L"guestfs_add_drive_opts\*(R" like this:
.PP
.Vb 6
\& char **servers = { /* optional servers ... */ NULL };
\& guestfs_add_drive_opts (g, "volume",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "sheepdog",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, servers,
\&                         \-1);
.Ve
.PP
The optional list of \f(CW\*(C`servers\*(C'\fR may be zero or more server addresses
(\f(CW"hostname:port"\fR).  The format of the server strings is documented in
\&\*(L"guestfs_add_drive_opts\*(R".
.PP
\fI\s-1SSH\s0\fR
.IX Subsection "SSH"
.PP
Libguestfs can access disks over a Secure Shell (\s-1SSH\s0) connection.
.PP
To do this, set the \f(CW\*(C`protocol\*(C'\fR and \f(CW\*(C`server\*(C'\fR and (optionally)  \f(CW\*(C`username\*(C'\fR
parameters of \*(L"guestfs_add_drive_opts\*(R" like this:
.PP
.Vb 7
\& char **server = { "remote.example.com", NULL };
\& guestfs_add_drive_opts (g, "/path/to/disk.img",
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "ssh",
\&                         GUESTFS_ADD_DRIVE_OPTS_SERVER, server,
\&                         GUESTFS_ADD_DRIVE_OPTS_USERNAME, "remoteuser",
\&                         \-1);
.Ve
.PP
The format of the server string is documented in \*(L"guestfs_add_drive_opts\*(R".
.SS "\s-1INSPECTION\s0"
.IX Subsection "INSPECTION"
Libguestfs has APIs for inspecting an unknown disk image to find out if it
contains operating systems, an install \s-1CD\s0 or a live \s-1CD.\s0
.PP
Add all disks belonging to the unknown virtual machine and call
\&\*(L"guestfs_launch\*(R" in the usual way.
.PP
Then call \*(L"guestfs_inspect_os\*(R".  This function uses other libguestfs calls
and certain heuristics, and returns a list of operating systems that were
found.  An empty list means none were found.  A single element is the root
filesystem of the operating system.  For dual\- or multi-boot guests,
multiple roots can be returned, each one corresponding to a separate
operating system.  (Multi-boot virtual machines are extremely rare in the
world of virtualization, but since this scenario can happen, we have built
libguestfs to deal with it.)
.PP
For each root, you can then call various \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR functions
to get additional details about that operating system.  For example, call
\&\*(L"guestfs_inspect_get_type\*(R" to return the string \f(CW\*(C`windows\*(C'\fR or \f(CW\*(C`linux\*(C'\fR for
Windows and Linux-based operating systems respectively.
.PP
Un*x\-like and Linux-based operating systems usually consist of several
filesystems which are mounted at boot time (for example, a separate boot
partition mounted on \fI/boot\fR).  The inspection rules are able to detect how
filesystems correspond to mount points.  Call
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR to get this mapping.  It might return a
hash table like this example:
.PP
.Vb 3
\& /boot => /dev/sda1
\& /     => /dev/vg_guest/lv_root
\& /usr  => /dev/vg_guest/lv_usr
.Ve
.PP
The caller can then make calls to \*(L"guestfs_mount\*(R" to mount the filesystems
as suggested.
.PP
Be careful to mount filesystems in the right order (eg. \fI/\fR before
\&\fI/usr\fR).  Sorting the keys of the hash by length, shortest first, should
work.
.PP
Inspection currently only works for some common operating systems.
Contributors are welcome to send patches for other operating systems that we
currently cannot detect.
.PP
暗号化ディスクは検査の前に開く必要があります。詳細は\*(L"暗号化ディスク\*(R"を参照してください。\*(L"guestfs_inspect_os\*(R"
関数はすべての暗号化デバイスを単に無視します。
.PP
A note on the implementation: The call \*(L"guestfs_inspect_os\*(R" performs
inspection and caches the results in the guest handle.  Subsequent calls to
\&\f(CW\*(C`guestfs_inspect_get_*\*(C'\fR return this cached information, but \fIdo not\fR
re-read the disks.  If you change the content of the guest disks, you can
redo inspection by calling \*(L"guestfs_inspect_os\*(R" again.
(\*(L"guestfs_inspect_list_applications2\*(R" works a little differently from the
other calls and does read the disks.  See documentation for that function
for details).
.PP
\fIインストールディスクの検査方法\fR
.IX Subsection "インストールディスクの検査方法"
.PP
libguestfs (1.9.4以降) は、いくつかのインストールディスク、インストール CD、live \s-1CD\s0 などを検知できます。
.PP
Call \*(L"guestfs_inspect_get_format\*(R" to return the format of the operating
system, which currently can be \f(CW\*(C`installed\*(C'\fR (a regular operating system) or
\&\f(CW\*(C`installer\*(C'\fR (some sort of install disk).
.PP
Further information is available about the operating system that can be
installed using the regular inspection APIs like
\&\*(L"guestfs_inspect_get_product_name\*(R", \*(L"guestfs_inspect_get_major_version\*(R"
etc.
.PP
インストールディスクに指定するいくつかの追加情報は \*(L"guestfs_inspect_is_live\*(R",
\&\*(L"guestfs_inspect_is_netinst\*(R" および \*(L"guestfs_inspect_is_multipart\*(R"
呼び出しからも取得可能です。
.SS "\s-1SPECIAL CONSIDERATIONS FOR WINDOWS GUESTS\s0"
.IX Subsection "SPECIAL CONSIDERATIONS FOR WINDOWS GUESTS"
libguestfs は \s-1NTFS\s0 パーティションをマウントできます。そのためには http://www.ntfs\-3g.org/
ドライバーを使用します。
.PP
\fIドライブレターとパス\fR
.IX Subsection "ドライブレターとパス"
.PP
\&\s-1DOS\s0 and Windows still use drive letters, and the filesystems are always
treated as case insensitive by Windows itself, and therefore you might find
a Windows configuration file referring to a path like
\&\f(CW\*(C`c:\ewindows\esystem32\*(C'\fR.  When the filesystem is mounted in libguestfs, that
directory might be referred to as \fI/WINDOWS/System32\fR.
.PP
Drive letter mappings can be found using inspection (see \*(L"\s-1INSPECTION\*(R"\s0 and
\&\*(L"guestfs_inspect_get_drive_mappings\*(R")
.PP
Dealing with separator characters (backslash vs forward slash) is outside
the scope of libguestfs, but usually a simple character replacement will
work.
.PP
To resolve the case insensitivity of paths, call
\&\*(L"guestfs_case_sensitive_path\*(R".
.PP
\fI\s-1LONG FILENAMES ON NTFS\s0\fR
.IX Subsection "LONG FILENAMES ON NTFS"
.PP
\&\s-1NTFS\s0 supports filenames up to 255 characters long.  \*(L"Character\*(R" means a 2
byte \s-1UTF\-16\s0 codepoint which can encode the most common Unicode codepoints.
.PP
Most Linux filesystems support filenames up to 255 \fIbytes\fR.  This means you
may get an error:
.PP
.Vb 1
\& File name too long
.Ve
.PP
when you copy a file from \s-1NTFS\s0 to a Linux filesystem if the name, when
reencoded as \s-1UTF\-8,\s0 would exceed 255 bytes in length.
.PP
This will most often happen when using non-ASCII names that are longer than
~127 characters (eg. Greek, Cyrillic) or longer than ~85 characters (Asian
languages).
.PP
A workaround is not to try to store such long filenames on Linux native
filesystems.  Since the \fItar\fR\|(1) format can store unlimited length
filenames, keep the files in a tarball.
.PP
\fIWindows レジストリのアクセス方法\fR
.IX Subsection "Windows レジストリのアクセス方法"
.PP
Libguestfs also provides some help for decoding Windows Registry \*(L"hive\*(R"
files, through a separate C library called \fIhivex\fR\|(3).
.PP
Before libguestfs 1.19.35 you had to download the hive file, operate on it
locally using hivex, and upload it again.  Since this version, we have
included the major hivex APIs directly in the libguestfs \s-1API\s0 (see
\&\*(L"guestfs_hivex_open\*(R").  This means that if you have opened a Windows
guest, you can read and write the registry directly.
.PP
\&\fIvirt\-win\-reg\fR\|(1) 参照。
.PP
\fI\s-1NTFS\-3G\s0 ファイルシステムにおけるシンボリックリンク\fR
.IX Subsection "NTFS-3G ファイルシステムにおけるシンボリックリンク"
.PP
Ntfs\-3g tries to rewrite \*(L"Junction Points\*(R" and \s-1NTFS\s0 \*(L"symbolic links\*(R" to
provide something which looks like a Linux symlink.  The way it tries to do
the rewriting is described here:
.PP
http://www.tuxera.com/community/ntfs\-3g\-advanced/junction\-points\-and\-symbolic\-links/
.PP
The essential problem is that ntfs\-3g simply does not have enough
information to do a correct job.  \s-1NTFS\s0 links can contain drive letters and
references to external device GUIDs that ntfs\-3g has no way of resolving.
It is almost certainly the case that libguestfs callers should ignore what
ntfs\-3g does (ie. don't use \*(L"guestfs_readlink\*(R" on \s-1NTFS\s0 volumes).
.PP
Instead if you encounter a symbolic link on an ntfs\-3g filesystem, use
\&\*(L"guestfs_lgetxattr\*(R" to read the \f(CW\*(C`system.ntfs_reparse_data\*(C'\fR extended
attribute, and read the raw reparse data from that (you can find the format
documented in various places around the web).
.PP
\fI\s-1EXTENDED ATTRIBUTES ON NTFS\-3G FILESYSTEMS\s0\fR
.IX Subsection "EXTENDED ATTRIBUTES ON NTFS-3G FILESYSTEMS"
.PP
There are other useful extended attributes that can be read from ntfs\-3g
filesystems (using \*(L"guestfs_getxattr\*(R").  See:
.PP
http://www.tuxera.com/community/ntfs\-3g\-advanced/extended\-attributes/
.PP
\fI\s-1WINDOWS HIBERNATION AND WINDOWS 8 FAST STARTUP\s0\fR
.IX Subsection "WINDOWS HIBERNATION AND WINDOWS 8 FAST STARTUP"
.PP
Windows guests which have been hibernated (instead of fully shut down)
cannot be mounted.  This is a limitation of ntfs\-3g.  You will see an error
like this:
.PP
.Vb 7
\& The disk contains an unclean file system (0, 0).
\& Metadata kept in Windows cache, refused to mount.
\& Failed to mount \*(Aq/dev/sda2\*(Aq: Operation not permitted
\& The NTFS partition is in an unsafe state. Please resume
\& and shutdown Windows fully (no hibernation or fast
\& restarting), or mount the volume read\-only with the
\& \*(Aqro\*(Aq mount option.
.Ve
.PP
Windows 8 では、シャットダウンボタンを押しても仮想マシンがシャットダウンしません。代わりに、仮想マシンが休止状態になります。これは
\&\*(L"高速スタートアップ\*(R" として知られています。
.PP
いくつかの推奨される回避策があります:
.IP "\(bu" 4
読み込み専用でマウントします (例: \*(L"guestfs_mount_ro\*(R")。
.IP "\(bu" 4
On Windows 8, turn off fast startup.  It is in the Control Panel → Power
Options → Choose what the power buttons do → Change settings that are
currently unavailable → Turn on fast startup.
.IP "\(bu" 4
On Windows 7 and earlier, shut the guest off properly instead of hibernating
it.
.SS "\s-1RESIZE2FS ERRORS\s0"
.IX Subsection "RESIZE2FS ERRORS"
The \*(L"guestfs_resize2fs\*(R", \*(L"guestfs_resize2fs_size\*(R" and
\&\*(L"guestfs_resize2fs_M\*(R" calls are used to resize ext2/3/4 filesystems.
.PP
The underlying program (\fIresize2fs\fR\|(8)) requires that the filesystem is
clean and recently fsck'd before you can resize it.  Also, if the resize
operation fails for some reason, then you had to call fsck the filesystem
again to fix it.
.PP
In libguestfs \f(CW\*(C`lt\*(C'\fR 1.17.14, you usually had to call \*(L"guestfs_e2fsck_f\*(R"
before the resize.  However, in \f(CW\*(C`ge\*(C'\fR 1.17.14, \fIe2fsck\fR\|(8) is called
automatically before the resize, so you no longer need to do this.
.PP
The \fIresize2fs\fR\|(8) program can still fail, in which case it prints an error
message similar to:
.PP
.Vb 2
\& 容量変更の操作を中断した後、ファイルシステムを
\& 修復するために \*(Aqe2fsck \-fy <device>\*(Aq を実行してください。
.Ve
.PP
You can do this by calling \*(L"guestfs_e2fsck\*(R" with the \f(CW\*(C`forceall\*(C'\fR option.
However in the context of disk images, it is usually better to avoid this
situation, eg. by rolling back to an earlier snapshot, or by copying and
resizing and on failure going back to the original.
.SS "\s-1USING LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES\s0"
.IX Subsection "USING LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES"
Although we don't want to discourage you from using the C \s-1API,\s0 we will
mention here that the same \s-1API\s0 is also available in other languages.
.PP
The \s-1API\s0 is broadly identical in all supported languages.  This means that
the C call \f(CW\*(C`guestfs_add_drive_ro(g,file)\*(C'\fR is \f(CW\*(C`$g\->add_drive_ro($file)\*(C'\fR
in Perl, \f(CW\*(C`g.add_drive_ro(file)\*(C'\fR in Python, and \f(CW\*(C`g#add_drive_ro file\*(C'\fR in
OCaml.  In other words, a straightforward, predictable isomorphism between
each language.
.PP
Error messages are automatically transformed into exceptions if the language
supports it.
.PP
We don't try to \*(L"object orientify\*(R" parts of the \s-1API\s0 in \s-1OO\s0 languages,
although contributors are welcome to write higher level APIs above what we
provide in their favourite languages if they wish.
.IP "\fB\*(C+\fR" 4
.IX Item ""
\&\*(C+ プログラムから \fIguestfs.h\fR ヘッダーファイルを使用できます。 \*(C+ \s-1API\s0 は C \s-1API\s0 と同一です。 \*(C+
のクラスと例外は使用されません。
.IP "\fBC#\fR" 4
.IX Item "C#"
The C# bindings are highly experimental.  Please read the warnings at the
top of \fIcsharp/Libguestfs.cs\fR.
.IP "\fBErlang\fR" 4
.IX Item "Erlang"
\&\fIguestfs\-erlang\fR\|(3) 参照。
.IP "\fBGObject\fR" 4
.IX Item "GObject"
Experimental GObject bindings (with GObject Introspection support) are
available.  See the \f(CW\*(C`gobject\*(C'\fR directory in the source.
.IP "\fBGo\fR" 4
.IX Item "Go"
See \fIguestfs\-golang\fR\|(3).
.IP "\fBHaskell\fR" 4
.IX Item "Haskell"
This language binding is working but incomplete:
.RS 4
.IP "\(bu" 4
Functions with optional arguments are not bound.  Implementing optional
arguments in Haskell seems to be very complex.
.IP "\(bu" 4
Events are not bound.
.IP "\(bu" 4
Functions with the following return types are not bound:
.RS 4
.IP "\(bu" 4
Any function returning a struct.
.IP "\(bu" 4
Any function returning a list of structs.
.IP "\(bu" 4
A few functions that return fixed length buffers (specifically ones declared
\&\f(CW\*(C`RBufferOut\*(C'\fR in the generator).
.IP "\(bu" 4
A tiny number of obscure functions that return constant strings
(specifically ones declared \f(CW\*(C`RConstOptString\*(C'\fR in the generator).
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\fBJava\fR" 4
.IX Item "Java"
Full documentation is contained in the Javadoc which is distributed with
libguestfs.  For examples, see \fIguestfs\-java\fR\|(3).
.IP "\fBLua\fR" 4
.IX Item "Lua"
\&\fIguestfs\-lua\fR\|(3) 参照。
.IP "\fBOCaml\fR" 4
.IX Item "OCaml"
\&\fIguestfs\-ocaml\fR\|(3) 参照。
.IP "\fBPerl\fR" 4
.IX Item "Perl"
\&\fIguestfs\-perl\fR\|(3) および \fISys::Guestfs\fR\|(3) 参照。
.IP "\fB\s-1PHP\s0\fR" 4
.IX Item "PHP"
For documentation see \f(CW\*(C`README\-PHP\*(C'\fR supplied with libguestfs sources or in
the php-libguestfs package for your distribution.
.Sp
\&\s-1PHP\s0 バインドは 64 ビットマシンにおいてのみ正しく動作します。
.IP "\fBPython\fR" 4
.IX Item "Python"
\&\fIguestfs\-python\fR\|(3) 参照。
.IP "\fBRuby\fR" 4
.IX Item "Ruby"
\&\fIguestfs\-ruby\fR\|(3) 参照。
.Sp
JRuby に対しては Java バインドを使用します。
.IP "\fBシェルスクリプト\fR" 4
.IX Item "シェルスクリプト"
\&\fIguestfish\fR\|(1) 参照。
.SS "\s-1LIBGUESTFS GOTCHAS\s0"
.IX Subsection "LIBGUESTFS GOTCHAS"
http://en.wikipedia.org/wiki/Gotcha_(programming): \*(L"A feature of a system
[...] that works in the way it is documented but is counterintuitive and
almost invites mistakes.\*(R"
.PP
Since we developed libguestfs and the associated tools, there are several
things we would have designed differently, but are now stuck with for
backwards compatibility or other reasons.  If there is ever a libguestfs 2.0
release, you can expect these to change.  Beware of them.
.IP "初期値は読み込み専用です。" 4
.IX Item "初期値は読み込み専用です。"
\&\fIguestfish\fR\|(3) では、 \fI\-\-ro\fR が初期値です。イメージを変更したいならば \fI\-\-rw\fR を指定する必要があります。
.Sp
これにより、動作中の仮想マシンのイメージを破壊する可能性を減らします。
.Sp
Note that many filesystems change the disk when you just mount and unmount,
even if you didn't perform any writes.  You need to use
\&\*(L"guestfs_add_drive_ro\*(R" to guarantee that the disk is not changed.
.IP "guestfish コマンドラインは使うのが難しいです。" 4
.IX Item "guestfish コマンドラインは使うのが難しいです。"
\&\fIguestfish disk.img\fR doesn't do what people expect (open \fIdisk.img\fR for
examination).  It tries to run a guestfish command \fIdisk.img\fR which doesn't
exist, so it fails.  In earlier versions of guestfish the error message was
also unintuitive, but we have corrected this since.  Like the Bourne shell,
we should have used \f(CW\*(C`guestfish \-c command\*(C'\fR to run commands.
.IP "guestfish megabyte modifiers don't work right on all commands" 4
.IX Item "guestfish megabyte modifiers don't work right on all commands"
In recent guestfish you can use \f(CW\*(C`1M\*(C'\fR to mean 1 megabyte (and similarly for
other modifiers).  What guestfish actually does is to multiply the number
part by the modifier part and pass the result to the C \s-1API.\s0  However this
doesn't work for a few APIs which aren't expecting bytes, but are already
expecting some other unit (eg. megabytes).
.Sp
最も一般的な \*(L"guestfs_lvcreate\*(R" です。 guestfish コマンド:
.Sp
.Vb 1
\& lvcreate LV VG 100M
.Ve
.Sp
does not do what you might expect.  Instead because \*(L"guestfs_lvcreate\*(R" is
already expecting megabytes, this tries to create a 100 \fIterabyte\fR (100
megabytes * megabytes) logical volume.  The error message you get from this
is also a little obscure.
.Sp
This could be fixed in the generator by specially marking parameters and
return values which take bytes or other units.
.IP "Ambiguity between devices and paths" 4
.IX Item "Ambiguity between devices and paths"
There is a subtle ambiguity in the \s-1API\s0 between a device name
(eg. \fI/dev/sdb2\fR) and a similar pathname.  A file might just happen to be
called \f(CW\*(C`sdb2\*(C'\fR in the directory \fI/dev\fR (consider some non-Unix \s-1VM\s0 image).
.Sp
In the current \s-1API\s0 we usually resolve this ambiguity by having two separate
calls, for example \*(L"guestfs_checksum\*(R" and \*(L"guestfs_checksum_device\*(R".
Some \s-1API\s0 calls are ambiguous and (incorrectly) resolve the problem by
detecting if the path supplied begins with \fI/dev/\fR.
.Sp
To avoid both the ambiguity and the need to duplicate some calls, we could
make paths/devices into structured names.  One way to do this would be to
use a notation like grub (\f(CW\*(C`hd(0,0)\*(C'\fR), although nobody really likes this
aspect of grub.  Another way would be to use a structured type, equivalent
to this OCaml type:
.Sp
.Vb 1
\& type path = Path of string | Device of int | Partition of int * int
.Ve
.Sp
which would allow you to pass arguments like:
.Sp
.Vb 4
\& Path "/foo/bar"
\& Device 1            (* /dev/sdb, または場合によると /dev/sda *)
\& Partition (1, 2)    (* /dev/sdb2 (または /dev/sda2 や /dev/sdb3?) *)
\& Path "/dev/sdb2"    (* デバイスではありません *)
.Ve
.Sp
As you can see there are still problems to resolve even with this
representation.  Also consider how it might work in guestfish.
.SS "キーとパスフレーズ"
.IX Subsection "キーとパスフレーズ"
特定の libguestfs 呼び出しは、C 文字列のように渡される、秘密を扱うキーの材料を含むパラメーターをとります。
.PP
In the future we would hope to change the libguestfs implementation so that
keys are \fImlock\fR\|(2)\-ed into physical \s-1RAM,\s0 and thus can never end up in
swap.  However this is \fInot\fR done at the moment, because of the complexity
of such an implementation.
.PP
Therefore you should be aware that any key parameter you pass to libguestfs
might end up being written out to the swap partition.  If this is a concern,
scrub the swap partition or don't use libguestfs on encrypted devices.
.SS "\s-1MULTIPLE HANDLES AND MULTIPLE THREADS\s0"
.IX Subsection "MULTIPLE HANDLES AND MULTIPLE THREADS"
All high-level libguestfs actions are synchronous.  If you want to use
libguestfs asynchronously then you must create a thread.
.PP
Only use the handle from a single thread.  Either use the handle exclusively
from one thread, or provide your own mutex so that two threads cannot issue
calls on the same handle at the same time.  Even apparently innocent
functions like \*(L"guestfs_get_trace\*(R" are \fInot\fR safe to be called from
multiple threads without a mutex.
.PP
See the graphical program guestfs-browser for one possible architecture for
multithreaded programs using libvirt and libguestfs.
.PP
Use \*(L"guestfs_set_identifier\*(R" to make it simpler to identify threads in
trace output.
.SS "パス"
.IX Subsection "パス"
Libguestfs needs a supermin appliance, which it finds by looking along an
internal path.
.PP
By default it looks for these in the directory \f(CW\*(C`$libdir/guestfs\*(C'\fR
(eg. \fI/usr/local/lib/guestfs\fR or \fI/usr/lib64/guestfs\fR).
.PP
Use \*(L"guestfs_set_path\*(R" or set the environment variable \*(L"\s-1LIBGUESTFS_PATH\*(R"\s0
to change the directories that libguestfs will search in.  The value is a
colon-separated list of paths.  The current directory is \fInot\fR searched
unless the path contains an empty element or \f(CW\*(C`.\*(C'\fR.  For example
\&\f(CW\*(C`LIBGUESTFS_PATH=:/usr/lib/guestfs\*(C'\fR would search the current directory and
then \fI/usr/lib/guestfs\fR.
.SS "\s-1QEMU\s0 ラッパー"
.IX Subsection "QEMU ラッパー"
自身の \s-1QEMU\s0 をコンパイルしたい、非標準の場所から \s-1QEMU\s0 を実行したい、または追加の引数を \s-1QEMU\s0 に渡したいならば、QEMU
のシェルスクリプト・ラッパーを書けます。
.PP
There is one important rule to remember: you \fImust \f(CI\*(C`exec qemu\*(C'\fI\fR as the
last command in the shell script (so that qemu replaces the shell and
becomes the direct child of the libguestfs-using program).  If you don't do
this, then the qemu process won't be cleaned up correctly.
.PP
Here is an example of a wrapper, where I have built my own copy of qemu from
source:
.PP
.Vb 3
\& #!/bin/sh \-
\& qemudir=/home/rjones/d/qemu
\& exec $qemudir/x86_64\-softmmu/qemu\-system\-x86_64 \-L $qemudir/pc\-bios "$@"
.Ve
.PP
Save this script as \fI/tmp/qemu.wrapper\fR (or wherever), \f(CW\*(C`chmod +x\*(C'\fR, and
then use it by setting the \s-1LIBGUESTFS_HV\s0 environment variable.  For example:
.PP
.Vb 1
\& LIBGUESTFS_HV=/tmp/qemu.wrapper guestfish
.Ve
.PP
Note that libguestfs also calls qemu with the \-help and \-version options in
order to determine features.
.PP
Wrappers can also be used to edit the options passed to qemu.  In the
following example, the \f(CW\*(C`\-machine ...\*(C'\fR option (\f(CW\*(C`\-machine\*(C'\fR and the following
argument) are removed from the command line and replaced with \f(CW\*(C`\-machine
pc,accel=tcg\*(C'\fR.  The while loop iterates over the options until it finds the
right one to remove, putting the remaining options into the \f(CW\*(C`args\*(C'\fR array.
.PP
.Vb 1
\& #!/bin/bash \-
\& 
\& i=0
\& while [ $# \-gt 0 ]; do
\&     case "$1" in
\&     \-machine)
\&         shift 2;;
\&     *)
\&         args[i]="$1"
\&         (( i++ ))
\&         shift ;;
\&     esac
\& done
\& 
\& exec qemu\-kvm \-machine pc,accel=tcg "${args[@]}"
.Ve
.SS "\s-1BACKEND\s0"
.IX Subsection "BACKEND"
The backend (previously known as the \*(L"attach method\*(R") controls how
libguestfs creates and/or connects to the backend daemon, eg. by starting
qemu directly, or using libvirt to manage an appliance, running User-Mode
Linux, or connecting to an already running daemon.
.PP
You can set the backend by calling \*(L"guestfs_set_backend\*(R", or by setting
the environment variable \f(CW\*(C`LIBGUESTFS_BACKEND\*(C'\fR.
.PP
Possible backends are described below:
.ie n .IP """direct""" 4
.el .IP "\f(CWdirect\fR" 4
.IX Item "direct"
.PD 0
.ie n .IP """appliance""" 4
.el .IP "\f(CWappliance\fR" 4
.IX Item "appliance"
.PD
Run qemu directly to launch an appliance.
.Sp
\&\f(CW\*(C`direct\*(C'\fR and \f(CW\*(C`appliance\*(C'\fR are synonyms.
.Sp
This is the ordinary method and normally the default, but see the note
below.
.ie n .IP """libvirt""" 4
.el .IP "\f(CWlibvirt\fR" 4
.IX Item "libvirt"
.PD 0
.ie n .IP """libvirt:null""" 4
.el .IP "\f(CWlibvirt:null\fR" 4
.IX Item "libvirt:null"
.ie n .IP """libvirt:\fIURI\fP""" 4
.el .IP "\f(CWlibvirt:\f(CIURI\f(CW\fR" 4
.IX Item "libvirt:URI"
.PD
Use libvirt to launch and manage the appliance.
.Sp
\&\f(CW\*(C`libvirt\*(C'\fR causes libguestfs to choose a suitable \s-1URI\s0 for creating session
guests.  If using the libvirt backend, you almost always should use this.
.Sp
\&\f(CW\*(C`libvirt:null\*(C'\fR causes libguestfs to use the \f(CW\*(C`NULL\*(C'\fR connection \s-1URI,\s0 which
causes libvirt to try to guess what the user meant.  You probably don't want
to use this.
.Sp
\&\f(CW\*(C`libvirt:\f(CIURI\f(CW\*(C'\fR uses \fI\s-1URI\s0\fR as the libvirt connection \s-1URI\s0 (see
http://libvirt.org/uri.html).  The typical libvirt backend with a \s-1URI\s0
would be \f(CW\*(C`libvirt:qemu:///session\*(C'\fR
.Sp
The libvirt backend supports more features, including hotplugging (see
\&\*(L"\s-1HOTPLUGGING\*(R"\s0) and sVirt.
.ie n .IP """uml""" 4
.el .IP "\f(CWuml\fR" 4
.IX Item "uml"
Run the User-Mode Linux kernel.  The location of the kernel is set using
\&\f(CW$LIBGUESTFS_HV\fR or using the \*(L"guestfs_set_qemu\*(R" \s-1API\s0 (note that qemu is
not involved, we just reuse the same variable in the handle for
convenience).
.Sp
User-Mode Linux can be much faster, simpler and more lightweight than using
a full-blown virtual machine, but it also has some shortcomings.  See
\&\*(L"USER-MODE \s-1LINUX BACKEND\*(R"\s0 below.
.ie n .IP """unix:\fIpath\fP""" 4
.el .IP "\f(CWunix:\f(CIpath\f(CW\fR" 4
.IX Item "unix:path"
Unix ドメイン・ソケット \fIpath\fR に接続します。
.Sp
This method lets you connect to an existing daemon or (using virtio-serial)
to a live guest.  For more information, see \*(L"\s-1ATTACHING TO RUNNING
DAEMONS\*(R"\s0.
.PP
\&\f(CW\*(C`direct\*(C'\fR is usually the default backend.  However since libguestfs ≥
1.19.24, libguestfs can be built with a different default by doing:
.PP
.Vb 1
\& ./configure \-\-with\-default\-backend=...
.Ve
.PP
To find out if libguestfs was compiled with a different default backend, do:
.PP
.Vb 2
\& unset LIBGUESTFS_BACKEND
\& guestfish get\-backend
.Ve
.SS "\s-1BACKEND SETTINGS\s0"
.IX Subsection "BACKEND SETTINGS"
Each backend can be configured by passing a list of strings.  You can either
call \*(L"guestfs_set_backend_settings\*(R" with a list of strings, or set the
\&\f(CW\*(C`LIBGUESTFS_BACKEND_SETTINGS\*(C'\fR environment variable to a colon-separated
list of strings (before creating the handle).
.PP
\fIforce_tcg\fR
.IX Subsection "force_tcg"
.PP
Using:
.PP
.Vb 1
\& export LIBGUESTFS_BACKEND_SETTINGS=force_tcg
.Ve
.PP
will force the direct and libvirt backends to use \s-1TCG\s0 (software emulation)
instead of \s-1KVM\s0 (hardware accelerated virtualization).
.PP
\fIgdb\fR
.IX Subsection "gdb"
.PP
The direct backend supports:
.PP
.Vb 1
\& export LIBGUESTFS_BACKEND_SETTINGS=gdb
.Ve
.PP
When this is set, qemu will not start running the appliance immediately.  It
will wait for you to connect to it using gdb:
.PP
.Vb 4
\& $ gdb
\& (gdb) symbol\-file /path/to/vmlinux
\& (gdb) target remote tcp::1234
\& (gdb) cont
.Ve
.PP
You can then debug the appliance kernel, which is useful to debug boot
failures (especially ones where there are no debug messages printed \- tip:
look in the kernel \f(CW\*(C`log_buf\*(C'\fR).
.PP
On Fedora, install \f(CW\*(C`kernel\-debuginfo\*(C'\fR for the \f(CW\*(C`vmlinux\*(C'\fR file (containing
symbols).  Make sure the symbols precisely match the kernel being used.
.PP
\fInetwork_bridge\fR
.IX Subsection "network_bridge"
.PP
The libvirt backend supports:
.PP
.Vb 1
\& export LIBGUESTFS_BACKEND_SETTINGS=network_bridge=virbrX
.Ve
.PP
This allows you to override the bridge that is connected to when the network
is enabled.  The default is \f(CW\*(C`virbr0\*(C'\fR.  See also \*(L"guestfs_set_network\*(R".
.SS "\s-1ATTACHING TO RUNNING DAEMONS\s0"
.IX Subsection "ATTACHING TO RUNNING DAEMONS"
\&\fINote (1):\fR This is \fBhighly experimental\fR and has a tendency to eat
babies.  Use with caution.
.PP
\&\fINote (2):\fR This section explains how to attach to a running daemon from a
low level perspective.  For most users, simply using virt tools such as
\&\fIguestfish\fR\|(1) with the \fI\-\-live\fR option will \*(L"just work\*(R".
.PP
\fIUsing guestfs_set_backend\fR
.IX Subsection "Using guestfs_set_backend"
.PP
By calling \*(L"guestfs_set_backend\*(R" you can change how the library connects
to the \f(CW\*(C`guestfsd\*(C'\fR daemon in \*(L"guestfs_launch\*(R" (read
\&\*(L"\s-1ARCHITECTURE\*(R"\s0 in \fIguestfs\-internals\fR\|(1) for some background).
.PP
The normal backend is \f(CW\*(C`direct\*(C'\fR, where a small appliance is created
containing the daemon, and then the library connects to this.  \f(CW\*(C`libvirt\*(C'\fR or
\&\f(CW\*(C`libvirt:\f(CIURI\f(CW\*(C'\fR are alternatives that use libvirt to start the appliance.
.PP
Setting the backend to \f(CW\*(C`unix:\f(CIpath\f(CW\*(C'\fR (where \fIpath\fR is the path of a Unix
domain socket) causes \*(L"guestfs_launch\*(R" to connect to an existing daemon
over the Unix domain socket.
.PP
The normal use for this is to connect to a running virtual machine that
contains a \f(CW\*(C`guestfsd\*(C'\fR daemon, and send commands so you can read and write
files inside the live virtual machine.
.PP
\fIlive フラグを用いた guestfs_add_domain の使用方法\fR
.IX Subsection "live フラグを用いた guestfs_add_domain の使用方法"
.PP
\&\*(L"guestfs_add_domain\*(R" provides some help for getting the correct backend.
If you pass the \f(CW\*(C`live\*(C'\fR option to this function, then (if the virtual
machine is running) it will examine the libvirt \s-1XML\s0 looking for a
virtio-serial channel to connect to:
.PP
.Vb 11
\& <domain>
\&   ...
\&   <devices>
\&     ...
\&     <channel type=\*(Aqunix\*(Aq>
\&       <source mode=\*(Aqbind\*(Aq path=\*(Aq/path/to/socket\*(Aq/>
\&       <target type=\*(Aqvirtio\*(Aq name=\*(Aqorg.libguestfs.channel.0\*(Aq/>
\&     </channel>
\&     ...
\&   </devices>
\& </domain>
.Ve
.PP
\&\*(L"guestfs_add_domain\*(R" extracts \fI/path/to/socket\fR and sets the backend to
\&\f(CW\*(C`unix:/path/to/socket\*(C'\fR.
.PP
Some of the libguestfs tools (including guestfish) support a \fI\-\-live\fR
option which is passed through to \*(L"guestfs_add_domain\*(R" thus allowing you
to attach to and modify live virtual machines.
.PP
The virtual machine needs to have been set up beforehand so that it has the
virtio-serial channel and so that guestfsd is running inside it.
.SS "USER-MODE \s-1LINUX BACKEND\s0"
.IX Subsection "USER-MODE LINUX BACKEND"
Setting the following environment variables (or the equivalent in the \s-1API\s0)
selects the User-Mode Linux backend:
.PP
.Vb 2
\& export LIBGUESTFS_BACKEND=uml
\& export LIBGUESTFS_HV=/path/to/vmlinux
.Ve
.PP
\&\f(CW\*(C`vmlinux\*(C'\fR (or it may be called \f(CW\*(C`linux\*(C'\fR) is the Linux binary, compiled to
run as a userspace process.  Note that we reuse the qemu variable in the
handle for convenience; qemu is not involved.
.PP
User-Mode Linux can be faster and more lightweight than running a full-blown
virtual machine as the backend (especially if you are already running
libguestfs in a virtual machine or cloud instance), but it also has some
shortcomings compared to the usual qemu/KVM\-based backend.
.PP
\fI\s-1BUILDING\s0 USER-MODE \s-1LINUX FROM SOURCE\s0\fR
.IX Subsection "BUILDING USER-MODE LINUX FROM SOURCE"
.PP
Your Linux distro may provide \s-1UML\s0 in which case you can ignore this section.
.PP
These instructions are adapted from:
http://user\-mode\-linux.sourceforge.net/source.html
.IP "1. Check out Linux sources" 4
.IX Item "1. Check out Linux sources"
Clone the Linux git repository or download the Linux source tarball.
.IP "2. Configure the kernel" 4
.IX Item "2. Configure the kernel"
\&\fBNote:\fR All 'make' commands must have \f(CW\*(C`ARCH=um\*(C'\fR added.
.Sp
.Vb 1
\& make menuconfig ARCH=um
.Ve
.Sp
Make sure any filesystem drivers that you need are compiled into the kernel.
.Sp
\&\fBCurrently, it needs a large amount of extra work to get modules working\fR.
It's recommended that you disable module support in the kernel
configuration, which will cause everything to be compiled into the image.
.IP "3. Build the kernel" 4
.IX Item "3. Build the kernel"
.Vb 1
\& make ARCH=um
.Ve
.Sp
This will leave a file called \f(CW\*(C`linux\*(C'\fR or \f(CW\*(C`vmlinux\*(C'\fR in the top-level
directory.  This is the \s-1UML\s0 kernel.  You should set \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR to
point to this file.
.PP
\fIUSER-MODE \s-1LINUX DIFFERENCES FROM KVM\s0\fR
.IX Subsection "USER-MODE LINUX DIFFERENCES FROM KVM"
.IP "\s-1UML\s0 only supports raw-format images" 4
.IX Item "UML only supports raw-format images"
Only plain raw-format images will work.  No qcow2, no backing files.
.IP "\s-1UML\s0 does not support any remote drives" 4
.IX Item "UML does not support any remote drives"
No \s-1NBD,\s0 etc.
.IP "\s-1UML\s0 only works on ix86 and x86\-64" 4
.IX Item "UML only works on ix86 and x86-64"
.PD 0
.IP "\s-1UML\s0 is experimental" 4
.IX Item "UML is experimental"
.PD
In particular, support for \s-1UML\s0 in libguestfs depends on support for \s-1UML\s0 in
the upstream kernel.  If \s-1UML\s0 was ever removed from the upstream Linux
kernel, then we might remove it from libguestfs too.
.SS "\s-1ABI\s0 保証"
.IX Subsection "ABI 保証"
We guarantee the libguestfs \s-1ABI\s0 (binary interface), for public, high-level
actions as outlined in this section.  Although we will deprecate some
actions, for example if they get replaced by newer calls, we will keep the
old actions forever.  This allows you the developer to program in confidence
against the libguestfs \s-1API.\s0
.SS "ブロックデバイスの命名法"
.IX Subsection "ブロックデバイスの命名法"
In the kernel there is now quite a profusion of schemata for naming block
devices (in this context, by \fIblock device\fR I mean a physical or virtual
hard drive).  The original Linux \s-1IDE\s0 driver used names starting with
\&\fI/dev/hd*\fR.  \s-1SCSI\s0 devices have historically used a different naming scheme,
\&\fI/dev/sd*\fR.  When the Linux kernel \fIlibata\fR driver became a popular
replacement for the old \s-1IDE\s0 driver (particularly for \s-1SATA\s0 devices) those
devices also used the \fI/dev/sd*\fR scheme.  Additionally we now have virtual
machines with paravirtualized drivers.  This has created several different
naming systems, such as \fI/dev/vd*\fR for virtio disks and \fI/dev/xvd*\fR for
Xen \s-1PV\s0 disks.
.PP
As discussed above, libguestfs uses a qemu appliance running an embedded
Linux kernel to access block devices.  We can run a variety of appliances
based on a variety of Linux kernels.
.PP
This causes a problem for libguestfs because many \s-1API\s0 calls use device or
partition names.  Working scripts and the recipe (example) scripts that we
make available over the internet could fail if the naming scheme changes.
.PP
Therefore libguestfs defines \fI/dev/sd*\fR as the \fIstandard naming scheme\fR.
Internally \fI/dev/sd*\fR names are translated, if necessary, to other names as
required.  For example, under \s-1RHEL 5\s0 which uses the \fI/dev/hd*\fR scheme, any
device parameter \fI/dev/sda2\fR is translated to \fI/dev/hda2\fR transparently.
.PP
Note that this \fIonly\fR applies to parameters.  The \*(L"guestfs_list_devices\*(R",
\&\*(L"guestfs_list_partitions\*(R" and similar calls return the true names of the
devices and partitions as known to the appliance, but see
\&\*(L"guestfs_canonical_device_name\*(R".
.PP
\fIディスクラベル\fR
.IX Subsection "ディスクラベル"
.PP
In libguestfs ≥ 1.20, you can give a label to a disk when you add it,
using the optional \f(CW\*(C`label\*(C'\fR parameter to \*(L"guestfs_add_drive_opts\*(R".  (Note
that disk labels are different from and not related to filesystem labels).
.PP
Not all versions of libguestfs support setting a disk label, and when it is
supported, it is limited to 20 \s-1ASCII\s0 characters \f(CW\*(C`[a\-zA\-Z]\*(C'\fR.
.PP
When you add a disk with a label, it can either be addressed using
\&\fI/dev/sd*\fR, or using \fI/dev/disk/guestfs/\fIlabel\fI\fR.  Partitions on the disk
can be addressed using \fI/dev/disk/guestfs/\fIlabel\fI\fIpartnum\fI\fR.
.PP
Listing devices (\*(L"guestfs_list_devices\*(R") and partitions
(\*(L"guestfs_list_partitions\*(R") returns the raw block device name.  However
you can use \*(L"guestfs_list_disk_labels\*(R" to map disk labels to raw block
device and partition names.
.PP
\fI\s-1ALGORITHM FOR BLOCK DEVICE NAME TRANSLATION\s0\fR
.IX Subsection "ALGORITHM FOR BLOCK DEVICE NAME TRANSLATION"
.PP
Usually this translation is transparent.  However in some (very rare)  cases
you may need to know the exact algorithm.  Such cases include where you use
\&\*(L"guestfs_config\*(R" to add a mixture of virtio and \s-1IDE\s0 devices to the
qemu-based appliance, so have a mixture of \fI/dev/sd*\fR and \fI/dev/vd*\fR
devices.
.PP
The algorithm is applied only to \fIparameters\fR which are known to be either
device or partition names.  Return values from functions such as
\&\*(L"guestfs_list_devices\*(R" are never changed.
.IP "\(bu" 4
Is the string a parameter which is a device or partition name?
.IP "\(bu" 4
Does the string begin with \fI/dev/sd\fR?
.IP "\(bu" 4
名前付きのデバイスが存在しますか？そうならば、そのデバイスを使用します。しかし、そうで \fIなければ\fR 、この手順を続けます。
.IP "\(bu" 4
Replace initial \fI/dev/sd\fR string with \fI/dev/hd\fR.
.Sp
For example, change \fI/dev/sda2\fR to \fI/dev/hda2\fR.
.Sp
名前付きデバイスが存在すれば、それを使用します。なければ、続けます。
.IP "\(bu" 4
Replace initial \fI/dev/sd\fR string with \fI/dev/vd\fR.
.Sp
名前付きデバイスが存在すれば、それを使用します。なければ、エラーを返します。
.PP
\fI\s-1PORTABILITY CONCERNS WITH BLOCK DEVICE NAMING\s0\fR
.IX Subsection "PORTABILITY CONCERNS WITH BLOCK DEVICE NAMING"
.PP
Although the standard naming scheme and automatic translation is useful for
simple programs and guestfish scripts, for larger programs it is best not to
rely on this mechanism.
.PP
Where possible for maximum future portability programs using libguestfs
should use these future-proof techniques:
.IP "\(bu" 4
実際のデバイス名を一覧表示するには \*(L"guestfs_list_devices\*(R" または \*(L"guestfs_list_partitions\*(R"
を使用します。そして、それらの名前を直接使用します。
.Sp
それらのデバイス名が定義により存在しているので、それらは変換されません。
.IP "\(bu" 4
\&\s-1LVM\s0 名、UUID およびファイルシステムのラベルのように、ファイルシステムを識別するための高レベルの方法を使用します。
.SS "\s-1NULL DISKS\s0"
.IX Subsection "NULL DISKS"
When adding a disk using, eg., \*(L"guestfs_add_drive\*(R", you can set the
filename to \f(CW"/dev/null"\fR.  This string is treated specially by libguestfs,
causing it to add a \*(L"null disk\*(R".
.PP
A null disk has the following properties:
.IP "\(bu" 4
A null disk will appear as a normal device, eg. in calls to
\&\*(L"guestfs_list_devices\*(R".
.IP "\(bu" 4
You may add \f(CW"/dev/null"\fR multiple times.
.IP "\(bu" 4
You should not try to access a null disk in any way.  For example, you
shouldn't try to read it or mount it.
.PP
Null disks are used for three main purposes:
.IP "1." 4
Performance testing of libguestfs (see \fIguestfs\-performance\fR\|(1)).
.IP "2." 4
The internal test suite.
.IP "3." 4
If you want to use libguestfs APIs that don't refer to disks, since
libguestfs requires that at least one disk is added, you should add a null
disk.
.Sp
たとえば、機能が利用可能であるかを確認するために、このようなコードを使用します:
.Sp
.Vb 2
\& guestfs_h *g;
\& char **groups = [ "btrfs", NULL ];
\& 
\& g = guestfs_create ();
\& guestfs_add_drive (g, "/dev/null");
\& guestfs_launch (g);
\& if (guestfs_available (g, groups) == 0) {
\&   // group(s) are available
\& } else {
\&   // group(s) are not available
\& }
\& guestfs_close (g);
.Ve
.SS "\s-1DISK IMAGE FORMATS\s0"
.IX Subsection "DISK IMAGE FORMATS"
Virtual disks come in a variety of formats.  Some common formats are listed
below.
.PP
Note that libguestfs itself is not responsible for handling the disk format:
this is done using \fIqemu\fR\|(1).  If support for a particular format is
missing or broken, this has to be fixed in qemu.
.PP
\fI\s-1COMMON VIRTUAL DISK IMAGE FORMATS\s0\fR
.IX Subsection "COMMON VIRTUAL DISK IMAGE FORMATS"
.IP "\fIraw\fR" 4
.IX Item "raw"
Raw format is simply a dump of the sequential bytes of the virtual hard
disk.  There is no header, container, compression or processing of any sort.
.Sp
Since raw format requires no translation to read or write, it is both fast
and very well supported by qemu and all other hypervisors.  You can consider
it to be a universal format that any hypervisor can access.
.Sp
Raw format files are not compressed and so take up the full space of the
original disk image even when they are empty.  A variation (on Linux/Unix at
least) is to not store ranges of all-zero bytes by storing the file as a
sparse file.  This \*(L"variant format\*(R" is sometimes called \fIraw sparse\fR.  Many
utilities, including \fIvirt\-sparsify\fR\|(1), can make raw disk images sparse.
.IP "\fIqcow2\fR" 4
.IX Item "qcow2"
Qcow2 is the native disk image format used by qemu.  Internally it uses a
two-level directory structure so that only blocks containing data are stored
in the file.  It also has many other features such as compression, snapshots
and backing files.
.Sp
There are at least two distinct variants of this format, although qemu (and
hence libguestfs) handles both transparently to the user.
.IP "\fIvmdk\fR" 4
.IX Item "vmdk"
\&\s-1VMDK\s0 is VMware's native disk image format.  There are many variations.
Modern qemu (hence libguestfs) supports most variations, but you should be
aware that older versions of qemu had some very bad data-corrupting bugs in
this area.
.Sp
Note that VMware \s-1ESX\s0 exposes files with the name \fIguest\-flat.vmdk\fR.  These
are not \s-1VMDK.\s0  They are raw format files which happen to have a \f(CW\*(C`.vmdk\*(C'\fR
extension.
.IP "\fIvdi\fR" 4
.IX Item "vdi"
\&\s-1VDI\s0 は VirtualBox のネイティブなディスクイメージ形式です。QEMU (つまり libguestfs)
は全体的にこれをよくサポートしています。
.IP "\fIvpc\fR" 4
.IX Item "vpc"
.PD 0
.IP "\fIvhd\fR" 4
.IX Item "vhd"
.PD
\&\s-1VPC\s0 (旧) と \s-1VHD\s0 (新) は Microsoft (および、以前の Connectix) Virtual \s-1PC\s0 および Hyper-V
のネイティブなディスクイメージ形式です。
.IP "推奨されない形式" 4
.IX Item "推奨されない形式"
The following formats are obsolete and should not be used: \fIqcow\fR (aka
\&\fIqcow1\fR), \fIcow\fR, \fIbochs\fR.
.PP
\fI\s-1DETECTING THE FORMAT OF A DISK IMAGE\s0\fR
.IX Subsection "DETECTING THE FORMAT OF A DISK IMAGE"
.PP
Firstly note there is a security issue with auto-detecting the format of a
disk image.  It may or may not apply in your use case.  Read
\&\*(L"\s-1CVE\-2010\-3851\*(R"\s0 below.
.PP
Libguestfs offers an \s-1API\s0 to get the format of a disk image
(\*(L"guestfs_disk_format\*(R", and it is safest to use this.
.PP
\&\fIDon't\fR be tempted to try parsing the text / human-readable output of
\&\f(CW\*(C`qemu\-img\*(C'\fR since it cannot be parsed reliably and securely.  Also do not
use the \f(CW\*(C`file\*(C'\fR command since the output of that changes over time.
.SH "CONNECTION MANAGEMENT"
.IX Header "CONNECTION MANAGEMENT"
.SS "guestfs_h *"
.IX Subsection "guestfs_h *"
\&\f(CW\*(C`guestfs_h\*(C'\fR is the opaque type representing a connection handle.  Create a
handle by calling \*(L"guestfs_create\*(R" or \*(L"guestfs_create_flags\*(R".  Call
\&\*(L"guestfs_close\*(R" to free the handle and release all resources used.
.PP
For information on using multiple handles and threads, see the section
\&\*(L"\s-1MULTIPLE HANDLES AND MULTIPLE THREADS\*(R"\s0 above.
.SS "guestfs_create"
.IX Subsection "guestfs_create"
.Vb 1
\& guestfs_h *guestfs_create (void);
.Ve
.PP
接続ハンドルを作成します。
.PP
On success this returns a non-NULL pointer to a handle.  On error it returns
\&\s-1NULL.\s0
.PP
You have to \*(L"configure\*(R" the handle after creating it.  This includes calling
\&\*(L"guestfs_add_drive_opts\*(R" (or one of the equivalent calls) on the handle at
least once.
.PP
ハンドルを設定後、 \*(L"guestfs_launch\*(R" を呼び出す必要があります。
.PP
You may also want to configure error handling for the handle.  See the
\&\*(L"\s-1ERROR HANDLING\*(R"\s0 section below.
.SS "guestfs_create_flags"
.IX Subsection "guestfs_create_flags"
.Vb 1
\& guestfs_h *guestfs_create_flags (unsigned flags [, ...]);
.Ve
.PP
Create a connection handle, supplying extra flags and extra arguments to
control how the handle is created.
.PP
On success this returns a non-NULL pointer to a handle.  On error it returns
\&\s-1NULL.\s0
.PP
\&\*(L"guestfs_create\*(R" is equivalent to calling \f(CWguestfs_create_flags(0)\fR.
.PP
The following flags may be logically ORed together.  (Currently no extra
arguments are used).
.ie n .IP """GUESTFS_CREATE_NO_ENVIRONMENT""" 4
.el .IP "\f(CWGUESTFS_CREATE_NO_ENVIRONMENT\fR" 4
.IX Item "GUESTFS_CREATE_NO_ENVIRONMENT"
Don't parse any environment variables (such as \f(CW\*(C`LIBGUESTFS_DEBUG\*(C'\fR etc).
.Sp
You can call \*(L"guestfs_parse_environment\*(R" or
\&\*(L"guestfs_parse_environment_list\*(R" afterwards to parse environment
variables.  Alternately, \fIdon't\fR call these functions if you want the
handle to be unaffected by environment variables.  See the example below.
.Sp
The default (if this flag is not given) is to implicitly call
\&\*(L"guestfs_parse_environment\*(R".
.ie n .IP """GUESTFS_CREATE_NO_CLOSE_ON_EXIT""" 4
.el .IP "\f(CWGUESTFS_CREATE_NO_CLOSE_ON_EXIT\fR" 4
.IX Item "GUESTFS_CREATE_NO_CLOSE_ON_EXIT"
Don't try to close the handle in an \fIatexit\fR\|(3) handler if the program
exits without explicitly closing the handle.
.Sp
The default (if this flag is not given) is to install such an atexit
handler.
.PP
\fI\f(CI\*(C`GUESTFS_CREATE_NO_ENVIRONMENT\*(C'\fI の使用法\fR
.IX Subsection "GUESTFS_CREATE_NO_ENVIRONMENT の使用法"
.PP
You might use \f(CW\*(C`GUESTFS_CREATE_NO_ENVIRONMENT\*(C'\fR and an explicit call to
\&\*(L"guestfs_parse_environment\*(R" like this:
.PP
.Vb 2
\& guestfs_h *g;
\& int r;
\& 
\& g = guestfs_create_flags (GUESTFS_CREATE_NO_ENVIRONMENT);
\& if (!g) {
\&   perror ("guestfs_create_flags");
\&   exit (EXIT_FAILURE);
\& }
\& r = guestfs_parse_environment (g);
\& if (r == \-1)
\&   exit (EXIT_FAILURE);
.Ve
.PP
Or to create a handle which is unaffected by environment variables, omit the
call to \f(CW\*(C`guestfs_parse_environment\*(C'\fR from the above code.
.PP
The above code has another advantage which is that any errors from parsing
the environment are passed through the error handler, whereas
\&\f(CW\*(C`guestfs_create\*(C'\fR prints errors on stderr and ignores them.
.SS "guestfs_close"
.IX Subsection "guestfs_close"
.Vb 1
\& void guestfs_close (guestfs_h *g);
.Ve
.PP
This closes the connection handle and frees up all resources used.  If a
close callback was set on the handle, then it is called.
.PP
ハンドルを閉じる正しい方法は次のとおりです:
.PP
.Vb 4
\& if (guestfs_shutdown (g) == \-1) {
\&   /* ここで書き込みエラーを処理する */
\& }
\& guestfs_close (g);
.Ve
.PP
\&\*(L"guestfs_shutdown\*(R" は以下の \fBすべて\fR が成り立つ場合のみ必要です:
.IP "1." 4
一つ以上のディスクを読み書きモードで追加した、\fIかつ\fR
.IP "2." 4
guestfs_launch が呼び出された、\fIかつ\fR
.IP "3." 4
何か変更を実施した、\fIかつ\fR
.IP "4." 4
you have a way to handle write errors (eg. by exiting with an error code or
reporting something to the user).
.SH "エラー処理"
.IX Header "エラー処理"
\&\s-1API\s0 関数はエラーを返します。たとえば、ほとんどすべての \f(CW\*(C`int\*(C'\fR を返す関数はエラーを意味するために \f(CW\*(C`\-1\*(C'\fR を返します。
.PP
エラーに関する追加の情報が利用可能です: 失敗したものがシステムコールならば、エラーメッセージ文字列およびオプションのエラー番号（errno）です。
.PP
You can get at the additional information about the last error on the handle
by calling \*(L"guestfs_last_error\*(R", \*(L"guestfs_last_errno\*(R", and/or by setting
up an error handler with \*(L"guestfs_set_error_handler\*(R".
.PP
When the handle is created, a default error handler is installed which
prints the error message string to \f(CW\*(C`stderr\*(C'\fR.  For small short-running
command line programs it is sufficient to do:
.PP
.Vb 2
\& if (guestfs_launch (g) == \-1)
\&   exit (EXIT_FAILURE);
.Ve
.PP
since the default error handler will ensure that an error message has been
printed to \f(CW\*(C`stderr\*(C'\fR before the program exits.
.PP
For other programs the caller will almost certainly want to install an
alternate error handler or do error handling in-line as in the example
below.  The non-C language bindings all install \s-1NULL\s0 error handlers and turn
errors into exceptions using code similar to this:
.PP
.Vb 2
\& const char *msg;
\& int errnum;
\& 
\& /* これは標準エラーにエラーを表示するときの
\&    デフォルトの動作を無効化します。 */
\& guestfs_set_error_handler (g, NULL, NULL);
\& 
\& if (guestfs_launch (g) == \-1) {
\&   /* エラーメッセージを検査する、表示する、例外を投げるなど */
\&   msg = guestfs_last_error (g);
\&   errnum = guestfs_last_errno (g);
\& 
\&   fprintf (stderr, "%s", msg);
\&   if (errnum != 0)
\&     fprintf (stderr, ": %s", strerror (errnum));
\&   fprintf (stderr, "\en");
\& 
\&   /* ... */
\& }
.Ve
.PP
\&\*(L"guestfs_create\*(R" returns \f(CW\*(C`NULL\*(C'\fR if the handle cannot be created, and
because there is no handle if this happens there is no way to get additional
error information.  Since libguestfs ≥ 1.20, you can use
\&\*(L"guestfs_create_flags\*(R" to properly deal with errors during handle
creation, although the vast majority of programs can continue to use
\&\*(L"guestfs_create\*(R" and not worry about this situation.
.PP
Out of memory errors are handled differently.  The default action is to call
\&\fIabort\fR\|(3).  If this is undesirable, then you can set a handler using
\&\*(L"guestfs_set_out_of_memory_handler\*(R".
.SS "guestfs_last_error"
.IX Subsection "guestfs_last_error"
.Vb 1
\& const char *guestfs_last_error (guestfs_h *g);
.Ve
.PP
This returns the last error message that happened on \f(CW\*(C`g\*(C'\fR.  If there has not
been an error since the handle was created, then this returns \f(CW\*(C`NULL\*(C'\fR.
.PP
Note the returned string does \fInot\fR have a newline character at the end.
Most error messages are single lines.  Some are split over multiple lines
and contain \f(CW\*(C`\en\*(C'\fR characters within the string but not at the end.
.PP
The lifetime of the returned string is until the next error occurs on the
same handle, or \*(L"guestfs_close\*(R" is called.  If you need to keep it longer,
copy it.
.SS "guestfs_last_errno"
.IX Subsection "guestfs_last_errno"
.Vb 1
\& int guestfs_last_errno (guestfs_h *g);
.Ve
.PP
これは \f(CW\*(C`g\*(C'\fR において発生した最後のエラー番号（errno）を返します。
.PP
もし成功すると、0 以外のエラー番号の整数が返されます。
.PP
In many cases the special errno \f(CW\*(C`ENOTSUP\*(C'\fR is returned if you tried to call
a function or use a feature which is not supported.
.PP
If no error number is available, this returns 0.  This call can return 0 in
three situations:
.IP "1." 4
ハンドルにおいて何もエラーがありませんでした。
.IP "2." 4
エラーがありましたが、エラー番号に意味がありませんでした。エラーがシステムコールの失敗により発生しましたが、何か他の理由による場合に対応します。
.IP "3." 4
エラーがシステムコールの失敗により発生しましたが、エラー番号が何らかの理由により捕捉されず返されました。これは通常 libguestfs
のバグを意味します。
.PP
Libguestfs tries to convert the errno from inside the appliance into a
corresponding errno for the caller (not entirely trivial: the appliance
might be running a completely different operating system from the library
and error numbers are not standardized across Un*xen).  If this could not be
done, then the error is translated to \f(CW\*(C`EINVAL\*(C'\fR.  In practice this should
only happen in very rare circumstances.
.SS "guestfs_set_error_handler"
.IX Subsection "guestfs_set_error_handler"
.Vb 6
\& typedef void (*guestfs_error_handler_cb) (guestfs_h *g,
\&                                           void *opaque,
\&                                           const char *msg);
\& void guestfs_set_error_handler (guestfs_h *g,
\&                                 guestfs_error_handler_cb cb,
\&                                 void *opaque);
.Ve
.PP
The callback \f(CW\*(C`cb\*(C'\fR will be called if there is an error.  The parameters
passed to the callback are an opaque data pointer and the error message
string.
.PP
\&\f(CW\*(C`errno\*(C'\fR is not passed to the callback.  To get that the callback must call
\&\*(L"guestfs_last_errno\*(R".
.PP
Note that the message string \f(CW\*(C`msg\*(C'\fR is freed as soon as the callback
function returns, so if you want to stash it somewhere you must make your
own copy.
.PP
標準のハンドラーは \f(CW\*(C`stderr\*(C'\fR にメッセージを表示します。
.PP
\&\f(CW\*(C`cb\*(C'\fR を \f(CW\*(C`NULL\*(C'\fR に設定すると、 \fIno\fR ハンドラーが呼び出されます。
.SS "guestfs_get_error_handler"
.IX Subsection "guestfs_get_error_handler"
.Vb 2
\& guestfs_error_handler_cb guestfs_get_error_handler (guestfs_h *g,
\&                                                     void **opaque_rtn);
.Ve
.PP
現在のエラーハンドラのコールバックを返します。
.SS "guestfs_push_error_handler"
.IX Subsection "guestfs_push_error_handler"
.Vb 3
\& void guestfs_push_error_handler (guestfs_h *g,
\&                                  guestfs_error_handler_cb cb,
\&                                  void *opaque);
.Ve
.PP
This is the same as \*(L"guestfs_set_error_handler\*(R", except that the old error
handler is stashed away in a stack inside the handle.  You can restore the
previous error handler by calling \*(L"guestfs_pop_error_handler\*(R".
.PP
Use the following code to temporarily disable errors around a function:
.PP
.Vb 3
\& guestfs_push_error_handler (g, NULL, NULL);
\& guestfs_mkdir (g, "/foo"); /* We don\*(Aqt care if this fails. */
\& guestfs_pop_error_handler (g);
.Ve
.SS "guestfs_pop_error_handler"
.IX Subsection "guestfs_pop_error_handler"
.Vb 1
\& void guestfs_pop_error_handler (guestfs_h *g);
.Ve
.PP
Restore the previous error handler (see \*(L"guestfs_push_error_handler\*(R").
.PP
If you pop the stack too many times, then the default error handler is
restored.
.SS "guestfs_set_out_of_memory_handler"
.IX Subsection "guestfs_set_out_of_memory_handler"
.Vb 3
\& typedef void (*guestfs_abort_cb) (void);
\& void guestfs_set_out_of_memory_handler (guestfs_h *g,
\&                                         guestfs_abort_cb);
.Ve
.PP
メモリー不足になると、コールバック \f(CW\*(C`cb\*(C'\fR が呼び出されます。 \fIこのコールバックは戻ってこない可能性があることに注意してください\fR。
.PP
デフォルトでは \fIabort\fR\|(3) を呼び出します。
.PP
\&\f(CW\*(C`cb\*(C'\fR を \f(CW\*(C`NULL\*(C'\fR に設定できません。メモリー不足の状況を無視できません。
.SS "guestfs_get_out_of_memory_handler"
.IX Subsection "guestfs_get_out_of_memory_handler"
.Vb 1
\& guestfs_abort_fn guestfs_get_out_of_memory_handler (guestfs_h *g);
.Ve
.PP
アウトオブメモリーハンドラーを返します。
.SH "API 呼び出し"
.IX Header "API 呼び出し"
.SS "guestfs_acl_delete_def_file"
.IX Subsection "guestfs_acl_delete_def_file"
.Vb 3
\& int
\& guestfs_acl_delete_def_file (guestfs_h *g,
\&                              const char *dir);
.Ve
.PP
この関数はディレクトリー \f(CW\*(C`dir\*(C'\fR に設定されている標準の \s-1POSIX\s0 アクセス制御リスト (\s-1ACL:\s0 Access Control List)
を削除します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`acl\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.19.63)
.SS "guestfs_acl_get_file"
.IX Subsection "guestfs_acl_get_file"
.Vb 4
\& char *
\& guestfs_acl_get_file (guestfs_h *g,
\&                       const char *path,
\&                       const char *acltype);
.Ve
.PP
This function returns the \s-1POSIX\s0 Access Control List (\s-1ACL\s0) attached to
\&\f(CW\*(C`path\*(C'\fR.  The \s-1ACL\s0 is returned in \*(L"long text form\*(R" (see \fIacl\fR\|(5)).
.PP
The \f(CW\*(C`acltype\*(C'\fR parameter may be:
.ie n .IP """access""" 4
.el .IP "\f(CWaccess\fR" 4
.IX Item "access"
Return the ordinary (access) \s-1ACL\s0 for any file, directory or other filesystem
object.
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
Return the default \s-1ACL.\s0  Normally this only makes sense if \f(CW\*(C`path\*(C'\fR is a
directory.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`acl\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.19.63)
.SS "guestfs_acl_set_file"
.IX Subsection "guestfs_acl_set_file"
.Vb 5
\& int
\& guestfs_acl_set_file (guestfs_h *g,
\&                       const char *path,
\&                       const char *acltype,
\&                       const char *acl);
.Ve
.PP
This function sets the \s-1POSIX\s0 Access Control List (\s-1ACL\s0) attached to \f(CW\*(C`path\*(C'\fR.
.PP
The \f(CW\*(C`acltype\*(C'\fR parameter may be:
.ie n .IP """access""" 4
.el .IP "\f(CWaccess\fR" 4
.IX Item "access"
Set the ordinary (access) \s-1ACL\s0 for any file, directory or other filesystem
object.
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
Set the default \s-1ACL.\s0  Normally this only makes sense if \f(CW\*(C`path\*(C'\fR is a
directory.
.PP
The \f(CW\*(C`acl\*(C'\fR parameter is the new \s-1ACL\s0 in either \*(L"long text form\*(R" or \*(L"short
text form\*(R" (see \fIacl\fR\|(5)).  The new \s-1ACL\s0 completely replaces any previous
\&\s-1ACL\s0 on the file.  The \s-1ACL\s0 must contain the full Unix permissions
(eg. \f(CW\*(C`u::rwx,g::rx,o::rx\*(C'\fR).
.PP
If you are specifying individual users or groups, then the mask field is
also required (eg. \f(CW\*(C`m::rwx\*(C'\fR), followed by the \f(CW\*(C`u:\f(CIID\f(CW:...\*(C'\fR and/or
\&\f(CW\*(C`g:\f(CIID\f(CW:...\*(C'\fR field(s).  A full \s-1ACL\s0 string might therefore look like this:
.PP
.Vb 2
\& u::rwx,g::rwx,o::rwx,m::rwx,u:500:rwx,g:500:rwx
\& \e Unix permissions / \emask/ \e      ACL        /
.Ve
.PP
You should use numeric UIDs and GIDs.  To map usernames and groupnames to
the correct numeric \s-1ID\s0 in the context of the guest, use the Augeas functions
(see \f(CW\*(C`guestfs_aug_init\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`acl\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.19.63)
.SS "guestfs_add_cdrom"
.IX Subsection "guestfs_add_cdrom"
.Vb 3
\& int
\& guestfs_add_cdrom (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_add_drive_ro\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
この関数は仮想 CD-ROM ディスクイメージを仮想マシンに追加します。
.PP
The image is added as read-only drive, so this function is equivalent of
\&\f(CW\*(C`guestfs_add_drive_ro\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_add_domain"
.IX Subsection "guestfs_add_domain"
.Vb 4
\& int
\& guestfs_add_domain (guestfs_h *g,
\&                     const char *dom,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 9
\& GUESTFS_ADD_DOMAIN_LIBVIRTURI, const char *libvirturi,
\& GUESTFS_ADD_DOMAIN_READONLY, int readonly,
\& GUESTFS_ADD_DOMAIN_IFACE, const char *iface,
\& GUESTFS_ADD_DOMAIN_LIVE, int live,
\& GUESTFS_ADD_DOMAIN_ALLOWUUID, int allowuuid,
\& GUESTFS_ADD_DOMAIN_READONLYDISK, const char *readonlydisk,
\& GUESTFS_ADD_DOMAIN_CACHEMODE, const char *cachemode,
\& GUESTFS_ADD_DOMAIN_DISCARD, const char *discard,
\& GUESTFS_ADD_DOMAIN_COPYONREAD, int copyonread,
.Ve
.PP
This function adds the disk(s) attached to the named libvirt domain \f(CW\*(C`dom\*(C'\fR.
It works by connecting to libvirt, requesting the domain and domain \s-1XML\s0 from
libvirt, parsing it for disks, and calling \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR on each
one.
.PP
The number of disks added is returned.  This operation is atomic: if an
error is returned, then no disks are added.
.PP
This function does some minimal checks to make sure the libvirt domain is
not running (unless \f(CW\*(C`readonly\*(C'\fR is true).  In a future version we will try
to acquire the libvirt lock on each disk.
.PP
Disks must be accessible locally.  This often means that adding disks from a
remote libvirt connection (see http://libvirt.org/remote.html)  will fail
unless those disks are accessible via the same device path locally too.
.PP
The optional \f(CW\*(C`libvirturi\*(C'\fR parameter sets the libvirt \s-1URI\s0 (see
http://libvirt.org/uri.html).  If this is not set then we connect to the
default libvirt \s-1URI\s0 (or one set through an environment variable, see the
libvirt documentation for full details).
.PP
The optional \f(CW\*(C`live\*(C'\fR flag controls whether this call will try to connect to
a running virtual machine \f(CW\*(C`guestfsd\*(C'\fR process if it sees a suitable
<channel> element in the libvirt \s-1XML\s0 definition.  The default (if
the flag is omitted) is never to try.  See \*(L"\s-1ATTACHING TO RUNNING
DAEMONS\*(R"\s0 for more information.
.PP
If the \f(CW\*(C`allowuuid\*(C'\fR flag is true (default is false) then a \s-1UUID\s0 \fImay\fR be
passed instead of the domain name.  The \f(CW\*(C`dom\*(C'\fR string is treated as a \s-1UUID\s0
first and looked up, and if that lookup fails then we treat \f(CW\*(C`dom\*(C'\fR as a name
as usual.
.PP
The optional \f(CW\*(C`readonlydisk\*(C'\fR parameter controls what we do for disks which
are marked <readonly/> in the libvirt \s-1XML.\s0  Possible values are:
.ie n .IP "readonlydisk = ""error""" 4
.el .IP "readonlydisk = ``error''" 4
.IX Item "readonlydisk = error"
\&\f(CW\*(C`readonly\*(C'\fR が偽ならば:
.Sp
The whole call is aborted with an error if any disk with the
<readonly/> flag is found.
.Sp
\&\f(CW\*(C`readonly\*(C'\fR が真ならば:
.Sp
<readonly/> フラグを持つディスクは読み込み専用で追加されます。
.ie n .IP "readonlydisk = ""read""" 4
.el .IP "readonlydisk = ``read''" 4
.IX Item "readonlydisk = read"
\&\f(CW\*(C`readonly\*(C'\fR が偽ならば:
.Sp
<readonly/> フラグを持つディスクは読み込み専用で追加されます。他のディスクは読み書き用で追加されます。
.Sp
\&\f(CW\*(C`readonly\*(C'\fR が真ならば:
.Sp
<readonly/> フラグを持つディスクは読み込み専用で追加されます。
.ie n .IP "readonlydisk = ""write"" (デフォルト)" 4
.el .IP "readonlydisk = ``write'' (デフォルト)" 4
.IX Item "readonlydisk = write (デフォルト)"
\&\f(CW\*(C`readonly\*(C'\fR が偽ならば:
.Sp
<readonly/> フラグを持つディスクは読み書き用で追加されます。
.Sp
\&\f(CW\*(C`readonly\*(C'\fR が真ならば:
.Sp
<readonly/> フラグを持つディスクは読み込み専用で追加されます。
.ie n .IP "readonlydisk = ""ignore""" 4
.el .IP "readonlydisk = ``ignore''" 4
.IX Item "readonlydisk = ignore"
\&\f(CW\*(C`readonly\*(C'\fR が真または偽ならば:
.Sp
<readonly/> フラグのあるディスクはスキップされます
.PP
他のオプションパラメーターは \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR にそのまま渡されます。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.7.4 において追加)
.SS "guestfs_add_domain_va"
.IX Subsection "guestfs_add_domain_va"
.Vb 4
\& int
\& guestfs_add_domain_va (guestfs_h *g,
\&                        const char *dom,
\&                        va_list args);
.Ve
.PP
これは \*(L"guestfs_add_domain\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_domain_argv"
.IX Subsection "guestfs_add_domain_argv"
.Vb 4
\& int
\& guestfs_add_domain_argv (guestfs_h *g,
\&                          const char *dom,
\&                          const struct guestfs_add_domain_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_add_domain\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_drive"
.IX Subsection "guestfs_add_drive"
.Vb 3
\& int
\& guestfs_add_drive (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_add_drive_opts\*(R" with no optional
arguments.
.PP
(0.3 において追加)
.SS "guestfs_add_drive_opts"
.IX Subsection "guestfs_add_drive_opts"
.Vb 4
\& int
\& guestfs_add_drive_opts (guestfs_h *g,
\&                         const char *filename,
\&                         ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 12
\& GUESTFS_ADD_DRIVE_OPTS_READONLY, int readonly,
\& GUESTFS_ADD_DRIVE_OPTS_FORMAT, const char *format,
\& GUESTFS_ADD_DRIVE_OPTS_IFACE, const char *iface,
\& GUESTFS_ADD_DRIVE_OPTS_NAME, const char *name,
\& GUESTFS_ADD_DRIVE_OPTS_LABEL, const char *label,
\& GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, const char *protocol,
\& GUESTFS_ADD_DRIVE_OPTS_SERVER, char *const *server,
\& GUESTFS_ADD_DRIVE_OPTS_USERNAME, const char *username,
\& GUESTFS_ADD_DRIVE_OPTS_SECRET, const char *secret,
\& GUESTFS_ADD_DRIVE_OPTS_CACHEMODE, const char *cachemode,
\& GUESTFS_ADD_DRIVE_OPTS_DISCARD, const char *discard,
\& GUESTFS_ADD_DRIVE_OPTS_COPYONREAD, int copyonread,
.Ve
.PP
This function adds a disk image called \fIfilename\fR to the handle.
\&\fIfilename\fR may be a regular host file or a host device.
.PP
When this function is called before \f(CW\*(C`guestfs_launch\*(C'\fR (the usual case) then
the first time you call this function, the disk appears in the \s-1API\s0 as
\&\fI/dev/sda\fR, the second time as \fI/dev/sdb\fR, and so on.
.PP
In libguestfs ≥ 1.20 you can also call this function after launch (with
some restrictions).  This is called \*(L"hotplugging\*(R".  When hotplugging, you
must specify a \f(CW\*(C`label\*(C'\fR so that the new disk gets a predictable name.  For
more information see \*(L"\s-1HOTPLUGGING\*(R"\s0.
.PP
You don't necessarily need to be root when using libguestfs.  However you
obviously do need sufficient permissions to access the filename for whatever
operations you want to perform (ie. read access if you just want to read the
image or write access if you want to modify the image).
.PP
This call checks that \fIfilename\fR exists.
.PP
\&\fIfilename\fR may be the special string \f(CW"/dev/null"\fR.  See \*(L"\s-1NULL
DISKS\*(R"\s0.
.PP
オプション引数は次のとおりです:
.ie n .IP """readonly""" 4
.el .IP "\f(CWreadonly\fR" 4
.IX Item "readonly"
If true then the image is treated as read-only.  Writes are still allowed,
but they are stored in a temporary snapshot overlay which is discarded at
the end.  The disk that you add is not modified.
.ie n .IP """format""" 4
.el .IP "\f(CWformat\fR" 4
.IX Item "format"
This forces the image format.  If you omit this (or use \f(CW\*(C`guestfs_add_drive\*(C'\fR
or \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR) then the format is automatically detected.
Possible formats include \f(CW\*(C`raw\*(C'\fR and \f(CW\*(C`qcow2\*(C'\fR.
.Sp
Automatic detection of the format opens you up to a potential security hole
when dealing with untrusted raw-format images.  See \s-1CVE\-2010\-3851\s0 and
RHBZ#642934.  Specifying the format closes this security hole.
.ie n .IP """iface""" 4
.el .IP "\f(CWiface\fR" 4
.IX Item "iface"
This rarely-used option lets you emulate the behaviour of the deprecated
\&\f(CW\*(C`guestfs_add_drive_with_if\*(C'\fR call (q.v.)
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The name the drive had in the original guest, e.g. \fI/dev/sdb\fR.  This is
used as a hint to the guest inspection process if it is available.
.ie n .IP """label""" 4
.el .IP "\f(CWlabel\fR" 4
.IX Item "label"
Give the disk a label.  The label should be a unique, short string using
\&\fIonly\fR \s-1ASCII\s0 characters \f(CW\*(C`[a\-zA\-Z]\*(C'\fR.  As well as its usual name in the \s-1API\s0
(such as \fI/dev/sda\fR), the drive will also be named
\&\fI/dev/disk/guestfs/\fIlabel\fI\fR.
.Sp
\&\*(L"ディスクラベル\*(R"を参照してください。
.ie n .IP """protocol""" 4
.el .IP "\f(CWprotocol\fR" 4
.IX Item "protocol"
The optional protocol argument can be used to select an alternate source
protocol.
.Sp
See also: \*(L"\s-1REMOTE STORAGE\*(R"\s0.
.RS 4
.ie n .IP """protocol = ""file""""" 4
.el .IP "\f(CWprotocol = ``file''\fR" 4
.IX Item "protocol = ""file"""
\&\fIfilename\fR is interpreted as a local file or device.  This is the default
if the optional protocol parameter is omitted.
.ie n .IP """protocol = ""ftp""|""ftps""|""http""|""https""|""tftp""""" 4
.el .IP "\f(CWprotocol = ``ftp''|``ftps''|``http''|``https''|``tftp''\fR" 4
.IX Item "protocol = ""ftp""|""ftps""|""http""|""https""|""tftp"""
Connect to a remote \s-1FTP, HTTP\s0 or \s-1TFTP\s0 server.  The \f(CW\*(C`server\*(C'\fR parameter must
also be supplied \- see below.
.Sp
See also: \*(L"\s-1FTP, HTTP AND TFTP\*(R"\s0
.ie n .IP """protocol = ""gluster""""" 4
.el .IP "\f(CWprotocol = ``gluster''\fR" 4
.IX Item "protocol = ""gluster"""
Connect to the GlusterFS server.  The \f(CW\*(C`server\*(C'\fR parameter must also be
supplied \- see below.
.Sp
See also: \*(L"\s-1GLUSTER\*(R"\s0
.ie n .IP """protocol = ""iscsi""""" 4
.el .IP "\f(CWprotocol = ``iscsi''\fR" 4
.IX Item "protocol = ""iscsi"""
Connect to the iSCSI server.  The \f(CW\*(C`server\*(C'\fR parameter must also be supplied
\&\- see below.  The \f(CW\*(C`username\*(C'\fR parameter may be supplied.  See below.  The
\&\f(CW\*(C`secret\*(C'\fR parameter may be supplied.  See below.
.Sp
See also: \*(L"\s-1ISCSI\*(R"\s0.
.ie n .IP """protocol = ""nbd""""" 4
.el .IP "\f(CWprotocol = ``nbd''\fR" 4
.IX Item "protocol = ""nbd"""
Connect to the Network Block Device server.  The \f(CW\*(C`server\*(C'\fR parameter must
also be supplied \- see below.
.Sp
See also: \*(L"\s-1NETWORK BLOCK DEVICE\*(R"\s0.
.ie n .IP """protocol = ""rbd""""" 4
.el .IP "\f(CWprotocol = ``rbd''\fR" 4
.IX Item "protocol = ""rbd"""
Connect to the Ceph (librbd/RBD) server.  The \f(CW\*(C`server\*(C'\fR parameter must also
be supplied \- see below.  The \f(CW\*(C`username\*(C'\fR parameter may be supplied.  See
below.  The \f(CW\*(C`secret\*(C'\fR parameter may be supplied.  See below.
.Sp
See also: \*(L"\s-1CEPH\*(R"\s0.
.ie n .IP """protocol = ""sheepdog""""" 4
.el .IP "\f(CWprotocol = ``sheepdog''\fR" 4
.IX Item "protocol = ""sheepdog"""
Connect to the Sheepdog server.  The \f(CW\*(C`server\*(C'\fR parameter may also be
supplied \- see below.
.Sp
See also: \*(L"\s-1SHEEPDOG\*(R"\s0.
.ie n .IP """protocol = ""ssh""""" 4
.el .IP "\f(CWprotocol = ``ssh''\fR" 4
.IX Item "protocol = ""ssh"""
Connect to the Secure Shell (ssh) server.
.Sp
The \f(CW\*(C`server\*(C'\fR parameter must be supplied.  The \f(CW\*(C`username\*(C'\fR parameter may be
supplied.  See below.
.Sp
See also: \*(L"\s-1SSH\*(R"\s0.
.RE
.RS 4
.RE
.ie n .IP """server""" 4
.el .IP "\f(CWserver\fR" 4
.IX Item "server"
For protocols which require access to a remote server, this is a list of
server(s).
.Sp
.Vb 10
\& Protocol       Number of servers required
\& \-\-\-\-\-\-\-\-       \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& file           List must be empty or param not used at all
\& ftp|ftps|http|https|tftp  Exactly one
\& gluster        Exactly one
\& iscsi          Exactly one
\& nbd            Exactly one
\& rbd            Zero or more
\& sheepdog       Zero or more
\& ssh            Exactly one
.Ve
.Sp
Each list element is a string specifying a server.  The string must be in
one of the following formats:
.Sp
.Vb 5
\& hostname
\& hostname:port
\& tcp:hostname
\& tcp:hostname:port
\& unix:/path/to/socket
.Ve
.Sp
If the port number is omitted, then the standard port number for the
protocol is used (see \fI/etc/services\fR).
.ie n .IP """username""" 4
.el .IP "\f(CWusername\fR" 4
.IX Item "username"
For the \f(CW\*(C`ftp\*(C'\fR, \f(CW\*(C`ftps\*(C'\fR, \f(CW\*(C`http\*(C'\fR, \f(CW\*(C`https\*(C'\fR, \f(CW\*(C`iscsi\*(C'\fR, \f(CW\*(C`rbd\*(C'\fR, \f(CW\*(C`ssh\*(C'\fR and
\&\f(CW\*(C`tftp\*(C'\fR protocols, this specifies the remote username.
.Sp
If not given, then the local username is used for \f(CW\*(C`ssh\*(C'\fR, and no
authentication is attempted for ceph.  But note this sometimes may give
unexpected results, for example if using the libvirt backend and if the
libvirt backend is configured to start the qemu appliance as a special user
such as \f(CW\*(C`qemu.qemu\*(C'\fR.  If in doubt, specify the remote username you want.
.ie n .IP """secret""" 4
.el .IP "\f(CWsecret\fR" 4
.IX Item "secret"
For the \f(CW\*(C`rbd\*(C'\fR protocol only, this specifies the 'secret' to use when
connecting to the remote device.  It must be base64 encoded.
.Sp
If not given, then a secret matching the given username will be looked up in
the default keychain locations, or if no username is given, then no
authentication will be used.
.ie n .IP """cachemode""" 4
.el .IP "\f(CWcachemode\fR" 4
.IX Item "cachemode"
Choose whether or not libguestfs will obey sync operations (safe but slow)
or not (unsafe but fast).  The possible values for this string are:
.RS 4
.ie n .IP """cachemode = ""writeback""""" 4
.el .IP "\f(CWcachemode = ``writeback''\fR" 4
.IX Item "cachemode = ""writeback"""
これがデフォルトです。
.Sp
Write operations in the \s-1API\s0 do not return until a \fIwrite\fR\|(2) call has
completed in the host [but note this does not imply that anything gets
written to disk].
.Sp
Sync operations in the \s-1API,\s0 including implicit syncs caused by filesystem
journalling, will not return until an \fIfdatasync\fR\|(2) call has completed in
the host, indicating that data has been committed to disk.
.ie n .IP """cachemode = ""unsafe""""" 4
.el .IP "\f(CWcachemode = ``unsafe''\fR" 4
.IX Item "cachemode = ""unsafe"""
In this mode, there are no guarantees.  Libguestfs may cache anything and
ignore sync requests.  This is suitable only for scratch or temporary disks.
.RE
.RS 4
.RE
.ie n .IP """discard""" 4
.el .IP "\f(CWdiscard\fR" 4
.IX Item "discard"
Enable or disable discard (a.k.a. trim or unmap) support on this drive.  If
enabled, operations such as \f(CW\*(C`guestfs_fstrim\*(C'\fR will be able to discard / make
thin / punch holes in the underlying host file or device.
.Sp
Possible discard settings are:
.RS 4
.ie n .IP """discard = ""disable""""" 4
.el .IP "\f(CWdiscard = ``disable''\fR" 4
.IX Item "discard = ""disable"""
Disable discard support.  This is the default.
.ie n .IP """discard = ""enable""""" 4
.el .IP "\f(CWdiscard = ``enable''\fR" 4
.IX Item "discard = ""enable"""
Enable discard support.  Fail if discard is not possible.
.ie n .IP """discard = ""besteffort""""" 4
.el .IP "\f(CWdiscard = ``besteffort''\fR" 4
.IX Item "discard = ""besteffort"""
Enable discard support if possible, but don't fail if it is not supported.
.Sp
Since not all backends and not all underlying systems support discard, this
is a good choice if you want to use discard if possible, but don't mind if
it doesn't work.
.RE
.RS 4
.RE
.ie n .IP """copyonread""" 4
.el .IP "\f(CWcopyonread\fR" 4
.IX Item "copyonread"
The boolean parameter \f(CW\*(C`copyonread\*(C'\fR enables copy-on-read support.  This only
affects disk formats which have backing files, and causes reads to be stored
in the overlay layer, speeding up multiple reads of the same area of disk.
.Sp
The default is false.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_add_drive_opts_va"
.IX Subsection "guestfs_add_drive_opts_va"
.Vb 4
\& int
\& guestfs_add_drive_opts_va (guestfs_h *g,
\&                            const char *filename,
\&                            va_list args);
.Ve
.PP
これは \*(L"guestfs_add_drive_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_drive_opts_argv"
.IX Subsection "guestfs_add_drive_opts_argv"
.Vb 4
\& int
\& guestfs_add_drive_opts_argv (guestfs_h *g,
\&                              const char *filename,
\&                              const struct guestfs_add_drive_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_add_drive_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_drive_ro"
.IX Subsection "guestfs_add_drive_ro"
.Vb 3
\& int
\& guestfs_add_drive_ro (guestfs_h *g,
\&                       const char *filename);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_copy_device_to_device\*(R" を使用してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.38 において追加)
.SS "guestfs_add_drive_ro_with_if"
.IX Subsection "guestfs_add_drive_ro_with_if"
.Vb 4
\& int
\& guestfs_add_drive_ro_with_if (guestfs_h *g,
\&                               const char *filename,
\&                               const char *iface);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_add_drive\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is the same as \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR but it allows you to specify the
\&\s-1QEMU\s0 interface emulation to use at run time.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.84 において追加)
.SS "guestfs_add_drive_scratch"
.IX Subsection "guestfs_add_drive_scratch"
.Vb 4
\& int
\& guestfs_add_drive_scratch (guestfs_h *g,
\&                            int64_t size,
\&                            ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_ADD_DRIVE_SCRATCH_NAME, const char *name,
\& GUESTFS_ADD_DRIVE_SCRATCH_LABEL, const char *label,
.Ve
.PP
This command adds a temporary scratch drive to the handle.  The \f(CW\*(C`size\*(C'\fR
parameter is the virtual size (in bytes).  The scratch drive is blank
initially (all reads return zeroes until you start writing to it).  The
drive is deleted when the handle is closed.
.PP
The optional arguments \f(CW\*(C`name\*(C'\fR and \f(CW\*(C`label\*(C'\fR are passed through to
\&\f(CW\*(C`guestfs_add_drive\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.23.10)
.SS "guestfs_add_drive_scratch_va"
.IX Subsection "guestfs_add_drive_scratch_va"
.Vb 4
\& int
\& guestfs_add_drive_scratch_va (guestfs_h *g,
\&                               int64_t size,
\&                               va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_add_drive_scratch\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_drive_scratch_argv"
.IX Subsection "guestfs_add_drive_scratch_argv"
.Vb 4
\& int
\& guestfs_add_drive_scratch_argv (guestfs_h *g,
\&                                 int64_t size,
\&                                 const struct guestfs_add_drive_scratch_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_add_drive_scratch\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_drive_with_if"
.IX Subsection "guestfs_add_drive_with_if"
.Vb 4
\& int
\& guestfs_add_drive_with_if (guestfs_h *g,
\&                            const char *filename,
\&                            const char *iface);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_add_drive\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is the same as \f(CW\*(C`guestfs_add_drive\*(C'\fR but it allows you to specify the
\&\s-1QEMU\s0 interface emulation to use at run time.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.84 において追加)
.SS "guestfs_add_libvirt_dom"
.IX Subsection "guestfs_add_libvirt_dom"
.Vb 4
\& int
\& guestfs_add_libvirt_dom (guestfs_h *g,
\&                          void * /* really virDomainPtr */ dom,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 7
\& GUESTFS_ADD_LIBVIRT_DOM_READONLY, int readonly,
\& GUESTFS_ADD_LIBVIRT_DOM_IFACE, const char *iface,
\& GUESTFS_ADD_LIBVIRT_DOM_LIVE, int live,
\& GUESTFS_ADD_LIBVIRT_DOM_READONLYDISK, const char *readonlydisk,
\& GUESTFS_ADD_LIBVIRT_DOM_CACHEMODE, const char *cachemode,
\& GUESTFS_ADD_LIBVIRT_DOM_DISCARD, const char *discard,
\& GUESTFS_ADD_LIBVIRT_DOM_COPYONREAD, int copyonread,
.Ve
.PP
This function adds the disk(s) attached to the libvirt domain \f(CW\*(C`dom\*(C'\fR.  It
works by requesting the domain \s-1XML\s0 from libvirt, parsing it for disks, and
calling \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR on each one.
.PP
In the C \s-1API\s0 we declare \f(CW\*(C`void *dom\*(C'\fR, but really it has type \f(CW\*(C`virDomainPtr
dom\*(C'\fR.  This is so we don't need <libvirt.h>.
.PP
The number of disks added is returned.  This operation is atomic: if an
error is returned, then no disks are added.
.PP
This function does some minimal checks to make sure the libvirt domain is
not running (unless \f(CW\*(C`readonly\*(C'\fR is true).  In a future version we will try
to acquire the libvirt lock on each disk.
.PP
Disks must be accessible locally.  This often means that adding disks from a
remote libvirt connection (see http://libvirt.org/remote.html)  will fail
unless those disks are accessible via the same device path locally too.
.PP
The optional \f(CW\*(C`live\*(C'\fR flag controls whether this call will try to connect to
a running virtual machine \f(CW\*(C`guestfsd\*(C'\fR process if it sees a suitable
<channel> element in the libvirt \s-1XML\s0 definition.  The default (if
the flag is omitted) is never to try.  See \*(L"\s-1ATTACHING TO RUNNING
DAEMONS\*(R"\s0 for more information.
.PP
The optional \f(CW\*(C`readonlydisk\*(C'\fR parameter controls what we do for disks which
are marked <readonly/> in the libvirt \s-1XML.\s0  See
\&\f(CW\*(C`guestfs_add_domain\*(C'\fR for possible values.
.PP
他のオプションパラメーターは \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR にそのまま渡されます。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.29.14)
.SS "guestfs_add_libvirt_dom_va"
.IX Subsection "guestfs_add_libvirt_dom_va"
.Vb 4
\& int
\& guestfs_add_libvirt_dom_va (guestfs_h *g,
\&                             void * /* really virDomainPtr */ dom,
\&                             va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_add_libvirt_dom\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_add_libvirt_dom_argv"
.IX Subsection "guestfs_add_libvirt_dom_argv"
.Vb 4
\& int
\& guestfs_add_libvirt_dom_argv (guestfs_h *g,
\&                               void * /* really virDomainPtr */ dom,
\&                               const struct guestfs_add_libvirt_dom_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_add_libvirt_dom\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_aug_clear"
.IX Subsection "guestfs_aug_clear"
.Vb 3
\& int
\& guestfs_aug_clear (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Set the value associated with \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR.  This is the same as the
\&\fIaugtool\fR\|(1) \f(CW\*(C`clear\*(C'\fR command.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.4 において追加)
.SS "guestfs_aug_close"
.IX Subsection "guestfs_aug_close"
.Vb 2
\& int
\& guestfs_aug_close (guestfs_h *g);
.Ve
.PP
Close the current Augeas handle and free up any resources used by it.  After
calling this, you have to call \f(CW\*(C`guestfs_aug_init\*(C'\fR again before you can use
any other Augeas functions.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_defnode"
.IX Subsection "guestfs_aug_defnode"
.Vb 5
\& struct guestfs_int_bool *
\& guestfs_aug_defnode (guestfs_h *g,
\&                      const char *name,
\&                      const char *expr,
\&                      const char *val);
.Ve
.PP
その値が \f(CW\*(C`expr\*(C'\fR を評価した結果である変数 \f(CW\*(C`name\*(C'\fR を定義します。
.PP
\&\f(CW\*(C`expr\*(C'\fR が空のノードセットであると評価された場合、ノードが作成されます。\f(CW\*(C`guestfs_aug_set\*(C'\fR \f(CW\*(C`expr\*(C'\fR, \f(CW\*(C`value\*(C'\fR
を呼び出すことと同等です。\f(CW\*(C`name\*(C'\fR  は単一のノードを含むノードセットです。
.PP
成功した場合、ノードセットに含まれるノード数を含むペアが返されます。また、ノードが作成されたかどうかの論理フラグが返されます。
.PP
この関数は \f(CW\*(C`struct guestfs_int_bool *\*(C'\fR を返します。もしくは、エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_int_bool\*(C'\fI を呼び出す必要があります\fR。
.PP
(0.7 において追加)
.SS "guestfs_aug_defvar"
.IX Subsection "guestfs_aug_defvar"
.Vb 4
\& int
\& guestfs_aug_defvar (guestfs_h *g,
\&                     const char *name,
\&                     const char *expr);
.Ve
.PP
\&\f(CW\*(C`expr\*(C'\fR を評価した結果の値である Augeas 変数 \f(CW\*(C`name\*(C'\fR を定義します。 \f(CW\*(C`expr\*(C'\fR が \s-1NULL\s0 ならば、 \f(CW\*(C`name\*(C'\fR
が定義されません。
.PP
成功した場合、\f(CW\*(C`expr\*(C'\fR にあるノード数が返されます。または、\f(CW\*(C`expr\*(C'\fR がノードセット以外のものであると評価された場合、\f(CW0\fR
が返されます。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_get"
.IX Subsection "guestfs_aug_get"
.Vb 3
\& char *
\& guestfs_aug_get (guestfs_h *g,
\&                  const char *augpath);
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR と関連づけられた値を検索します。\f(CW\*(C`path\*(C'\fR がちょうど一つのノードと一致した場合、\f(CW\*(C`value\*(C'\fR が返されます。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(0.7 において追加)
.SS "guestfs_aug_init"
.IX Subsection "guestfs_aug_init"
.Vb 4
\& int
\& guestfs_aug_init (guestfs_h *g,
\&                   const char *root,
\&                   int flags);
.Ve
.PP
Create a new Augeas handle for editing configuration files.  If there was
any previous Augeas handle associated with this guestfs session, then it is
closed.
.PP
あらゆる他の \f(CW\*(C`guestfs_aug_*\*(C'\fR コマンドを使用する前に、これを呼び出す必要があります。
.PP
\&\f(CW\*(C`root\*(C'\fR is the filesystem root.  \f(CW\*(C`root\*(C'\fR must not be \s-1NULL,\s0 use \fI/\fR instead.
.PP
The flags are the same as the flags defined in <augeas.h>, the
logical \fIor\fR of the following integers:
.ie n .IP """AUG_SAVE_BACKUP"" = 1" 4
.el .IP "\f(CWAUG_SAVE_BACKUP\fR = 1" 4
.IX Item "AUG_SAVE_BACKUP = 1"
\&\f(CW\*(C`.augsave\*(C'\fR 拡張子を付けて元のファイルを保持します。
.ie n .IP """AUG_SAVE_NEWFILE"" = 2" 4
.el .IP "\f(CWAUG_SAVE_NEWFILE\fR = 2" 4
.IX Item "AUG_SAVE_NEWFILE = 2"
拡張子 \f(CW\*(C`.augnew\*(C'\fR を付けたファイルに変更点を保存し、元を上書きしません。\f(CW\*(C`AUG_SAVE_BACKUP\*(C'\fR を上書きします。
.ie n .IP """AUG_TYPE_CHECK"" = 4" 4
.el .IP "\f(CWAUG_TYPE_CHECK\fR = 4" 4
.IX Item "AUG_TYPE_CHECK = 4"
Typecheck lenses.
.Sp
This option is only useful when debugging Augeas lenses.  Use of this option
may require additional memory for the libguestfs appliance.  You may need to
set the \f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR environment variable or call
\&\f(CW\*(C`guestfs_set_memsize\*(C'\fR.
.ie n .IP """AUG_NO_STDINC"" = 8" 4
.el .IP "\f(CWAUG_NO_STDINC\fR = 8" 4
.IX Item "AUG_NO_STDINC = 8"
モジュールの標準的な読み込みパスを使用しません。
.ie n .IP """AUG_SAVE_NOOP"" = 16" 4
.el .IP "\f(CWAUG_SAVE_NOOP\fR = 16" 4
.IX Item "AUG_SAVE_NOOP = 16"
Make save a no-op, just record what would have been changed.
.ie n .IP """AUG_NO_LOAD"" = 32" 4
.el .IP "\f(CWAUG_NO_LOAD\fR = 32" 4
.IX Item "AUG_NO_LOAD = 32"
\&\f(CW\*(C`guestfs_aug_init\*(C'\fR にツリーを読み込みません。
.PP
ハンドルを閉じるために \f(CW\*(C`guestfs_aug_close\*(C'\fR を呼び出せます。
.PP
Augeas に関する詳細は http://augeas.net/ を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_insert"
.IX Subsection "guestfs_aug_insert"
.Vb 5
\& int
\& guestfs_aug_insert (guestfs_h *g,
\&                     const char *augpath,
\&                     const char *label,
\&                     int before);
.Ve
.PP
Create a new sibling \f(CW\*(C`label\*(C'\fR for \f(CW\*(C`path\*(C'\fR, inserting it into the tree before
or after \f(CW\*(C`path\*(C'\fR (depending on the boolean flag \f(CW\*(C`before\*(C'\fR).
.PP
\&\f(CW\*(C`path\*(C'\fR must match exactly one existing node in the tree, and \f(CW\*(C`label\*(C'\fR must
be a label, ie. not contain \fI/\fR, \f(CW\*(C`*\*(C'\fR or end with a bracketed index \f(CW\*(C`[N]\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_label"
.IX Subsection "guestfs_aug_label"
.Vb 3
\& char *
\& guestfs_aug_label (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
The label (name of the last element) of the Augeas path expression
\&\f(CW\*(C`augpath\*(C'\fR is returned.  \f(CW\*(C`augpath\*(C'\fR must match exactly one node, else this
function returns an error.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.23.14)
.SS "guestfs_aug_load"
.IX Subsection "guestfs_aug_load"
.Vb 2
\& int
\& guestfs_aug_load (guestfs_h *g);
.Ve
.PP
ファイルをツリーの中に読み込みます
.PP
See \f(CW\*(C`aug_load\*(C'\fR in the Augeas documentation for the full gory details.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_ls"
.IX Subsection "guestfs_aug_ls"
.Vb 3
\& char **
\& guestfs_aug_ls (guestfs_h *g,
\&                 const char *augpath);
.Ve
.PP
This is just a shortcut for listing \f(CW\*(C`guestfs_aug_match\*(C'\fR \f(CW\*(C`path/*\*(C'\fR and
sorting the resulting nodes into alphabetical order.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.8 において追加)
.SS "guestfs_aug_match"
.IX Subsection "guestfs_aug_match"
.Vb 3
\& char **
\& guestfs_aug_match (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Returns a list of paths which match the path expression \f(CW\*(C`path\*(C'\fR.  The
returned paths are sufficiently qualified so that they match exactly one
node in the current tree.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.7 において追加)
.SS "guestfs_aug_mv"
.IX Subsection "guestfs_aug_mv"
.Vb 4
\& int
\& guestfs_aug_mv (guestfs_h *g,
\&                 const char *src,
\&                 const char *dest);
.Ve
.PP
ノード \f(CW\*(C`src\*(C'\fR を \f(CW\*(C`dest\*(C'\fR に移動します。 \f(CW\*(C`src\*(C'\fR はただ一つのノードである必要があります。 \f(CW\*(C`dest\*(C'\fR
は存在すると上書きされます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_rm"
.IX Subsection "guestfs_aug_rm"
.Vb 3
\& int
\& guestfs_aug_rm (guestfs_h *g,
\&                 const char *augpath);
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR とすべての子を削除します。
.PP
成功すると、これは削除された項目の数が返します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_save"
.IX Subsection "guestfs_aug_save"
.Vb 2
\& int
\& guestfs_aug_save (guestfs_h *g);
.Ve
.PP
これにより、すべての保留の変更がディスクに書き込まれます。
.PP
The flags which were passed to \f(CW\*(C`guestfs_aug_init\*(C'\fR affect exactly how files
are saved.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_set"
.IX Subsection "guestfs_aug_set"
.Vb 4
\& int
\& guestfs_aug_set (guestfs_h *g,
\&                  const char *augpath,
\&                  const char *val);
.Ve
.PP
Set the value associated with \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`val\*(C'\fR.
.PP
In the Augeas \s-1API,\s0 it is possible to clear a node by setting the value to
\&\s-1NULL.\s0  Due to an oversight in the libguestfs \s-1API\s0 you cannot do that with
this call.  Instead you must use the \f(CW\*(C`guestfs_aug_clear\*(C'\fR call.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.7 において追加)
.SS "guestfs_aug_setm"
.IX Subsection "guestfs_aug_setm"
.Vb 5
\& int
\& guestfs_aug_setm (guestfs_h *g,
\&                   const char *base,
\&                   const char *sub,
\&                   const char *val);
.Ve
.PP
Change multiple Augeas nodes in a single operation.  \f(CW\*(C`base\*(C'\fR is an
expression matching multiple nodes.  \f(CW\*(C`sub\*(C'\fR is a path expression relative to
\&\f(CW\*(C`base\*(C'\fR.  All nodes matching \f(CW\*(C`base\*(C'\fR are found, and then for each node,
\&\f(CW\*(C`sub\*(C'\fR is changed to \f(CW\*(C`val\*(C'\fR.  \f(CW\*(C`sub\*(C'\fR may also be \f(CW\*(C`NULL\*(C'\fR in which case the
\&\f(CW\*(C`base\*(C'\fR nodes are modified.
.PP
This returns the number of nodes modified.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.23.14)
.SS "guestfs_aug_transform"
.IX Subsection "guestfs_aug_transform"
.Vb 5
\& int
\& guestfs_aug_transform (guestfs_h *g,
\&                        const char *lens,
\&                        const char *file,
\&                        ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_AUG_TRANSFORM_REMOVE, int remove,
.Ve
.PP
Add an Augeas transformation for the specified \f(CW\*(C`lens\*(C'\fR so it can handle
\&\f(CW\*(C`file\*(C'\fR.
.PP
If \f(CW\*(C`remove\*(C'\fR is true (\f(CW\*(C`false\*(C'\fR by default), then the transformation is
removed.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.35.2)
.SS "guestfs_aug_transform_va"
.IX Subsection "guestfs_aug_transform_va"
.Vb 5
\& int
\& guestfs_aug_transform_va (guestfs_h *g,
\&                           const char *lens,
\&                           const char *file,
\&                           va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_aug_transform\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_aug_transform_argv"
.IX Subsection "guestfs_aug_transform_argv"
.Vb 5
\& int
\& guestfs_aug_transform_argv (guestfs_h *g,
\&                             const char *lens,
\&                             const char *file,
\&                             const struct guestfs_aug_transform_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_aug_transform\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_available"
.IX Subsection "guestfs_available"
.Vb 3
\& int
\& guestfs_available (guestfs_h *g,
\&                    char *const *groups);
.Ve
.PP
This command is used to check the availability of some groups of
functionality in the appliance, which not all builds of the libguestfs
appliance will be able to provide.
.PP
The libguestfs groups, and the functions that those groups correspond to,
are listed in \*(L"\s-1AVAILABILITY\*(R"\s0.  You can also fetch this list at
runtime by calling \f(CW\*(C`guestfs_available_all_groups\*(C'\fR.
.PP
The argument \f(CW\*(C`groups\*(C'\fR is a list of group names, eg: \f(CW\*(C`["inotify",
"augeas"]\*(C'\fR would check for the availability of the Linux inotify functions
and Augeas (configuration file editing) functions.
.PP
The command returns no error if \fIall\fR requested groups are available.
.PP
It fails with an error if one or more of the requested groups is unavailable
in the appliance.
.PP
If an unknown group name is included in the list of groups then an error is
always returned.
.PP
\&\fI注記:\fR
.IP "\(bu" 4
\&\f(CW\*(C`guestfs_feature_available\*(C'\fR is the same as this call, but with a slightly
simpler to use \s-1API:\s0 that call returns a boolean true/false instead of
throwing an error.
.IP "\(bu" 4
この関数を呼び出す前に \f(CW\*(C`guestfs_launch\*(C'\fR を呼び出す必要があります。
.Sp
The reason is because we don't know what groups are supported by the
appliance/daemon until it is running and can be queried.
.IP "\(bu" 4
If a group of functions is available, this does not necessarily mean that
they will work.  You still have to check for errors when calling individual
\&\s-1API\s0 functions even if they are available.
.IP "\(bu" 4
It is usually the job of distro packagers to build complete functionality
into the libguestfs appliance.  Upstream libguestfs, if built from source
with all requirements satisfied, will support everything.
.IP "\(bu" 4
This call was added in version \f(CW1.0.80\fR.  In previous versions of
libguestfs all you could do would be to speculatively execute a command to
find out if the daemon implemented it.  See also \f(CW\*(C`guestfs_version\*(C'\fR.
.PP
\&\f(CW\*(C`guestfs_filesystem_available\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.80 において追加)
.SS "guestfs_available_all_groups"
.IX Subsection "guestfs_available_all_groups"
.Vb 2
\& char **
\& guestfs_available_all_groups (guestfs_h *g);
.Ve
.PP
This command returns a list of all optional groups that this daemon knows
about.  Note this returns both supported and unsupported groups.  To find
out which ones the daemon can actually support you have to call
\&\f(CW\*(C`guestfs_available\*(C'\fR / \f(CW\*(C`guestfs_feature_available\*(C'\fR on each member of the
returned list.
.PP
\&\f(CW\*(C`guestfs_available\*(C'\fR, \f(CW\*(C`guestfs_feature_available\*(C'\fR および
\&\*(L"\s-1AVAILABILITY\*(R"\s0 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.3.15 において追加)
.SS "guestfs_base64_in"
.IX Subsection "guestfs_base64_in"
.Vb 4
\& int
\& guestfs_base64_in (guestfs_h *g,
\&                    const char *base64file,
\&                    const char *filename);
.Ve
.PP
This command uploads base64\-encoded data from \f(CW\*(C`base64file\*(C'\fR to \fIfilename\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.5 において追加)
.SS "guestfs_base64_out"
.IX Subsection "guestfs_base64_out"
.Vb 4
\& int
\& guestfs_base64_out (guestfs_h *g,
\&                     const char *filename,
\&                     const char *base64file);
.Ve
.PP
This command downloads the contents of \fIfilename\fR, writing it out to local
file \f(CW\*(C`base64file\*(C'\fR encoded as base64.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.5 において追加)
.SS "guestfs_blkdiscard"
.IX Subsection "guestfs_blkdiscard"
.Vb 3
\& int
\& guestfs_blkdiscard (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
This discards all blocks on the block device \f(CW\*(C`device\*(C'\fR, giving the free
space back to the host.
.PP
This operation requires support in libguestfs, the host filesystem, qemu and
the host kernel.  If this support isn't present it may give an error or even
appear to run but do nothing.  You must also set the \f(CW\*(C`discard\*(C'\fR attribute on
the underlying drive (see \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`blkdiscard\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.25.44)
.SS "guestfs_blkdiscardzeroes"
.IX Subsection "guestfs_blkdiscardzeroes"
.Vb 3
\& int
\& guestfs_blkdiscardzeroes (guestfs_h *g,
\&                           const char *device);
.Ve
.PP
This call returns true if blocks on \f(CW\*(C`device\*(C'\fR that have been discarded by a
call to \f(CW\*(C`guestfs_blkdiscard\*(C'\fR are returned as blocks of zero bytes when read
the next time.
.PP
If it returns false, then it may be that discarded blocks are read as stale
or random data.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
This function depends on the feature \f(CW\*(C`blkdiscardzeroes\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.25.44)
.SS "guestfs_blkid"
.IX Subsection "guestfs_blkid"
.Vb 3
\& char **
\& guestfs_blkid (guestfs_h *g,
\&                const char *device);
.Ve
.PP
This command returns block device attributes for \f(CW\*(C`device\*(C'\fR. The following
fields are usually present in the returned hash. Other fields may also be
present.
.ie n .IP """UUID""" 4
.el .IP "\f(CWUUID\fR" 4
.IX Item "UUID"
このデバイスのUUID。
.ie n .IP """LABEL""" 4
.el .IP "\f(CWLABEL\fR" 4
.IX Item "LABEL"
このデバイスのラベル。
.ie n .IP """VERSION""" 4
.el .IP "\f(CWVERSION\fR" 4
.IX Item "VERSION"
blkid コマンドのバージョン。
.ie n .IP """TYPE""" 4
.el .IP "\f(CWTYPE\fR" 4
.IX Item "TYPE"
このデバイスのファイルシステム形式または RAID。
.ie n .IP """USAGE""" 4
.el .IP "\f(CWUSAGE\fR" 4
.IX Item "USAGE"
このデバイスの使用法です。たとえば、\f(CW\*(C`filesystem\*(C'\fR や \f(CW\*(C`raid\*(C'\fR。
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(1.15.9 において追加)
.SS "guestfs_blockdev_flushbufs"
.IX Subsection "guestfs_blockdev_flushbufs"
.Vb 3
\& int
\& guestfs_blockdev_flushbufs (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR と関連づけられている内部バッファーをフラッシュするようカーネルに指示します。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_getbsz"
.IX Subsection "guestfs_blockdev_getbsz"
.Vb 3
\& int
\& guestfs_blockdev_getbsz (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
これはデバイスのブロック容量を返します。
.PP
Note: this is different from both \fIsize in blocks\fR and \fIfilesystem block
size\fR.  Also this setting is not really used by anything.  You should
probably not use it for anything.  Filesystems have their own idea about
what block size to choose.
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_getro"
.IX Subsection "guestfs_blockdev_getro"
.Vb 3
\& int
\& guestfs_blockdev_getro (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
ブロックデバイスが読み込み専用であるかどうかを示す論理値を返します（読み込み専用ならば真、そうでなければ偽）。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_getsize64"
.IX Subsection "guestfs_blockdev_getsize64"
.Vb 3
\& int64_t
\& guestfs_blockdev_getsize64 (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
これはデバイスの容量をバイト単位で返します。
.PP
\&\f(CW\*(C`guestfs_blockdev_getsz\*(C'\fR 参照。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_getss"
.IX Subsection "guestfs_blockdev_getss"
.Vb 3
\& int
\& guestfs_blockdev_getss (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
これはブロックデバイスのセクター容量を返します。通常は 512 ですが、最近のデバイスはより大きいかもしれません。
.PP
（これはセクターのサイズではありません、そのためには \f(CW\*(C`guestfs_blockdev_getsz\*(C'\fR を使用する必要があることに注意してください）。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_getsz"
.IX Subsection "guestfs_blockdev_getsz"
.Vb 3
\& int64_t
\& guestfs_blockdev_getsz (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
This returns the size of the device in units of 512\-byte sectors (even if
the sectorsize isn't 512 bytes ... weird).
.PP
See also \f(CW\*(C`guestfs_blockdev_getss\*(C'\fR for the real sector size of the device,
and \f(CW\*(C`guestfs_blockdev_getsize64\*(C'\fR for the more useful \fIsize in bytes\fR.
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_rereadpt"
.IX Subsection "guestfs_blockdev_rereadpt"
.Vb 3
\& int
\& guestfs_blockdev_rereadpt (guestfs_h *g,
\&                            const char *device);
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR のパーティションテーブルを再読み込みします。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_setbsz"
.IX Subsection "guestfs_blockdev_setbsz"
.Vb 4
\& int
\& guestfs_blockdev_setbsz (guestfs_h *g,
\&                          const char *device,
\&                          int blocksize);
.Ve
.PP
\&\fIThis function is deprecated.\fR There is no replacement.  Consult the \s-1API\s0
documentation in \fIguestfs\fR\|(3) for further information.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This call does nothing and has never done anything because of a bug in
blockdev.  \fBDo not use it.\fR
.PP
If you need to set the filesystem block size, use the \f(CW\*(C`blocksize\*(C'\fR option of
\&\f(CW\*(C`guestfs_mkfs\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_setra"
.IX Subsection "guestfs_blockdev_setra"
.Vb 4
\& int
\& guestfs_blockdev_setra (guestfs_h *g,
\&                         const char *device,
\&                         int sectors);
.Ve
.PP
Set readahead (in 512\-byte sectors) for the device.
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.29.10)
.SS "guestfs_blockdev_setro"
.IX Subsection "guestfs_blockdev_setro"
.Vb 3
\& int
\& guestfs_blockdev_setro (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR という名前のブロックデバイスを読み込み専用に設定します。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_blockdev_setrw"
.IX Subsection "guestfs_blockdev_setrw"
.Vb 3
\& int
\& guestfs_blockdev_setrw (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR という名前のブロックデバイスを読み書きに設定します。
.PP
これは \fIblockdev\fR\|(8) コマンドを使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.9.3)
.SS "guestfs_btrfs_balance_cancel"
.IX Subsection "guestfs_btrfs_balance_cancel"
.Vb 3
\& int
\& guestfs_btrfs_balance_cancel (guestfs_h *g,
\&                               const char *path);
.Ve
.PP
Cancel a running balance on a btrfs filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_balance_pause"
.IX Subsection "guestfs_btrfs_balance_pause"
.Vb 3
\& int
\& guestfs_btrfs_balance_pause (guestfs_h *g,
\&                              const char *path);
.Ve
.PP
Pause a running balance on a btrfs filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_balance_resume"
.IX Subsection "guestfs_btrfs_balance_resume"
.Vb 3
\& int
\& guestfs_btrfs_balance_resume (guestfs_h *g,
\&                               const char *path);
.Ve
.PP
Resume a paused balance on a btrfs filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_balance_status"
.IX Subsection "guestfs_btrfs_balance_status"
.Vb 3
\& struct guestfs_btrfsbalance *
\& guestfs_btrfs_balance_status (guestfs_h *g,
\&                               const char *path);
.Ve
.PP
Show the status of a running or paused balance on a btrfs filesystem.
.PP
This function returns a \f(CW\*(C`struct guestfs_btrfsbalance *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_btrfsbalance\*(C'\fI after
use\fR.
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.26)
.SS "guestfs_btrfs_device_add"
.IX Subsection "guestfs_btrfs_device_add"
.Vb 4
\& int
\& guestfs_btrfs_device_add (guestfs_h *g,
\&                           char *const *devices,
\&                           const char *fs);
.Ve
.PP
\&\f(CW\*(C`devices\*(C'\fR にあるデバイスの一覧を \f(CW\*(C`fs\*(C'\fR にマウントされた btrfs ファイルシステムに追加します。もし \f(CW\*(C`devices\*(C'\fR
が空の一覧ならば、何もしません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_device_delete"
.IX Subsection "guestfs_btrfs_device_delete"
.Vb 4
\& int
\& guestfs_btrfs_device_delete (guestfs_h *g,
\&                              char *const *devices,
\&                              const char *fs);
.Ve
.PP
\&\f(CW\*(C`devices\*(C'\fR にあるデバイスの一覧を \f(CW\*(C`fs\*(C'\fR にマウントされた btrfs ファイルシステムから削除します。もし \f(CW\*(C`devices\*(C'\fR
が空の一覧ならば、何もしません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_filesystem_balance"
.IX Subsection "guestfs_btrfs_filesystem_balance"
.Vb 3
\& int
\& guestfs_btrfs_filesystem_balance (guestfs_h *g,
\&                                   const char *fs);
.Ve
.PP
Balance the chunks in the btrfs filesystem mounted at \f(CW\*(C`fs\*(C'\fR across the
underlying devices.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_filesystem_defragment"
.IX Subsection "guestfs_btrfs_filesystem_defragment"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_defragment (guestfs_h *g,
\&                                      const char *path,
\&                                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_FLUSH, int flush,
\& GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_COMPRESS, const char *compress,
.Ve
.PP
Defragment a file or directory on a btrfs filesystem. compress is one of
zlib or lzo.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_filesystem_defragment_va"
.IX Subsection "guestfs_btrfs_filesystem_defragment_va"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_defragment_va (guestfs_h *g,
\&                                         const char *path,
\&                                         va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_btrfs_filesystem_defragment\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_filesystem_defragment_argv"
.IX Subsection "guestfs_btrfs_filesystem_defragment_argv"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_defragment_argv (guestfs_h *g,
\&                                           const char *path,
\&                                           const struct guestfs_btrfs_filesystem_defragment_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_btrfs_filesystem_defragment\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_filesystem_resize"
.IX Subsection "guestfs_btrfs_filesystem_resize"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize (guestfs_h *g,
\&                                  const char *mountpoint,
\&                                  ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE, int64_t size,
.Ve
.PP
このコマンドは btrfs ファイルシステムの容量を変更します。
.PP
Note that unlike other resize calls, the filesystem has to be mounted and
the parameter is the mountpoint not the device (this is a requirement of
btrfs itself).
.PP
オプションのパラメーターは次のとおりです:
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
ファイルシステムの新しい容量（バイト単位）。省略されると、ファイルシステムは最大の容量に変更されます。
.PP
\&\fIbtrfs\fR\|(8) 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.11.17 において追加)
.SS "guestfs_btrfs_filesystem_resize_va"
.IX Subsection "guestfs_btrfs_filesystem_resize_va"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize_va (guestfs_h *g,
\&                                     const char *mountpoint,
\&                                     va_list args);
.Ve
.PP
これは \*(L"guestfs_btrfs_filesystem_resize\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_filesystem_resize_argv"
.IX Subsection "guestfs_btrfs_filesystem_resize_argv"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize_argv (guestfs_h *g,
\&                                       const char *mountpoint,
\&                                       const struct guestfs_btrfs_filesystem_resize_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_btrfs_filesystem_resize\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_filesystem_show"
.IX Subsection "guestfs_btrfs_filesystem_show"
.Vb 3
\& char **
\& guestfs_btrfs_filesystem_show (guestfs_h *g,
\&                                const char *device);
.Ve
.PP
Show all the devices where the filesystems in \f(CW\*(C`device\*(C'\fR is spanned over.
.PP
If not all the devices for the filesystems are present, then this function
fails and the \f(CW\*(C`errno\*(C'\fR is set to \f(CW\*(C`ENODEV\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.29)
.SS "guestfs_btrfs_filesystem_sync"
.IX Subsection "guestfs_btrfs_filesystem_sync"
.Vb 3
\& int
\& guestfs_btrfs_filesystem_sync (guestfs_h *g,
\&                                const char *fs);
.Ve
.PP
\&\f(CW\*(C`fs\*(C'\fR にマウントされた btrfs ファイルシステムにおいて強制同期します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_fsck"
.IX Subsection "guestfs_btrfs_fsck"
.Vb 4
\& int
\& guestfs_btrfs_fsck (guestfs_h *g,
\&                     const char *device,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_BTRFS_FSCK_SUPERBLOCK, int64_t superblock,
\& GUESTFS_BTRFS_FSCK_REPAIR, int repair,
.Ve
.PP
btrfs ファイルシステムをチェックするために使用されると、\f(CW\*(C`device\*(C'\fR はファイルシステムが保存されているデバイスファイルです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.43 において追加)
.SS "guestfs_btrfs_fsck_va"
.IX Subsection "guestfs_btrfs_fsck_va"
.Vb 4
\& int
\& guestfs_btrfs_fsck_va (guestfs_h *g,
\&                        const char *device,
\&                        va_list args);
.Ve
.PP
これは \*(L"guestfs_btrfs_fsck\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_fsck_argv"
.IX Subsection "guestfs_btrfs_fsck_argv"
.Vb 4
\& int
\& guestfs_btrfs_fsck_argv (guestfs_h *g,
\&                          const char *device,
\&                          const struct guestfs_btrfs_fsck_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_btrfs_fsck\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_image"
.IX Subsection "guestfs_btrfs_image"
.Vb 5
\& int
\& guestfs_btrfs_image (guestfs_h *g,
\&                      char *const *source,
\&                      const char *image,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_BTRFS_IMAGE_COMPRESSLEVEL, int compresslevel,
.Ve
.PP
This is used to create an image of a btrfs filesystem.  All data will be
zeroed, but metadata and the like is preserved.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.32)
.SS "guestfs_btrfs_image_va"
.IX Subsection "guestfs_btrfs_image_va"
.Vb 5
\& int
\& guestfs_btrfs_image_va (guestfs_h *g,
\&                         char *const *source,
\&                         const char *image,
\&                         va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_btrfs_image\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_image_argv"
.IX Subsection "guestfs_btrfs_image_argv"
.Vb 5
\& int
\& guestfs_btrfs_image_argv (guestfs_h *g,
\&                           char *const *source,
\&                           const char *image,
\&                           const struct guestfs_btrfs_image_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_btrfs_image\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_qgroup_assign"
.IX Subsection "guestfs_btrfs_qgroup_assign"
.Vb 5
\& int
\& guestfs_btrfs_qgroup_assign (guestfs_h *g,
\&                              const char *src,
\&                              const char *dst,
\&                              const char *path);
.Ve
.PP
Add qgroup \f(CW\*(C`src\*(C'\fR to parent qgroup \f(CW\*(C`dst\*(C'\fR. This command can group several
qgroups into a parent qgroup to share common limit.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_qgroup_create"
.IX Subsection "guestfs_btrfs_qgroup_create"
.Vb 4
\& int
\& guestfs_btrfs_qgroup_create (guestfs_h *g,
\&                              const char *qgroupid,
\&                              const char *subvolume);
.Ve
.PP
Create a quota group (qgroup) for subvolume at \f(CW\*(C`subvolume\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_qgroup_destroy"
.IX Subsection "guestfs_btrfs_qgroup_destroy"
.Vb 4
\& int
\& guestfs_btrfs_qgroup_destroy (guestfs_h *g,
\&                               const char *qgroupid,
\&                               const char *subvolume);
.Ve
.PP
Destroy a quota group.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_qgroup_limit"
.IX Subsection "guestfs_btrfs_qgroup_limit"
.Vb 4
\& int
\& guestfs_btrfs_qgroup_limit (guestfs_h *g,
\&                             const char *subvolume,
\&                             int64_t size);
.Ve
.PP
Limit the size of the subvolume with path \f(CW\*(C`subvolume\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_qgroup_remove"
.IX Subsection "guestfs_btrfs_qgroup_remove"
.Vb 5
\& int
\& guestfs_btrfs_qgroup_remove (guestfs_h *g,
\&                              const char *src,
\&                              const char *dst,
\&                              const char *path);
.Ve
.PP
Remove qgroup \f(CW\*(C`src\*(C'\fR from the parent qgroup \f(CW\*(C`dst\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_qgroup_show"
.IX Subsection "guestfs_btrfs_qgroup_show"
.Vb 3
\& struct guestfs_btrfsqgroup_list *
\& guestfs_btrfs_qgroup_show (guestfs_h *g,
\&                            const char *path);
.Ve
.PP
Show all subvolume quota groups in a btrfs filesystem, including their
usages.
.PP
This function returns a \f(CW\*(C`struct guestfs_btrfsqgroup_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_btrfsqgroup_list\*(C'\fI
after use\fR.
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_quota_enable"
.IX Subsection "guestfs_btrfs_quota_enable"
.Vb 4
\& int
\& guestfs_btrfs_quota_enable (guestfs_h *g,
\&                             const char *fs,
\&                             int enable);
.Ve
.PP
Enable or disable subvolume quota support for filesystem which contains
\&\f(CW\*(C`path\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_quota_rescan"
.IX Subsection "guestfs_btrfs_quota_rescan"
.Vb 3
\& int
\& guestfs_btrfs_quota_rescan (guestfs_h *g,
\&                             const char *fs);
.Ve
.PP
Trash all qgroup numbers and scan the metadata again with the current
config.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_replace"
.IX Subsection "guestfs_btrfs_replace"
.Vb 5
\& int
\& guestfs_btrfs_replace (guestfs_h *g,
\&                        const char *srcdev,
\&                        const char *targetdev,
\&                        const char *mntpoint);
.Ve
.PP
Replace device of a btrfs filesystem. On a live filesystem, duplicate the
data to the target device which is currently stored on the source device.
After completion of the operation, the source device is wiped out and
removed from the filesystem.
.PP
The \f(CW\*(C`targetdev\*(C'\fR needs to be same size or larger than the \f(CW\*(C`srcdev\*(C'\fR. Devices
which are currently mounted are never allowed to be used as the
\&\f(CW\*(C`targetdev\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.48)
.SS "guestfs_btrfs_rescue_chunk_recover"
.IX Subsection "guestfs_btrfs_rescue_chunk_recover"
.Vb 3
\& int
\& guestfs_btrfs_rescue_chunk_recover (guestfs_h *g,
\&                                     const char *device);
.Ve
.PP
Recover the chunk tree of btrfs filesystem by scanning the devices one by
one.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_rescue_super_recover"
.IX Subsection "guestfs_btrfs_rescue_super_recover"
.Vb 3
\& int
\& guestfs_btrfs_rescue_super_recover (guestfs_h *g,
\&                                     const char *device);
.Ve
.PP
Recover bad superblocks from good copies.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_scrub_cancel"
.IX Subsection "guestfs_btrfs_scrub_cancel"
.Vb 3
\& int
\& guestfs_btrfs_scrub_cancel (guestfs_h *g,
\&                             const char *path);
.Ve
.PP
Cancel a running scrub on a btrfs filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_scrub_resume"
.IX Subsection "guestfs_btrfs_scrub_resume"
.Vb 3
\& int
\& guestfs_btrfs_scrub_resume (guestfs_h *g,
\&                             const char *path);
.Ve
.PP
Resume a previously canceled or interrupted scrub on a btrfs filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_scrub_start"
.IX Subsection "guestfs_btrfs_scrub_start"
.Vb 3
\& int
\& guestfs_btrfs_scrub_start (guestfs_h *g,
\&                            const char *path);
.Ve
.PP
Reads all the data and metadata on the filesystem, and uses checksums and
the duplicate copies from \s-1RAID\s0 storage to identify and repair any corrupt
data.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.22)
.SS "guestfs_btrfs_scrub_status"
.IX Subsection "guestfs_btrfs_scrub_status"
.Vb 3
\& struct guestfs_btrfsscrub *
\& guestfs_btrfs_scrub_status (guestfs_h *g,
\&                             const char *path);
.Ve
.PP
Show status of running or finished scrub on a btrfs filesystem.
.PP
This function returns a \f(CW\*(C`struct guestfs_btrfsscrub *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_btrfsscrub\*(C'\fI after use\fR.
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.26)
.SS "guestfs_btrfs_set_seeding"
.IX Subsection "guestfs_btrfs_set_seeding"
.Vb 4
\& int
\& guestfs_btrfs_set_seeding (guestfs_h *g,
\&                            const char *device,
\&                            int seeding);
.Ve
.PP
btrfs ファイルシステムを含むデバイスの seeding 機能を有効化または無効化します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.43 において追加)
.SS "guestfs_btrfs_subvolume_create"
.IX Subsection "guestfs_btrfs_subvolume_create"
.Vb 3
\& int
\& guestfs_btrfs_subvolume_create (guestfs_h *g,
\&                                 const char *dest);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_btrfs_subvolume_create_opts\*(R" with
no optional arguments.
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_create_opts"
.IX Subsection "guestfs_btrfs_subvolume_create_opts"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_create_opts (guestfs_h *g,
\&                                      const char *dest,
\&                                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_BTRFS_SUBVOLUME_CREATE_OPTS_QGROUPID, const char *qgroupid,
.Ve
.PP
Create a btrfs subvolume.  The \f(CW\*(C`dest\*(C'\fR argument is the destination directory
and the name of the subvolume, in the form \fI/path/to/dest/name\fR.  The
optional parameter \f(CW\*(C`qgroupid\*(C'\fR represents the qgroup which the newly created
subvolume will be added to.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_create_opts_va"
.IX Subsection "guestfs_btrfs_subvolume_create_opts_va"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_create_opts_va (guestfs_h *g,
\&                                         const char *dest,
\&                                         va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_btrfs_subvolume_create_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_subvolume_create_opts_argv"
.IX Subsection "guestfs_btrfs_subvolume_create_opts_argv"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_create_opts_argv (guestfs_h *g,
\&                                           const char *dest,
\&                                           const struct guestfs_btrfs_subvolume_create_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_btrfs_subvolume_create_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_subvolume_delete"
.IX Subsection "guestfs_btrfs_subvolume_delete"
.Vb 3
\& int
\& guestfs_btrfs_subvolume_delete (guestfs_h *g,
\&                                 const char *subvolume);
.Ve
.PP
Delete the named btrfs subvolume or snapshot.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_get_default"
.IX Subsection "guestfs_btrfs_subvolume_get_default"
.Vb 3
\& int64_t
\& guestfs_btrfs_subvolume_get_default (guestfs_h *g,
\&                                      const char *fs);
.Ve
.PP
Get the default subvolume or snapshot of a filesystem mounted at
\&\f(CW\*(C`mountpoint\*(C'\fR.
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_subvolume_list"
.IX Subsection "guestfs_btrfs_subvolume_list"
.Vb 3
\& struct guestfs_btrfssubvolume_list *
\& guestfs_btrfs_subvolume_list (guestfs_h *g,
\&                               const char *fs);
.Ve
.PP
\&\f(CW\*(C`fs\*(C'\fR にマウントされている btrfs ファイルシステムの btrfs スナップショットとサブディレクトリーを一覧表示します。
.PP
この関数は \f(CW\*(C`struct guestfs_btrfssubvolume_list *\*(C'\fR を返します。エラーが発生した場合、NULL が返されます。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_btrfssubvolume_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_set_default"
.IX Subsection "guestfs_btrfs_subvolume_set_default"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_set_default (guestfs_h *g,
\&                                      int64_t id,
\&                                      const char *fs);
.Ve
.PP
Set the subvolume of the btrfs filesystem \f(CW\*(C`fs\*(C'\fR which will be mounted by
default.  See \f(CW\*(C`guestfs_btrfs_subvolume_list\*(C'\fR to get a list of subvolumes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_show"
.IX Subsection "guestfs_btrfs_subvolume_show"
.Vb 3
\& char **
\& guestfs_btrfs_subvolume_show (guestfs_h *g,
\&                               const char *subvolume);
.Ve
.PP
Return detailed information of the subvolume.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.17)
.SS "guestfs_btrfs_subvolume_snapshot"
.IX Subsection "guestfs_btrfs_subvolume_snapshot"
.Vb 4
\& int
\& guestfs_btrfs_subvolume_snapshot (guestfs_h *g,
\&                                   const char *source,
\&                                   const char *dest);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_btrfs_subvolume_snapshot_opts\*(R"
with no optional arguments.
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_snapshot_opts"
.IX Subsection "guestfs_btrfs_subvolume_snapshot_opts"
.Vb 5
\& int
\& guestfs_btrfs_subvolume_snapshot_opts (guestfs_h *g,
\&                                        const char *source,
\&                                        const char *dest,
\&                                        ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_RO, int ro,
\& GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_QGROUPID, const char *qgroupid,
.Ve
.PP
Create a snapshot of the btrfs subvolume \f(CW\*(C`source\*(C'\fR.  The \f(CW\*(C`dest\*(C'\fR argument is
the destination directory and the name of the snapshot, in the form
\&\fI/path/to/dest/name\fR. By default the newly created snapshot is writable, if
the value of optional parameter \f(CW\*(C`ro\*(C'\fR is true, then a readonly snapshot is
created. The optional parameter \f(CW\*(C`qgroupid\*(C'\fR represents the qgroup which the
newly created snapshot will be added to.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.35 において追加)
.SS "guestfs_btrfs_subvolume_snapshot_opts_va"
.IX Subsection "guestfs_btrfs_subvolume_snapshot_opts_va"
.Vb 5
\& int
\& guestfs_btrfs_subvolume_snapshot_opts_va (guestfs_h *g,
\&                                           const char *source,
\&                                           const char *dest,
\&                                           va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_btrfs_subvolume_snapshot_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfs_subvolume_snapshot_opts_argv"
.IX Subsection "guestfs_btrfs_subvolume_snapshot_opts_argv"
.Vb 5
\& int
\& guestfs_btrfs_subvolume_snapshot_opts_argv (guestfs_h *g,
\&                                             const char *source,
\&                                             const char *dest,
\&                                             const struct guestfs_btrfs_subvolume_snapshot_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_btrfs_subvolume_snapshot_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_btrfstune_enable_extended_inode_refs"
.IX Subsection "guestfs_btrfstune_enable_extended_inode_refs"
.Vb 3
\& int
\& guestfs_btrfstune_enable_extended_inode_refs (guestfs_h *g,
\&                                               const char *device);
.Ve
.PP
This will Enable extended inode refs.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.29)
.SS "guestfs_btrfstune_enable_skinny_metadata_extent_refs"
.IX Subsection "guestfs_btrfstune_enable_skinny_metadata_extent_refs"
.Vb 3
\& int
\& guestfs_btrfstune_enable_skinny_metadata_extent_refs (guestfs_h *g,
\&                                                       const char *device);
.Ve
.PP
This enable skinny metadata extent refs.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.29)
.SS "guestfs_btrfstune_seeding"
.IX Subsection "guestfs_btrfstune_seeding"
.Vb 4
\& int
\& guestfs_btrfstune_seeding (guestfs_h *g,
\&                            const char *device,
\&                            int seeding);
.Ve
.PP
Enable seeding of a btrfs device, this will force a fs readonly so that you
can use it to build other filesystems.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.29)
.SS "guestfs_c_pointer"
.IX Subsection "guestfs_c_pointer"
.Vb 2
\& int64_t
\& guestfs_c_pointer (guestfs_h *g);
.Ve
.PP
In non-C language bindings, this allows you to retrieve the underlying C
pointer to the handle (ie. \f(CW\*(C`guestfs_h *\*(C'\fR).  The purpose of this is to allow
other libraries to interwork with libguestfs.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.29.17)
.SS "guestfs_canonical_device_name"
.IX Subsection "guestfs_canonical_device_name"
.Vb 3
\& char *
\& guestfs_canonical_device_name (guestfs_h *g,
\&                                const char *device);
.Ve
.PP
This utility function is useful when displaying device names to the user.
It takes a number of irregular device names and returns them in a consistent
format:
.IP "\fI/dev/hdX\fR" 4
.IX Item "/dev/hdX"
.PD 0
.IP "\fI/dev/vdX\fR" 4
.IX Item "/dev/vdX"
.PD
These are returned as \fI/dev/sdX\fR.  Note this works for device names and
partition names.  This is approximately the reverse of the algorithm
described in \*(L"\s-1BLOCK DEVICE NAMING\*(R"\s0.
.IP "\fI/dev/mapper/VG\-LV\fR" 4
.IX Item "/dev/mapper/VG-LV"
.PD 0
.IP "\fI/dev/dm\-N\fR" 4
.IX Item "/dev/dm-N"
.PD
Converted to \fI/dev/VG/LV\fR form using \f(CW\*(C`guestfs_lvm_canonical_lv_name\*(C'\fR.
.PP
他の文字列は修正されずに返されます。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.7 において追加)
.SS "guestfs_cap_get_file"
.IX Subsection "guestfs_cap_get_file"
.Vb 3
\& char *
\& guestfs_cap_get_file (guestfs_h *g,
\&                       const char *path);
.Ve
.PP
This function returns the Linux capabilities attached to \f(CW\*(C`path\*(C'\fR.  The
capabilities set is returned in text form (see \fIcap_to_text\fR\|(3)).
.PP
If no capabilities are attached to a file, an empty string is returned.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`linuxcaps\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.19.63)
.SS "guestfs_cap_set_file"
.IX Subsection "guestfs_cap_set_file"
.Vb 4
\& int
\& guestfs_cap_set_file (guestfs_h *g,
\&                       const char *path,
\&                       const char *cap);
.Ve
.PP
This function sets the Linux capabilities attached to \f(CW\*(C`path\*(C'\fR.  The
capabilities set \f(CW\*(C`cap\*(C'\fR should be passed in text form (see
\&\fIcap_from_text\fR\|(3)).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxcaps\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.19.63)
.SS "guestfs_case_sensitive_path"
.IX Subsection "guestfs_case_sensitive_path"
.Vb 3
\& char *
\& guestfs_case_sensitive_path (guestfs_h *g,
\&                              const char *path);
.Ve
.PP
This can be used to resolve case insensitive paths on a filesystem which is
case sensitive.  The use case is to resolve paths which you have read from
Windows configuration files or the Windows Registry, to the true path.
.PP
The command handles a peculiarity of the Linux ntfs\-3g filesystem driver
(and probably others), which is that although the underlying filesystem is
case-insensitive, the driver exports the filesystem to Linux as
case-sensitive.
.PP
One consequence of this is that special directories such as \fIC:\ewindows\fR
may appear as \fI/WINDOWS\fR or \fI/windows\fR (or other things) depending on the
precise details of how they were created.  In Windows itself this would not
be a problem.
.PP
バグか機能か？次を見て決めてください:
http://www.tuxera.com/community/ntfs\-3g\-faq/#posixfilenames1
.PP
\&\f(CW\*(C`guestfs_case_sensitive_path\*(C'\fR attempts to resolve the true case of each
element in the path. It will return a resolved path if either the full path
or its parent directory exists. If the parent directory exists but the full
path does not, the case of the parent directory will be correctly resolved,
and the remainder appended unmodified. For example, if the file
\&\f(CW"/Windows/System32/netkvm.sys"\fR exists:
.ie n .IP """guestfs_case_sensitive_path"" (""/windows/system32/netkvm.sys"")" 4
.el .IP "\f(CWguestfs_case_sensitive_path\fR (``/windows/system32/netkvm.sys'')" 4
.IX Item "guestfs_case_sensitive_path (/windows/system32/netkvm.sys)"
\&\*(L"Windows/System32/netkvm.sys\*(R"
.ie n .IP """guestfs_case_sensitive_path"" (""/windows/system32/NoSuchFile"")" 4
.el .IP "\f(CWguestfs_case_sensitive_path\fR (``/windows/system32/NoSuchFile'')" 4
.IX Item "guestfs_case_sensitive_path (/windows/system32/NoSuchFile)"
\&\*(L"Windows/System32/NoSuchFile\*(R"
.ie n .IP """guestfs_case_sensitive_path"" (""/windows/system33/netkvm.sys"")" 4
.el .IP "\f(CWguestfs_case_sensitive_path\fR (``/windows/system33/netkvm.sys'')" 4
.IX Item "guestfs_case_sensitive_path (/windows/system33/netkvm.sys)"
\&\fI\s-1ERROR\s0\fR
.PP
\&\fINote\fR: Because of the above behaviour, \f(CW\*(C`guestfs_case_sensitive_path\*(C'\fR
cannot be used to check for the existence of a file.
.PP
\&\fINote\fR: This function does not handle drive names, backslashes etc.
.PP
\&\f(CW\*(C`guestfs_realpath\*(C'\fR 参照。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.75 において追加)
.SS "guestfs_cat"
.IX Subsection "guestfs_cat"
.Vb 3
\& char *
\& guestfs_cat (guestfs_h *g,
\&              const char *path);
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR という名前のファイルの内容を返します。
.PP
Because, in C, this function returns a \f(CW\*(C`char *\*(C'\fR, there is no way to
differentiate between a \f(CW\*(C`\e0\*(C'\fR character in a file and end of string.  To
handle binary files, use the \f(CW\*(C`guestfs_read_file\*(C'\fR or \f(CW\*(C`guestfs_download\*(C'\fR
functions.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(0.4 において追加)
.SS "guestfs_checksum"
.IX Subsection "guestfs_checksum"
.Vb 4
\& char *
\& guestfs_checksum (guestfs_h *g,
\&                   const char *csumtype,
\&                   const char *path);
.Ve
.PP
この呼び出しは \f(CW\*(C`path\*(C'\fR という名前のファイルの \s-1MD5,\s0 SHAx または \s-1CRC\s0 チェックサムを計算します。
.PP
計算するチェックサムの種類は、以下の値のどれかである \f(CW\*(C`csumtype\*(C'\fR パラメーターにより与えられます:
.ie n .IP """crc""" 4
.el .IP "\f(CWcrc\fR" 4
.IX Item "crc"
\&\f(CW\*(C`cksum\*(C'\fR コマンドに対して \s-1POSIX\s0 により指定された巡回冗長検査 (\s-1CRC:\s0 cyclic redundancy check)
を計算します。
.ie n .IP """md5""" 4
.el .IP "\f(CWmd5\fR" 4
.IX Item "md5"
（\f(CW\*(C`md5sum\*(C'\fR プログラムを用いて）MD5 ハッシュを計算します。
.ie n .IP """sha1""" 4
.el .IP "\f(CWsha1\fR" 4
.IX Item "sha1"
（\f(CW\*(C`sha1sum\*(C'\fR プログラムを用いて）SHA1 ハッシュを計算します。
.ie n .IP """sha224""" 4
.el .IP "\f(CWsha224\fR" 4
.IX Item "sha224"
（\f(CW\*(C`sha224sum\*(C'\fR プログラムを用いて）SHA224 ハッシュを計算します。
.ie n .IP """sha256""" 4
.el .IP "\f(CWsha256\fR" 4
.IX Item "sha256"
（\f(CW\*(C`sha256sum\*(C'\fR プログラムを用いて）SHA256 ハッシュを計算します。
.ie n .IP """sha384""" 4
.el .IP "\f(CWsha384\fR" 4
.IX Item "sha384"
（\f(CW\*(C`sha384sum\*(C'\fR プログラムを用いて）SHA384 ハッシュを計算します。
.ie n .IP """sha512""" 4
.el .IP "\f(CWsha512\fR" 4
.IX Item "sha512"
（\f(CW\*(C`sha512sum\*(C'\fR プログラムを用いて）SHA512 ハッシュを計算します。
.PP
チェックサムは表示可能な文字列として返されます。
.PP
デバイスのチェックサムを取得するには \f(CW\*(C`guestfs_checksum_device\*(C'\fR を使用します。
.PP
多くのファイルのチェックサムを取得するには \f(CW\*(C`guestfs_checksums_out\*(C'\fR を使用します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.2 において追加)
.SS "guestfs_checksum_device"
.IX Subsection "guestfs_checksum_device"
.Vb 4
\& char *
\& guestfs_checksum_device (guestfs_h *g,
\&                          const char *csumtype,
\&                          const char *device);
.Ve
.PP
This call computes the \s-1MD5,\s0 SHAx or \s-1CRC\s0 checksum of the contents of the
device named \f(CW\*(C`device\*(C'\fR.  For the types of checksums supported see the
\&\f(CW\*(C`guestfs_checksum\*(C'\fR command.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.3.2 において追加)
.SS "guestfs_checksums_out"
.IX Subsection "guestfs_checksums_out"
.Vb 5
\& int
\& guestfs_checksums_out (guestfs_h *g,
\&                        const char *csumtype,
\&                        const char *directory,
\&                        const char *sumsfile);
.Ve
.PP
This command computes the checksums of all regular files in \fIdirectory\fR and
then emits a list of those checksums to the local output file \f(CW\*(C`sumsfile\*(C'\fR.
.PP
This can be used for verifying the integrity of a virtual machine.  However
to be properly secure you should pay attention to the output of the checksum
command (it uses the ones from \s-1GNU\s0 coreutils).  In particular when the
filename is not printable, coreutils uses a special backslash syntax.  For
more information, see the \s-1GNU\s0 coreutils info file.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.7 において追加)
.SS "guestfs_chmod"
.IX Subsection "guestfs_chmod"
.Vb 4
\& int
\& guestfs_chmod (guestfs_h *g,
\&                int mode,
\&                const char *path);
.Ve
.PP
Change the mode (permissions) of \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`mode\*(C'\fR.  Only numeric modes are
supported.
.PP
\&\fINote\fR: When using this command from guestfish, \f(CW\*(C`mode\*(C'\fR by default would be
decimal, unless you prefix it with \f(CW0\fR to get octal, ie. use \f(CW0700\fR not
\&\f(CW700\fR.
.PP
実際に設定されるモードは umask により影響されます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_chown"
.IX Subsection "guestfs_chown"
.Vb 5
\& int
\& guestfs_chown (guestfs_h *g,
\&                int owner,
\&                int group,
\&                const char *path);
.Ve
.PP
ファイルの所有者を \f(CW\*(C`owner\*(C'\fR に、グループを \f(CW\*(C`group\*(C'\fR に変更します。
.PP
Only numeric uid and gid are supported.  If you want to use names, you will
need to locate and parse the password file yourself (Augeas support makes
this relatively easy).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_clear_backend_setting"
.IX Subsection "guestfs_clear_backend_setting"
.Vb 3
\& int
\& guestfs_clear_backend_setting (guestfs_h *g,
\&                                const char *name);
.Ve
.PP
If there is a backend setting string matching \f(CW"name"\fR or beginning with
\&\f(CW"name="\fR, then that string is removed from the backend settings.
.PP
This call returns the number of strings which were removed (which may be 0,
1 or greater than 1).
.PP
See \*(L"\s-1BACKEND\*(R"\s0, \*(L"\s-1BACKEND SETTINGS\*(R"\s0.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.27.2)
.SS "guestfs_command"
.IX Subsection "guestfs_command"
.Vb 3
\& char *
\& guestfs_command (guestfs_h *g,
\&                  char *const *arguments);
.Ve
.PP
This call runs a command from the guest filesystem.  The filesystem must be
mounted, and must contain a compatible operating system (ie. something
Linux, with the same or compatible processor architecture).
.PP
The single parameter is an argv-style list of arguments.  The first element
is the name of the program to run.  Subsequent elements are parameters.  The
list must be non-empty (ie. must contain a program name).  Note that the
command runs directly, and is \fInot\fR invoked via the shell (see
\&\f(CW\*(C`guestfs_sh\*(C'\fR).
.PP
The return value is anything printed to \fIstdout\fR by the command.
.PP
If the command returns a non-zero exit status, then this function returns an
error message.  The error message string is the content of \fIstderr\fR from
the command.
.PP
The \f(CW$PATH\fR environment variable will contain at least \fI/usr/bin\fR and
\&\fI/bin\fR.  If you require a program from another location, you should provide
the full path in the first parameter.
.PP
Shared libraries and data files required by the program must be available on
filesystems which are mounted in the correct places.  It is the caller's
responsibility to ensure all filesystems that are needed are mounted at the
right locations.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(Added in 1.9.1)
.SS "guestfs_command_lines"
.IX Subsection "guestfs_command_lines"
.Vb 3
\& char **
\& guestfs_command_lines (guestfs_h *g,
\&                        char *const *arguments);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_command\*(C'\fR, but splits the result into a list of
lines.
.PP
関連項目: \f(CW\*(C`guestfs_sh_lines\*(C'\fR
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(Added in 1.9.1)
.SS "guestfs_compress_device_out"
.IX Subsection "guestfs_compress_device_out"
.Vb 6
\& int
\& guestfs_compress_device_out (guestfs_h *g,
\&                              const char *ctype,
\&                              const char *device,
\&                              const char *zdevice,
\&                              ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_COMPRESS_DEVICE_OUT_LEVEL, int level,
.Ve
.PP
This command compresses \f(CW\*(C`device\*(C'\fR and writes it out to the local file
\&\f(CW\*(C`zdevice\*(C'\fR.
.PP
\&\f(CW\*(C`ctype\*(C'\fR およびオプションの \f(CW\*(C`level\*(C'\fR パラメーターは \f(CW\*(C`guestfs_compress_out\*(C'\fR におけるものと同じ意味です。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.13.15 において追加)
.SS "guestfs_compress_device_out_va"
.IX Subsection "guestfs_compress_device_out_va"
.Vb 6
\& int
\& guestfs_compress_device_out_va (guestfs_h *g,
\&                                 const char *ctype,
\&                                 const char *device,
\&                                 const char *zdevice,
\&                                 va_list args);
.Ve
.PP
これは \*(L"guestfs_compress_device_out\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_compress_device_out_argv"
.IX Subsection "guestfs_compress_device_out_argv"
.Vb 6
\& int
\& guestfs_compress_device_out_argv (guestfs_h *g,
\&                                   const char *ctype,
\&                                   const char *device,
\&                                   const char *zdevice,
\&                                   const struct guestfs_compress_device_out_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_compress_device_out\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_compress_out"
.IX Subsection "guestfs_compress_out"
.Vb 6
\& int
\& guestfs_compress_out (guestfs_h *g,
\&                       const char *ctype,
\&                       const char *file,
\&                       const char *zfile,
\&                       ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_COMPRESS_OUT_LEVEL, int level,
.Ve
.PP
This command compresses \fIfile\fR and writes it out to the local file
\&\fIzfile\fR.
.PP
The compression program used is controlled by the \f(CW\*(C`ctype\*(C'\fR parameter.
Currently this includes: \f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR or \f(CW\*(C`lzop\*(C'\fR.
Some compression types may not be supported by particular builds of
libguestfs, in which case you will get an error containing the substring
\&\*(L"not supported\*(R".
.PP
The optional \f(CW\*(C`level\*(C'\fR parameter controls compression level.  The meaning and
default for this parameter depends on the compression program being used.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.13.15 において追加)
.SS "guestfs_compress_out_va"
.IX Subsection "guestfs_compress_out_va"
.Vb 6
\& int
\& guestfs_compress_out_va (guestfs_h *g,
\&                          const char *ctype,
\&                          const char *file,
\&                          const char *zfile,
\&                          va_list args);
.Ve
.PP
これは \*(L"guestfs_compress_out\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_compress_out_argv"
.IX Subsection "guestfs_compress_out_argv"
.Vb 6
\& int
\& guestfs_compress_out_argv (guestfs_h *g,
\&                            const char *ctype,
\&                            const char *file,
\&                            const char *zfile,
\&                            const struct guestfs_compress_out_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_compress_out\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_config"
.IX Subsection "guestfs_config"
.Vb 4
\& int
\& guestfs_config (guestfs_h *g,
\&                 const char *hvparam,
\&                 const char *hvvalue);
.Ve
.PP
This can be used to add arbitrary hypervisor parameters of the form \fI\-param
value\fR.  Actually it's not quite arbitrary \- we prevent you from setting
some parameters which would interfere with parameters that we use.
.PP
The first character of \f(CW\*(C`hvparam\*(C'\fR string must be a \f(CW\*(C`\-\*(C'\fR (dash).
.PP
\&\f(CW\*(C`hvvalue\*(C'\fR can be \s-1NULL.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_copy_attributes"
.IX Subsection "guestfs_copy_attributes"
.Vb 5
\& int
\& guestfs_copy_attributes (guestfs_h *g,
\&                          const char *src,
\&                          const char *dest,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 4
\& GUESTFS_COPY_ATTRIBUTES_ALL, int all,
\& GUESTFS_COPY_ATTRIBUTES_MODE, int mode,
\& GUESTFS_COPY_ATTRIBUTES_XATTRIBUTES, int xattributes,
\& GUESTFS_COPY_ATTRIBUTES_OWNERSHIP, int ownership,
.Ve
.PP
Copy the attributes of a path (which can be a file or a directory)  to
another path.
.PP
By default \f(CW\*(C`no\*(C'\fR attribute is copied, so make sure to specify any (or \f(CW\*(C`all\*(C'\fR
to copy everything).
.PP
The optional arguments specify which attributes can be copied:
.ie n .IP """mode""" 4
.el .IP "\f(CWmode\fR" 4
.IX Item "mode"
Copy part of the file mode from \f(CW\*(C`source\*(C'\fR to \f(CW\*(C`destination\*(C'\fR. Only the \s-1UNIX\s0
permissions and the sticky/setuid/setgid bits can be copied.
.ie n .IP """xattributes""" 4
.el .IP "\f(CWxattributes\fR" 4
.IX Item "xattributes"
Copy the Linux extended attributes (xattrs) from \f(CW\*(C`source\*(C'\fR to
\&\f(CW\*(C`destination\*(C'\fR.  This flag does nothing if the \fIlinuxxattrs\fR feature is not
available (see \f(CW\*(C`guestfs_feature_available\*(C'\fR).
.ie n .IP """ownership""" 4
.el .IP "\f(CWownership\fR" 4
.IX Item "ownership"
Copy the owner uid and the group gid of \f(CW\*(C`source\*(C'\fR to \f(CW\*(C`destination\*(C'\fR.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Copy \fBall\fR the attributes from \f(CW\*(C`source\*(C'\fR to \f(CW\*(C`destination\*(C'\fR. Enabling it
enables all the other flags, if they are not specified already.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.25.21)
.SS "guestfs_copy_attributes_va"
.IX Subsection "guestfs_copy_attributes_va"
.Vb 5
\& int
\& guestfs_copy_attributes_va (guestfs_h *g,
\&                             const char *src,
\&                             const char *dest,
\&                             va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_copy_attributes\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_attributes_argv"
.IX Subsection "guestfs_copy_attributes_argv"
.Vb 5
\& int
\& guestfs_copy_attributes_argv (guestfs_h *g,
\&                               const char *src,
\&                               const char *dest,
\&                               const struct guestfs_copy_attributes_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_copy_attributes\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_device_to_device"
.IX Subsection "guestfs_copy_device_to_device"
.Vb 5
\& int
\& guestfs_copy_device_to_device (guestfs_h *g,
\&                                const char *src,
\&                                const char *dest,
\&                                ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, int64_t size,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SPARSE, int sparse,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_APPEND, int append,
.Ve
.PP
4 つの呼び出し \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR, \f(CW\*(C`guestfs_copy_device_to_file\*(C'\fR,
\&\f(CW\*(C`guestfs_copy_file_to_device\*(C'\fR, および \f(CW\*(C`guestfs_copy_file_to_file\*(C'\fR は、ソース
(デバイス|ファイル) から宛先 (デバイス|ファイル) にコピーできます。
.PP
Partial copies can be made since you can specify optionally the source
offset, destination offset and size to copy.  These values are all specified
in bytes.  If not given, the offsets both default to zero, and the size
defaults to copying as much as possible until we hit the end of the source.
.PP
ソースと宛先は同じオブジェクトである可能性があります。しかしながら、重なり合う領域は正しくコピーされないかもしれません。
.PP
宛先がファイルならば、必要に応じて作成されます。宛先ファイルが十分に大きくなければ、拡張されます。
.PP
If the destination is a file and the \f(CW\*(C`append\*(C'\fR flag is not set, then the
destination file is truncated.  If the \f(CW\*(C`append\*(C'\fR flag is set, then the copy
appends to the destination file.  The \f(CW\*(C`append\*(C'\fR flag currently cannot be set
for devices.
.PP
If the \f(CW\*(C`sparse\*(C'\fR flag is true then the call avoids writing blocks that
contain only zeroes, which can help in some situations where the backing
disk is thin-provisioned.  Note that unless the target is already zeroed,
using this option will result in incorrect copying.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.13.25 において追加)
.SS "guestfs_copy_device_to_device_va"
.IX Subsection "guestfs_copy_device_to_device_va"
.Vb 5
\& int
\& guestfs_copy_device_to_device_va (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   va_list args);
.Ve
.PP
これは \*(L"guestfs_copy_device_to_device\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_device_to_device_argv"
.IX Subsection "guestfs_copy_device_to_device_argv"
.Vb 5
\& int
\& guestfs_copy_device_to_device_argv (guestfs_h *g,
\&                                     const char *src,
\&                                     const char *dest,
\&                                     const struct guestfs_copy_device_to_device_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_copy_device_to_device\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_device_to_file"
.IX Subsection "guestfs_copy_device_to_file"
.Vb 5
\& int
\& guestfs_copy_device_to_file (guestfs_h *g,
\&                              const char *src,
\&                              const char *dest,
\&                              ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_DEVICE_TO_FILE_SIZE, int64_t size,
\& GUESTFS_COPY_DEVICE_TO_FILE_SPARSE, int sparse,
\& GUESTFS_COPY_DEVICE_TO_FILE_APPEND, int append,
.Ve
.PP
この呼び出しの一般的な概要は \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.13.25 において追加)
.SS "guestfs_copy_device_to_file_va"
.IX Subsection "guestfs_copy_device_to_file_va"
.Vb 5
\& int
\& guestfs_copy_device_to_file_va (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 va_list args);
.Ve
.PP
これは \*(L"guestfs_copy_device_to_file\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_device_to_file_argv"
.IX Subsection "guestfs_copy_device_to_file_argv"
.Vb 5
\& int
\& guestfs_copy_device_to_file_argv (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   const struct guestfs_copy_device_to_file_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_copy_device_to_file\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_file_to_device"
.IX Subsection "guestfs_copy_file_to_device"
.Vb 5
\& int
\& guestfs_copy_file_to_device (guestfs_h *g,
\&                              const char *src,
\&                              const char *dest,
\&                              ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_FILE_TO_DEVICE_SIZE, int64_t size,
\& GUESTFS_COPY_FILE_TO_DEVICE_SPARSE, int sparse,
\& GUESTFS_COPY_FILE_TO_DEVICE_APPEND, int append,
.Ve
.PP
この呼び出しの一般的な概要は \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.13.25 において追加)
.SS "guestfs_copy_file_to_device_va"
.IX Subsection "guestfs_copy_file_to_device_va"
.Vb 5
\& int
\& guestfs_copy_file_to_device_va (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 va_list args);
.Ve
.PP
これは \*(L"guestfs_copy_file_to_device\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_file_to_device_argv"
.IX Subsection "guestfs_copy_file_to_device_argv"
.Vb 5
\& int
\& guestfs_copy_file_to_device_argv (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   const struct guestfs_copy_file_to_device_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_copy_file_to_device\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_file_to_file"
.IX Subsection "guestfs_copy_file_to_file"
.Vb 5
\& int
\& guestfs_copy_file_to_file (guestfs_h *g,
\&                            const char *src,
\&                            const char *dest,
\&                            ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_FILE_TO_FILE_SIZE, int64_t size,
\& GUESTFS_COPY_FILE_TO_FILE_SPARSE, int sparse,
\& GUESTFS_COPY_FILE_TO_FILE_APPEND, int append,
.Ve
.PP
この呼び出しの一般的な概要は \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR を参照してください。
.PP
This is \fBnot\fR the function you want for copying files.  This is for copying
blocks within existing files.  See \f(CW\*(C`guestfs_cp\*(C'\fR, \f(CW\*(C`guestfs_cp_a\*(C'\fR and
\&\f(CW\*(C`guestfs_mv\*(C'\fR for general file copying and moving functions.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.13.25 において追加)
.SS "guestfs_copy_file_to_file_va"
.IX Subsection "guestfs_copy_file_to_file_va"
.Vb 5
\& int
\& guestfs_copy_file_to_file_va (guestfs_h *g,
\&                               const char *src,
\&                               const char *dest,
\&                               va_list args);
.Ve
.PP
これは \*(L"guestfs_copy_file_to_file\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_file_to_file_argv"
.IX Subsection "guestfs_copy_file_to_file_argv"
.Vb 5
\& int
\& guestfs_copy_file_to_file_argv (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 const struct guestfs_copy_file_to_file_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_copy_file_to_file\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_copy_in"
.IX Subsection "guestfs_copy_in"
.Vb 4
\& int
\& guestfs_copy_in (guestfs_h *g,
\&                  const char *localpath,
\&                  const char *remotedir);
.Ve
.PP
\&\f(CW\*(C`guestfs_copy_in\*(C'\fR copies local files or directories recursively into the
disk image, placing them in the directory called \f(CW\*(C`remotedir\*(C'\fR (which must
exist).
.PP
Wildcards cannot be used.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.29.24)
.SS "guestfs_copy_out"
.IX Subsection "guestfs_copy_out"
.Vb 4
\& int
\& guestfs_copy_out (guestfs_h *g,
\&                   const char *remotepath,
\&                   const char *localdir);
.Ve
.PP
\&\f(CW\*(C`guestfs_copy_out\*(C'\fR copies remote files or directories recursively out of
the disk image, placing them on the host disk in a local directory called
\&\f(CW\*(C`localdir\*(C'\fR (which must exist).
.PP
To download to the current directory, use \f(CW\*(C`.\*(C'\fR as in:
.PP
.Vb 1
\& C<guestfs_copy_out> /home .
.Ve
.PP
Wildcards cannot be used.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.29.24)
.SS "guestfs_copy_size"
.IX Subsection "guestfs_copy_size"
.Vb 5
\& int
\& guestfs_copy_size (guestfs_h *g,
\&                    const char *src,
\&                    const char *dest,
\&                    int64_t size);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_copy_device_to_device\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command copies exactly \f(CW\*(C`size\*(C'\fR bytes from one source device or file
\&\f(CW\*(C`src\*(C'\fR to another destination device or file \f(CW\*(C`dest\*(C'\fR.
.PP
Note this will fail if the source is too short or if the destination is not
large enough.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.0.87 において追加)
.SS "guestfs_cp"
.IX Subsection "guestfs_cp"
.Vb 4
\& int
\& guestfs_cp (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
ファイルを \f(CW\*(C`src\*(C'\fR から \f(CW\*(C`dest\*(C'\fR にコピーします。ここで \f(CW\*(C`dest\*(C'\fR は宛先ファイル名または宛先ディレクトリです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.18 において追加)
.SS "guestfs_cp_a"
.IX Subsection "guestfs_cp_a"
.Vb 4
\& int
\& guestfs_cp_a (guestfs_h *g,
\&               const char *src,
\&               const char *dest);
.Ve
.PP
ファイルまたはディレクトリを \f(CW\*(C`src\*(C'\fR から \f(CW\*(C`dest\*(C'\fR に \f(CW\*(C`cp \-a\*(C'\fR コマンドを使用して再帰的にコピーします。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.18 において追加)
.SS "guestfs_cp_r"
.IX Subsection "guestfs_cp_r"
.Vb 4
\& int
\& guestfs_cp_r (guestfs_h *g,
\&               const char *src,
\&               const char *dest);
.Ve
.PP
This copies a file or directory from \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR recursively using the
\&\f(CW\*(C`cp \-rP\*(C'\fR command.
.PP
Most users should use \f(CW\*(C`guestfs_cp_a\*(C'\fR instead.  This command is useful when
you don't want to preserve permissions, because the target filesystem does
not support it (primarily when writing to \s-1DOS FAT\s0 filesystems).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.21.38 において追加)
.SS "guestfs_cpio_out"
.IX Subsection "guestfs_cpio_out"
.Vb 5
\& int
\& guestfs_cpio_out (guestfs_h *g,
\&                   const char *directory,
\&                   const char *cpiofile,
\&                   ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_CPIO_OUT_FORMAT, const char *format,
.Ve
.PP
This command packs the contents of \fIdirectory\fR and downloads it to local
file \f(CW\*(C`cpiofile\*(C'\fR.
.PP
The optional \f(CW\*(C`format\*(C'\fR parameter can be used to select the format.  Only the
following formats are currently permitted:
.ie n .IP """newc""" 4
.el .IP "\f(CWnewc\fR" 4
.IX Item "newc"
New (\s-1SVR4\s0) portable format.  This format happens to be compatible with the
cpio-like format used by the Linux kernel for initramfs.
.Sp
This is the default format.
.ie n .IP """crc""" 4
.el .IP "\f(CWcrc\fR" 4
.IX Item "crc"
New (\s-1SVR4\s0) portable format with a checksum.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.27.9)
.SS "guestfs_cpio_out_va"
.IX Subsection "guestfs_cpio_out_va"
.Vb 5
\& int
\& guestfs_cpio_out_va (guestfs_h *g,
\&                      const char *directory,
\&                      const char *cpiofile,
\&                      va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_cpio_out\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_cpio_out_argv"
.IX Subsection "guestfs_cpio_out_argv"
.Vb 5
\& int
\& guestfs_cpio_out_argv (guestfs_h *g,
\&                        const char *directory,
\&                        const char *cpiofile,
\&                        const struct guestfs_cpio_out_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_cpio_out\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_dd"
.IX Subsection "guestfs_dd"
.Vb 4
\& int
\& guestfs_dd (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_copy_device_to_device\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command copies from one source device or file \f(CW\*(C`src\*(C'\fR to another
destination device or file \f(CW\*(C`dest\*(C'\fR.  Normally you would use this to copy to
or from a device or partition, for example to duplicate a filesystem.
.PP
If the destination is a device, it must be as large or larger than the
source file or device, otherwise the copy will fail.  This command cannot do
partial copies (see \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.80 において追加)
.SS "guestfs_device_index"
.IX Subsection "guestfs_device_index"
.Vb 3
\& int
\& guestfs_device_index (guestfs_h *g,
\&                       const char *device);
.Ve
.PP
この関数はデバイス名 (例: \*(L"/dev/sdb\*(R") を取得し、デバイスの一覧にあるデバイスのインデックスを返します。
.PP
Index numbers start from 0.  The named device must exist, for example as a
string returned from \f(CW\*(C`guestfs_list_devices\*(C'\fR.
.PP
\&\f(CW\*(C`guestfs_list_devices\*(C'\fR, \f(CW\*(C`guestfs_part_to_dev\*(C'\fR 参照。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.19.7 において追加)
.SS "guestfs_df"
.IX Subsection "guestfs_df"
.Vb 2
\& char *
\& guestfs_df (guestfs_h *g);
.Ve
.PP
このコマンドはディスク使用状況を報告するために \f(CW\*(C`df\*(C'\fR コマンドを実行します。
.PP
This command is mostly useful for interactive sessions.  It is \fInot\fR
intended that you try to parse the output string.  Use \f(CW\*(C`guestfs_statvfs\*(C'\fR
from programs.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.54 において追加)
.SS "guestfs_df_h"
.IX Subsection "guestfs_df_h"
.Vb 2
\& char *
\& guestfs_df_h (guestfs_h *g);
.Ve
.PP
このコマンドはディスク使用状況を読みやすい形式で報告するために \f(CW\*(C`df \-h\*(C'\fR コマンドを実行します。
.PP
This command is mostly useful for interactive sessions.  It is \fInot\fR
intended that you try to parse the output string.  Use \f(CW\*(C`guestfs_statvfs\*(C'\fR
from programs.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.54 において追加)
.SS "guestfs_disk_create"
.IX Subsection "guestfs_disk_create"
.Vb 6
\& int
\& guestfs_disk_create (guestfs_h *g,
\&                      const char *filename,
\&                      const char *format,
\&                      int64_t size,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_DISK_CREATE_BACKINGFILE, const char *backingfile,
\& GUESTFS_DISK_CREATE_BACKINGFORMAT, const char *backingformat,
\& GUESTFS_DISK_CREATE_PREALLOCATION, const char *preallocation,
\& GUESTFS_DISK_CREATE_COMPAT, const char *compat,
\& GUESTFS_DISK_CREATE_CLUSTERSIZE, int clustersize,
.Ve
.PP
Create a blank disk image called \fIfilename\fR (a host file)  with format
\&\f(CW\*(C`format\*(C'\fR (usually \f(CW\*(C`raw\*(C'\fR or \f(CW\*(C`qcow2\*(C'\fR).  The size is \f(CW\*(C`size\*(C'\fR bytes.
.PP
If used with the optional \f(CW\*(C`backingfile\*(C'\fR parameter, then a snapshot is
created on top of the backing file.  In this case, \f(CW\*(C`size\*(C'\fR must be passed as
\&\f(CW\*(C`\-1\*(C'\fR.  The size of the snapshot is the same as the size of the backing
file, which is discovered automatically.  You are encouraged to also pass
\&\f(CW\*(C`backingformat\*(C'\fR to describe the format of \f(CW\*(C`backingfile\*(C'\fR.
.PP
If \fIfilename\fR refers to a block device, then the device is formatted.  The
\&\f(CW\*(C`size\*(C'\fR is ignored since block devices have an intrinsic size.
.PP
The other optional parameters are:
.ie n .IP """preallocation""" 4
.el .IP "\f(CWpreallocation\fR" 4
.IX Item "preallocation"
If format is \f(CW\*(C`raw\*(C'\fR, then this can be either \f(CW\*(C`off\*(C'\fR (or \f(CW\*(C`sparse\*(C'\fR)  or
\&\f(CW\*(C`full\*(C'\fR to create a sparse or fully allocated file respectively.  The
default is \f(CW\*(C`off\*(C'\fR.
.Sp
If format is \f(CW\*(C`qcow2\*(C'\fR, then this can be \f(CW\*(C`off\*(C'\fR (or \f(CW\*(C`sparse\*(C'\fR), \f(CW\*(C`metadata\*(C'\fR
or \f(CW\*(C`full\*(C'\fR.  Preallocating metadata can be faster when doing lots of writes,
but uses more space.  The default is \f(CW\*(C`off\*(C'\fR.
.ie n .IP """compat""" 4
.el .IP "\f(CWcompat\fR" 4
.IX Item "compat"
\&\f(CW\*(C`qcow2\*(C'\fR only: Pass the string \f(CW1.1\fR to use the advanced qcow2 format
supported by qemu ≥ 1.1.
.ie n .IP """clustersize""" 4
.el .IP "\f(CWclustersize\fR" 4
.IX Item "clustersize"
\&\f(CW\*(C`qcow2\*(C'\fR only: Change the qcow2 cluster size.  The default is 65536 (bytes)
and this setting may be any power of two between 512 and 2097152.
.PP
Note that this call does not add the new disk to the handle.  You may need
to call \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR separately.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.25.31)
.SS "guestfs_disk_create_va"
.IX Subsection "guestfs_disk_create_va"
.Vb 6
\& int
\& guestfs_disk_create_va (guestfs_h *g,
\&                         const char *filename,
\&                         const char *format,
\&                         int64_t size,
\&                         va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_disk_create\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_disk_create_argv"
.IX Subsection "guestfs_disk_create_argv"
.Vb 6
\& int
\& guestfs_disk_create_argv (guestfs_h *g,
\&                           const char *filename,
\&                           const char *format,
\&                           int64_t size,
\&                           const struct guestfs_disk_create_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_disk_create\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_disk_format"
.IX Subsection "guestfs_disk_format"
.Vb 3
\& char *
\& guestfs_disk_format (guestfs_h *g,
\&                      const char *filename);
.Ve
.PP
Detect and return the format of the disk image called \fIfilename\fR.
\&\fIfilename\fR can also be a host device, etc.  If the format of the image
could not be detected, then \f(CW"unknown"\fR is returned.
.PP
Note that detecting the disk format can be insecure under some
circumstances.  See \*(L"\s-1CVE\-2010\-3851\*(R"\s0.
.PP
関連項目: \*(L"ディスクイメージ形式\*(R"
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.38 において追加)
.SS "guestfs_disk_has_backing_file"
.IX Subsection "guestfs_disk_has_backing_file"
.Vb 3
\& int
\& guestfs_disk_has_backing_file (guestfs_h *g,
\&                                const char *filename);
.Ve
.PP
Detect and return whether the disk image \fIfilename\fR has a backing file.
.PP
Note that detecting disk features can be insecure under some circumstances.
See \*(L"\s-1CVE\-2010\-3851\*(R"\s0.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.19.39 にて追加)
.SS "guestfs_disk_virtual_size"
.IX Subsection "guestfs_disk_virtual_size"
.Vb 3
\& int64_t
\& guestfs_disk_virtual_size (guestfs_h *g,
\&                            const char *filename);
.Ve
.PP
Detect and return the virtual size in bytes of the disk image called
\&\fIfilename\fR.
.PP
Note that detecting disk features can be insecure under some circumstances.
See \*(L"\s-1CVE\-2010\-3851\*(R"\s0.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.19.39 にて追加)
.SS "guestfs_dmesg"
.IX Subsection "guestfs_dmesg"
.Vb 2
\& char *
\& guestfs_dmesg (guestfs_h *g);
.Ve
.PP
This returns the kernel messages (\f(CW\*(C`dmesg\*(C'\fR output) from the guest kernel.
This is sometimes useful for extended debugging of problems.
.PP
Another way to get the same information is to enable verbose messages with
\&\f(CW\*(C`guestfs_set_verbose\*(C'\fR or by setting the environment variable
\&\f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR before running the program.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.18 において追加)
.SS "guestfs_download"
.IX Subsection "guestfs_download"
.Vb 4
\& int
\& guestfs_download (guestfs_h *g,
\&                   const char *remotefilename,
\&                   const char *filename);
.Ve
.PP
Download file \fIremotefilename\fR and save it as \fIfilename\fR on the local
machine.
.PP
\&\fIfilename\fR can also be a named pipe.
.PP
\&\f(CW\*(C`guestfs_upload\*(C'\fR, \f(CW\*(C`guestfs_cat\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.0.2 において追加)
.SS "guestfs_download_blocks"
.IX Subsection "guestfs_download_blocks"
.Vb 7
\& int
\& guestfs_download_blocks (guestfs_h *g,
\&                          const char *device,
\&                          int64_t start,
\&                          int64_t stop,
\&                          const char *filename,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_DOWNLOAD_BLOCKS_UNALLOCATED, int unallocated,
.Ve
.PP
Download the data units from \fIstart\fR address to \fIstop\fR from the disk
partition (eg. \fI/dev/sda1\fR)  and save them as \fIfilename\fR on the local
machine.
.PP
The use of this \s-1API\s0 on sparse disk image formats such as \s-1QCOW,\s0 may result in
large zero-filled files downloaded on the host.
.PP
The size of a data unit varies across filesystem implementations.  On \s-1NTFS\s0
filesystems data units are referred as clusters while on ExtX ones they are
referred as fragments.
.PP
If the optional \f(CW\*(C`unallocated\*(C'\fR flag is true (default is false), only the
unallocated blocks will be extracted.  This is useful to detect hidden data
or to retrieve deleted files which data units have not been overwritten yet.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
This function depends on the feature \f(CW\*(C`sleuthkit\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.45)
.SS "guestfs_download_blocks_va"
.IX Subsection "guestfs_download_blocks_va"
.Vb 7
\& int
\& guestfs_download_blocks_va (guestfs_h *g,
\&                             const char *device,
\&                             int64_t start,
\&                             int64_t stop,
\&                             const char *filename,
\&                             va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_download_blocks\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_download_blocks_argv"
.IX Subsection "guestfs_download_blocks_argv"
.Vb 7
\& int
\& guestfs_download_blocks_argv (guestfs_h *g,
\&                               const char *device,
\&                               int64_t start,
\&                               int64_t stop,
\&                               const char *filename,
\&                               const struct guestfs_download_blocks_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_download_blocks\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_download_inode"
.IX Subsection "guestfs_download_inode"
.Vb 5
\& int
\& guestfs_download_inode (guestfs_h *g,
\&                         const char *device,
\&                         int64_t inode,
\&                         const char *filename);
.Ve
.PP
Download a file given its inode from the disk partition (eg. \fI/dev/sda1\fR)
and save it as \fIfilename\fR on the local machine.
.PP
It is not required to mount the disk to run this command.
.PP
The command is capable of downloading deleted or inaccessible files.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
This function depends on the feature \f(CW\*(C`sleuthkit\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.14)
.SS "guestfs_download_offset"
.IX Subsection "guestfs_download_offset"
.Vb 6
\& int
\& guestfs_download_offset (guestfs_h *g,
\&                          const char *remotefilename,
\&                          const char *filename,
\&                          int64_t offset,
\&                          int64_t size);
.Ve
.PP
Download file \fIremotefilename\fR and save it as \fIfilename\fR on the local
machine.
.PP
\&\fIremotefilename\fR is read for \f(CW\*(C`size\*(C'\fR bytes starting at \f(CW\*(C`offset\*(C'\fR (this
region must be within the file or device).
.PP
Note that there is no limit on the amount of data that can be downloaded
with this call, unlike with \f(CW\*(C`guestfs_pread\*(C'\fR, and this call always reads the
full amount unless an error occurs.
.PP
\&\f(CW\*(C`guestfs_download\*(C'\fR, \f(CW\*(C`guestfs_pread\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.5.17 において追加)
.SS "guestfs_drop_caches"
.IX Subsection "guestfs_drop_caches"
.Vb 3
\& int
\& guestfs_drop_caches (guestfs_h *g,
\&                      int whattodrop);
.Ve
.PP
This instructs the guest kernel to drop its page cache, and/or dentries and
inode caches.  The parameter \f(CW\*(C`whattodrop\*(C'\fR tells the kernel what precisely
to drop, see http://linux\-mm.org/Drop_Caches
.PP
\&\f(CW\*(C`whattodrop\*(C'\fR を 3 に設定することにより、すべてのものを破棄します。
.PP
This automatically calls \fIsync\fR\|(2) before the operation, so that the
maximum guest memory is freed.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.18 において追加)
.SS "guestfs_du"
.IX Subsection "guestfs_du"
.Vb 3
\& int64_t
\& guestfs_du (guestfs_h *g,
\&             const char *path);
.Ve
.PP
このコマンドは \f(CW\*(C`path\*(C'\fR のファイル空間使用量を見積もるために \f(CW\*(C`du \-s\*(C'\fR コマンドを実行します。
.PP
\&\f(CW\*(C`path\*(C'\fR can be a file or a directory.  If \f(CW\*(C`path\*(C'\fR is a directory then the
estimate includes the contents of the directory and all subdirectories
(recursively).
.PP
結果は \fIキロバイト\fR (つまり 1024 バイトの単位) の見積もり容量です。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.0.54 において追加)
.SS "guestfs_e2fsck"
.IX Subsection "guestfs_e2fsck"
.Vb 4
\& int
\& guestfs_e2fsck (guestfs_h *g,
\&                 const char *device,
\&                 ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_E2FSCK_CORRECT, int correct,
\& GUESTFS_E2FSCK_FORCEALL, int forceall,
.Ve
.PP
This runs the ext2/ext3 filesystem checker on \f(CW\*(C`device\*(C'\fR.  It can take the
following optional arguments:
.ie n .IP """correct""" 4
.el .IP "\f(CWcorrect\fR" 4
.IX Item "correct"
Automatically repair the file system. This option will cause e2fsck to
automatically fix any filesystem problems that can be safely fixed without
human intervention.
.Sp
This option may not be specified at the same time as the \f(CW\*(C`forceall\*(C'\fR option.
.ie n .IP """forceall""" 4
.el .IP "\f(CWforceall\fR" 4
.IX Item "forceall"
すべての質問に対して 'yes' の回答をすると仮定します。e2fsck が非対話的に使用できます。
.Sp
このオプションは \f(CW\*(C`correct\*(C'\fR オプションと同時に指定できません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.15.17 において追加)
.SS "guestfs_e2fsck_va"
.IX Subsection "guestfs_e2fsck_va"
.Vb 4
\& int
\& guestfs_e2fsck_va (guestfs_h *g,
\&                    const char *device,
\&                    va_list args);
.Ve
.PP
これは \*(L"guestfs_e2fsck\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_e2fsck_argv"
.IX Subsection "guestfs_e2fsck_argv"
.Vb 4
\& int
\& guestfs_e2fsck_argv (guestfs_h *g,
\&                      const char *device,
\&                      const struct guestfs_e2fsck_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_e2fsck\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_e2fsck_f"
.IX Subsection "guestfs_e2fsck_f"
.Vb 3
\& int
\& guestfs_e2fsck_f (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_e2fsck\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This runs \f(CW\*(C`e2fsck \-p \-f device\*(C'\fR, ie. runs the ext2/ext3 filesystem checker
on \f(CW\*(C`device\*(C'\fR, noninteractively (\fI\-p\fR), even if the filesystem appears to be
clean (\fI\-f\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.29 において追加)
.SS "guestfs_echo_daemon"
.IX Subsection "guestfs_echo_daemon"
.Vb 3
\& char *
\& guestfs_echo_daemon (guestfs_h *g,
\&                      char *const *words);
.Ve
.PP
This command concatenates the list of \f(CW\*(C`words\*(C'\fR passed with single spaces
between them and returns the resulting string.
.PP
You can use this command to test the connection through to the daemon.
.PP
\&\f(CW\*(C`guestfs_ping_daemon\*(C'\fR 参照。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.69 において追加)
.SS "guestfs_egrep"
.IX Subsection "guestfs_egrep"
.Vb 4
\& char **
\& guestfs_egrep (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`egrep\*(C'\fR プログラムを呼び出し、一致した行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_egrepi"
.IX Subsection "guestfs_egrepi"
.Vb 4
\& char **
\& guestfs_egrepi (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`egrep \-i\*(C'\fR プログラムを呼び出し、一致した行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_equal"
.IX Subsection "guestfs_equal"
.Vb 4
\& int
\& guestfs_equal (guestfs_h *g,
\&                const char *file1,
\&                const char *file2);
.Ve
.PP
This compares the two files \fIfile1\fR and \fIfile2\fR and returns true if their
content is exactly equal, or false otherwise.
.PP
外部の \fIcmp\fR\|(1) プログラムが比較のために使用されます。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.18 において追加)
.SS "guestfs_exists"
.IX Subsection "guestfs_exists"
.Vb 3
\& int
\& guestfs_exists (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a file, directory (or anything)
with the given \f(CW\*(C`path\*(C'\fR name.
.PP
\&\f(CW\*(C`guestfs_is_file\*(C'\fR, \f(CW\*(C`guestfs_is_dir\*(C'\fR, \f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(0.8 において追加)
.SS "guestfs_extlinux"
.IX Subsection "guestfs_extlinux"
.Vb 3
\& int
\& guestfs_extlinux (guestfs_h *g,
\&                   const char *directory);
.Ve
.PP
Install the \s-1SYSLINUX\s0 bootloader on the device mounted at \fIdirectory\fR.
Unlike \f(CW\*(C`guestfs_syslinux\*(C'\fR which requires a \s-1FAT\s0 filesystem, this can be used
on an ext2/3/4 or btrfs filesystem.
.PP
The \fIdirectory\fR parameter can be either a mountpoint, or a directory within
the mountpoint.
.PP
You also have to mark the partition as \*(L"active\*(R"
(\f(CW\*(C`guestfs_part_set_bootable\*(C'\fR) and a Master Boot Record must be installed
(eg. using \f(CW\*(C`guestfs_pwrite_device\*(C'\fR) on the first sector of the whole disk.
The \s-1SYSLINUX\s0 package comes with some suitable Master Boot Records.  See the
\&\fIextlinux\fR\|(1) man page for further information.
.PP
Additional configuration can be supplied to \s-1SYSLINUX\s0 by placing a file
called \fIextlinux.conf\fR on the filesystem under \fIdirectory\fR.  For further
information about the contents of this file, see \fIextlinux\fR\|(1).
.PP
\&\f(CW\*(C`guestfs_syslinux\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`extlinux\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.21.27 において追加)
.SS "guestfs_fallocate"
.IX Subsection "guestfs_fallocate"
.Vb 4
\& int
\& guestfs_fallocate (guestfs_h *g,
\&                    const char *path,
\&                    int len);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_fallocate64\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command preallocates a file (containing zero bytes) named \f(CW\*(C`path\*(C'\fR of
size \f(CW\*(C`len\*(C'\fR bytes.  If the file exists already, it is overwritten.
.PP
Do not confuse this with the guestfish-specific \f(CW\*(C`alloc\*(C'\fR command which
allocates a file in the host and attaches it as a device.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_fallocate64"
.IX Subsection "guestfs_fallocate64"
.Vb 4
\& int
\& guestfs_fallocate64 (guestfs_h *g,
\&                      const char *path,
\&                      int64_t len);
.Ve
.PP
This command preallocates a file (containing zero bytes) named \f(CW\*(C`path\*(C'\fR of
size \f(CW\*(C`len\*(C'\fR bytes.  If the file exists already, it is overwritten.
.PP
Note that this call allocates disk blocks for the file.  To create a sparse
file use \f(CW\*(C`guestfs_truncate_size\*(C'\fR instead.
.PP
The deprecated call \f(CW\*(C`guestfs_fallocate\*(C'\fR does the same, but owing to an
oversight it only allowed 30 bit lengths to be specified, effectively
limiting the maximum size of files created through that call to 1GB.
.PP
Do not confuse this with the guestfish-specific \f(CW\*(C`alloc\*(C'\fR and \f(CW\*(C`sparse\*(C'\fR
commands which create a file in the host and attach it as a device.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.17 において追加)
.SS "guestfs_feature_available"
.IX Subsection "guestfs_feature_available"
.Vb 3
\& int
\& guestfs_feature_available (guestfs_h *g,
\&                            char *const *groups);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_available\*(C'\fR, but unlike that call it returns a
simple true/false boolean result, instead of throwing an exception if a
feature is not found.  For other documentation see \f(CW\*(C`guestfs_available\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.21.26 において追加)
.SS "guestfs_fgrep"
.IX Subsection "guestfs_fgrep"
.Vb 4
\& char **
\& guestfs_fgrep (guestfs_h *g,
\&                const char *pattern,
\&                const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This calls the external \f(CW\*(C`fgrep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_fgrepi"
.IX Subsection "guestfs_fgrepi"
.Vb 4
\& char **
\& guestfs_fgrepi (guestfs_h *g,
\&                 const char *pattern,
\&                 const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
外部の \f(CW\*(C`fgrep \-i\*(C'\fR プログラムを呼び出し、一致した行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_file"
.IX Subsection "guestfs_file"
.Vb 3
\& char *
\& guestfs_file (guestfs_h *g,
\&               const char *path);
.Ve
.PP
この呼び出しは、ファイルの形式または内容を決定するために、標準的な \fIfile\fR\|(1) コマンドを使用します。
.PP
This call will also transparently look inside various types of compressed
file.
.PP
The exact command which runs is \f(CW\*(C`file \-zb path\*(C'\fR.  Note in particular that
the filename is not prepended to the output (the \fI\-b\fR option).
.PP
The output depends on the output of the underlying \fIfile\fR\|(1) command and it
can change in future in ways beyond our control.  In other words, the output
is not guaranteed by the \s-1ABI.\s0
.PP
関連項目: \fIfile\fR\|(1), \f(CW\*(C`guestfs_vfs_type\*(C'\fR, \f(CW\*(C`guestfs_lstat\*(C'\fR, \f(CW\*(C`guestfs_is_file\*(C'\fR,
\&\f(CW\*(C`guestfs_is_blockdev\*(C'\fR (etc), \f(CW\*(C`guestfs_is_zero\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.9.1)
.SS "guestfs_file_architecture"
.IX Subsection "guestfs_file_architecture"
.Vb 3
\& char *
\& guestfs_file_architecture (guestfs_h *g,
\&                            const char *filename);
.Ve
.PP
This detects the architecture of the binary \fIfilename\fR, and returns it if
known.
.PP
現在定義されているアーキテクチャーは次のとおりです:
.ie n .IP """aarch64""" 4
.el .IP "``aarch64''" 4
.IX Item "aarch64"
64 bit \s-1ARM.\s0
.ie n .IP """arm""" 4
.el .IP "``arm''" 4
.IX Item "arm"
32 bit \s-1ARM.\s0
.ie n .IP """i386""" 4
.el .IP "``i386''" 4
.IX Item "i386"
この文字列は、バイナリーの正確なプロセッサー要求にかかわりなく、すべての 32 ビット i386, i486, i586, i686
バイナリーに対して返されます。
.ie n .IP """ia64""" 4
.el .IP "``ia64''" 4
.IX Item "ia64"
Intel Itanium.
.ie n .IP """ppc""" 4
.el .IP "``ppc''" 4
.IX Item "ppc"
32 ビット Power \s-1PC.\s0
.ie n .IP """ppc64""" 4
.el .IP "``ppc64''" 4
.IX Item "ppc64"
64 bit Power \s-1PC\s0 (big endian).
.ie n .IP """ppc64le""" 4
.el .IP "``ppc64le''" 4
.IX Item "ppc64le"
64 bit Power \s-1PC\s0 (little endian).
.ie n .IP """riscv32""" 4
.el .IP "``riscv32''" 4
.IX Item "riscv32"
.PD 0
.ie n .IP """riscv64""" 4
.el .IP "``riscv64''" 4
.IX Item "riscv64"
.ie n .IP """riscv128""" 4
.el .IP "``riscv128''" 4
.IX Item "riscv128"
.PD
RISC-V 32\-, 64\- or 128\-bit variants.
.ie n .IP """s390""" 4
.el .IP "``s390''" 4
.IX Item "s390"
31 bit \s-1IBM S/390.\s0
.ie n .IP """s390x""" 4
.el .IP "``s390x''" 4
.IX Item "s390x"
64 bit \s-1IBM S/390.\s0
.ie n .IP """sparc""" 4
.el .IP "``sparc''" 4
.IX Item "sparc"
32 ビット \s-1SPARC.\s0
.ie n .IP """sparc64""" 4
.el .IP "``sparc64''" 4
.IX Item "sparc64"
64 ビット \s-1SPARC V9\s0 およびそれ以降.
.ie n .IP """x86_64""" 4
.el .IP "``x86_64''" 4
.IX Item "x86_64"
64 ビット x86\-64.
.PP
libguestfs は将来他のアーキテクチャー文字列を返すかもしれません。
.PP
この関数は少なくとも以下の種類のファイルにおいて機能します:
.IP "\(bu" 4
多くの種類の Un*x および Linux バイナリー
.IP "\(bu" 4
多くの種類の Un*x および Linux 共有ライブラリー
.IP "\(bu" 4
Windows Win32 および Win64 バイナリー
.IP "\(bu" 4
Windows Win32 および Win64 \s-1DLL\s0
.Sp
Win32 バイナリーと \s-1DLL\s0 が \f(CW\*(C`i386\*(C'\fR を返します。
.Sp
Win64 バイナリーと \s-1DLL\s0 が \f(CW\*(C`x86_64\*(C'\fR を返します。
.IP "\(bu" 4
Linux カーネルモジュール
.IP "\(bu" 4
新形式の Linux initrd イメージ
.IP "\(bu" 4
いくつかの非 x86 Linux vmlinuz カーネル
.PP
今のところ実行できないこと:
.IP "\(bu" 4
静的ライブラリー (libfoo.a)
.IP "\(bu" 4
圧縮された ext2 ファイルシステムとして Linux 旧形式の initrd (\s-1RHEL 3\s0)
.IP "\(bu" 4
x86 Linux vmlinuz カーネル
.Sp
x86 vmlinuz images (bzImage format) consist of a mix of 16\-, 32\- and
compressed code, and are horribly hard to unpack.  If you want to find the
architecture of a kernel, use the architecture of the associated initrd or
kernel module(s) instead.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_filesize"
.IX Subsection "guestfs_filesize"
.Vb 3
\& int64_t
\& guestfs_filesize (guestfs_h *g,
\&                   const char *file);
.Ve
.PP
This command returns the size of \fIfile\fR in bytes.
.PP
ファイルに関する他の統計情報を取得するには、\f(CW\*(C`guestfs_stat\*(C'\fR, \f(CW\*(C`guestfs_lstat\*(C'\fR, \f(CW\*(C`guestfs_is_dir\*(C'\fR,
\&\f(CW\*(C`guestfs_is_file\*(C'\fR などを使用します。ブロックデバイスの容量を取得するには、\f(CW\*(C`guestfs_blockdev_getsize64\*(C'\fR
を使用します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.82 において追加)
.SS "guestfs_filesystem_available"
.IX Subsection "guestfs_filesystem_available"
.Vb 3
\& int
\& guestfs_filesystem_available (guestfs_h *g,
\&                               const char *filesystem);
.Ve
.PP
Check whether libguestfs supports the named filesystem.  The argument
\&\f(CW\*(C`filesystem\*(C'\fR is a filesystem name, such as \f(CW\*(C`ext3\*(C'\fR.
.PP
このコマンドを使用する前に \f(CW\*(C`guestfs_launch\*(C'\fR を呼び出す必要があります。
.PP
This is mainly useful as a negative test.  If this returns true, it doesn't
mean that a particular filesystem can be created or mounted, since
filesystems can fail for other reasons such as it being a later version of
the filesystem, or having incompatible features, or lacking the right
mkfs.<\fIfs\fR> tool.
.PP
\&\f(CW\*(C`guestfs_available\*(C'\fR, \f(CW\*(C`guestfs_feature_available\*(C'\fR,
\&\*(L"\s-1AVAILABILITY\*(R"\s0 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.19.5 において追加)
.SS "guestfs_filesystem_walk"
.IX Subsection "guestfs_filesystem_walk"
.Vb 3
\& struct guestfs_tsk_dirent_list *
\& guestfs_filesystem_walk (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Walk through the internal structures of a disk partition (eg. \fI/dev/sda1\fR)
in order to return a list of all the files and directories stored within.
.PP
It is not necessary to mount the disk partition to run this command.
.PP
All entries in the filesystem are returned. This function can list deleted
or unaccessible files. The entries are \fInot\fR sorted.
.PP
The \f(CW\*(C`tsk_dirent\*(C'\fR structure contains the following fields.
.IP "'tsk_inode'" 4
.IX Item "'tsk_inode'"
Filesystem reference number of the node. It migh be \f(CW0\fR if the node has
been deleted.
.IP "'tsk_type'" 4
.IX Item "'tsk_type'"
Basic file type information.  See below for a detailed list of values.
.IP "'tsk_size'" 4
.IX Item "'tsk_size'"
File size in bytes. It migh be \f(CW\*(C`\-1\*(C'\fR if the node has been deleted.
.IP "'tsk_name'" 4
.IX Item "'tsk_name'"
The file path relative to its directory.
.IP "'tsk_flags'" 4
.IX Item "'tsk_flags'"
Bitfield containing extra information regarding the entry.  It contains the
logical \s-1OR\s0 of the following values:
.RS 4
.IP "0x0001" 4
.IX Item "0x0001"
If set to \f(CW1\fR, the file is allocated and visible within the filesystem.
Otherwise, the file has been deleted.  Under certain circumstances, the
function \f(CW\*(C`download_inode\*(C'\fR can be used to recover deleted files.
.IP "0x0002" 4
.IX Item "0x0002"
Filesystem such as \s-1NTFS\s0 and Ext2 or greater, separate the file name from the
metadata structure.  The bit is set to \f(CW1\fR when the file name is in an
unallocated state and the metadata structure is in an allocated one.  This
generally implies the metadata has been reallocated to a new file.
Therefore, information such as file type, file size, timestamps, number of
links and symlink target might not correspond with the ones of the original
deleted entry.
.IP "0x0004" 4
.IX Item "0x0004"
The bit is set to \f(CW1\fR when the file is compressed using filesystem native
compression support (\s-1NTFS\s0). The \s-1API\s0 is not able to detect application level
compression.
.RE
.RS 4
.RE
.IP "'tsk_atime_sec'" 4
.IX Item "'tsk_atime_sec'"
.PD 0
.IP "'tsk_atime_nsec'" 4
.IX Item "'tsk_atime_nsec'"
.IP "'tsk_mtime_sec'" 4
.IX Item "'tsk_mtime_sec'"
.IP "'tsk_mtime_nsec'" 4
.IX Item "'tsk_mtime_nsec'"
.IP "'tsk_ctime_sec'" 4
.IX Item "'tsk_ctime_sec'"
.IP "'tsk_ctime_nsec'" 4
.IX Item "'tsk_ctime_nsec'"
.IP "'tsk_crtime_sec'" 4
.IX Item "'tsk_crtime_sec'"
.IP "'tsk_crtime_nsec'" 4
.IX Item "'tsk_crtime_nsec'"
.PD
Respectively, access, modification, last status change and creation time in
Unix format in seconds and nanoseconds.
.IP "'tsk_nlink'" 4
.IX Item "'tsk_nlink'"
Number of file names pointing to this entry.
.IP "'tsk_link'" 4
.IX Item "'tsk_link'"
If the entry is a symbolic link, this field will contain the path to the
target file.
.PP
The \f(CW\*(C`tsk_type\*(C'\fR field will contain one of the following characters:
.IP "'b'" 4
.IX Item "'b'"
ブロック特殊
.IP "'c'" 4
.IX Item "'c'"
キャラクター特殊
.IP "'d'" 4
.IX Item "'d'"
ディレクトリ
.IP "'f'" 4
.IX Item "'f'"
\&\s-1FIFO\s0 (名前付きパイプ)
.IP "'l'" 4
.IX Item "'l'"
シンボリックリンク
.IP "'r'" 4
.IX Item "'r'"
通常のファイル
.IP "'s'" 4
.IX Item "'s'"
ソケット
.IP "'h'" 4
.IX Item "'h'"
Shadow inode (Solaris)
.IP "'w'" 4
.IX Item "'w'"
Whiteout inode (\s-1BSD\s0)
.IP "'u'" 4
.IX Item "'u'"
未知のファイル種別
.PP
This function returns a \f(CW\*(C`struct guestfs_tsk_dirent_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_tsk_dirent_list\*(C'\fI
after use\fR.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
This function depends on the feature \f(CW\*(C`libtsk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.39)
.SS "guestfs_fill"
.IX Subsection "guestfs_fill"
.Vb 5
\& int
\& guestfs_fill (guestfs_h *g,
\&               int c,
\&               int len,
\&               const char *path);
.Ve
.PP
このコマンドは \f(CW\*(C`path\*(C'\fR という新しいファイルを作成します。初期の内容は \f(CW\*(C`len\*(C'\fR オクテットの \f(CW\*(C`c\*(C'\fR です。ここで \f(CW\*(C`c\*(C'\fR は
\&\f(CW\*(C`[0..255]\*(C'\fR の範囲の数値である必要があります。
.PP
To fill a file with zero bytes (sparsely), it is much more efficient to use
\&\f(CW\*(C`guestfs_truncate_size\*(C'\fR.  To create a file with a pattern of repeating
bytes use \f(CW\*(C`guestfs_fill_pattern\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.0.79 において追加)
.SS "guestfs_fill_dir"
.IX Subsection "guestfs_fill_dir"
.Vb 4
\& int
\& guestfs_fill_dir (guestfs_h *g,
\&                   const char *dir,
\&                   int nr);
.Ve
.PP
This function, useful for testing filesystems, creates \f(CW\*(C`nr\*(C'\fR empty files in
the directory \f(CW\*(C`dir\*(C'\fR with names \f(CW00000000\fR through \f(CW\*(C`nr\-1\*(C'\fR (ie. each file
name is 8 digits long padded with zeroes).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.32 において追加)
.SS "guestfs_fill_pattern"
.IX Subsection "guestfs_fill_pattern"
.Vb 5
\& int
\& guestfs_fill_pattern (guestfs_h *g,
\&                       const char *pattern,
\&                       int len,
\&                       const char *path);
.Ve
.PP
This function is like \f(CW\*(C`guestfs_fill\*(C'\fR except that it creates a new file of
length \f(CW\*(C`len\*(C'\fR containing the repeating pattern of bytes in \f(CW\*(C`pattern\*(C'\fR.  The
pattern is truncated if necessary to ensure the length of the file is
exactly \f(CW\*(C`len\*(C'\fR bytes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.3.12 において追加)
.SS "guestfs_find"
.IX Subsection "guestfs_find"
.Vb 3
\& char **
\& guestfs_find (guestfs_h *g,
\&               const char *directory);
.Ve
.PP
This command lists out all files and directories, recursively, starting at
\&\fIdirectory\fR.  It is essentially equivalent to running the shell command
\&\f(CW\*(C`find directory \-print\*(C'\fR but some post-processing happens on the output,
described below.
.PP
This returns a list of strings \fIwithout any prefix\fR.  Thus if the directory
structure was:
.PP
.Vb 3
\& /tmp/a
\& /tmp/b
\& /tmp/c/d
.Ve
.PP
then the returned list from \f(CW\*(C`guestfs_find\*(C'\fR \fI/tmp\fR would be 4 elements:
.PP
.Vb 4
\& a
\& b
\& c
\& c/d
.Ve
.PP
If \fIdirectory\fR is not a directory, then this command returns an error.
.PP
返された一覧は並び替えられています。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.27 において追加)
.SS "guestfs_find0"
.IX Subsection "guestfs_find0"
.Vb 4
\& int
\& guestfs_find0 (guestfs_h *g,
\&                const char *directory,
\&                const char *files);
.Ve
.PP
This command lists out all files and directories, recursively, starting at
\&\fIdirectory\fR, placing the resulting list in the external file called
\&\fIfiles\fR.
.PP
This command works the same way as \f(CW\*(C`guestfs_find\*(C'\fR with the following
exceptions:
.IP "\(bu" 4
The resulting list is written to an external file.
.IP "\(bu" 4
Items (filenames) in the result are separated by \f(CW\*(C`\e0\*(C'\fR characters.  See
\&\fIfind\fR\|(1) option \fI\-print0\fR.
.IP "\(bu" 4
結果の一覧はソートされていません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.74 において追加)
.SS "guestfs_find_inode"
.IX Subsection "guestfs_find_inode"
.Vb 4
\& struct guestfs_tsk_dirent_list *
\& guestfs_find_inode (guestfs_h *g,
\&                     const char *device,
\&                     int64_t inode);
.Ve
.PP
Searches all the entries associated with the given inode.
.PP
For each entry, a \f(CW\*(C`tsk_dirent\*(C'\fR structure is returned.  See
\&\f(CW\*(C`filesystem_walk\*(C'\fR for more information about \f(CW\*(C`tsk_dirent\*(C'\fR structures.
.PP
This function returns a \f(CW\*(C`struct guestfs_tsk_dirent_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_tsk_dirent_list\*(C'\fI
after use\fR.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
This function depends on the feature \f(CW\*(C`libtsk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.35.6)
.SS "guestfs_findfs_label"
.IX Subsection "guestfs_findfs_label"
.Vb 3
\& char *
\& guestfs_findfs_label (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
This command searches the filesystems and returns the one which has the
given label.  An error is returned if no such filesystem can be found.
.PP
To find the label of a filesystem, use \f(CW\*(C`guestfs_vfs_label\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_findfs_uuid"
.IX Subsection "guestfs_findfs_uuid"
.Vb 3
\& char *
\& guestfs_findfs_uuid (guestfs_h *g,
\&                      const char *uuid);
.Ve
.PP
This command searches the filesystems and returns the one which has the
given \s-1UUID.\s0  An error is returned if no such filesystem can be found.
.PP
ファイルシステムの \s-1UUID\s0 を見つけるには \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR を使用します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_fsck"
.IX Subsection "guestfs_fsck"
.Vb 4
\& int
\& guestfs_fsck (guestfs_h *g,
\&               const char *fstype,
\&               const char *device);
.Ve
.PP
This runs the filesystem checker (fsck) on \f(CW\*(C`device\*(C'\fR which should have
filesystem type \f(CW\*(C`fstype\*(C'\fR.
.PP
返された整数は状態です。 \f(CW\*(C`fsck\*(C'\fR からの状態コードの一覧は \fIfsck\fR\|(8) を参照してください。
.PP
注:
.IP "\(bu" 4
複数の状態コードが同時に合計されるかもしれません。
.IP "\(bu" 4
A non-zero return code can mean \*(L"success\*(R", for example if errors have been
corrected on the filesystem.
.IP "\(bu" 4
Checking or repairing \s-1NTFS\s0 volumes is not supported (by linux-ntfs).
.PP
This command is entirely equivalent to running \f(CW\*(C`fsck \-a \-t fstype device\*(C'\fR.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.16 において追加)
.SS "guestfs_fstrim"
.IX Subsection "guestfs_fstrim"
.Vb 4
\& int
\& guestfs_fstrim (guestfs_h *g,
\&                 const char *mountpoint,
\&                 ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 3
\& GUESTFS_FSTRIM_OFFSET, int64_t offset,
\& GUESTFS_FSTRIM_LENGTH, int64_t length,
\& GUESTFS_FSTRIM_MINIMUMFREEEXTENT, int64_t minimumfreeextent,
.Ve
.PP
Trim the free space in the filesystem mounted on \f(CW\*(C`mountpoint\*(C'\fR.  The
filesystem must be mounted read-write.
.PP
The filesystem contents are not affected, but any free space in the
filesystem is \*(L"trimmed\*(R", that is, given back to the host device, thus making
disk images more sparse, allowing unused space in qcow2 files to be reused,
etc.
.PP
This operation requires support in libguestfs, the mounted filesystem, the
host filesystem, qemu and the host kernel.  If this support isn't present it
may give an error or even appear to run but do nothing.
.PP
In the case where the kernel vfs driver does not support trimming, this call
will fail with errno set to \f(CW\*(C`ENOTSUP\*(C'\fR.  Currently this happens when trying
to trim \s-1FAT\s0 filesystems.
.PP
See also \f(CW\*(C`guestfs_zero_free_space\*(C'\fR.  That is a slightly different operation
that turns free space in the filesystem into zeroes.  It is valid to call
\&\f(CW\*(C`guestfs_fstrim\*(C'\fR either instead of, or after calling
\&\f(CW\*(C`guestfs_zero_free_space\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`fstrim\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.6 において追加)
.SS "guestfs_fstrim_va"
.IX Subsection "guestfs_fstrim_va"
.Vb 4
\& int
\& guestfs_fstrim_va (guestfs_h *g,
\&                    const char *mountpoint,
\&                    va_list args);
.Ve
.PP
これは \*(L"guestfs_fstrim\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_fstrim_argv"
.IX Subsection "guestfs_fstrim_argv"
.Vb 4
\& int
\& guestfs_fstrim_argv (guestfs_h *g,
\&                      const char *mountpoint,
\&                      const struct guestfs_fstrim_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_fstrim\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_get_append"
.IX Subsection "guestfs_get_append"
.Vb 2
\& const char *
\& guestfs_get_append (guestfs_h *g);
.Ve
.PP
Return the additional kernel options which are added to the libguestfs
appliance kernel command line.
.PP
\&\f(CW\*(C`NULL\*(C'\fR ならば、オプションが追加されません。
.PP
This function returns a string which may be \s-1NULL.\s0  There is no way to return
an error from this function.  The string is owned by the guest handle and
must \fInot\fR be freed.
.PP
(1.0.26 において追加)
.SS "guestfs_get_attach_method"
.IX Subsection "guestfs_get_attach_method"
.Vb 2
\& char *
\& guestfs_get_attach_method (guestfs_h *g);
.Ve
.PP
\&\fIこの函数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_get_backend\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
Return the current backend.
.PP
\&\f(CW\*(C`guestfs_set_backend\*(C'\fR および \*(L"\s-1BACKEND\*(R"\s0 参照。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.9.8 において追加)
.SS "guestfs_get_autosync"
.IX Subsection "guestfs_get_autosync"
.Vb 2
\& int
\& guestfs_get_autosync (guestfs_h *g);
.Ve
.PP
autosync フラグを取得します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(0.3 において追加)
.SS "guestfs_get_backend"
.IX Subsection "guestfs_get_backend"
.Vb 2
\& char *
\& guestfs_get_backend (guestfs_h *g);
.Ve
.PP
Return the current backend.
.PP
This handle property was previously called the \*(L"attach method\*(R".
.PP
\&\f(CW\*(C`guestfs_set_backend\*(C'\fR および \*(L"\s-1BACKEND\*(R"\s0 参照。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.21.26 において追加)
.SS "guestfs_get_backend_setting"
.IX Subsection "guestfs_get_backend_setting"
.Vb 3
\& char *
\& guestfs_get_backend_setting (guestfs_h *g,
\&                              const char *name);
.Ve
.PP
Find a backend setting string which is either \f(CW"name"\fR or begins with
\&\f(CW"name="\fR.  If \f(CW"name"\fR, this returns the string \f(CW"1"\fR.  If \f(CW"name="\fR,
this returns the part after the equals sign (which may be an empty string).
.PP
If no such setting is found, this function throws an error.  The errno (see
\&\f(CW\*(C`guestfs_last_errno\*(C'\fR) will be \f(CW\*(C`ESRCH\*(C'\fR in this case.
.PP
See \*(L"\s-1BACKEND\*(R"\s0, \*(L"\s-1BACKEND SETTINGS\*(R"\s0.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.27.2)
.SS "guestfs_get_backend_settings"
.IX Subsection "guestfs_get_backend_settings"
.Vb 2
\& char **
\& guestfs_get_backend_settings (guestfs_h *g);
.Ve
.PP
Return the current backend settings.
.PP
This call returns all backend settings strings.  If you want to find a
single backend setting, see \f(CW\*(C`guestfs_get_backend_setting\*(C'\fR.
.PP
See \*(L"\s-1BACKEND\*(R"\s0, \*(L"\s-1BACKEND SETTINGS\*(R"\s0.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.25.24)
.SS "guestfs_get_cachedir"
.IX Subsection "guestfs_get_cachedir"
.Vb 2
\& char *
\& guestfs_get_cachedir (guestfs_h *g);
.Ve
.PP
アプライアンスのキャッシュを保存するために、ハンドルにより使用されるディレクトリーを取得します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.58 において追加)
.SS "guestfs_get_direct"
.IX Subsection "guestfs_get_direct"
.Vb 2
\& int
\& guestfs_get_direct (guestfs_h *g);
.Ve
.PP
Return the direct appliance mode flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.72 において追加)
.SS "guestfs_get_e2attrs"
.IX Subsection "guestfs_get_e2attrs"
.Vb 3
\& char *
\& guestfs_get_e2attrs (guestfs_h *g,
\&                      const char *file);
.Ve
.PP
This returns the file attributes associated with \fIfile\fR.
.PP
The attributes are a set of bits associated with each inode which affect the
behaviour of the file.  The attributes are returned as a string of letters
(described below).  The string may be empty, indicating that no file
attributes are set for this file.
.PP
These attributes are only present when the file is located on an ext2/3/4
filesystem.  Using this call on other filesystem types will result in an
error.
.PP
The characters (file attributes) in the returned string are currently:
.IP "'A'" 4
.IX Item "'A'"
ファイルがアクセスされたとき、アクセス日時 (atime) を変更しません。
.IP "'a'" 4
.IX Item "'a'"
ファイルは追記専用です。
.IP "'c'" 4
.IX Item "'c'"
ファイルはディスクにおいて圧縮されます。
.IP "'D'" 4
.IX Item "'D'"
(ディレクトリーのみ。) このディレクトリーへの変更がディスクに同期的に書き込まれます。
.IP "'d'" 4
.IX Item "'d'"
The file is not a candidate for backup (see \fIdump\fR\|(8)).
.IP "'E'" 4
.IX Item "'E'"
ファイルは圧縮エラーがあります。
.IP "'e'" 4
.IX Item "'e'"
ファイルは拡張属性を使用しています。
.IP "'h'" 4
.IX Item "'h'"
The file is storing its blocks in units of the filesystem blocksize instead
of sectors.
.IP "'I'" 4
.IX Item "'I'"
(ディレクトリーのみ。)  ディレクトリーはハッシュツリーを使用しています。
.IP "'i'" 4
.IX Item "'i'"
The file is immutable.  It cannot be modified, deleted or renamed.  No link
can be created to this file.
.IP "'j'" 4
.IX Item "'j'"
ファイルはジャーナル付きデータです。
.IP "'s'" 4
.IX Item "'s'"
ファイルが削除されるとき、そのブロックはすべてゼロが書き込みされます。
.IP "'S'" 4
.IX Item "'S'"
このファイルへの変更は同期的にディスクに書き込まれます。
.IP "'T'" 4
.IX Item "'T'"
(Directories only.)  This is a hint to the block allocator that
subdirectories contained in this directory should be spread across blocks.
If not present, the block allocator will try to group subdirectories
together.
.IP "'t'" 4
.IX Item "'t'"
For a file, this disables tail-merging.  (Not used by upstream
implementations of ext2.)
.IP "'u'" 4
.IX Item "'u'"
When the file is deleted, its blocks will be saved, allowing the file to be
undeleted.
.IP "'X'" 4
.IX Item "'X'"
圧縮ファイルの内容にアクセスできます。
.IP "'Z'" 4
.IX Item "'Z'"
圧縮されたファイルがダーティーです。
.PP
More file attributes may be added to this list later.  Not all file
attributes may be set for all kinds of files.  For detailed information,
consult the \fIchattr\fR\|(1) man page.
.PP
\&\f(CW\*(C`guestfs_set_e2attrs\*(C'\fR 参照。
.PP
Don't confuse these attributes with extended attributes (see
\&\f(CW\*(C`guestfs_getxattr\*(C'\fR).
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.17.31 において追加)
.SS "guestfs_get_e2generation"
.IX Subsection "guestfs_get_e2generation"
.Vb 3
\& int64_t
\& guestfs_get_e2generation (guestfs_h *g,
\&                           const char *file);
.Ve
.PP
This returns the ext2 file generation of a file.  The generation (which used
to be called the \*(L"version\*(R") is a number associated with an inode.  This is
most commonly used by \s-1NFS\s0 servers.
.PP
The generation is only present when the file is located on an ext2/3/4
filesystem.  Using this call on other filesystem types will result in an
error.
.PP
\&\f(CW\*(C`guestfs_set_e2generation\*(C'\fR 参照。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.17.31 において追加)
.SS "guestfs_get_e2label"
.IX Subsection "guestfs_get_e2label"
.Vb 3
\& char *
\& guestfs_get_e2label (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_vfs_label\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは \f(CW\*(C`device\*(C'\fR にあるファイルシステムの ext2/3/4 ファイルシステムラベルを返します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.15 において追加)
.SS "guestfs_get_e2uuid"
.IX Subsection "guestfs_get_e2uuid"
.Vb 3
\& char *
\& guestfs_get_e2uuid (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_vfs_uuid\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは \f(CW\*(C`device\*(C'\fR にあるファイルシステムの ext2/3/4 ファイルシステム \s-1UUID\s0 を返します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.15 において追加)
.SS "guestfs_get_hv"
.IX Subsection "guestfs_get_hv"
.Vb 2
\& char *
\& guestfs_get_hv (guestfs_h *g);
.Ve
.PP
Return the current hypervisor binary.
.PP
This is always non-NULL.  If it wasn't set already, then this will return
the default qemu binary name.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.23.17)
.SS "guestfs_get_identifier"
.IX Subsection "guestfs_get_identifier"
.Vb 2
\& const char *
\& guestfs_get_identifier (guestfs_h *g);
.Ve
.PP
Get the handle identifier.  See \f(CW\*(C`guestfs_set_identifier\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  The string is owned by
the guest handle and must \fInot\fR be freed.
.PP
(Added in 1.31.14)
.SS "guestfs_get_libvirt_requested_credential_challenge"
.IX Subsection "guestfs_get_libvirt_requested_credential_challenge"
.Vb 3
\& char *
\& guestfs_get_libvirt_requested_credential_challenge (guestfs_h *g,
\&                                                     int index);
.Ve
.PP
Get the challenge (provided by libvirt) for the \f(CW\*(C`index\*(C'\fR'th requested
credential.  If libvirt did not provide a challenge, this returns the empty
string \f(CW""\fR.
.PP
See \*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 for documentation and example code.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.52 において追加))
.SS "guestfs_get_libvirt_requested_credential_defresult"
.IX Subsection "guestfs_get_libvirt_requested_credential_defresult"
.Vb 3
\& char *
\& guestfs_get_libvirt_requested_credential_defresult (guestfs_h *g,
\&                                                     int index);
.Ve
.PP
Get the default result (provided by libvirt) for the \f(CW\*(C`index\*(C'\fR'th requested
credential.  If libvirt did not provide a default result, this returns the
empty string \f(CW""\fR.
.PP
See \*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 for documentation and example code.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.52 において追加))
.SS "guestfs_get_libvirt_requested_credential_prompt"
.IX Subsection "guestfs_get_libvirt_requested_credential_prompt"
.Vb 3
\& char *
\& guestfs_get_libvirt_requested_credential_prompt (guestfs_h *g,
\&                                                  int index);
.Ve
.PP
Get the prompt (provided by libvirt) for the \f(CW\*(C`index\*(C'\fR'th requested
credential.  If libvirt did not provide a prompt, this returns the empty
string \f(CW""\fR.
.PP
See \*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 for documentation and example code.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.52 において追加))
.SS "guestfs_get_libvirt_requested_credentials"
.IX Subsection "guestfs_get_libvirt_requested_credentials"
.Vb 2
\& char **
\& guestfs_get_libvirt_requested_credentials (guestfs_h *g);
.Ve
.PP
This should only be called during the event callback for events of type
\&\f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR.
.PP
Return the list of credentials requested by libvirt.  Possible values are a
subset of the strings provided when you called
\&\f(CW\*(C`guestfs_set_libvirt_supported_credentials\*(C'\fR.
.PP
See \*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 for documentation and example code.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.19.52 において追加))
.SS "guestfs_get_memsize"
.IX Subsection "guestfs_get_memsize"
.Vb 2
\& int
\& guestfs_get_memsize (guestfs_h *g);
.Ve
.PP
This gets the memory size in megabytes allocated to the hypervisor.
.PP
If \f(CW\*(C`guestfs_set_memsize\*(C'\fR was not called on this handle, and if
\&\f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR was not set, then this returns the compiled-in default
value for memsize.
.PP
libguestfs のアーキテクチャーの詳細は \fIguestfs\fR\|(3) を参照してください。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.55 において追加)
.SS "guestfs_get_network"
.IX Subsection "guestfs_get_network"
.Vb 2
\& int
\& guestfs_get_network (guestfs_h *g);
.Ve
.PP
これは有効化されているネットワークフラグを返します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.4 において追加)
.SS "guestfs_get_path"
.IX Subsection "guestfs_get_path"
.Vb 2
\& const char *
\& guestfs_get_path (guestfs_h *g);
.Ve
.PP
現在の検索パスを返します。
.PP
This is always non-NULL.  If it wasn't set already, then this will return
the default path.
.PP
This function returns a string, or \s-1NULL\s0 on error.  The string is owned by
the guest handle and must \fInot\fR be freed.
.PP
(0.3 において追加)
.SS "guestfs_get_pgroup"
.IX Subsection "guestfs_get_pgroup"
.Vb 2
\& int
\& guestfs_get_pgroup (guestfs_h *g);
.Ve
.PP
これはプロセスグループフラグを返します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.11.18 において追加)
.SS "guestfs_get_pid"
.IX Subsection "guestfs_get_pid"
.Vb 2
\& int
\& guestfs_get_pid (guestfs_h *g);
.Ve
.PP
Return the process \s-1ID\s0 of the hypervisor.  If there is no hypervisor running,
then this will return an error.
.PP
This is an internal call used for debugging and testing.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.56 において追加)
.SS "guestfs_get_program"
.IX Subsection "guestfs_get_program"
.Vb 2
\& const char *
\& guestfs_get_program (guestfs_h *g);
.Ve
.PP
Get the program name.  See \f(CW\*(C`guestfs_set_program\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  The string is owned by
the guest handle and must \fInot\fR be freed.
.PP
(1.21.29 において追加)
.SS "guestfs_get_qemu"
.IX Subsection "guestfs_get_qemu"
.Vb 2
\& const char *
\& guestfs_get_qemu (guestfs_h *g);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_get_hv\*(R" call
instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
Return the current hypervisor binary (usually qemu).
.PP
This is always non-NULL.  If it wasn't set already, then this will return
the default qemu binary name.
.PP
This function returns a string, or \s-1NULL\s0 on error.  The string is owned by
the guest handle and must \fInot\fR be freed.
.PP
(1.0.6 において追加)
.SS "guestfs_get_recovery_proc"
.IX Subsection "guestfs_get_recovery_proc"
.Vb 2
\& int
\& guestfs_get_recovery_proc (guestfs_h *g);
.Ve
.PP
復元プロセス有効化フラグを返します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.77 において追加)
.SS "guestfs_get_selinux"
.IX Subsection "guestfs_get_selinux"
.Vb 2
\& int
\& guestfs_get_selinux (guestfs_h *g);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_selinux_relabel\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This returns the current setting of the selinux flag which is passed to the
appliance at boot time.  See \f(CW\*(C`guestfs_set_selinux\*(C'\fR.
.PP
libguestfs のアーキテクチャーの詳細は \fIguestfs\fR\|(3) を参照してください。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.67 において追加)
.SS "guestfs_get_smp"
.IX Subsection "guestfs_get_smp"
.Vb 2
\& int
\& guestfs_get_smp (guestfs_h *g);
.Ve
.PP
This returns the number of virtual CPUs assigned to the appliance.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.13.15 において追加)
.SS "guestfs_get_sockdir"
.IX Subsection "guestfs_get_sockdir"
.Vb 2
\& char *
\& guestfs_get_sockdir (guestfs_h *g);
.Ve
.PP
Get the directory used by the handle to store temporary socket files.
.PP
This is different from \f(CW\*(C`guestfs_tmpdir\*(C'\fR, as we need shorter paths for
sockets (due to the limited buffers of filenames for \s-1UNIX\s0 sockets), and
\&\f(CW\*(C`guestfs_tmpdir\*(C'\fR may be too long for them.
.PP
The environment variable \f(CW\*(C`XDG_RUNTIME_DIR\*(C'\fR controls the default value: If
\&\f(CW\*(C`XDG_RUNTIME_DIR\*(C'\fR is set, then that is the default.  Else \fI/tmp\fR is the
default.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.33.8)
.SS "guestfs_get_state"
.IX Subsection "guestfs_get_state"
.Vb 2
\& int
\& guestfs_get_state (guestfs_h *g);
.Ve
.PP
This returns the current state as an opaque integer.  This is only useful
for printing debug and internal error messages.
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.2 において追加)
.SS "guestfs_get_tmpdir"
.IX Subsection "guestfs_get_tmpdir"
.Vb 2
\& char *
\& guestfs_get_tmpdir (guestfs_h *g);
.Ve
.PP
Get the directory used by the handle to store temporary files.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.58 において追加)
.SS "guestfs_get_trace"
.IX Subsection "guestfs_get_trace"
.Vb 2
\& int
\& guestfs_get_trace (guestfs_h *g);
.Ve
.PP
コマンドトレースフラグを返します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.69 において追加)
.SS "guestfs_get_umask"
.IX Subsection "guestfs_get_umask"
.Vb 2
\& int
\& guestfs_get_umask (guestfs_h *g);
.Ve
.PP
Return the current umask.  By default the umask is \f(CW022\fR unless it has been
set by calling \f(CW\*(C`guestfs_umask\*(C'\fR.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.3.4 において追加)
.SS "guestfs_get_verbose"
.IX Subsection "guestfs_get_verbose"
.Vb 2
\& int
\& guestfs_get_verbose (guestfs_h *g);
.Ve
.PP
これはメッセージ冗長化フラグを返します。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(0.3 において追加)
.SS "guestfs_getcon"
.IX Subsection "guestfs_getcon"
.Vb 2
\& char *
\& guestfs_getcon (guestfs_h *g);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_selinux_relabel\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これはデーモンの SELinux セキュリティコンテキストを取得します。
.PP
\&\fIguestfs\fR\|(3) における SELinux および \f(CW\*(C`guestfs_setcon\*(C'\fR に関するドキュメントを参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`selinux\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.67 において追加)
.SS "guestfs_getxattr"
.IX Subsection "guestfs_getxattr"
.Vb 5
\& char *
\& guestfs_getxattr (guestfs_h *g,
\&                   const char *path,
\&                   const char *name,
\&                   size_t *size_r);
.Ve
.PP
Get a single extended attribute from file \f(CW\*(C`path\*(C'\fR named \f(CW\*(C`name\*(C'\fR.  This call
follows symlinks.  If you want to lookup an extended attribute for the
symlink itself, use \f(CW\*(C`guestfs_lgetxattr\*(C'\fR.
.PP
Normally it is better to get all extended attributes from a file in one go
by calling \f(CW\*(C`guestfs_getxattrs\*(C'\fR.  However some Linux filesystem
implementations are buggy and do not provide a way to list out attributes.
For these filesystems (notably ntfs\-3g)  you have to know the names of the
extended attributes you want in advance and call this function.
.PP
Extended attribute values are blobs of binary data.  If there is no extended
attribute named \f(CW\*(C`name\*(C'\fR, this returns an error.
.PP
関連項目: \f(CW\*(C`guestfs_getxattrs\*(C'\fR, \f(CW\*(C`guestfs_lgetxattr\*(C'\fR, \fIattr\fR\|(5)
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.7.24 において追加)
.SS "guestfs_getxattrs"
.IX Subsection "guestfs_getxattrs"
.Vb 3
\& struct guestfs_xattr_list *
\& guestfs_getxattrs (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
This call lists the extended attributes of the file or directory \f(CW\*(C`path\*(C'\fR.
.PP
At the system call level, this is a combination of the \fIlistxattr\fR\|(2) and
\&\fIgetxattr\fR\|(2) calls.
.PP
関連項目: \f(CW\*(C`guestfs_lgetxattrs\*(C'\fR, \fIattr\fR\|(5)
.PP
この関数は \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR を返します。もしくは、エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.59 において追加)
.SS "guestfs_glob_expand"
.IX Subsection "guestfs_glob_expand"
.Vb 3
\& char **
\& guestfs_glob_expand (guestfs_h *g,
\&                      const char *pattern);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_glob_expand_opts\*(R" with no
optional arguments.
.PP
(1.0.50 において追加)
.SS "guestfs_glob_expand_opts"
.IX Subsection "guestfs_glob_expand_opts"
.Vb 4
\& char **
\& guestfs_glob_expand_opts (guestfs_h *g,
\&                           const char *pattern,
\&                           ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_GLOB_EXPAND_OPTS_DIRECTORYSLASH, int directoryslash,
.Ve
.PP
This command searches for all the pathnames matching \f(CW\*(C`pattern\*(C'\fR according to
the wildcard expansion rules used by the shell.
.PP
If no paths match, then this returns an empty list (note: not an error).
.PP
It is just a wrapper around the C \fIglob\fR\|(3) function with flags
\&\f(CW\*(C`GLOB_MARK|GLOB_BRACE\*(C'\fR.  See that manual page for more details.
.PP
\&\f(CW\*(C`directoryslash\*(C'\fR controls whether use the \f(CW\*(C`GLOB_MARK\*(C'\fR flag for \fIglob\fR\|(3),
and it defaults to true.  It can be explicitly set as off to return no
trailing slashes in filenames of directories.
.PP
Notice that there is no equivalent command for expanding a device name
(eg. \fI/dev/sd*\fR).  Use \f(CW\*(C`guestfs_list_devices\*(C'\fR, \f(CW\*(C`guestfs_list_partitions\*(C'\fR
etc functions instead.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.50 において追加)
.SS "guestfs_glob_expand_opts_va"
.IX Subsection "guestfs_glob_expand_opts_va"
.Vb 4
\& char **
\& guestfs_glob_expand_opts_va (guestfs_h *g,
\&                              const char *pattern,
\&                              va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_glob_expand_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_glob_expand_opts_argv"
.IX Subsection "guestfs_glob_expand_opts_argv"
.Vb 4
\& char **
\& guestfs_glob_expand_opts_argv (guestfs_h *g,
\&                                const char *pattern,
\&                                const struct guestfs_glob_expand_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_glob_expand_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_grep"
.IX Subsection "guestfs_grep"
.Vb 4
\& char **
\& guestfs_grep (guestfs_h *g,
\&               const char *regex,
\&               const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_grep_opts\*(R" with no optional
arguments.
.PP
(1.0.66 において追加)
.SS "guestfs_grep_opts"
.IX Subsection "guestfs_grep_opts"
.Vb 5
\& char **
\& guestfs_grep_opts (guestfs_h *g,
\&                    const char *regex,
\&                    const char *path,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 4
\& GUESTFS_GREP_OPTS_EXTENDED, int extended,
\& GUESTFS_GREP_OPTS_FIXED, int fixed,
\& GUESTFS_GREP_OPTS_INSENSITIVE, int insensitive,
\& GUESTFS_GREP_OPTS_COMPRESSED, int compressed,
.Ve
.PP
This calls the external \f(CW\*(C`grep\*(C'\fR program and returns the matching lines.
.PP
オプションのフラグは次のとおりです:
.ie n .IP """extended""" 4
.el .IP "\f(CWextended\fR" 4
.IX Item "extended"
Use extended regular expressions.  This is the same as using the \fI\-E\fR flag.
.ie n .IP """fixed""" 4
.el .IP "\f(CWfixed\fR" 4
.IX Item "fixed"
Match fixed (don't use regular expressions).  This is the same as using the
\&\fI\-F\fR flag.
.ie n .IP """insensitive""" 4
.el .IP "\f(CWinsensitive\fR" 4
.IX Item "insensitive"
Match case-insensitive.  This is the same as using the \fI\-i\fR flag.
.ie n .IP """compressed""" 4
.el .IP "\f(CWcompressed\fR" 4
.IX Item "compressed"
Use \f(CW\*(C`zgrep\*(C'\fR instead of \f(CW\*(C`grep\*(C'\fR.  This allows the input to be compress\- or
gzip-compressed.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_grep_opts_va"
.IX Subsection "guestfs_grep_opts_va"
.Vb 5
\& char **
\& guestfs_grep_opts_va (guestfs_h *g,
\&                       const char *regex,
\&                       const char *path,
\&                       va_list args);
.Ve
.PP
これは \*(L"guestfs_grep_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_grep_opts_argv"
.IX Subsection "guestfs_grep_opts_argv"
.Vb 5
\& char **
\& guestfs_grep_opts_argv (guestfs_h *g,
\&                         const char *regex,
\&                         const char *path,
\&                         const struct guestfs_grep_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_grep_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_grepi"
.IX Subsection "guestfs_grepi"
.Vb 4
\& char **
\& guestfs_grepi (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`grep \-i\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_grub_install"
.IX Subsection "guestfs_grub_install"
.Vb 4
\& int
\& guestfs_grub_install (guestfs_h *g,
\&                       const char *root,
\&                       const char *device);
.Ve
.PP
This command installs \s-1GRUB 1\s0 (the Grand Unified Bootloader) on \f(CW\*(C`device\*(C'\fR,
with the root directory being \f(CW\*(C`root\*(C'\fR.
.PP
注:
.IP "\(bu" 4
There is currently no way in the \s-1API\s0 to install grub2, which is used by most
modern Linux guests.  It is possible to run the grub2 command from the
guest, although see the caveats in \*(L"\s-1RUNNING COMMANDS\*(R"\s0.
.IP "\(bu" 4
This uses \f(CW\*(C`grub\-install\*(C'\fR from the host.  Unfortunately grub is not always
compatible with itself, so this only works in rather narrow circumstances.
Careful testing with each guest version is advisable.
.IP "\(bu" 4
If grub-install reports the error \*(L"No suitable drive was found in the
generated device map.\*(R" it may be that you need to create a
\&\fI/boot/grub/device.map\fR file first that contains the mapping between grub
device names and Linux device names.  It is usually sufficient to create a
file containing:
.Sp
.Vb 1
\& (hd0) /dev/vda
.Ve
.Sp
replacing \fI/dev/vda\fR with the name of the installation device.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`grub\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.17 において追加)
.SS "guestfs_head"
.IX Subsection "guestfs_head"
.Vb 3
\& char **
\& guestfs_head (guestfs_h *g,
\&               const char *path);
.Ve
.PP
このコマンドは文字列の一覧として、ファイルの先頭 10 行までを返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.54 において追加)
.SS "guestfs_head_n"
.IX Subsection "guestfs_head_n"
.Vb 4
\& char **
\& guestfs_head_n (guestfs_h *g,
\&                 int nrlines,
\&                 const char *path);
.Ve
.PP
パラメーター \f(CW\*(C`nrlines\*(C'\fR が正の数ならば、これはファイル \f(CW\*(C`path\*(C'\fR の先頭 \f(CW\*(C`nrlines\*(C'\fR 行を返します。
.PP
パラメーター \f(CW\*(C`nrlines\*(C'\fR が負の数ならば、これはファイル \f(CW\*(C`path\*(C'\fR の末尾 \f(CW\*(C`nrlines\*(C'\fR 行を取り除いた行を返します。
.PP
パラメーター \f(CW\*(C`nrlines\*(C'\fR が 0 ならば、空の一覧を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.54 において追加)
.SS "guestfs_hexdump"
.IX Subsection "guestfs_hexdump"
.Vb 3
\& char *
\& guestfs_hexdump (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
指定された \f(CW\*(C`path\*(C'\fR において \f(CW\*(C`hexdump \-C\*(C'\fR を実行します。結果は、読みやすい形式になり、ファイルの正規化された 16
進ダンプです。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.22 において追加)
.SS "guestfs_hivex_close"
.IX Subsection "guestfs_hivex_close"
.Vb 2
\& int
\& guestfs_hivex_close (guestfs_h *g);
.Ve
.PP
現在の hivex ハンドルを閉じます。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_commit"
.IX Subsection "guestfs_hivex_commit"
.Vb 3
\& int
\& guestfs_hivex_commit (guestfs_h *g,
\&                       const char *filename);
.Ve
.PP
ハイブへの変更をコミット（書き込み）します。
.PP
If the optional \fIfilename\fR parameter is null, then the changes are written
back to the same hive that was opened.  If this is not null then they are
written to the alternate filename given and the original hive is left
untouched.
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_add_child"
.IX Subsection "guestfs_hivex_node_add_child"
.Vb 4
\& int64_t
\& guestfs_hivex_node_add_child (guestfs_h *g,
\&                               int64_t parent,
\&                               const char *name);
.Ve
.PP
子ノードに \f(CW\*(C`name\*(C'\fR という名前の \f(CW\*(C`parent\*(C'\fR を追加します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_children"
.IX Subsection "guestfs_hivex_node_children"
.Vb 3
\& struct guestfs_hivex_node_list *
\& guestfs_hivex_node_children (guestfs_h *g,
\&                              int64_t nodeh);
.Ve
.PP
\&\f(CW\*(C`nodeh\*(C'\fR のサブキーであるノードの一覧を返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は \f(CW\*(C`struct guestfs_hivex_node_list *\*(C'\fR を返します。エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用した後に \f(CI\*(C`guestfs_free_hivex_node_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_delete_child"
.IX Subsection "guestfs_hivex_node_delete_child"
.Vb 3
\& int
\& guestfs_hivex_node_delete_child (guestfs_h *g,
\&                                  int64_t nodeh);
.Ve
.PP
\&\f(CW\*(C`nodeh\*(C'\fR を削除します。必要に応じて、再帰的に削除します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_get_child"
.IX Subsection "guestfs_hivex_node_get_child"
.Vb 4
\& int64_t
\& guestfs_hivex_node_get_child (guestfs_h *g,
\&                               int64_t nodeh,
\&                               const char *name);
.Ve
.PP
Return the child of \f(CW\*(C`nodeh\*(C'\fR with the name \f(CW\*(C`name\*(C'\fR, if it exists.  This can
return \f(CW0\fR meaning the name was not found.
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_get_value"
.IX Subsection "guestfs_hivex_node_get_value"
.Vb 4
\& int64_t
\& guestfs_hivex_node_get_value (guestfs_h *g,
\&                               int64_t nodeh,
\&                               const char *key);
.Ve
.PP
Return the value attached to \f(CW\*(C`nodeh\*(C'\fR which has the name \f(CW\*(C`key\*(C'\fR, if it
exists.  This can return \f(CW0\fR meaning the key was not found.
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_name"
.IX Subsection "guestfs_hivex_node_name"
.Vb 3
\& char *
\& guestfs_hivex_node_name (guestfs_h *g,
\&                          int64_t nodeh);
.Ve
.PP
\&\f(CW\*(C`nodeh\*(C'\fR の名前を返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_parent"
.IX Subsection "guestfs_hivex_node_parent"
.Vb 3
\& int64_t
\& guestfs_hivex_node_parent (guestfs_h *g,
\&                            int64_t nodeh);
.Ve
.PP
\&\f(CW\*(C`nodeh\*(C'\fR の親ノードを返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_set_value"
.IX Subsection "guestfs_hivex_node_set_value"
.Vb 7
\& int
\& guestfs_hivex_node_set_value (guestfs_h *g,
\&                               int64_t nodeh,
\&                               const char *key,
\&                               int64_t t,
\&                               const char *val,
\&                               size_t val_size);
.Ve
.PP
Set or replace a single value under the node \f(CW\*(C`nodeh\*(C'\fR.  The \f(CW\*(C`key\*(C'\fR is the
name, \f(CW\*(C`t\*(C'\fR is the type, and \f(CW\*(C`val\*(C'\fR is the data.
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_node_values"
.IX Subsection "guestfs_hivex_node_values"
.Vb 3
\& struct guestfs_hivex_value_list *
\& guestfs_hivex_node_values (guestfs_h *g,
\&                            int64_t nodeh);
.Ve
.PP
Return the array of (key, datatype, data) tuples attached to \f(CW\*(C`nodeh\*(C'\fR.
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は \f(CW\*(C`struct guestfs_hivex_value_list *\*(C'\fR を返します。エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用した後に \f(CI\*(C`guestfs_free_hivex_value_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_open"
.IX Subsection "guestfs_hivex_open"
.Vb 4
\& int
\& guestfs_hivex_open (guestfs_h *g,
\&                     const char *filename,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 4
\& GUESTFS_HIVEX_OPEN_VERBOSE, int verbose,
\& GUESTFS_HIVEX_OPEN_DEBUG, int debug,
\& GUESTFS_HIVEX_OPEN_WRITE, int write,
\& GUESTFS_HIVEX_OPEN_UNSAFE, int unsafe,
.Ve
.PP
Open the Windows Registry hive file named \fIfilename\fR.  If there was any
previous hivex handle associated with this guestfs session, then it is
closed.
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_open_va"
.IX Subsection "guestfs_hivex_open_va"
.Vb 4
\& int
\& guestfs_hivex_open_va (guestfs_h *g,
\&                        const char *filename,
\&                        va_list args);
.Ve
.PP
これは \*(L"guestfs_hivex_open\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_hivex_open_argv"
.IX Subsection "guestfs_hivex_open_argv"
.Vb 4
\& int
\& guestfs_hivex_open_argv (guestfs_h *g,
\&                          const char *filename,
\&                          const struct guestfs_hivex_open_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_hivex_open\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_hivex_root"
.IX Subsection "guestfs_hivex_root"
.Vb 2
\& int64_t
\& guestfs_hivex_root (guestfs_h *g);
.Ve
.PP
ハイブのルートノードを返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_value_key"
.IX Subsection "guestfs_hivex_value_key"
.Vb 3
\& char *
\& guestfs_hivex_value_key (guestfs_h *g,
\&                          int64_t valueh);
.Ve
.PP
(key, datatype, data) 組のキー (name) 項目を返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_value_type"
.IX Subsection "guestfs_hivex_value_type"
.Vb 3
\& int64_t
\& guestfs_hivex_value_type (guestfs_h *g,
\&                           int64_t valueh);
.Ve
.PP
(key, datatype, data) 組の datatype 項目を返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_value_utf8"
.IX Subsection "guestfs_hivex_value_utf8"
.Vb 3
\& char *
\& guestfs_hivex_value_utf8 (guestfs_h *g,
\&                           int64_t valueh);
.Ve
.PP
This calls \f(CW\*(C`guestfs_hivex_value_value\*(C'\fR (which returns the data field from a
hivex value tuple).  It then assumes that the field is a \s-1UTF\-16LE\s0 string and
converts the result to \s-1UTF\-8\s0 (or if this is not possible, it returns an
error).
.PP
This is useful for reading strings out of the Windows registry.  However it
is not foolproof because the registry is not strongly-typed and fields can
contain arbitrary or unexpected data.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_hivex_value_value"
.IX Subsection "guestfs_hivex_value_value"
.Vb 4
\& char *
\& guestfs_hivex_value_value (guestfs_h *g,
\&                            int64_t valueh,
\&                            size_t *size_r);
.Ve
.PP
(key, datatype, data) 組のデータ項目を返します。
.PP
これは同じ名前の \fIhivex\fR\|(3) のラッパーです。
.PP
関連項目: \f(CW\*(C`guestfs_hivex_value_utf8\*(C'\fR。
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
This function depends on the feature \f(CW\*(C`hivex\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.35 において追加)
.SS "guestfs_initrd_cat"
.IX Subsection "guestfs_initrd_cat"
.Vb 5
\& char *
\& guestfs_initrd_cat (guestfs_h *g,
\&                     const char *initrdpath,
\&                     const char *filename,
\&                     size_t *size_r);
.Ve
.PP
This command unpacks the file \fIfilename\fR from the initrd file called
\&\fIinitrdpath\fR.  The filename must be given \fIwithout\fR the initial \fI/\fR
character.
.PP
For example, in guestfish you could use the following command to examine the
boot script (usually called \fI/init\fR)  contained in a Linux initrd or
initramfs image:
.PP
.Vb 1
\& initrd\-cat /boot/initrd\-<version>.img init
.Ve
.PP
\&\f(CW\*(C`guestfs_initrd_list\*(C'\fR 参照。
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.84 において追加)
.SS "guestfs_initrd_list"
.IX Subsection "guestfs_initrd_list"
.Vb 3
\& char **
\& guestfs_initrd_list (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
このコマンドは initrd に含まれるファイルを一覧表示します。
.PP
The files are listed without any initial \fI/\fR character.  The files are
listed in the order they appear (not necessarily alphabetical).  Directory
names are listed as separate items.
.PP
古い Linux カーネル (2.4 およびそれ以前) は initrd として圧縮 ext2 ファイルシステムを使用していました。新しい
initramfs 形式 (圧縮 cpio ファイル) \fIのみ\fR をサポートします。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.54 において追加)
.SS "guestfs_inotify_add_watch"
.IX Subsection "guestfs_inotify_add_watch"
.Vb 4
\& int64_t
\& guestfs_inotify_add_watch (guestfs_h *g,
\&                            const char *path,
\&                            int mask);
.Ve
.PP
\&\f(CW\*(C`mask\*(C'\fR に一覧化されたイベントに対して \f(CW\*(C`path\*(C'\fR を監視します。
.PP
Note that if \f(CW\*(C`path\*(C'\fR is a directory then events within that directory are
watched, but this does \fInot\fR happen recursively (in subdirectories).
.PP
Note for non-C or non-Linux callers: the inotify events are defined by the
Linux kernel \s-1ABI\s0 and are listed in \fI/usr/include/sys/inotify.h\fR.
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`inotify\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_inotify_close"
.IX Subsection "guestfs_inotify_close"
.Vb 2
\& int
\& guestfs_inotify_close (guestfs_h *g);
.Ve
.PP
This closes the inotify handle which was previously opened by inotify_init.
It removes all watches, throws away any pending events, and deallocates all
resources.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`inotify\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_inotify_files"
.IX Subsection "guestfs_inotify_files"
.Vb 2
\& char **
\& guestfs_inotify_files (guestfs_h *g);
.Ve
.PP
This function is a helpful wrapper around \f(CW\*(C`guestfs_inotify_read\*(C'\fR which just
returns a list of pathnames of objects that were touched.  The returned
pathnames are sorted and deduplicated.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`inotify\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_inotify_init"
.IX Subsection "guestfs_inotify_init"
.Vb 3
\& int
\& guestfs_inotify_init (guestfs_h *g,
\&                       int maxevents);
.Ve
.PP
This command creates a new inotify handle.  The inotify subsystem can be
used to notify events which happen to objects in the guest filesystem.
.PP
\&\f(CW\*(C`maxevents\*(C'\fR is the maximum number of events which will be queued up between
calls to \f(CW\*(C`guestfs_inotify_read\*(C'\fR or \f(CW\*(C`guestfs_inotify_files\*(C'\fR.  If this is
passed as \f(CW0\fR, then the kernel (or previously set)  default is used.  For
Linux 2.6.29 the default was 16384 events.  Beyond this limit, the kernel
throws away events, but records the fact that it threw them away by setting
a flag \f(CW\*(C`IN_Q_OVERFLOW\*(C'\fR in the returned structure list (see
\&\f(CW\*(C`guestfs_inotify_read\*(C'\fR).
.PP
何らかのイベントを生成する前に、いくつかのウォッチと内部ウォッチリストに追加する必要があります。  参照:
\&\f(CW\*(C`guestfs_inotify_add_watch\*(C'\fR および \f(CW\*(C`guestfs_inotify_rm_watch\*(C'\fR。
.PP
Queued up events should be read periodically by calling
\&\f(CW\*(C`guestfs_inotify_read\*(C'\fR (or \f(CW\*(C`guestfs_inotify_files\*(C'\fR which is just a helpful
wrapper around \f(CW\*(C`guestfs_inotify_read\*(C'\fR).  If you don't read the events out
often enough then you risk the internal queue overflowing.
.PP
The handle should be closed after use by calling \f(CW\*(C`guestfs_inotify_close\*(C'\fR.
This also removes any watches automatically.
.PP
See also \fIinotify\fR\|(7) for an overview of the inotify interface as exposed
by the Linux kernel, which is roughly what we expose via libguestfs.  Note
that there is one global inotify handle per libguestfs instance.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`inotify\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_inotify_read"
.IX Subsection "guestfs_inotify_read"
.Vb 2
\& struct guestfs_inotify_event_list *
\& guestfs_inotify_read (guestfs_h *g);
.Ve
.PP
Return the complete queue of events that have happened since the previous
read call.
.PP
何もイベントが起きないと、これは空の一覧を返します。
.PP
\&\fINote\fR: In order to make sure that all events have been read, you must call
this function repeatedly until it returns an empty list.  The reason is that
the call will read events up to the maximum appliance-to-host message size
and leave remaining events in the queue.
.PP
This function returns a \f(CW\*(C`struct guestfs_inotify_event_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call
\&\f(CI\*(C`guestfs_free_inotify_event_list\*(C'\fI after use\fR.
.PP
This function depends on the feature \f(CW\*(C`inotify\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_inotify_rm_watch"
.IX Subsection "guestfs_inotify_rm_watch"
.Vb 3
\& int
\& guestfs_inotify_rm_watch (guestfs_h *g,
\&                           int wd);
.Ve
.PP
前に定義された inotify ウォッチを削除します。 \f(CW\*(C`guestfs_inotify_add_watch\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`inotify\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_inspect_get_arch"
.IX Subsection "guestfs_inspect_get_arch"
.Vb 3
\& char *
\& guestfs_inspect_get_arch (guestfs_h *g,
\&                           const char *root);
.Ve
.PP
これは検査したオペレーティングシステムのアーキテクチャーを返します。とりうる値は \f(CW\*(C`guestfs_file_architecture\*(C'\fR
の下に一覧化されています。
.PP
アーキテクチャーが決められなければ、文字列 \f(CW\*(C`unknown\*(C'\fR が返されます。
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_distro"
.IX Subsection "guestfs_inspect_get_distro"
.Vb 3
\& char *
\& guestfs_inspect_get_distro (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
これは検査したオペレーティングシステムのディストリビューションを返します。
.PP
定義されているディストリビューションは現在次のとおりです:
.ie n .IP """alpinelinux""" 4
.el .IP "``alpinelinux''" 4
.IX Item "alpinelinux"
Alpine Linux.
.ie n .IP """altlinux""" 4
.el .IP "``altlinux''" 4
.IX Item "altlinux"
\&\s-1ALT\s0 Linux.
.ie n .IP """archlinux""" 4
.el .IP "``archlinux''" 4
.IX Item "archlinux"
Arch Linux.
.ie n .IP """buildroot""" 4
.el .IP "``buildroot''" 4
.IX Item "buildroot"
Buildroot 派生のディストリビューション. 具体的にどれかを認識しません.
.ie n .IP """centos""" 4
.el .IP "``centos''" 4
.IX Item "centos"
CentOS.
.ie n .IP """cirros""" 4
.el .IP "``cirros''" 4
.IX Item "cirros"
Cirros.
.ie n .IP """coreos""" 4
.el .IP "``coreos''" 4
.IX Item "coreos"
CoreOS.
.ie n .IP """debian""" 4
.el .IP "``debian''" 4
.IX Item "debian"
Debian.
.ie n .IP """fedora""" 4
.el .IP "``fedora''" 4
.IX Item "fedora"
Fedora.
.ie n .IP """freebsd""" 4
.el .IP "``freebsd''" 4
.IX Item "freebsd"
FreeBSD.
.ie n .IP """freedos""" 4
.el .IP "``freedos''" 4
.IX Item "freedos"
FreeDOS.
.ie n .IP """frugalware""" 4
.el .IP "``frugalware''" 4
.IX Item "frugalware"
Frugalware.
.ie n .IP """gentoo""" 4
.el .IP "``gentoo''" 4
.IX Item "gentoo"
Gentoo.
.ie n .IP """linuxmint""" 4
.el .IP "``linuxmint''" 4
.IX Item "linuxmint"
Linux Mint.
.ie n .IP """mageia""" 4
.el .IP "``mageia''" 4
.IX Item "mageia"
Mageia.
.ie n .IP """mandriva""" 4
.el .IP "``mandriva''" 4
.IX Item "mandriva"
Mandriva.
.ie n .IP """meego""" 4
.el .IP "``meego''" 4
.IX Item "meego"
MeeGo.
.ie n .IP """netbsd""" 4
.el .IP "``netbsd''" 4
.IX Item "netbsd"
NetBSD.
.ie n .IP """openbsd""" 4
.el .IP "``openbsd''" 4
.IX Item "openbsd"
OpenBSD.
.ie n .IP """opensuse""" 4
.el .IP "``opensuse''" 4
.IX Item "opensuse"
OpenSUSE.
.ie n .IP """oraclelinux""" 4
.el .IP "``oraclelinux''" 4
.IX Item "oraclelinux"
Oracle Linux.
.ie n .IP """pardus""" 4
.el .IP "``pardus''" 4
.IX Item "pardus"
Pardus.
.ie n .IP """pldlinux""" 4
.el .IP "``pldlinux''" 4
.IX Item "pldlinux"
\&\s-1PLD\s0 Linux.
.ie n .IP """redhat-based""" 4
.el .IP "``redhat-based''" 4
.IX Item "redhat-based"
いくつかの Red Hat 派生ディストリビューション.
.ie n .IP """rhel""" 4
.el .IP "``rhel''" 4
.IX Item "rhel"
Red Hat Enterprise Linux.
.ie n .IP """scientificlinux""" 4
.el .IP "``scientificlinux''" 4
.IX Item "scientificlinux"
Scientific Linux.
.ie n .IP """slackware""" 4
.el .IP "``slackware''" 4
.IX Item "slackware"
Slackware.
.ie n .IP """sles""" 4
.el .IP "``sles''" 4
.IX Item "sles"
SuSE Linux Enterprise Server または Desktop.
.ie n .IP """suse-based""" 4
.el .IP "``suse-based''" 4
.IX Item "suse-based"
いくつかの openSuSE 派生ディストリビューション.
.ie n .IP """ttylinux""" 4
.el .IP "``ttylinux''" 4
.IX Item "ttylinux"
ttylinux.
.ie n .IP """ubuntu""" 4
.el .IP "``ubuntu''" 4
.IX Item "ubuntu"
Ubuntu.
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
ディストリビューションがわかりませんでした。
.ie n .IP """voidlinux""" 4
.el .IP "``voidlinux''" 4
.IX Item "voidlinux"
Void Linux.
.ie n .IP """windows""" 4
.el .IP "``windows''" 4
.IX Item "windows"
Windows はディストリビューションがありません。OS 種別が Windows ならば、この文字列は返されません。
.PP
libguestfs の将来のバージョンは、ここに他の文字列を返す可能性があります。呼び出し元はあらゆる文字列の処理に備えなければいけません。
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_drive_mappings"
.IX Subsection "guestfs_inspect_get_drive_mappings"
.Vb 3
\& char **
\& guestfs_inspect_get_drive_mappings (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
This call is useful for Windows which uses a primitive system of assigning
drive letters (like \fIC:\e\fR) to partitions.  This inspection \s-1API\s0 examines the
Windows Registry to find out how disks/partitions are mapped to drive
letters, and returns a hash table as in the example below:
.PP
.Vb 3
\& C      =>     /dev/vda2
\& E      =>     /dev/vdb1
\& F      =>     /dev/vdc1
.Ve
.PP
Note that keys are drive letters.  For Windows, the key is case insensitive
and just contains the drive letter, without the customary colon separator
character.
.PP
In future we may support other operating systems that also used drive
letters, but the keys for those might not be case insensitive and might be
longer than 1 character.  For example in \s-1OS\-9,\s0 hard drives were named \f(CW\*(C`h0\*(C'\fR,
\&\f(CW\*(C`h1\*(C'\fR etc.
.PP
For Windows guests, currently only hard drive mappings are returned.
Removable disks (eg. DVD-ROMs) are ignored.
.PP
For guests that do not use drive mappings, or if the drive mappings could
not be determined, this returns an empty hash table.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を確認してください。合わせて
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, \f(CW\*(C`guestfs_inspect_get_filesystems\*(C'\fR
を参照してください。
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(1.9.17 において追加)
.SS "guestfs_inspect_get_filesystems"
.IX Subsection "guestfs_inspect_get_filesystems"
.Vb 3
\& char **
\& guestfs_inspect_get_filesystems (guestfs_h *g,
\&                                  const char *root);
.Ve
.PP
This returns a list of all the filesystems that we think are associated with
this operating system.  This includes the root filesystem, other ordinary
filesystems, and non-mounted devices like swap partitions.
.PP
In the case of a multi-boot virtual machine, it is possible for a filesystem
to be shared between operating systems.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を読んでください。  \f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR
参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_format"
.IX Subsection "guestfs_inspect_get_format"
.Vb 3
\& char *
\& guestfs_inspect_get_format (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
This returns the format of the inspected operating system.  You can use it
to detect install images, live CDs and similar.
.PP
今のところ定義されている形式は次のとおりです:
.ie n .IP """installed""" 4
.el .IP "``installed''" 4
.IX Item "installed"
インストールされているオペレーティングシステムです。
.ie n .IP """installer""" 4
.el .IP "``installer''" 4
.IX Item "installer"
検査されるディスクイメージが、インストールされたオペレーティング・システムではなく、\fIブート可能な\fR インストールディスク、ライブ
CD、または似たようなものです。
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
このディスクイメージの形式は不明です。
.PP
libguestfs の将来のバージョンは、ここに他の文字列を返す可能性があります。呼び出し元はあらゆる文字列の処理に備えなければいけません。
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.9.4 において追加)
.SS "guestfs_inspect_get_hostname"
.IX Subsection "guestfs_inspect_get_hostname"
.Vb 3
\& char *
\& guestfs_inspect_get_hostname (guestfs_h *g,
\&                               const char *root);
.Ve
.PP
This function returns the hostname of the operating system as found by
inspection of the guest's configuration files.
.PP
If the hostname could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR is
returned.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.7.9 において追加)
.SS "guestfs_inspect_get_icon"
.IX Subsection "guestfs_inspect_get_icon"
.Vb 5
\& char *
\& guestfs_inspect_get_icon (guestfs_h *g,
\&                           const char *root,
\&                           size_t *size_r,
\&                           ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_INSPECT_GET_ICON_FAVICON, int favicon,
\& GUESTFS_INSPECT_GET_ICON_HIGHQUALITY, int highquality,
.Ve
.PP
This function returns an icon corresponding to the inspected operating
system.  The icon is returned as a buffer containing a \s-1PNG\s0 image (re-encoded
to \s-1PNG\s0 if necessary).
.PP
If it was not possible to get an icon this function returns a zero-length
(non-NULL) buffer.  \fICallers must check for this case\fR.
.PP
Libguestfs will start by looking for a file called \fI/etc/favicon.png\fR or
\&\fIC:\eetc\efavicon.png\fR and if it has the correct format, the contents of this
file will be returned.  You can disable favicons by passing the optional
\&\f(CW\*(C`favicon\*(C'\fR boolean as false (default is true).
.PP
If finding the favicon fails, then we look in other places in the guest for
a suitable icon.
.PP
If the optional \f(CW\*(C`highquality\*(C'\fR boolean is true then only high quality icons
are returned, which means only icons of high resolution with an alpha
channel.  The default (false) is to return any icon we can, even if it is of
substandard quality.
.PP
注:
.IP "\(bu" 4
Unlike most other inspection \s-1API\s0 calls, the guest's disks must be mounted up
before you call this, since it needs to read information from the guest
filesystem during the call.
.IP "\(bu" 4
\&\fBSecurity:\fR The icon data comes from the untrusted guest, and should be
treated with caution.  \s-1PNG\s0 files have been known to contain exploits.
Ensure that libpng (or other relevant libraries) are fully up to date before
trying to process or display the icon.
.IP "\(bu" 4
The \s-1PNG\s0 image returned can be any size.  It might not be square.  Libguestfs
tries to return the largest, highest quality icon available.  The
application must scale the icon to the required size.
.IP "\(bu" 4
Extracting icons from Windows guests requires the external \f(CW\*(C`wrestool\*(C'\fR
program from the \f(CW\*(C`icoutils\*(C'\fR package, and several programs (\f(CW\*(C`bmptopnm\*(C'\fR,
\&\f(CW\*(C`pnmtopng\*(C'\fR, \f(CW\*(C`pamcut\*(C'\fR)  from the \f(CW\*(C`netpbm\*(C'\fR package.  These must be
installed separately.
.IP "\(bu" 4
Operating system icons are usually trademarks.  Seek legal advice before
using trademarks in applications.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
(1.11.12 において追加)
.SS "guestfs_inspect_get_icon_va"
.IX Subsection "guestfs_inspect_get_icon_va"
.Vb 5
\& char *
\& guestfs_inspect_get_icon_va (guestfs_h *g,
\&                              const char *root,
\&                              size_t *size_r,
\&                              va_list args);
.Ve
.PP
これは \*(L"guestfs_inspect_get_icon\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_inspect_get_icon_argv"
.IX Subsection "guestfs_inspect_get_icon_argv"
.Vb 5
\& char *
\& guestfs_inspect_get_icon_argv (guestfs_h *g,
\&                                const char *root,
\&                                size_t *size_r,
\&                                const struct guestfs_inspect_get_icon_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_inspect_get_icon\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_inspect_get_major_version"
.IX Subsection "guestfs_inspect_get_major_version"
.Vb 3
\& int
\& guestfs_inspect_get_major_version (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
This returns the major version number of the inspected operating system.
.PP
Windows uses a consistent versioning scheme which is \fInot\fR reflected in the
popular public names used by the operating system.  Notably the operating
system known as \*(L"Windows 7\*(R" is really version 6.1 (ie. major = 6, minor =
1).  You can find out the real versions corresponding to releases of Windows
by consulting Wikipedia or \s-1MSDN.\s0
.PP
If the version could not be determined, then \f(CW0\fR is returned.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_minor_version"
.IX Subsection "guestfs_inspect_get_minor_version"
.Vb 3
\& int
\& guestfs_inspect_get_minor_version (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
検査するオペレーティングシステムのマイナーバージョン番号を返します。
.PP
If the version could not be determined, then \f(CW0\fR is returned.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を読んでください。  \f(CW\*(C`guestfs_inspect_get_major_version\*(C'\fR
参照。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_mountpoints"
.IX Subsection "guestfs_inspect_get_mountpoints"
.Vb 3
\& char **
\& guestfs_inspect_get_mountpoints (guestfs_h *g,
\&                                  const char *root);
.Ve
.PP
This returns a hash of where we think the filesystems associated with this
operating system should be mounted.  Callers should note that this is at
best an educated guess made by reading configuration files such as
\&\fI/etc/fstab\fR.  \fIIn particular note\fR that this may return filesystems which
are non-existent or not mountable and callers should be prepared to handle
or ignore failures if they try to mount them.
.PP
Each element in the returned hashtable has a key which is the path of the
mountpoint (eg. \fI/boot\fR) and a value which is the filesystem that would be
mounted there (eg. \fI/dev/sda1\fR).
.PP
Non-mounted devices such as swap devices are \fInot\fR returned in this list.
.PP
For operating systems like Windows which still use drive letters, this call
will only return an entry for the first drive \*(L"mounted on\*(R" \fI/\fR.  For
information about the mapping of drive letters to partitions, see
\&\f(CW\*(C`guestfs_inspect_get_drive_mappings\*(C'\fR.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を読んでください。  \f(CW\*(C`guestfs_inspect_get_filesystems\*(C'\fR
参照。
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_package_format"
.IX Subsection "guestfs_inspect_get_package_format"
.Vb 3
\& char *
\& guestfs_inspect_get_package_format (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
This function and \f(CW\*(C`guestfs_inspect_get_package_management\*(C'\fR return the
package format and package management tool used by the inspected operating
system.  For example for Fedora these functions would return \f(CW\*(C`rpm\*(C'\fR (package
format), and \f(CW\*(C`yum\*(C'\fR or \f(CW\*(C`dnf\*(C'\fR (package management).
.PP
This returns the string \f(CW\*(C`unknown\*(C'\fR if we could not determine the package
format \fIor\fR if the operating system does not have a real packaging system
(eg. Windows).
.PP
Possible strings include: \f(CW\*(C`rpm\*(C'\fR, \f(CW\*(C`deb\*(C'\fR, \f(CW\*(C`ebuild\*(C'\fR, \f(CW\*(C`pisi\*(C'\fR, \f(CW\*(C`pacman\*(C'\fR,
\&\f(CW\*(C`pkgsrc\*(C'\fR, \f(CW\*(C`apk\*(C'\fR, \f(CW\*(C`xbps\*(C'\fR.  Future versions of libguestfs may return other
strings.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.7.5 において追加)
.SS "guestfs_inspect_get_package_management"
.IX Subsection "guestfs_inspect_get_package_management"
.Vb 3
\& char *
\& guestfs_inspect_get_package_management (guestfs_h *g,
\&                                         const char *root);
.Ve
.PP
\&\f(CW\*(C`guestfs_inspect_get_package_format\*(C'\fR and this function return the package
format and package management tool used by the inspected operating system.
For example for Fedora these functions would return \f(CW\*(C`rpm\*(C'\fR (package format),
and \f(CW\*(C`yum\*(C'\fR or \f(CW\*(C`dnf\*(C'\fR (package management).
.PP
This returns the string \f(CW\*(C`unknown\*(C'\fR if we could not determine the package
management tool \fIor\fR if the operating system does not have a real packaging
system (eg. Windows).
.PP
Possible strings include: \f(CW\*(C`yum\*(C'\fR, \f(CW\*(C`dnf\*(C'\fR, \f(CW\*(C`up2date\*(C'\fR, \f(CW\*(C`apt\*(C'\fR (for all Debian
derivatives), \f(CW\*(C`portage\*(C'\fR, \f(CW\*(C`pisi\*(C'\fR, \f(CW\*(C`pacman\*(C'\fR, \f(CW\*(C`urpmi\*(C'\fR, \f(CW\*(C`zypper\*(C'\fR, \f(CW\*(C`apk\*(C'\fR,
\&\f(CW\*(C`xbps\*(C'\fR.  Future versions of libguestfs may return other strings.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.7.5 において追加)
.SS "guestfs_inspect_get_product_name"
.IX Subsection "guestfs_inspect_get_product_name"
.Vb 3
\& char *
\& guestfs_inspect_get_product_name (guestfs_h *g,
\&                                   const char *root);
.Ve
.PP
This returns the product name of the inspected operating system.  The
product name is generally some freeform string which can be displayed to the
user, but should not be parsed by programs.
.PP
If the product name could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR is
returned.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_product_variant"
.IX Subsection "guestfs_inspect_get_product_variant"
.Vb 3
\& char *
\& guestfs_inspect_get_product_variant (guestfs_h *g,
\&                                      const char *root);
.Ve
.PP
This returns the product variant of the inspected operating system.
.PP
For Windows guests, this returns the contents of the Registry key
\&\f(CW\*(C`HKLM\eSoftware\eMicrosoft\eWindows NT\eCurrentVersion\*(C'\fR \f(CW\*(C`InstallationType\*(C'\fR
which is usually a string such as \f(CW\*(C`Client\*(C'\fR or \f(CW\*(C`Server\*(C'\fR (other values are
possible).  This can be used to distinguish consumer and enterprise versions
of Windows that have the same version number (for example, Windows 7 and
Windows 2008 Server are both version 6.1, but the former is \f(CW\*(C`Client\*(C'\fR and
the latter is \f(CW\*(C`Server\*(C'\fR).
.PP
For enterprise Linux guests, in future we intend this to return the product
variant such as \f(CW\*(C`Desktop\*(C'\fR, \f(CW\*(C`Server\*(C'\fR and so on.  But this is not
implemented at present.
.PP
If the product variant could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR
is returned.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。 \f(CW\*(C`guestfs_inspect_get_product_name\*(C'\fR,
\&\f(CW\*(C`guestfs_inspect_get_major_version\*(C'\fR も合わせて参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.9.13 において追加)
.SS "guestfs_inspect_get_roots"
.IX Subsection "guestfs_inspect_get_roots"
.Vb 2
\& char **
\& guestfs_inspect_get_roots (guestfs_h *g);
.Ve
.PP
This function is a convenient way to get the list of root devices, as
returned from a previous call to \f(CW\*(C`guestfs_inspect_os\*(C'\fR, but without redoing
the whole inspection process.
.PP
This returns an empty list if either no root devices were found or the
caller has not called \f(CW\*(C`guestfs_inspect_os\*(C'\fR.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.7.3 において追加)
.SS "guestfs_inspect_get_type"
.IX Subsection "guestfs_inspect_get_type"
.Vb 3
\& char *
\& guestfs_inspect_get_type (guestfs_h *g,
\&                           const char *root);
.Ve
.PP
This returns the type of the inspected operating system.  Currently defined
types are:
.ie n .IP """linux""" 4
.el .IP "``linux''" 4
.IX Item "linux"
すべての Linux ベースのオペレーティングシステム.
.ie n .IP """windows""" 4
.el .IP "``windows''" 4
.IX Item "windows"
すべての Microsoft Windows オペレーティングシステム.
.ie n .IP """freebsd""" 4
.el .IP "``freebsd''" 4
.IX Item "freebsd"
FreeBSD.
.ie n .IP """netbsd""" 4
.el .IP "``netbsd''" 4
.IX Item "netbsd"
NetBSD.
.ie n .IP """openbsd""" 4
.el .IP "``openbsd''" 4
.IX Item "openbsd"
OpenBSD.
.ie n .IP """hurd""" 4
.el .IP "``hurd''" 4
.IX Item "hurd"
GNU/Hurd.
.ie n .IP """dos""" 4
.el .IP "``dos''" 4
.IX Item "dos"
MS-DOS, FreeDOS およびその他.
.ie n .IP """minix""" 4
.el .IP "``minix''" 4
.IX Item "minix"
\&\s-1MINIX.\s0
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
オペレーティング・システムの種類がわかりませんでした。
.PP
libguestfs の将来のバージョンは、ここに他の文字列を返す可能性があります。呼び出し元はあらゆる文字列の処理に備えなければいけません。
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.3 において追加)
.SS "guestfs_inspect_get_windows_current_control_set"
.IX Subsection "guestfs_inspect_get_windows_current_control_set"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_current_control_set (guestfs_h *g,
\&                                                  const char *root);
.Ve
.PP
これは検査した仮想マシンの Windows CurrentControlSet を返します。 CurrentControlSet は
\&\f(CW\*(C`ControlSet001\*(C'\fR のようなレジストリキーの名前です。
.PP
この呼び出しは、仮想マシンが Windows であり、レジストリが検査により確認できることを仮定しています。該当しない場合、エラーが返されます。
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.9.17 において追加)
.SS "guestfs_inspect_get_windows_software_hive"
.IX Subsection "guestfs_inspect_get_windows_software_hive"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_software_hive (guestfs_h *g,
\&                                            const char *root);
.Ve
.PP
This returns the path to the hive (binary Windows Registry file)
corresponding to HKLM\eSOFTWARE.
.PP
This call assumes that the guest is Windows and that the guest has a
software hive file with the right name.  If this is not the case then an
error is returned.  This call does not check that the hive is a valid
Windows Registry hive.
.PP
You can use \f(CW\*(C`guestfs_hivex_open\*(C'\fR to read or write to the hive.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.35.26)
.SS "guestfs_inspect_get_windows_system_hive"
.IX Subsection "guestfs_inspect_get_windows_system_hive"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_system_hive (guestfs_h *g,
\&                                          const char *root);
.Ve
.PP
This returns the path to the hive (binary Windows Registry file)
corresponding to HKLM\eSYSTEM.
.PP
This call assumes that the guest is Windows and that the guest has a system
hive file with the right name.  If this is not the case then an error is
returned.  This call does not check that the hive is a valid Windows
Registry hive.
.PP
You can use \f(CW\*(C`guestfs_hivex_open\*(C'\fR to read or write to the hive.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.35.26)
.SS "guestfs_inspect_get_windows_systemroot"
.IX Subsection "guestfs_inspect_get_windows_systemroot"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_systemroot (guestfs_h *g,
\&                                         const char *root);
.Ve
.PP
This returns the Windows systemroot of the inspected guest.  The systemroot
is a directory path such as \fI/WINDOWS\fR.
.PP
This call assumes that the guest is Windows and that the systemroot could be
determined by inspection.  If this is not the case then an error is
returned.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.25 において追加)
.SS "guestfs_inspect_is_live"
.IX Subsection "guestfs_inspect_is_live"
.Vb 3
\& int
\& guestfs_inspect_is_live (guestfs_h *g,
\&                          const char *root);
.Ve
.PP
If \f(CW\*(C`guestfs_inspect_get_format\*(C'\fR returns \f(CW\*(C`installer\*(C'\fR (this is an install
disk), then this returns true if a live image was detected on the disk.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.9.4 において追加)
.SS "guestfs_inspect_is_multipart"
.IX Subsection "guestfs_inspect_is_multipart"
.Vb 3
\& int
\& guestfs_inspect_is_multipart (guestfs_h *g,
\&                               const char *root);
.Ve
.PP
If \f(CW\*(C`guestfs_inspect_get_format\*(C'\fR returns \f(CW\*(C`installer\*(C'\fR (this is an install
disk), then this returns true if the disk is part of a set.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.9.4 において追加)
.SS "guestfs_inspect_is_netinst"
.IX Subsection "guestfs_inspect_is_netinst"
.Vb 3
\& int
\& guestfs_inspect_is_netinst (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
If \f(CW\*(C`guestfs_inspect_get_format\*(C'\fR returns \f(CW\*(C`installer\*(C'\fR (this is an install
disk), then this returns true if the disk is a network installer, ie. not a
self-contained install \s-1CD\s0 but one which is likely to require network access
to complete the install.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.9.4 において追加)
.SS "guestfs_inspect_list_applications"
.IX Subsection "guestfs_inspect_list_applications"
.Vb 3
\& struct guestfs_application_list *
\& guestfs_inspect_list_applications (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_inspect_list_applications2\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
Return the list of applications installed in the operating system.
.PP
\&\fINote:\fR This call works differently from other parts of the inspection
\&\s-1API.\s0  You have to call \f(CW\*(C`guestfs_inspect_os\*(C'\fR, then
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, then mount up the disks, before calling
this.  Listing applications is a significantly more difficult operation
which requires access to the full filesystem.  Also note that unlike the
other \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR calls which are just returning data cached in
the libguestfs handle, this call actually reads parts of the mounted
filesystems during the call.
.PP
This returns an empty list if the inspection code was not able to determine
the list of applications.
.PP
The application structure contains the following fields:
.ie n .IP """app_name""" 4
.el .IP "\f(CWapp_name\fR" 4
.IX Item "app_name"
アプリケーションの名前。 Red Hat 派生および Debian 派生の Linux 仮想マシンの場合、パッケージ名になります。
.ie n .IP """app_display_name""" 4
.el .IP "\f(CWapp_display_name\fR" 4
.IX Item "app_display_name"
The display name of the application, sometimes localized to the install
language of the guest operating system.
.Sp
If unavailable this is returned as an empty string \f(CW""\fR.  Callers needing
to display something can use \f(CW\*(C`app_name\*(C'\fR instead.
.ie n .IP """app_epoch""" 4
.el .IP "\f(CWapp_epoch\fR" 4
.IX Item "app_epoch"
For package managers which use epochs, this contains the epoch of the
package (an integer).  If unavailable, this is returned as \f(CW0\fR.
.ie n .IP """app_version""" 4
.el .IP "\f(CWapp_version\fR" 4
.IX Item "app_version"
The version string of the application or package.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app_release""" 4
.el .IP "\f(CWapp_release\fR" 4
.IX Item "app_release"
The release string of the application or package, for package managers that
use this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_install_path""" 4
.el .IP "\f(CWapp_install_path\fR" 4
.IX Item "app_install_path"
The installation path of the application (on operating systems such as
Windows which use installation paths).  This path is in the format used by
the guest operating system, it is not a libguestfs path.
.Sp
If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_trans_path""" 4
.el .IP "\f(CWapp_trans_path\fR" 4
.IX Item "app_trans_path"
The install path translated into a libguestfs path.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app_publisher""" 4
.el .IP "\f(CWapp_publisher\fR" 4
.IX Item "app_publisher"
The name of the publisher of the application, for package managers that use
this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_url""" 4
.el .IP "\f(CWapp_url\fR" 4
.IX Item "app_url"
The \s-1URL\s0 (eg. upstream \s-1URL\s0) of the application.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app_source_package""" 4
.el .IP "\f(CWapp_source_package\fR" 4
.IX Item "app_source_package"
For packaging systems which support this, the name of the source package.
If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_summary""" 4
.el .IP "\f(CWapp_summary\fR" 4
.IX Item "app_summary"
A short (usually one line) description of the application or package.  If
unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_description""" 4
.el .IP "\f(CWapp_description\fR" 4
.IX Item "app_description"
A longer description of the application or package.  If unavailable this is
returned as an empty string \f(CW""\fR.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
This function returns a \f(CW\*(C`struct guestfs_application_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_application_list\*(C'\fI
after use\fR.
.PP
(1.7.8 において追加)
.SS "guestfs_inspect_list_applications2"
.IX Subsection "guestfs_inspect_list_applications2"
.Vb 3
\& struct guestfs_application2_list *
\& guestfs_inspect_list_applications2 (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
Return the list of applications installed in the operating system.
.PP
\&\fINote:\fR This call works differently from other parts of the inspection
\&\s-1API.\s0  You have to call \f(CW\*(C`guestfs_inspect_os\*(C'\fR, then
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, then mount up the disks, before calling
this.  Listing applications is a significantly more difficult operation
which requires access to the full filesystem.  Also note that unlike the
other \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR calls which are just returning data cached in
the libguestfs handle, this call actually reads parts of the mounted
filesystems during the call.
.PP
This returns an empty list if the inspection code was not able to determine
the list of applications.
.PP
The application structure contains the following fields:
.ie n .IP """app2_name""" 4
.el .IP "\f(CWapp2_name\fR" 4
.IX Item "app2_name"
アプリケーションの名前。 Red Hat 派生および Debian 派生の Linux 仮想マシンの場合、パッケージ名になります。
.ie n .IP """app2_display_name""" 4
.el .IP "\f(CWapp2_display_name\fR" 4
.IX Item "app2_display_name"
The display name of the application, sometimes localized to the install
language of the guest operating system.
.Sp
If unavailable this is returned as an empty string \f(CW""\fR.  Callers needing
to display something can use \f(CW\*(C`app2_name\*(C'\fR instead.
.ie n .IP """app2_epoch""" 4
.el .IP "\f(CWapp2_epoch\fR" 4
.IX Item "app2_epoch"
For package managers which use epochs, this contains the epoch of the
package (an integer).  If unavailable, this is returned as \f(CW0\fR.
.ie n .IP """app2_version""" 4
.el .IP "\f(CWapp2_version\fR" 4
.IX Item "app2_version"
The version string of the application or package.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app2_release""" 4
.el .IP "\f(CWapp2_release\fR" 4
.IX Item "app2_release"
The release string of the application or package, for package managers that
use this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app2_arch""" 4
.el .IP "\f(CWapp2_arch\fR" 4
.IX Item "app2_arch"
The architecture string of the application or package, for package managers
that use this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app2_install_path""" 4
.el .IP "\f(CWapp2_install_path\fR" 4
.IX Item "app2_install_path"
The installation path of the application (on operating systems such as
Windows which use installation paths).  This path is in the format used by
the guest operating system, it is not a libguestfs path.
.Sp
If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app2_trans_path""" 4
.el .IP "\f(CWapp2_trans_path\fR" 4
.IX Item "app2_trans_path"
The install path translated into a libguestfs path.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app2_publisher""" 4
.el .IP "\f(CWapp2_publisher\fR" 4
.IX Item "app2_publisher"
The name of the publisher of the application, for package managers that use
this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app2_url""" 4
.el .IP "\f(CWapp2_url\fR" 4
.IX Item "app2_url"
The \s-1URL\s0 (eg. upstream \s-1URL\s0) of the application.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app2_source_package""" 4
.el .IP "\f(CWapp2_source_package\fR" 4
.IX Item "app2_source_package"
For packaging systems which support this, the name of the source package.
If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app2_summary""" 4
.el .IP "\f(CWapp2_summary\fR" 4
.IX Item "app2_summary"
A short (usually one line) description of the application or package.  If
unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app2_description""" 4
.el .IP "\f(CWapp2_description\fR" 4
.IX Item "app2_description"
A longer description of the application or package.  If unavailable this is
returned as an empty string \f(CW""\fR.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
This function returns a \f(CW\*(C`struct guestfs_application2_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call
\&\f(CI\*(C`guestfs_free_application2_list\*(C'\fI after use\fR.
.PP
(1.19.56 において追加)
.SS "guestfs_inspect_os"
.IX Subsection "guestfs_inspect_os"
.Vb 2
\& char **
\& guestfs_inspect_os (guestfs_h *g);
.Ve
.PP
This function uses other libguestfs functions and certain heuristics to
inspect the disk(s) (usually disks belonging to a virtual machine), looking
for operating systems.
.PP
The list returned is empty if no operating systems were found.
.PP
If one operating system was found, then this returns a list with a single
element, which is the name of the root filesystem of this operating system.
It is also possible for this function to return a list containing more than
one element, indicating a dual-boot or multi-boot virtual machine, with each
element being the root filesystem of one of the operating systems.
.PP
You can pass the root string(s) returned to other \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR
functions in order to query further information about each operating system,
such as the name and version.
.PP
This function uses other libguestfs features such as \f(CW\*(C`guestfs_mount_ro\*(C'\fR and
\&\f(CW\*(C`guestfs_umount_all\*(C'\fR in order to mount and unmount filesystems and look at
the contents.  This should be called with no disks currently mounted.  The
function may also use Augeas, so any existing Augeas handle will be closed.
.PP
This function cannot decrypt encrypted disks.  The caller must do that first
(supplying the necessary keys) if the disk is encrypted.
.PP
詳細は \*(L"\s-1INSPECTION\*(R"\s0 を参照してください。
.PP
\&\f(CW\*(C`guestfs_list_filesystems\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.5.3 において追加)
.SS "guestfs_is_blockdev"
.IX Subsection "guestfs_is_blockdev"
.Vb 3
\& int
\& guestfs_is_blockdev (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_is_blockdev_opts\*(R" with no
optional arguments.
.PP
(1.5.10 において追加)
.SS "guestfs_is_blockdev_opts"
.IX Subsection "guestfs_is_blockdev_opts"
.Vb 4
\& int
\& guestfs_is_blockdev_opts (guestfs_h *g,
\&                           const char *path,
\&                           ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_IS_BLOCKDEV_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
与えられた\f(CW\*(C`パス\*(C'\fR名を持つブロックデバイスがあれば、\f(CW\*(C`真\*(C'\fRを返します。
.PP
If the optional flag \f(CW\*(C`followsymlinks\*(C'\fR is true, then a symlink (or chain of
symlinks) that ends with a block device also causes the function to return
true.
.PP
This call only looks at files within the guest filesystem.  Libguestfs
partitions and block devices (eg. \fI/dev/sda\fR) cannot be used as the \f(CW\*(C`path\*(C'\fR
parameter of this call.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.10 において追加)
.SS "guestfs_is_blockdev_opts_va"
.IX Subsection "guestfs_is_blockdev_opts_va"
.Vb 4
\& int
\& guestfs_is_blockdev_opts_va (guestfs_h *g,
\&                              const char *path,
\&                              va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_is_blockdev_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_blockdev_opts_argv"
.IX Subsection "guestfs_is_blockdev_opts_argv"
.Vb 4
\& int
\& guestfs_is_blockdev_opts_argv (guestfs_h *g,
\&                                const char *path,
\&                                const struct guestfs_is_blockdev_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_is_blockdev_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_busy"
.IX Subsection "guestfs_is_busy"
.Vb 2
\& int
\& guestfs_is_busy (guestfs_h *g);
.Ve
.PP
This always returns false.  This function is deprecated with no
replacement.  Do not use this function.
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.2 において追加)
.SS "guestfs_is_chardev"
.IX Subsection "guestfs_is_chardev"
.Vb 3
\& int
\& guestfs_is_chardev (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_is_chardev_opts\*(R" with no optional
arguments.
.PP
(1.5.10 において追加)
.SS "guestfs_is_chardev_opts"
.IX Subsection "guestfs_is_chardev_opts"
.Vb 4
\& int
\& guestfs_is_chardev_opts (guestfs_h *g,
\&                          const char *path,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_IS_CHARDEV_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a character device with the
given \f(CW\*(C`path\*(C'\fR name.
.PP
If the optional flag \f(CW\*(C`followsymlinks\*(C'\fR is true, then a symlink (or chain of
symlinks) that ends with a chardev also causes the function to return true.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.10 において追加)
.SS "guestfs_is_chardev_opts_va"
.IX Subsection "guestfs_is_chardev_opts_va"
.Vb 4
\& int
\& guestfs_is_chardev_opts_va (guestfs_h *g,
\&                             const char *path,
\&                             va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_is_chardev_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_chardev_opts_argv"
.IX Subsection "guestfs_is_chardev_opts_argv"
.Vb 4
\& int
\& guestfs_is_chardev_opts_argv (guestfs_h *g,
\&                               const char *path,
\&                               const struct guestfs_is_chardev_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_is_chardev_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_config"
.IX Subsection "guestfs_is_config"
.Vb 2
\& int
\& guestfs_is_config (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is being configured (in the \f(CW\*(C`CONFIG\*(C'\fR
state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.2 において追加)
.SS "guestfs_is_dir"
.IX Subsection "guestfs_is_dir"
.Vb 3
\& int
\& guestfs_is_dir (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_is_dir_opts\*(R" with no optional
arguments.
.PP
(0.8 において追加)
.SS "guestfs_is_dir_opts"
.IX Subsection "guestfs_is_dir_opts"
.Vb 4
\& int
\& guestfs_is_dir_opts (guestfs_h *g,
\&                      const char *path,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_IS_DIR_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a directory with the given
\&\f(CW\*(C`path\*(C'\fR name.  Note that it returns false for other objects like files.
.PP
If the optional flag \f(CW\*(C`followsymlinks\*(C'\fR is true, then a symlink (or chain of
symlinks) that ends with a directory also causes the function to return
true.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(0.8 において追加)
.SS "guestfs_is_dir_opts_va"
.IX Subsection "guestfs_is_dir_opts_va"
.Vb 4
\& int
\& guestfs_is_dir_opts_va (guestfs_h *g,
\&                         const char *path,
\&                         va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_is_dir_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_dir_opts_argv"
.IX Subsection "guestfs_is_dir_opts_argv"
.Vb 4
\& int
\& guestfs_is_dir_opts_argv (guestfs_h *g,
\&                           const char *path,
\&                           const struct guestfs_is_dir_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_is_dir_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_fifo"
.IX Subsection "guestfs_is_fifo"
.Vb 3
\& int
\& guestfs_is_fifo (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_is_fifo_opts\*(R" with no optional
arguments.
.PP
(1.5.10 において追加)
.SS "guestfs_is_fifo_opts"
.IX Subsection "guestfs_is_fifo_opts"
.Vb 4
\& int
\& guestfs_is_fifo_opts (guestfs_h *g,
\&                       const char *path,
\&                       ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_IS_FIFO_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a \s-1FIFO\s0 (named pipe)  with the
given \f(CW\*(C`path\*(C'\fR name.
.PP
If the optional flag \f(CW\*(C`followsymlinks\*(C'\fR is true, then a symlink (or chain of
symlinks) that ends with a \s-1FIFO\s0 also causes the function to return true.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.10 において追加)
.SS "guestfs_is_fifo_opts_va"
.IX Subsection "guestfs_is_fifo_opts_va"
.Vb 4
\& int
\& guestfs_is_fifo_opts_va (guestfs_h *g,
\&                          const char *path,
\&                          va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_is_fifo_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_fifo_opts_argv"
.IX Subsection "guestfs_is_fifo_opts_argv"
.Vb 4
\& int
\& guestfs_is_fifo_opts_argv (guestfs_h *g,
\&                            const char *path,
\&                            const struct guestfs_is_fifo_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_is_fifo_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_file"
.IX Subsection "guestfs_is_file"
.Vb 3
\& int
\& guestfs_is_file (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_is_file_opts\*(R" with no optional
arguments.
.PP
(0.8 において追加)
.SS "guestfs_is_file_opts"
.IX Subsection "guestfs_is_file_opts"
.Vb 4
\& int
\& guestfs_is_file_opts (guestfs_h *g,
\&                       const char *path,
\&                       ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a regular file with the given
\&\f(CW\*(C`path\*(C'\fR name.  Note that it returns false for other objects like
directories.
.PP
If the optional flag \f(CW\*(C`followsymlinks\*(C'\fR is true, then a symlink (or chain of
symlinks) that ends with a file also causes the function to return true.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(0.8 において追加)
.SS "guestfs_is_file_opts_va"
.IX Subsection "guestfs_is_file_opts_va"
.Vb 4
\& int
\& guestfs_is_file_opts_va (guestfs_h *g,
\&                          const char *path,
\&                          va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_is_file_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_file_opts_argv"
.IX Subsection "guestfs_is_file_opts_argv"
.Vb 4
\& int
\& guestfs_is_file_opts_argv (guestfs_h *g,
\&                            const char *path,
\&                            const struct guestfs_is_file_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_is_file_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_launching"
.IX Subsection "guestfs_is_launching"
.Vb 2
\& int
\& guestfs_is_launching (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is launching the subprocess (in the
\&\f(CW\*(C`LAUNCHING\*(C'\fR state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.2 において追加)
.SS "guestfs_is_lv"
.IX Subsection "guestfs_is_lv"
.Vb 3
\& int
\& guestfs_is_lv (guestfs_h *g,
\&                const char *mountable);
.Ve
.PP
This command tests whether \f(CW\*(C`mountable\*(C'\fR is a logical volume, and returns
true iff this is the case.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.3 において追加)
.SS "guestfs_is_ready"
.IX Subsection "guestfs_is_ready"
.Vb 2
\& int
\& guestfs_is_ready (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is ready to accept commands (in the
\&\f(CW\*(C`READY\*(C'\fR state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.0.2 において追加)
.SS "guestfs_is_socket"
.IX Subsection "guestfs_is_socket"
.Vb 3
\& int
\& guestfs_is_socket (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_is_socket_opts\*(R" with no optional
arguments.
.PP
(1.5.10 において追加)
.SS "guestfs_is_socket_opts"
.IX Subsection "guestfs_is_socket_opts"
.Vb 4
\& int
\& guestfs_is_socket_opts (guestfs_h *g,
\&                         const char *path,
\&                         ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_IS_SOCKET_OPTS_FOLLOWSYMLINKS, int followsymlinks,
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a Unix domain socket with the
given \f(CW\*(C`path\*(C'\fR name.
.PP
If the optional flag \f(CW\*(C`followsymlinks\*(C'\fR is true, then a symlink (or chain of
symlinks) that ends with a socket also causes the function to return true.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.10 において追加)
.SS "guestfs_is_socket_opts_va"
.IX Subsection "guestfs_is_socket_opts_va"
.Vb 4
\& int
\& guestfs_is_socket_opts_va (guestfs_h *g,
\&                            const char *path,
\&                            va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_is_socket_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_socket_opts_argv"
.IX Subsection "guestfs_is_socket_opts_argv"
.Vb 4
\& int
\& guestfs_is_socket_opts_argv (guestfs_h *g,
\&                              const char *path,
\&                              const struct guestfs_is_socket_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_is_socket_opts\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_is_symlink"
.IX Subsection "guestfs_is_symlink"
.Vb 3
\& int
\& guestfs_is_symlink (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a symbolic link with the given
\&\f(CW\*(C`path\*(C'\fR name.
.PP
\&\f(CW\*(C`guestfs_stat\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.5.10 において追加)
.SS "guestfs_is_whole_device"
.IX Subsection "guestfs_is_whole_device"
.Vb 3
\& int
\& guestfs_is_whole_device (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if \f(CW\*(C`device\*(C'\fR refers to a whole block
device. That is, not a partition or a logical device.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.21.9 において追加)
.SS "guestfs_is_zero"
.IX Subsection "guestfs_is_zero"
.Vb 3
\& int
\& guestfs_is_zero (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This returns true iff the file exists and the file is empty or it contains
all zero bytes.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.11.8 において追加)
.SS "guestfs_is_zero_device"
.IX Subsection "guestfs_is_zero_device"
.Vb 3
\& int
\& guestfs_is_zero_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
This returns true iff the device exists and contains all zero bytes.
.PP
Note that for large devices this can take a long time to run.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.11.8 において追加)
.SS "guestfs_isoinfo"
.IX Subsection "guestfs_isoinfo"
.Vb 3
\& struct guestfs_isoinfo *
\& guestfs_isoinfo (guestfs_h *g,
\&                  const char *isofile);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_isoinfo_device\*(C'\fR except that it works for an
\&\s-1ISO\s0 file located inside some other mounted filesystem.  Note that in the
common case where you have added an \s-1ISO\s0 file as a libguestfs device, you
would \fInot\fR call this.  Instead you would call \f(CW\*(C`guestfs_isoinfo_device\*(C'\fR.
.PP
This function returns a \f(CW\*(C`struct guestfs_isoinfo *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_isoinfo\*(C'\fI after use\fR.
.PP
(1.17.19 において追加)
.SS "guestfs_isoinfo_device"
.IX Subsection "guestfs_isoinfo_device"
.Vb 3
\& struct guestfs_isoinfo *
\& guestfs_isoinfo_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR is an \s-1ISO\s0 device.  This returns a struct of information read from
the primary volume descriptor (the \s-1ISO\s0 equivalent of the superblock) of the
device.
.PP
Usually it is more efficient to use the \fIisoinfo\fR\|(1) command with the \fI\-d\fR
option on the host to analyze \s-1ISO\s0 files, instead of going through
libguestfs.
.PP
プライマリーボリューム記述子の項目に関する詳細は、
http://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor を参照してください。
.PP
This function returns a \f(CW\*(C`struct guestfs_isoinfo *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_isoinfo\*(C'\fI after use\fR.
.PP
(1.17.19 において追加)
.SS "guestfs_journal_close"
.IX Subsection "guestfs_journal_close"
.Vb 2
\& int
\& guestfs_journal_close (guestfs_h *g);
.Ve
.PP
Close the journal handle.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_journal_get"
.IX Subsection "guestfs_journal_get"
.Vb 2
\& struct guestfs_xattr_list *
\& guestfs_journal_get (guestfs_h *g);
.Ve
.PP
Read the current journal entry.  This returns all the fields in the journal
as a set of \f(CW\*(C`(attrname, attrval)\*(C'\fR pairs.  The \f(CW\*(C`attrname\*(C'\fR is the field name
(a string).
.PP
The \f(CW\*(C`attrval\*(C'\fR is the field value (a binary blob, often but not always a
string).  Please note that \f(CW\*(C`attrval\*(C'\fR is a byte array, \fInot\fR a
\&\e0\-terminated C string.
.PP
The length of data may be truncated to the data threshold (see:
\&\f(CW\*(C`guestfs_journal_set_data_threshold\*(C'\fR,
\&\f(CW\*(C`guestfs_journal_get_data_threshold\*(C'\fR).
.PP
If you set the data threshold to unlimited (\f(CW0\fR) then this call can read a
journal entry of any size, ie. it is not limited by the libguestfs protocol.
.PP
この関数は \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR を返します。もしくは、エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_journal_get_data_threshold"
.IX Subsection "guestfs_journal_get_data_threshold"
.Vb 2
\& int64_t
\& guestfs_journal_get_data_threshold (guestfs_h *g);
.Ve
.PP
Get the current data threshold for reading journal entries.  This is a hint
to the journal that it may truncate data fields to this size when reading
them (note also that it may not truncate them).  If this returns \f(CW0\fR, then
the threshold is unlimited.
.PP
See also \f(CW\*(C`guestfs_journal_set_data_threshold\*(C'\fR.
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_journal_get_realtime_usec"
.IX Subsection "guestfs_journal_get_realtime_usec"
.Vb 2
\& int64_t
\& guestfs_journal_get_realtime_usec (guestfs_h *g);
.Ve
.PP
Get the realtime (wallclock) timestamp of the current journal entry.
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.27.18)
.SS "guestfs_journal_next"
.IX Subsection "guestfs_journal_next"
.Vb 2
\& int
\& guestfs_journal_next (guestfs_h *g);
.Ve
.PP
Move to the next journal entry.  You have to call this at least once after
opening the handle before you are able to read data.
.PP
The returned boolean tells you if there are any more journal records to
read.  \f(CW\*(C`true\*(C'\fR means you can read the next record (eg. using
\&\f(CW\*(C`guestfs_journal_get\*(C'\fR), and \f(CW\*(C`false\*(C'\fR means you have reached the end of the
journal.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_journal_open"
.IX Subsection "guestfs_journal_open"
.Vb 3
\& int
\& guestfs_journal_open (guestfs_h *g,
\&                       const char *directory);
.Ve
.PP
Open the systemd journal located in \fIdirectory\fR.  Any previously opened
journal handle is closed.
.PP
The contents of the journal can be read using \f(CW\*(C`guestfs_journal_next\*(C'\fR and
\&\f(CW\*(C`guestfs_journal_get\*(C'\fR.
.PP
After you have finished using the journal, you should close the handle by
calling \f(CW\*(C`guestfs_journal_close\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_journal_set_data_threshold"
.IX Subsection "guestfs_journal_set_data_threshold"
.Vb 3
\& int
\& guestfs_journal_set_data_threshold (guestfs_h *g,
\&                                     int64_t threshold);
.Ve
.PP
Set the data threshold for reading journal entries.  This is a hint to the
journal that it may truncate data fields to this size when reading them
(note also that it may not truncate them).  If you set this to \f(CW0\fR, then
the threshold is unlimited.
.PP
See also \f(CW\*(C`guestfs_journal_get_data_threshold\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_journal_skip"
.IX Subsection "guestfs_journal_skip"
.Vb 3
\& int64_t
\& guestfs_journal_skip (guestfs_h *g,
\&                       int64_t skip);
.Ve
.PP
Skip forwards (\f(CW\*(C`skip ≥ 0\*(C'\fR) or backwards (\f(CW\*(C`skip < 0\*(C'\fR) in the
journal.
.PP
The number of entries actually skipped is returned (note \f(CW\*(C`rskip ≥ 0\*(C'\fR).  If this is not the same as the absolute value of the skip parameter
(\f(CW\*(C`|skip|\*(C'\fR) you passed in then it means you have reached the end or the
start of the journal.
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`journal\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.23.11)
.SS "guestfs_kill_subprocess"
.IX Subsection "guestfs_kill_subprocess"
.Vb 2
\& int
\& guestfs_kill_subprocess (guestfs_h *g);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_shutdown\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This kills the hypervisor.
.PP
これを呼び出してはいけません。代わりに \f(CW\*(C`guestfs_shutdown\*(C'\fR を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_launch"
.IX Subsection "guestfs_launch"
.Vb 2
\& int
\& guestfs_launch (guestfs_h *g);
.Ve
.PP
You should call this after configuring the handle (eg. adding drives) but
before performing any actions.
.PP
Do not call \f(CW\*(C`guestfs_launch\*(C'\fR twice on the same handle.  Although it will
not give an error (for historical reasons), the precise behaviour when you
do this is not well defined.  Handles are very cheap to create, so create a
new one for each launch.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(0.3 において追加)
.SS "guestfs_lchown"
.IX Subsection "guestfs_lchown"
.Vb 5
\& int
\& guestfs_lchown (guestfs_h *g,
\&                 int owner,
\&                 int group,
\&                 const char *path);
.Ve
.PP
Change the file owner to \f(CW\*(C`owner\*(C'\fR and group to \f(CW\*(C`group\*(C'\fR.  This is like
\&\f(CW\*(C`guestfs_chown\*(C'\fR but if \f(CW\*(C`path\*(C'\fR is a symlink then the link itself is
changed, not the target.
.PP
Only numeric uid and gid are supported.  If you want to use names, you will
need to locate and parse the password file yourself (Augeas support makes
this relatively easy).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.77 において追加)
.SS "guestfs_ldmtool_create_all"
.IX Subsection "guestfs_ldmtool_create_all"
.Vb 2
\& int
\& guestfs_ldmtool_create_all (guestfs_h *g);
.Ve
.PP
This function scans all block devices looking for Windows dynamic disk
volumes and partitions, and creates devices for any that were found.
.PP
Call \f(CW\*(C`guestfs_list_ldm_volumes\*(C'\fR and \f(CW\*(C`guestfs_list_ldm_partitions\*(C'\fR to
return all devices.
.PP
Note that you \fBdon't\fR normally need to call this explicitly, since it is
done automatically at \f(CW\*(C`guestfs_launch\*(C'\fR time.  However you might want to
call this function if you have hotplugged disks or have just created a
Windows dynamic disk.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_diskgroup_disks"
.IX Subsection "guestfs_ldmtool_diskgroup_disks"
.Vb 3
\& char **
\& guestfs_ldmtool_diskgroup_disks (guestfs_h *g,
\&                                  const char *diskgroup);
.Ve
.PP
Return the disks in a Windows dynamic disk group.  The \f(CW\*(C`diskgroup\*(C'\fR
parameter should be the \s-1GUID\s0 of a disk group, one element from the list
returned by \f(CW\*(C`guestfs_ldmtool_scan\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_diskgroup_name"
.IX Subsection "guestfs_ldmtool_diskgroup_name"
.Vb 3
\& char *
\& guestfs_ldmtool_diskgroup_name (guestfs_h *g,
\&                                 const char *diskgroup);
.Ve
.PP
Return the name of a Windows dynamic disk group.  The \f(CW\*(C`diskgroup\*(C'\fR parameter
should be the \s-1GUID\s0 of a disk group, one element from the list returned by
\&\f(CW\*(C`guestfs_ldmtool_scan\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_diskgroup_volumes"
.IX Subsection "guestfs_ldmtool_diskgroup_volumes"
.Vb 3
\& char **
\& guestfs_ldmtool_diskgroup_volumes (guestfs_h *g,
\&                                    const char *diskgroup);
.Ve
.PP
Return the volumes in a Windows dynamic disk group.  The \f(CW\*(C`diskgroup\*(C'\fR
parameter should be the \s-1GUID\s0 of a disk group, one element from the list
returned by \f(CW\*(C`guestfs_ldmtool_scan\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_remove_all"
.IX Subsection "guestfs_ldmtool_remove_all"
.Vb 2
\& int
\& guestfs_ldmtool_remove_all (guestfs_h *g);
.Ve
.PP
This is essentially the opposite of \f(CW\*(C`guestfs_ldmtool_create_all\*(C'\fR.  It
removes the device mapper mappings for all Windows dynamic disk volumes
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_scan"
.IX Subsection "guestfs_ldmtool_scan"
.Vb 2
\& char **
\& guestfs_ldmtool_scan (guestfs_h *g);
.Ve
.PP
This function scans for Windows dynamic disks.  It returns a list of
identifiers (GUIDs) for all disk groups that were found.  These identifiers
can be passed to other \f(CW\*(C`guestfs_ldmtool_*\*(C'\fR functions.
.PP
This function scans all block devices.  To scan a subset of block devices,
call \f(CW\*(C`guestfs_ldmtool_scan_devices\*(C'\fR instead.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_scan_devices"
.IX Subsection "guestfs_ldmtool_scan_devices"
.Vb 3
\& char **
\& guestfs_ldmtool_scan_devices (guestfs_h *g,
\&                               char *const *devices);
.Ve
.PP
This function scans for Windows dynamic disks.  It returns a list of
identifiers (GUIDs) for all disk groups that were found.  These identifiers
can be passed to other \f(CW\*(C`guestfs_ldmtool_*\*(C'\fR functions.
.PP
The parameter \f(CW\*(C`devices\*(C'\fR is a list of block devices which are scanned.  If
this list is empty, all block devices are scanned.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_volume_hint"
.IX Subsection "guestfs_ldmtool_volume_hint"
.Vb 4
\& char *
\& guestfs_ldmtool_volume_hint (guestfs_h *g,
\&                              const char *diskgroup,
\&                              const char *volume);
.Ve
.PP
Return the hint field of the volume named \f(CW\*(C`volume\*(C'\fR in the disk group with
\&\s-1GUID\s0 \f(CW\*(C`diskgroup\*(C'\fR.  This may not be defined, in which case the empty string
is returned.  The hint field is often, though not always, the name of a
Windows drive, eg. \f(CW\*(C`E:\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_volume_partitions"
.IX Subsection "guestfs_ldmtool_volume_partitions"
.Vb 4
\& char **
\& guestfs_ldmtool_volume_partitions (guestfs_h *g,
\&                                    const char *diskgroup,
\&                                    const char *volume);
.Ve
.PP
Return the list of partitions in the volume named \f(CW\*(C`volume\*(C'\fR in the disk
group with \s-1GUID\s0 \f(CW\*(C`diskgroup\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_ldmtool_volume_type"
.IX Subsection "guestfs_ldmtool_volume_type"
.Vb 4
\& char *
\& guestfs_ldmtool_volume_type (guestfs_h *g,
\&                              const char *diskgroup,
\&                              const char *volume);
.Ve
.PP
Return the type of the volume named \f(CW\*(C`volume\*(C'\fR in the disk group with \s-1GUID\s0
\&\f(CW\*(C`diskgroup\*(C'\fR.
.PP
Possible volume types that can be returned here include: \f(CW\*(C`simple\*(C'\fR,
\&\f(CW\*(C`spanned\*(C'\fR, \f(CW\*(C`striped\*(C'\fR, \f(CW\*(C`mirrored\*(C'\fR, \f(CW\*(C`raid5\*(C'\fR.  Other types may also be
returned.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_lgetxattr"
.IX Subsection "guestfs_lgetxattr"
.Vb 5
\& char *
\& guestfs_lgetxattr (guestfs_h *g,
\&                    const char *path,
\&                    const char *name,
\&                    size_t *size_r);
.Ve
.PP
Get a single extended attribute from file \f(CW\*(C`path\*(C'\fR named \f(CW\*(C`name\*(C'\fR.  If \f(CW\*(C`path\*(C'\fR
is a symlink, then this call returns an extended attribute from the symlink.
.PP
Normally it is better to get all extended attributes from a file in one go
by calling \f(CW\*(C`guestfs_getxattrs\*(C'\fR.  However some Linux filesystem
implementations are buggy and do not provide a way to list out attributes.
For these filesystems (notably ntfs\-3g)  you have to know the names of the
extended attributes you want in advance and call this function.
.PP
Extended attribute values are blobs of binary data.  If there is no extended
attribute named \f(CW\*(C`name\*(C'\fR, this returns an error.
.PP
関連項目: \f(CW\*(C`guestfs_lgetxattrs\*(C'\fR, \f(CW\*(C`guestfs_getxattr\*(C'\fR, \fIattr\fR\|(5)
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.7.24 において追加)
.SS "guestfs_lgetxattrs"
.IX Subsection "guestfs_lgetxattrs"
.Vb 3
\& struct guestfs_xattr_list *
\& guestfs_lgetxattrs (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_getxattrs\*(C'\fR, but if \f(CW\*(C`path\*(C'\fR is a symbolic link,
then it returns the extended attributes of the link itself.
.PP
この関数は \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR を返します。もしくは、エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.59 において追加)
.SS "guestfs_list_9p"
.IX Subsection "guestfs_list_9p"
.Vb 2
\& char **
\& guestfs_list_9p (guestfs_h *g);
.Ve
.PP
List all 9p filesystems attached to the guest.  A list of mount tags is
returned.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.11.12 において追加)
.SS "guestfs_list_devices"
.IX Subsection "guestfs_list_devices"
.Vb 2
\& char **
\& guestfs_list_devices (guestfs_h *g);
.Ve
.PP
すべてのブロックデバイスを一覧表示します。
.PP
The full block device names are returned, eg. \fI/dev/sda\fR.
.PP
\&\f(CW\*(C`guestfs_list_filesystems\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.4 において追加)
.SS "guestfs_list_disk_labels"
.IX Subsection "guestfs_list_disk_labels"
.Vb 2
\& char **
\& guestfs_list_disk_labels (guestfs_h *g);
.Ve
.PP
If you add drives using the optional \f(CW\*(C`label\*(C'\fR parameter of
\&\f(CW\*(C`guestfs_add_drive_opts\*(C'\fR, you can use this call to map between disk labels,
and raw block device and partition names (like \fI/dev/sda\fR and
\&\fI/dev/sda1\fR).
.PP
This returns a hashtable, where keys are the disk labels (\fIwithout\fR the
\&\fI/dev/disk/guestfs\fR prefix), and the values are the full raw block device
and partition names (eg. \fI/dev/sda\fR and \fI/dev/sda1\fR).
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(1.19.49 において追加)
.SS "guestfs_list_dm_devices"
.IX Subsection "guestfs_list_dm_devices"
.Vb 2
\& char **
\& guestfs_list_dm_devices (guestfs_h *g);
.Ve
.PP
すべてのデバイスマッパーデバイスを一覧表示します。
.PP
The returned list contains \fI/dev/mapper/*\fR devices, eg. ones created by a
previous call to \f(CW\*(C`guestfs_luks_open\*(C'\fR.
.PP
Device mapper devices which correspond to logical volumes are \fInot\fR
returned in this list.  Call \f(CW\*(C`guestfs_lvs\*(C'\fR if you want to list logical
volumes.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.11.15 において追加)
.SS "guestfs_list_filesystems"
.IX Subsection "guestfs_list_filesystems"
.Vb 2
\& char **
\& guestfs_list_filesystems (guestfs_h *g);
.Ve
.PP
This inspection command looks for filesystems on partitions, block devices
and logical volumes, returning a list of \f(CW\*(C`mountables\*(C'\fR containing
filesystems and their type.
.PP
The return value is a hash, where the keys are the devices containing
filesystems, and the values are the filesystem types.  For example:
.PP
.Vb 4
\& "/dev/sda1" => "ntfs"
\& "/dev/sda2" => "ext2"
\& "/dev/vg_guest/lv_root" => "ext4"
\& "/dev/vg_guest/lv_swap" => "swap"
.Ve
.PP
The key is not necessarily a block device. It may also be an opaque
\&'mountable' string which can be passed to \f(CW\*(C`guestfs_mount\*(C'\fR.
.PP
The value can have the special value \*(L"unknown\*(R", meaning the content of the
device is undetermined or empty.  \*(L"swap\*(R" means a Linux swap partition.
.PP
This command runs other libguestfs commands, which might include
\&\f(CW\*(C`guestfs_mount\*(C'\fR and \f(CW\*(C`guestfs_umount\*(C'\fR, and therefore you should use this
soon after launch and only when nothing is mounted.
.PP
Not all of the filesystems returned will be mountable.  In particular, swap
partitions are returned in the list.  Also this command does not check that
each filesystem found is valid and mountable, and some filesystems might be
mountable but require special options.  Filesystems may not all belong to a
single logical operating system (use \f(CW\*(C`guestfs_inspect_os\*(C'\fR to look for
OSes).
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(1.5.15 において追加)
.SS "guestfs_list_ldm_partitions"
.IX Subsection "guestfs_list_ldm_partitions"
.Vb 2
\& char **
\& guestfs_list_ldm_partitions (guestfs_h *g);
.Ve
.PP
This function returns all Windows dynamic disk partitions that were found at
launch time.  It returns a list of device names.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_list_ldm_volumes"
.IX Subsection "guestfs_list_ldm_volumes"
.Vb 2
\& char **
\& guestfs_list_ldm_volumes (guestfs_h *g);
.Ve
.PP
This function returns all Windows dynamic disk volumes that were found at
launch time.  It returns a list of device names.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`ldm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.20.0 において追加)
.SS "guestfs_list_md_devices"
.IX Subsection "guestfs_list_md_devices"
.Vb 2
\& char **
\& guestfs_list_md_devices (guestfs_h *g);
.Ve
.PP
すべての Linux md デバイスを一覧表示します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.15.4 において追加)
.SS "guestfs_list_partitions"
.IX Subsection "guestfs_list_partitions"
.Vb 2
\& char **
\& guestfs_list_partitions (guestfs_h *g);
.Ve
.PP
List all the partitions detected on all block devices.
.PP
The full partition device names are returned, eg. \fI/dev/sda1\fR
.PP
This does not return logical volumes.  For that you will need to call
\&\f(CW\*(C`guestfs_lvs\*(C'\fR.
.PP
\&\f(CW\*(C`guestfs_list_filesystems\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.4 において追加)
.SS "guestfs_ll"
.IX Subsection "guestfs_ll"
.Vb 3
\& char *
\& guestfs_ll (guestfs_h *g,
\&             const char *directory);
.Ve
.PP
List the files in \fIdirectory\fR (relative to the root directory, there is no
cwd) in the format of 'ls \-la'.
.PP
このコマンドはほとんどの対話式セッションのために有用です。出力文字列を構文解析しようという意図は\fIありません\fR。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(0.4 において追加)
.SS "guestfs_llz"
.IX Subsection "guestfs_llz"
.Vb 3
\& char *
\& guestfs_llz (guestfs_h *g,
\&              const char *directory);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_lgetxattrs\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
List the files in \fIdirectory\fR in the format of 'ls \-laZ'.
.PP
このコマンドはほとんどの対話式セッションのために有用です。出力文字列を構文解析しようという意図は\fIありません\fR。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.17.6 において追加)
.SS "guestfs_ln"
.IX Subsection "guestfs_ln"
.Vb 4
\& int
\& guestfs_ln (guestfs_h *g,
\&             const char *target,
\&             const char *linkname);
.Ve
.PP
このコマンドは \f(CW\*(C`ln\*(C'\fR コマンドを使用してハードリンクを作成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_ln_f"
.IX Subsection "guestfs_ln_f"
.Vb 4
\& int
\& guestfs_ln_f (guestfs_h *g,
\&               const char *target,
\&               const char *linkname);
.Ve
.PP
This command creates a hard link using the \f(CW\*(C`ln \-f\*(C'\fR command.  The \fI\-f\fR
option removes the link (\f(CW\*(C`linkname\*(C'\fR) if it exists already.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_ln_s"
.IX Subsection "guestfs_ln_s"
.Vb 4
\& int
\& guestfs_ln_s (guestfs_h *g,
\&               const char *target,
\&               const char *linkname);
.Ve
.PP
このコマンドは \f(CW\*(C`ln \-s\*(C'\fR コマンドを使用してシンボリックリンクを作成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_ln_sf"
.IX Subsection "guestfs_ln_sf"
.Vb 4
\& int
\& guestfs_ln_sf (guestfs_h *g,
\&                const char *target,
\&                const char *linkname);
.Ve
.PP
This command creates a symbolic link using the \f(CW\*(C`ln \-sf\*(C'\fR command, The \fI\-f\fR
option removes the link (\f(CW\*(C`linkname\*(C'\fR) if it exists already.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_lremovexattr"
.IX Subsection "guestfs_lremovexattr"
.Vb 4
\& int
\& guestfs_lremovexattr (guestfs_h *g,
\&                       const char *xattr,
\&                       const char *path);
.Ve
.PP
これは \f(CW\*(C`guestfs_removexattr\*(C'\fR と同じです。ただし、\f(CW\*(C`path\*(C'\fR がシンボリックリンクならば、リンク自身の拡張属性を削除します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.59 において追加)
.SS "guestfs_ls"
.IX Subsection "guestfs_ls"
.Vb 3
\& char **
\& guestfs_ls (guestfs_h *g,
\&             const char *directory);
.Ve
.PP
List the files in \fIdirectory\fR (relative to the root directory, there is no
cwd).  The '.' and '..' entries are not returned, but hidden files are
shown.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.4 において追加)
.SS "guestfs_ls0"
.IX Subsection "guestfs_ls0"
.Vb 4
\& int
\& guestfs_ls0 (guestfs_h *g,
\&              const char *dir,
\&              const char *filenames);
.Ve
.PP
This specialized command is used to get a listing of the filenames in the
directory \f(CW\*(C`dir\*(C'\fR.  The list of filenames is written to the local file
\&\fIfilenames\fR (on the host).
.PP
出力ファイルにおいて、ファイル名が \f(CW\*(C`\e0\*(C'\fR 文字により区切られます。
.PP
\&\f(CW\*(C`.\*(C'\fR および \f(CW\*(C`..\*(C'\fR は返されません。ファイル名は並べ替えられません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.32 において追加)
.SS "guestfs_lsetxattr"
.IX Subsection "guestfs_lsetxattr"
.Vb 6
\& int
\& guestfs_lsetxattr (guestfs_h *g,
\&                    const char *xattr,
\&                    const char *val,
\&                    int vallen,
\&                    const char *path);
.Ve
.PP
これは \f(CW\*(C`guestfs_setxattr\*(C'\fR と同じですが、\f(CW\*(C`path\*(C'\fR がシンボリックリンクです。そして、リンク自身の拡張属性を設定します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.59 において追加)
.SS "guestfs_lstat"
.IX Subsection "guestfs_lstat"
.Vb 3
\& struct guestfs_stat *
\& guestfs_lstat (guestfs_h *g,
\&                const char *path);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_lstatns\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
与えられた \f(CW\*(C`path\*(C'\fR のファイル情報を返します。
.PP
これは、\f(CW\*(C`path\*(C'\fR がシンボリックリンクであることを除き、\f(CW\*(C`guestfs_stat\*(C'\fR
と同じです。そしてリンクは、参照しているファイルではなく、stat\-ed です。
.PP
This is the same as the \fIlstat\fR\|(2) system call.
.PP
この関数は \f(CW\*(C`struct guestfs_stat *\*(C'\fR を返します。エラーがあれば \s-1NULL\s0 です。 \fI呼び出し元は使用後に
\&\f(CI\*(C`guestfs_free_stat\*(C'\fI を呼び出す必要があります\fR。
.PP
(Added in 1.9.2)
.SS "guestfs_lstatlist"
.IX Subsection "guestfs_lstatlist"
.Vb 4
\& struct guestfs_stat_list *
\& guestfs_lstatlist (guestfs_h *g,
\&                    const char *path,
\&                    char *const *names);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_lstatnslist\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This call allows you to perform the \f(CW\*(C`guestfs_lstat\*(C'\fR operation on multiple
files, where all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list
of files from this directory.
.PP
On return you get a list of stat structs, with a one-to-one correspondence
to the \f(CW\*(C`names\*(C'\fR list.  If any name did not exist or could not be lstat'd,
then the \f(CW\*(C`st_ino\*(C'\fR field of that structure is set to \f(CW\*(C`\-1\*(C'\fR.
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also \f(CW\*(C`guestfs_lxattrlist\*(C'\fR
for a similarly efficient call for getting extended attributes.
.PP
This function returns a \f(CW\*(C`struct guestfs_stat_list *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_stat_list\*(C'\fI after use\fR.
.PP
(1.0.77 において追加)
.SS "guestfs_lstatns"
.IX Subsection "guestfs_lstatns"
.Vb 3
\& struct guestfs_statns *
\& guestfs_lstatns (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
与えられた \f(CW\*(C`path\*(C'\fR のファイル情報を返します。
.PP
This is the same as \f(CW\*(C`guestfs_statns\*(C'\fR except that if \f(CW\*(C`path\*(C'\fR is a symbolic
link, then the link is stat-ed, not the file it refers to.
.PP
This is the same as the \fIlstat\fR\|(2) system call.
.PP
This function returns a \f(CW\*(C`struct guestfs_statns *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_statns\*(C'\fI after use\fR.
.PP
(Added in 1.27.53)
.SS "guestfs_lstatnslist"
.IX Subsection "guestfs_lstatnslist"
.Vb 4
\& struct guestfs_statns_list *
\& guestfs_lstatnslist (guestfs_h *g,
\&                      const char *path,
\&                      char *const *names);
.Ve
.PP
This call allows you to perform the \f(CW\*(C`guestfs_lstatns\*(C'\fR operation on multiple
files, where all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list
of files from this directory.
.PP
On return you get a list of stat structs, with a one-to-one correspondence
to the \f(CW\*(C`names\*(C'\fR list.  If any name did not exist or could not be lstat'd,
then the \f(CW\*(C`st_ino\*(C'\fR field of that structure is set to \f(CW\*(C`\-1\*(C'\fR.
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also \f(CW\*(C`guestfs_lxattrlist\*(C'\fR
for a similarly efficient call for getting extended attributes.
.PP
This function returns a \f(CW\*(C`struct guestfs_statns_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_statns_list\*(C'\fI after
use\fR.
.PP
(Added in 1.27.53)
.SS "guestfs_luks_add_key"
.IX Subsection "guestfs_luks_add_key"
.Vb 6
\& int
\& guestfs_luks_add_key (guestfs_h *g,
\&                       const char *device,
\&                       const char *key,
\&                       const char *newkey,
\&                       int keyslot);
.Ve
.PP
This command adds a new key on \s-1LUKS\s0 device \f(CW\*(C`device\*(C'\fR.  \f(CW\*(C`key\*(C'\fR is any
existing key, and is used to access the device.  \f(CW\*(C`newkey\*(C'\fR is the new key to
add.  \f(CW\*(C`keyslot\*(C'\fR is the key slot that will be replaced.
.PP
Note that if \f(CW\*(C`keyslot\*(C'\fR already contains a key, then this command will
fail.  You have to use \f(CW\*(C`guestfs_luks_kill_slot\*(C'\fR first to remove that key.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS AND PASSPHRASES\*(R"\s0 for more
information.
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.2 において追加)
.SS "guestfs_luks_close"
.IX Subsection "guestfs_luks_close"
.Vb 3
\& int
\& guestfs_luks_close (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
This closes a \s-1LUKS\s0 device that was created earlier by \f(CW\*(C`guestfs_luks_open\*(C'\fR
or \f(CW\*(C`guestfs_luks_open_ro\*(C'\fR.  The \f(CW\*(C`device\*(C'\fR parameter must be the name of the
\&\s-1LUKS\s0 mapping device (ie. \fI/dev/mapper/mapname\fR) and \fInot\fR the name of the
underlying block device.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.1 において追加)
.SS "guestfs_luks_format"
.IX Subsection "guestfs_luks_format"
.Vb 5
\& int
\& guestfs_luks_format (guestfs_h *g,
\&                      const char *device,
\&                      const char *key,
\&                      int keyslot);
.Ve
.PP
This command erases existing data on \f(CW\*(C`device\*(C'\fR and formats the device as a
\&\s-1LUKS\s0 encrypted device.  \f(CW\*(C`key\*(C'\fR is the initial key, which is added to key
slot \f(CW\*(C`slot\*(C'\fR.  (\s-1LUKS\s0 supports 8 key slots, numbered 0\-7).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS AND PASSPHRASES\*(R"\s0 for more
information.
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.2 において追加)
.SS "guestfs_luks_format_cipher"
.IX Subsection "guestfs_luks_format_cipher"
.Vb 6
\& int
\& guestfs_luks_format_cipher (guestfs_h *g,
\&                             const char *device,
\&                             const char *key,
\&                             int keyslot,
\&                             const char *cipher);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_luks_format\*(C'\fR but it also allows you to
set the \f(CW\*(C`cipher\*(C'\fR used.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS AND PASSPHRASES\*(R"\s0 for more
information.
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.2 において追加)
.SS "guestfs_luks_kill_slot"
.IX Subsection "guestfs_luks_kill_slot"
.Vb 5
\& int
\& guestfs_luks_kill_slot (guestfs_h *g,
\&                         const char *device,
\&                         const char *key,
\&                         int keyslot);
.Ve
.PP
This command deletes the key in key slot \f(CW\*(C`keyslot\*(C'\fR from the encrypted \s-1LUKS\s0
device \f(CW\*(C`device\*(C'\fR.  \f(CW\*(C`key\*(C'\fR must be one of the \fIother\fR keys.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS AND PASSPHRASES\*(R"\s0 for more
information.
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.2 において追加)
.SS "guestfs_luks_open"
.IX Subsection "guestfs_luks_open"
.Vb 5
\& int
\& guestfs_luks_open (guestfs_h *g,
\&                    const char *device,
\&                    const char *key,
\&                    const char *mapname);
.Ve
.PP
This command opens a block device which has been encrypted according to the
Linux Unified Key Setup (\s-1LUKS\s0) standard.
.PP
\&\f(CW\*(C`device\*(C'\fR is the encrypted block device or partition.
.PP
The caller must supply one of the keys associated with the \s-1LUKS\s0 block
device, in the \f(CW\*(C`key\*(C'\fR parameter.
.PP
This creates a new block device called \fI/dev/mapper/mapname\fR.  Reads and
writes to this block device are decrypted from and encrypted to the
underlying \f(CW\*(C`device\*(C'\fR respectively.
.PP
If this block device contains \s-1LVM\s0 volume groups, then calling
\&\f(CW\*(C`guestfs_vgscan\*(C'\fR followed by \f(CW\*(C`guestfs_vg_activate_all\*(C'\fR will make them
visible.
.PP
すべてのデバイスマッパーデバイスを一覧表示するには \f(CW\*(C`guestfs_list_dm_devices\*(C'\fR を使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS AND PASSPHRASES\*(R"\s0 for more
information.
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.1 において追加)
.SS "guestfs_luks_open_ro"
.IX Subsection "guestfs_luks_open_ro"
.Vb 5
\& int
\& guestfs_luks_open_ro (guestfs_h *g,
\&                       const char *device,
\&                       const char *key,
\&                       const char *mapname);
.Ve
.PP
これは、読み込み専用のマッピングが作成されることを除き、\f(CW\*(C`guestfs_luks_open\*(C'\fR と同じです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS AND PASSPHRASES\*(R"\s0 for more
information.
.PP
This function depends on the feature \f(CW\*(C`luks\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.1 において追加)
.SS "guestfs_lvcreate"
.IX Subsection "guestfs_lvcreate"
.Vb 5
\& int
\& guestfs_lvcreate (guestfs_h *g,
\&                   const char *logvol,
\&                   const char *volgroup,
\&                   int mbytes);
.Ve
.PP
This creates an \s-1LVM\s0 logical volume called \f(CW\*(C`logvol\*(C'\fR on the volume group
\&\f(CW\*(C`volgroup\*(C'\fR, with \f(CW\*(C`size\*(C'\fR megabytes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.8 において追加)
.SS "guestfs_lvcreate_free"
.IX Subsection "guestfs_lvcreate_free"
.Vb 5
\& int
\& guestfs_lvcreate_free (guestfs_h *g,
\&                        const char *logvol,
\&                        const char *volgroup,
\&                        int percent);
.Ve
.PP
Create an \s-1LVM\s0 logical volume called \fI/dev/volgroup/logvol\fR, using
approximately \f(CW\*(C`percent\*(C'\fR % of the free space remaining in the volume group.
Most usefully, when \f(CW\*(C`percent\*(C'\fR is \f(CW100\fR this will create the largest
possible \s-1LV.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.18 において追加)
.SS "guestfs_lvm_canonical_lv_name"
.IX Subsection "guestfs_lvm_canonical_lv_name"
.Vb 3
\& char *
\& guestfs_lvm_canonical_lv_name (guestfs_h *g,
\&                                const char *lvname);
.Ve
.PP
This converts alternative naming schemes for LVs that you might find to the
canonical name.  For example, \fI/dev/mapper/VG\-LV\fR is converted to
\&\fI/dev/VG/LV\fR.
.PP
This command returns an error if the \f(CW\*(C`lvname\*(C'\fR parameter does not refer to a
logical volume.
.PP
\&\f(CW\*(C`guestfs_is_lv\*(C'\fR, \f(CW\*(C`guestfs_canonical_device_name\*(C'\fR も参照してください。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.24 において追加)
.SS "guestfs_lvm_clear_filter"
.IX Subsection "guestfs_lvm_clear_filter"
.Vb 2
\& int
\& guestfs_lvm_clear_filter (guestfs_h *g);
.Ve
.PP
This undoes the effect of \f(CW\*(C`guestfs_lvm_set_filter\*(C'\fR.  \s-1LVM\s0 will be able to
see every block device.
.PP
This command also clears the \s-1LVM\s0 cache and performs a volume group scan.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.5.1 において追加)
.SS "guestfs_lvm_remove_all"
.IX Subsection "guestfs_lvm_remove_all"
.Vb 2
\& int
\& guestfs_lvm_remove_all (guestfs_h *g);
.Ve
.PP
This command removes all \s-1LVM\s0 logical volumes, volume groups and physical
volumes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.8 において追加)
.SS "guestfs_lvm_set_filter"
.IX Subsection "guestfs_lvm_set_filter"
.Vb 3
\& int
\& guestfs_lvm_set_filter (guestfs_h *g,
\&                         char *const *devices);
.Ve
.PP
This sets the \s-1LVM\s0 device filter so that \s-1LVM\s0 will only be able to \*(L"see\*(R" the
block devices in the list \f(CW\*(C`devices\*(C'\fR, and will ignore all other attached
block devices.
.PP
Where disk image(s) contain duplicate PVs or VGs, this command is useful to
get \s-1LVM\s0 to ignore the duplicates, otherwise \s-1LVM\s0 can get confused.  Note also
there are two types of duplication possible: either cloned PVs/VGs which
have identical UUIDs; or VGs that are not cloned but just happen to have the
same name.  In normal operation you cannot create this situation, but you
can do it outside \s-1LVM,\s0 eg.  by cloning disk images or by bit twiddling
inside the \s-1LVM\s0 metadata.
.PP
This command also clears the \s-1LVM\s0 cache and performs a volume group scan.
.PP
You can filter whole block devices or individual partitions.
.PP
You cannot use this if any \s-1VG\s0 is currently in use (eg.  contains a mounted
filesystem), even if you are not filtering out that \s-1VG.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.5.1 において追加)
.SS "guestfs_lvremove"
.IX Subsection "guestfs_lvremove"
.Vb 3
\& int
\& guestfs_lvremove (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Remove an \s-1LVM\s0 logical volume \f(CW\*(C`device\*(C'\fR, where \f(CW\*(C`device\*(C'\fR is the path to the
\&\s-1LV,\s0 such as \fI/dev/VG/LV\fR.
.PP
You can also remove all LVs in a volume group by specifying the \s-1VG\s0 name,
\&\fI/dev/VG\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.13 において追加)
.SS "guestfs_lvrename"
.IX Subsection "guestfs_lvrename"
.Vb 4
\& int
\& guestfs_lvrename (guestfs_h *g,
\&                   const char *logvol,
\&                   const char *newlogvol);
.Ve
.PP
Rename a logical volume \f(CW\*(C`logvol\*(C'\fR with the new name \f(CW\*(C`newlogvol\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.83 において追加)
.SS "guestfs_lvresize"
.IX Subsection "guestfs_lvresize"
.Vb 4
\& int
\& guestfs_lvresize (guestfs_h *g,
\&                   const char *device,
\&                   int mbytes);
.Ve
.PP
これは既存の \s-1LVM\s0 論理ボリュームを \f(CW\*(C`mbytes\*(C'\fR に容量変更（拡大または縮小）します。縮小するとき、縮小された部分にあるデータは失われます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.27 において追加)
.SS "guestfs_lvresize_free"
.IX Subsection "guestfs_lvresize_free"
.Vb 4
\& int
\& guestfs_lvresize_free (guestfs_h *g,
\&                        const char *lv,
\&                        int percent);
.Ve
.PP
This expands an existing logical volume \f(CW\*(C`lv\*(C'\fR so that it fills \f(CW\*(C`pc\*(C'\fR% of the
remaining free space in the volume group.  Commonly you would call this with
pc = 100 which expands the logical volume as much as possible, using all
remaining free space in the volume group.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.3.3 において追加)
.SS "guestfs_lvs"
.IX Subsection "guestfs_lvs"
.Vb 2
\& char **
\& guestfs_lvs (guestfs_h *g);
.Ve
.PP
List all the logical volumes detected.  This is the equivalent of the
\&\fIlvs\fR\|(8) command.
.PP
This returns a list of the logical volume device names
(eg. \fI/dev/VolGroup00/LogVol00\fR).
.PP
\&\f(CW\*(C`guestfs_lvs_full\*(C'\fR, \f(CW\*(C`guestfs_list_filesystems\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.4 において追加)
.SS "guestfs_lvs_full"
.IX Subsection "guestfs_lvs_full"
.Vb 2
\& struct guestfs_lvm_lv_list *
\& guestfs_lvs_full (guestfs_h *g);
.Ve
.PP
List all the logical volumes detected.  This is the equivalent of the
\&\fIlvs\fR\|(8) command.  The \*(L"full\*(R" version includes all fields.
.PP
This function returns a \f(CW\*(C`struct guestfs_lvm_lv_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_lvm_lv_list\*(C'\fI after
use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.4 において追加)
.SS "guestfs_lvuuid"
.IX Subsection "guestfs_lvuuid"
.Vb 3
\& char *
\& guestfs_lvuuid (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
このコマンドは \s-1LVM\s0 論理ボリューム \f(CW\*(C`device\*(C'\fR の \s-1UUID\s0 を返します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.87 において追加)
.SS "guestfs_lxattrlist"
.IX Subsection "guestfs_lxattrlist"
.Vb 4
\& struct guestfs_xattr_list *
\& guestfs_lxattrlist (guestfs_h *g,
\&                     const char *path,
\&                     char *const *names);
.Ve
.PP
This call allows you to get the extended attributes of multiple files, where
all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list of files from
this directory.
.PP
On return you get a flat list of xattr structs which must be interpreted
sequentially.  The first xattr struct always has a zero-length \f(CW\*(C`attrname\*(C'\fR.
\&\f(CW\*(C`attrval\*(C'\fR in this struct is zero-length to indicate there was an error
doing \f(CW\*(C`lgetxattr\*(C'\fR for this file, \fIor\fR is a C string which is a decimal
number (the number of following attributes for this file, which could be
\&\f(CW"0"\fR).  Then after the first xattr struct are the zero or more attributes
for the first named file.  This repeats for the second and subsequent files.
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also \f(CW\*(C`guestfs_lstatlist\*(C'\fR for
a similarly efficient call for getting standard stats.
.PP
この関数は \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR を返します。もしくは、エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.77 において追加)
.SS "guestfs_max_disks"
.IX Subsection "guestfs_max_disks"
.Vb 2
\& int
\& guestfs_max_disks (guestfs_h *g);
.Ve
.PP
ハンドルに追加できるディスクの最大数を返します (例: \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR および同様の呼び出し)。
.PP
This function was added in libguestfs 1.19.7.  In previous versions of
libguestfs the limit was 25.
.PP
この話題に関する詳細は \*(L"\s-1MAXIMUM NUMBER OF DISKS\*(R"\s0 を参照してください。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.19.7 において追加)
.SS "guestfs_md_create"
.IX Subsection "guestfs_md_create"
.Vb 5
\& int
\& guestfs_md_create (guestfs_h *g,
\&                    const char *name,
\&                    char *const *devices,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_MD_CREATE_MISSINGBITMAP, int64_t missingbitmap,
\& GUESTFS_MD_CREATE_NRDEVICES, int nrdevices,
\& GUESTFS_MD_CREATE_SPARE, int spare,
\& GUESTFS_MD_CREATE_CHUNK, int64_t chunk,
\& GUESTFS_MD_CREATE_LEVEL, const char *level,
.Ve
.PP
Create a Linux md (\s-1RAID\s0) device named \f(CW\*(C`name\*(C'\fR on the devices in the list
\&\f(CW\*(C`devices\*(C'\fR.
.PP
オプションのパラメーターは次のとおりです:
.ie n .IP """missingbitmap""" 4
.el .IP "\f(CWmissingbitmap\fR" 4
.IX Item "missingbitmap"
A bitmap of missing devices.  If a bit is set it means that a missing device
is added to the array.  The least significant bit corresponds to the first
device in the array.
.Sp
例として:
.Sp
\&\f(CW\*(C`devices = ["/dev/sda"]\*(C'\fR かつ \f(CW\*(C`missingbitmap = 0x1\*(C'\fR ならば、結果の配列は
\&\f(CW\*(C`[<missing>, "/dev/sda"]\*(C'\fR になります。
.Sp
\&\f(CW\*(C`devices = ["/dev/sda"]\*(C'\fR かつ \f(CW\*(C`missingbitmap = 0x2\*(C'\fR ならば、結果の配列は
\&\f(CW\*(C`["/dev/sda", <missing>]\*(C'\fR になります。
.Sp
この初期値は \f(CW0\fR です（デバイスがありません）。
.Sp
\&\f(CW\*(C`devices\*(C'\fR の長さ + \f(CW\*(C`missingbitmap\*(C'\fR に設定されたビット数は \f(CW\*(C`nrdevices\*(C'\fR + \f(CW\*(C`spare\*(C'\fR
と同じである必要があります。
.ie n .IP """nrdevices""" 4
.el .IP "\f(CWnrdevices\fR" 4
.IX Item "nrdevices"
稼動中の \s-1RAID\s0 デバイス数。
.Sp
設定されていないと、この初期値は \f(CW\*(C`devices\*(C'\fR の長さ + \f(CW\*(C`missingbitmap\*(C'\fR に設定されたビット数になります。
.ie n .IP """spare""" 4
.el .IP "\f(CWspare\fR" 4
.IX Item "spare"
予備デバイス数。
.Sp
設定されていなければ、デフォルトは \f(CW0\fR です。
.ie n .IP """chunk""" 4
.el .IP "\f(CWchunk\fR" 4
.IX Item "chunk"
バイト単位のチャンク容量です。
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
\&\s-1RAID\s0 レベルです。次のどれかです: \fIlinear\fR, \fIraid0\fR, \fI0\fR, \fIstripe\fR, \fIraid1\fR, \fI1\fR,
\&\fImirror\fR, \fIraid4\fR, \fI4\fR, \fIraid5\fR, \fI5\fR, \fIraid6\fR, \fI6\fR, \fIraid10\fR,
\&\fI10\fR。これらのいくつかは同じものを意味しています。将来さらなるレベルが追加される可能性があります。
.Sp
設定されていないと、この初期値は \f(CW\*(C`raid1\*(C'\fR です。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`mdadm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.15.6 において追加)
.SS "guestfs_md_create_va"
.IX Subsection "guestfs_md_create_va"
.Vb 5
\& int
\& guestfs_md_create_va (guestfs_h *g,
\&                       const char *name,
\&                       char *const *devices,
\&                       va_list args);
.Ve
.PP
これは \*(L"guestfs_md_create\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_md_create_argv"
.IX Subsection "guestfs_md_create_argv"
.Vb 5
\& int
\& guestfs_md_create_argv (guestfs_h *g,
\&                         const char *name,
\&                         char *const *devices,
\&                         const struct guestfs_md_create_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_md_create\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_md_detail"
.IX Subsection "guestfs_md_detail"
.Vb 3
\& char **
\& guestfs_md_detail (guestfs_h *g,
\&                    const char *md);
.Ve
.PP
This command exposes the output of 'mdadm \-DY <md>'.  The following
fields are usually present in the returned hash.  Other fields may also be
present.
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
\&\s-1MD\s0 デバイスの \s-1RAID\s0 レベル。
.ie n .IP """devices""" 4
.el .IP "\f(CWdevices\fR" 4
.IX Item "devices"
\&\s-1MD\s0 デバイスにあるデバイス数。
.ie n .IP """metadata""" 4
.el .IP "\f(CWmetadata\fR" 4
.IX Item "metadata"
使用されているメタ情報のバージョン。
.ie n .IP """uuid""" 4
.el .IP "\f(CWuuid\fR" 4
.IX Item "uuid"
\&\s-1MD\s0 デバイスの UUID。
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
\&\s-1MD\s0 デバイスの名前。
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`mdadm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.15.6 において追加)
.SS "guestfs_md_stat"
.IX Subsection "guestfs_md_stat"
.Vb 3
\& struct guestfs_mdstat_list *
\& guestfs_md_stat (guestfs_h *g,
\&                  const char *md);
.Ve
.PP
This call returns a list of the underlying devices which make up the single
software \s-1RAID\s0 array device \f(CW\*(C`md\*(C'\fR.
.PP
ソフトウェア \s-1RAID\s0 デバイスの一覧を取得するには、\f(CW\*(C`guestfs_list_md_devices\*(C'\fR を呼び出します。
.PP
Each structure returned corresponds to one device along with additional
status information:
.ie n .IP """mdstat_device""" 4
.el .IP "\f(CWmdstat_device\fR" 4
.IX Item "mdstat_device"
下にあるデバイスの名前です。
.ie n .IP """mdstat_index""" 4
.el .IP "\f(CWmdstat_index\fR" 4
.IX Item "mdstat_index"
配列の中にあるこのデバイスのインデックスです。
.ie n .IP """mdstat_flags""" 4
.el .IP "\f(CWmdstat_flags\fR" 4
.IX Item "mdstat_flags"
Flags associated with this device.  This is a string containing (in no
specific order) zero or more of the following flags:
.RS 4
.ie n .IP """W""" 4
.el .IP "\f(CWW\fR" 4
.IX Item "W"
ほとんど書き込み
.ie n .IP """F""" 4
.el .IP "\f(CWF\fR" 4
.IX Item "F"
デバイス故障
.ie n .IP """S""" 4
.el .IP "\f(CWS\fR" 4
.IX Item "S"
RAIDスペアデバイス
.ie n .IP """R""" 4
.el .IP "\f(CWR\fR" 4
.IX Item "R"
置換
.RE
.RS 4
.RE
.PP
This function returns a \f(CW\*(C`struct guestfs_mdstat_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_mdstat_list\*(C'\fI after
use\fR.
.PP
This function depends on the feature \f(CW\*(C`mdadm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.21 において追加)
.SS "guestfs_md_stop"
.IX Subsection "guestfs_md_stop"
.Vb 3
\& int
\& guestfs_md_stop (guestfs_h *g,
\&                  const char *md);
.Ve
.PP
このコマンドは \f(CW\*(C`md\*(C'\fR という名前の \s-1MD\s0 アレイを無効化します。デバイスが停止されますが、破壊またはゼロ書き込みされません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`mdadm\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.15.6 において追加)
.SS "guestfs_mkdir"
.IX Subsection "guestfs_mkdir"
.Vb 3
\& int
\& guestfs_mkdir (guestfs_h *g,
\&                const char *path);
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR という名前のディレクトリーを作成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_mkdir_mode"
.IX Subsection "guestfs_mkdir_mode"
.Vb 4
\& int
\& guestfs_mkdir_mode (guestfs_h *g,
\&                     const char *path,
\&                     int mode);
.Ve
.PP
このコマンドはディレクトリーを作成します、ディレクトリーの初期パーミッションを \f(CW\*(C`mode\*(C'\fR に設定します。
.PP
一般的な Linux ファイルシステムに対して、設定されている実際のモードが \f(CW\*(C`mode & ~umask & 01777\*(C'\fR とされます。Linux
固有のファイルシステム以外は他の方法でモードを解釈します。
.PP
\&\f(CW\*(C`guestfs_mkdir\*(C'\fR, \f(CW\*(C`guestfs_umask\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.77 において追加)
.SS "guestfs_mkdir_p"
.IX Subsection "guestfs_mkdir_p"
.Vb 3
\& int
\& guestfs_mkdir_p (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR という名前のディレクトリーを作成します、必要に応じて親ディレクトリーを作成します。これは \f(CW\*(C`mkdir \-p\*(C'\fR
シェルコマンドと似ています。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_mkdtemp"
.IX Subsection "guestfs_mkdtemp"
.Vb 3
\& char *
\& guestfs_mkdtemp (guestfs_h *g,
\&                  const char *tmpl);
.Ve
.PP
This command creates a temporary directory.  The \f(CW\*(C`tmpl\*(C'\fR parameter should be
a full pathname for the temporary directory name with the final six
characters being \*(L"\s-1XXXXXX\*(R".\s0
.PP
例: \*(L"/tmp/myprogXXXXXX\*(R" または \*(L"/Temp/myprogXXXXXX\*(R"、2 つめの例は Windows
ファイルシステムに適しています。
.PP
作成された一時ディレクトリーの名前を返します。
.PP
一時ディレクトリーがモード 0700 で作成され、root により所有されます。
.PP
The caller is responsible for deleting the temporary directory and its
contents after use.
.PP
関連項目: \fImkdtemp\fR\|(3)
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.54 において追加)
.SS "guestfs_mke2fs"
.IX Subsection "guestfs_mke2fs"
.Vb 4
\& int
\& guestfs_mke2fs (guestfs_h *g,
\&                 const char *device,
\&                 ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 10
\& GUESTFS_MKE2FS_BLOCKSCOUNT, int64_t blockscount,
\& GUESTFS_MKE2FS_BLOCKSIZE, int64_t blocksize,
\& GUESTFS_MKE2FS_FRAGSIZE, int64_t fragsize,
\& GUESTFS_MKE2FS_BLOCKSPERGROUP, int64_t blockspergroup,
\& GUESTFS_MKE2FS_NUMBEROFGROUPS, int64_t numberofgroups,
\& GUESTFS_MKE2FS_BYTESPERINODE, int64_t bytesperinode,
\& GUESTFS_MKE2FS_INODESIZE, int64_t inodesize,
\& GUESTFS_MKE2FS_JOURNALSIZE, int64_t journalsize,
\& GUESTFS_MKE2FS_NUMBEROFINODES, int64_t numberofinodes,
\& GUESTFS_MKE2FS_STRIDESIZE, int64_t stridesize,
\& GUESTFS_MKE2FS_STRIPEWIDTH, int64_t stripewidth,
\& GUESTFS_MKE2FS_MAXONLINERESIZE, int64_t maxonlineresize,
\& GUESTFS_MKE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
\& GUESTFS_MKE2FS_MMPUPDATEINTERVAL, int mmpupdateinterval,
\& GUESTFS_MKE2FS_JOURNALDEVICE, const char *journaldevice,
\& GUESTFS_MKE2FS_LABEL, const char *label,
\& GUESTFS_MKE2FS_LASTMOUNTEDDIR, const char *lastmounteddir,
\& GUESTFS_MKE2FS_CREATOROS, const char *creatoros,
\& GUESTFS_MKE2FS_FSTYPE, const char *fstype,
\& GUESTFS_MKE2FS_USAGETYPE, const char *usagetype,
\& GUESTFS_MKE2FS_UUID, const char *uuid,
\& GUESTFS_MKE2FS_FORCECREATE, int forcecreate,
\& GUESTFS_MKE2FS_WRITESBANDGROUPONLY, int writesbandgrouponly,
\& GUESTFS_MKE2FS_LAZYITABLEINIT, int lazyitableinit,
\& GUESTFS_MKE2FS_LAZYJOURNALINIT, int lazyjournalinit,
\& GUESTFS_MKE2FS_TESTFS, int testfs,
\& GUESTFS_MKE2FS_DISCARD, int discard,
\& GUESTFS_MKE2FS_QUOTATYPE, int quotatype,
\& GUESTFS_MKE2FS_EXTENT, int extent,
\& GUESTFS_MKE2FS_FILETYPE, int filetype,
\& GUESTFS_MKE2FS_FLEXBG, int flexbg,
\& GUESTFS_MKE2FS_HASJOURNAL, int hasjournal,
\& GUESTFS_MKE2FS_JOURNALDEV, int journaldev,
\& GUESTFS_MKE2FS_LARGEFILE, int largefile,
\& GUESTFS_MKE2FS_QUOTA, int quota,
\& GUESTFS_MKE2FS_RESIZEINODE, int resizeinode,
\& GUESTFS_MKE2FS_SPARSESUPER, int sparsesuper,
\& GUESTFS_MKE2FS_UNINITBG, int uninitbg,
.Ve
.PP
\&\f(CW\*(C`mke2fs\*(C'\fR is used to create an ext2, ext3, or ext4 filesystem on \f(CW\*(C`device\*(C'\fR.
.PP
The optional \f(CW\*(C`blockscount\*(C'\fR is the size of the filesystem in blocks.  If
omitted it defaults to the size of \f(CW\*(C`device\*(C'\fR.  Note if the filesystem is too
small to contain a journal, \f(CW\*(C`mke2fs\*(C'\fR will silently create an ext2
filesystem instead.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.44 において追加)
.SS "guestfs_mke2fs_va"
.IX Subsection "guestfs_mke2fs_va"
.Vb 4
\& int
\& guestfs_mke2fs_va (guestfs_h *g,
\&                    const char *device,
\&                    va_list args);
.Ve
.PP
これは \*(L"guestfs_mke2fs\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mke2fs_argv"
.IX Subsection "guestfs_mke2fs_argv"
.Vb 4
\& int
\& guestfs_mke2fs_argv (guestfs_h *g,
\&                      const char *device,
\&                      const struct guestfs_mke2fs_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_mke2fs\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mke2fs_J"
.IX Subsection "guestfs_mke2fs_J"
.Vb 6
\& int
\& guestfs_mke2fs_J (guestfs_h *g,
\&                   const char *fstype,
\&                   int blocksize,
\&                   const char *device,
\&                   const char *journal);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mke2fs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部ジャーナルを \f(CW\*(C`journal\*(C'\fR に持つ ext2/3/4 ファイルシステムを \f(CW\*(C`device\*(C'\fR に作成します。次のコマンドと同じです:
.PP
.Vb 1
\& mke2fs \-t fstype \-b blocksize \-J device=<journal> <device>
.Ve
.PP
\&\f(CW\*(C`guestfs_mke2journal\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.68 において追加)
.SS "guestfs_mke2fs_JL"
.IX Subsection "guestfs_mke2fs_JL"
.Vb 6
\& int
\& guestfs_mke2fs_JL (guestfs_h *g,
\&                    const char *fstype,
\&                    int blocksize,
\&                    const char *device,
\&                    const char *label);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mke2fs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部ジャーナルをジャーナルラベル \f(CW\*(C`label\*(C'\fR に持つ ext2/3/4 ファイルシステムを \f(CW\*(C`device\*(C'\fR に作成します。
.PP
\&\f(CW\*(C`guestfs_mke2journal_L\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.68 において追加)
.SS "guestfs_mke2fs_JU"
.IX Subsection "guestfs_mke2fs_JU"
.Vb 6
\& int
\& guestfs_mke2fs_JU (guestfs_h *g,
\&                    const char *fstype,
\&                    int blocksize,
\&                    const char *device,
\&                    const char *uuid);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mke2fs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部ジャーナルを \s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR のジャーナルに持つ ext2/3/4 ファイルシステムを \f(CW\*(C`device\*(C'\fR に作成します。
.PP
\&\f(CW\*(C`guestfs_mke2journal_U\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxfsuuid\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.68 において追加)
.SS "guestfs_mke2journal"
.IX Subsection "guestfs_mke2journal"
.Vb 4
\& int
\& guestfs_mke2journal (guestfs_h *g,
\&                      int blocksize,
\&                      const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mke2fs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは \f(CW\*(C`device\*(C'\fR に ext2 外部ジャーナルを作成します。次のコマンドと同じです:
.PP
.Vb 1
\& mke2fs \-O journal_dev \-b blocksize device
.Ve
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.68 において追加)
.SS "guestfs_mke2journal_L"
.IX Subsection "guestfs_mke2journal_L"
.Vb 5
\& int
\& guestfs_mke2journal_L (guestfs_h *g,
\&                        int blocksize,
\&                        const char *label,
\&                        const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mke2fs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これはラベル \f(CW\*(C`label\*(C'\fR を持つ \f(CW\*(C`device\*(C'\fR に ext2 外部ジャーナルを作成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.68 において追加)
.SS "guestfs_mke2journal_U"
.IX Subsection "guestfs_mke2journal_U"
.Vb 5
\& int
\& guestfs_mke2journal_U (guestfs_h *g,
\&                        int blocksize,
\&                        const char *uuid,
\&                        const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mke2fs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This creates an ext2 external journal on \f(CW\*(C`device\*(C'\fR with \s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxfsuuid\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.68 において追加)
.SS "guestfs_mkfifo"
.IX Subsection "guestfs_mkfifo"
.Vb 4
\& int
\& guestfs_mkfifo (guestfs_h *g,
\&                 int mode,
\&                 const char *path);
.Ve
.PP
This call creates a \s-1FIFO\s0 (named pipe) called \f(CW\*(C`path\*(C'\fR with mode \f(CW\*(C`mode\*(C'\fR.  It
is just a convenient wrapper around \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
Unlike with \f(CW\*(C`guestfs_mknod\*(C'\fR, \f(CW\*(C`mode\*(C'\fR \fBmust\fR contain only permissions bits.
.PP
実際に設定されるモードは umask により影響されます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`mknod\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.55 において追加)
.SS "guestfs_mkfs"
.IX Subsection "guestfs_mkfs"
.Vb 4
\& int
\& guestfs_mkfs (guestfs_h *g,
\&               const char *fstype,
\&               const char *device);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_mkfs_opts\*(R" with no optional
arguments.
.PP
(0.8 において追加)
.SS "guestfs_mkfs_opts"
.IX Subsection "guestfs_mkfs_opts"
.Vb 5
\& int
\& guestfs_mkfs_opts (guestfs_h *g,
\&                    const char *fstype,
\&                    const char *device,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_MKFS_OPTS_BLOCKSIZE, int blocksize,
\& GUESTFS_MKFS_OPTS_FEATURES, const char *features,
\& GUESTFS_MKFS_OPTS_INODE, int inode,
\& GUESTFS_MKFS_OPTS_SECTORSIZE, int sectorsize,
\& GUESTFS_MKFS_OPTS_LABEL, const char *label,
.Ve
.PP
This function creates a filesystem on \f(CW\*(C`device\*(C'\fR.  The filesystem type is
\&\f(CW\*(C`fstype\*(C'\fR, for example \f(CW\*(C`ext3\*(C'\fR.
.PP
オプション引数は次のとおりです:
.ie n .IP """blocksize""" 4
.el .IP "\f(CWblocksize\fR" 4
.IX Item "blocksize"
ファイルシステムのブロック容量です。サポートされるブロック容量は、ファイルシステムの形式に依存します。一般的に Linux ext2/3
ファイルシステムには \f(CW1024\fR, \f(CW2048\fR または \f(CW4096\fR です。
.Sp
For \s-1VFAT\s0 and \s-1NTFS\s0 the \f(CW\*(C`blocksize\*(C'\fR parameter is treated as the requested
cluster size.
.Sp
\&\s-1UFS\s0 ブロック容量は \fImkfs.ufs\fR\|(8) を参照してください。
.ie n .IP """特徴""" 4
.el .IP "\f(CW特徴\fR" 4
.IX Item "特徴"
これは \fI\-O\fR パラメーターを外部の mkfs プログラムに渡します。
.Sp
特定のファイルシステム形式には、追加のファイルシステム機能が選択できます。詳細は \fImke2fs\fR\|(8) および \fImkfs.ufs\fR\|(8)
を参照してください。
.Sp
\&\f(CW\*(C`gfs\*(C'\fR または \f(CW\*(C`gfs2\*(C'\fR ファイルシステム形式ではこのオプションのパラメーターを使用できません。
.ie n .IP """inode""" 4
.el .IP "\f(CWinode\fR" 4
.IX Item "inode"
This passes the \fI\-I\fR parameter to the external \fImke2fs\fR\|(8) program which
sets the inode size (only for ext2/3/4 filesystems at present).
.ie n .IP """sectorsize""" 4
.el .IP "\f(CWsectorsize\fR" 4
.IX Item "sectorsize"
This passes the \fI\-S\fR parameter to external \fImkfs.ufs\fR\|(8) program, which
sets sector size for ufs filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_mkfs_opts_va"
.IX Subsection "guestfs_mkfs_opts_va"
.Vb 5
\& int
\& guestfs_mkfs_opts_va (guestfs_h *g,
\&                       const char *fstype,
\&                       const char *device,
\&                       va_list args);
.Ve
.PP
これは \*(L"guestfs_mkfs_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mkfs_opts_argv"
.IX Subsection "guestfs_mkfs_opts_argv"
.Vb 5
\& int
\& guestfs_mkfs_opts_argv (guestfs_h *g,
\&                         const char *fstype,
\&                         const char *device,
\&                         const struct guestfs_mkfs_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_mkfs_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mkfs_b"
.IX Subsection "guestfs_mkfs_b"
.Vb 5
\& int
\& guestfs_mkfs_b (guestfs_h *g,
\&                 const char *fstype,
\&                 int blocksize,
\&                 const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mkfs\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This call is similar to \f(CW\*(C`guestfs_mkfs\*(C'\fR, but it allows you to control the
block size of the resulting filesystem.  Supported block sizes depend on the
filesystem type, but typically they are \f(CW1024\fR, \f(CW2048\fR or \f(CW4096\fR only.
.PP
For \s-1VFAT\s0 and \s-1NTFS\s0 the \f(CW\*(C`blocksize\*(C'\fR parameter is treated as the requested
cluster size.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.68 において追加)
.SS "guestfs_mkfs_btrfs"
.IX Subsection "guestfs_mkfs_btrfs"
.Vb 4
\& int
\& guestfs_mkfs_btrfs (guestfs_h *g,
\&                     char *const *devices,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 8
\& GUESTFS_MKFS_BTRFS_ALLOCSTART, int64_t allocstart,
\& GUESTFS_MKFS_BTRFS_BYTECOUNT, int64_t bytecount,
\& GUESTFS_MKFS_BTRFS_DATATYPE, const char *datatype,
\& GUESTFS_MKFS_BTRFS_LEAFSIZE, int leafsize,
\& GUESTFS_MKFS_BTRFS_LABEL, const char *label,
\& GUESTFS_MKFS_BTRFS_METADATA, const char *metadata,
\& GUESTFS_MKFS_BTRFS_NODESIZE, int nodesize,
\& GUESTFS_MKFS_BTRFS_SECTORSIZE, int sectorsize,
.Ve
.PP
すべての設定可能なものについて設定を許可して、btrfs ファイルシステムを作成します。オプション引数の詳細は \fImkfs.btrfs\fR\|(8)
を参照してください。
.PP
btrfs ファイルシステムは複数のデバイスを結合できるので、これは非空白のデバイス一覧をとります。
.PP
一般的なファイルシステムを作成するには \f(CW\*(C`guestfs_mkfs\*(C'\fR を使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`btrfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.25 において追加)
.SS "guestfs_mkfs_btrfs_va"
.IX Subsection "guestfs_mkfs_btrfs_va"
.Vb 4
\& int
\& guestfs_mkfs_btrfs_va (guestfs_h *g,
\&                        char *const *devices,
\&                        va_list args);
.Ve
.PP
これは \*(L"guestfs_mkfs_btrfs\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mkfs_btrfs_argv"
.IX Subsection "guestfs_mkfs_btrfs_argv"
.Vb 4
\& int
\& guestfs_mkfs_btrfs_argv (guestfs_h *g,
\&                          char *const *devices,
\&                          const struct guestfs_mkfs_btrfs_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_mkfs_btrfs\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mklost_and_found"
.IX Subsection "guestfs_mklost_and_found"
.Vb 3
\& int
\& guestfs_mklost_and_found (guestfs_h *g,
\&                           const char *mountpoint);
.Ve
.PP
Make the \f(CW\*(C`lost+found\*(C'\fR directory, normally in the root directory of an
ext2/3/4 filesystem.  \f(CW\*(C`mountpoint\*(C'\fR is the directory under which we try to
create the \f(CW\*(C`lost+found\*(C'\fR directory.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.56 において追加)
.SS "guestfs_mkmountpoint"
.IX Subsection "guestfs_mkmountpoint"
.Vb 3
\& int
\& guestfs_mkmountpoint (guestfs_h *g,
\&                       const char *exemptpath);
.Ve
.PP
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR および \f(CW\*(C`guestfs_rmmountpoint\*(C'\fR
は、最初のファイルシステムをマウントする前に追加のマウントポイントを作成するために使用できる、特別な呼び出しです。
.PP
These calls are \fIonly\fR necessary in some very limited circumstances, mainly
the case where you want to mount a mix of unrelated and/or read-only
filesystems together.
.PP
For example, live CDs often contain a \*(L"Russian doll\*(R" nest of filesystems, an
\&\s-1ISO\s0 outer layer, with a squashfs image inside, with an ext2/3 image inside
that.  You can unpack this as follows in guestfish:
.PP
.Vb 8
\& add\-ro Fedora\-11\-i686\-Live.iso
\& run
\& mkmountpoint /cd
\& mkmountpoint /sqsh
\& mkmountpoint /ext3fs
\& mount /dev/sda /cd
\& mount\-loop /cd/LiveOS/squashfs.img /sqsh
\& mount\-loop /sqsh/LiveOS/ext3fs.img /ext3fs
.Ve
.PP
The inner filesystem is now unpacked under the /ext3fs mountpoint.
.PP
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR is not compatible with \f(CW\*(C`guestfs_umount_all\*(C'\fR.  You
may get unexpected errors if you try to mix these calls.  It is safest to
manually unmount filesystems and remove mountpoints after use.
.PP
\&\f(CW\*(C`guestfs_umount_all\*(C'\fR unmounts filesystems by sorting the paths longest
first, so for this to work for manual mountpoints, you must ensure that the
innermost mountpoints have the longest pathnames, as in the example code
above.
.PP
詳細は https://bugzilla.redhat.com/show_bug.cgi?id=599503 を参照してください
.PP
Autosync [see \f(CW\*(C`guestfs_set_autosync\*(C'\fR, this is set by default on handles]
can cause \f(CW\*(C`guestfs_umount_all\*(C'\fR to be called when the handle is closed which
can also trigger these issues.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.62 において追加)
.SS "guestfs_mknod"
.IX Subsection "guestfs_mknod"
.Vb 6
\& int
\& guestfs_mknod (guestfs_h *g,
\&                int mode,
\&                int devmajor,
\&                int devminor,
\&                const char *path);
.Ve
.PP
This call creates block or character special devices, or named pipes
(FIFOs).
.PP
The \f(CW\*(C`mode\*(C'\fR parameter should be the mode, using the standard constants.
\&\f(CW\*(C`devmajor\*(C'\fR and \f(CW\*(C`devminor\*(C'\fR are the device major and minor numbers, only
used when creating block and character special devices.
.PP
Note that, just like \fImknod\fR\|(2), the mode must be bitwise \s-1OR\s0'd with
S_IFBLK, S_IFCHR, S_IFIFO or S_IFSOCK (otherwise this call just creates a
regular file).  These constants are available in the standard Linux header
files, or you can use \f(CW\*(C`guestfs_mknod_b\*(C'\fR, \f(CW\*(C`guestfs_mknod_c\*(C'\fR or
\&\f(CW\*(C`guestfs_mkfifo\*(C'\fR which are wrappers around this command which bitwise \s-1OR\s0 in
the appropriate constant for you.
.PP
実際に設定されるモードは umask により影響されます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`mknod\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.55 において追加)
.SS "guestfs_mknod_b"
.IX Subsection "guestfs_mknod_b"
.Vb 6
\& int
\& guestfs_mknod_b (guestfs_h *g,
\&                  int mode,
\&                  int devmajor,
\&                  int devminor,
\&                  const char *path);
.Ve
.PP
This call creates a block device node called \f(CW\*(C`path\*(C'\fR with mode \f(CW\*(C`mode\*(C'\fR and
device major/minor \f(CW\*(C`devmajor\*(C'\fR and \f(CW\*(C`devminor\*(C'\fR.  It is just a convenient
wrapper around \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
Unlike with \f(CW\*(C`guestfs_mknod\*(C'\fR, \f(CW\*(C`mode\*(C'\fR \fBmust\fR contain only permissions bits.
.PP
実際に設定されるモードは umask により影響されます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`mknod\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.55 において追加)
.SS "guestfs_mknod_c"
.IX Subsection "guestfs_mknod_c"
.Vb 6
\& int
\& guestfs_mknod_c (guestfs_h *g,
\&                  int mode,
\&                  int devmajor,
\&                  int devminor,
\&                  const char *path);
.Ve
.PP
This call creates a char device node called \f(CW\*(C`path\*(C'\fR with mode \f(CW\*(C`mode\*(C'\fR and
device major/minor \f(CW\*(C`devmajor\*(C'\fR and \f(CW\*(C`devminor\*(C'\fR.  It is just a convenient
wrapper around \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
Unlike with \f(CW\*(C`guestfs_mknod\*(C'\fR, \f(CW\*(C`mode\*(C'\fR \fBmust\fR contain only permissions bits.
.PP
実際に設定されるモードは umask により影響されます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`mknod\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.55 において追加)
.SS "guestfs_mksquashfs"
.IX Subsection "guestfs_mksquashfs"
.Vb 5
\& int
\& guestfs_mksquashfs (guestfs_h *g,
\&                     const char *path,
\&                     const char *filename,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_MKSQUASHFS_COMPRESS, const char *compress,
\& GUESTFS_MKSQUASHFS_EXCLUDES, char *const *excludes,
.Ve
.PP
Create a squashfs filesystem for the specified \f(CW\*(C`path\*(C'\fR.
.PP
The optional \f(CW\*(C`compress\*(C'\fR flag controls compression.  If not given, then the
output compressed using \f(CW\*(C`gzip\*(C'\fR.  Otherwise one of the following strings may
be given to select the compression type of the squashfs: \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`lzma\*(C'\fR,
\&\f(CW\*(C`lzo\*(C'\fR, \f(CW\*(C`lz4\*(C'\fR, \f(CW\*(C`xz\*(C'\fR.
.PP
The other optional arguments are:
.ie n .IP """excludes""" 4
.el .IP "\f(CWexcludes\fR" 4
.IX Item "excludes"
A list of wildcards.  Files are excluded if they match any of the wildcards.
.PP
Please note that this \s-1API\s0 may fail when used to compress directories with
large files, such as the resulting squashfs will be over 3GB big.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`squashfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.35.25)
.SS "guestfs_mksquashfs_va"
.IX Subsection "guestfs_mksquashfs_va"
.Vb 5
\& int
\& guestfs_mksquashfs_va (guestfs_h *g,
\&                        const char *path,
\&                        const char *filename,
\&                        va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_mksquashfs\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mksquashfs_argv"
.IX Subsection "guestfs_mksquashfs_argv"
.Vb 5
\& int
\& guestfs_mksquashfs_argv (guestfs_h *g,
\&                          const char *path,
\&                          const char *filename,
\&                          const struct guestfs_mksquashfs_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_mksquashfs\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mkswap"
.IX Subsection "guestfs_mkswap"
.Vb 3
\& int
\& guestfs_mkswap (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_mkswap_opts\*(R" with no optional
arguments.
.PP
(1.0.55 において追加)
.SS "guestfs_mkswap_opts"
.IX Subsection "guestfs_mkswap_opts"
.Vb 4
\& int
\& guestfs_mkswap_opts (guestfs_h *g,
\&                      const char *device,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_MKSWAP_OPTS_LABEL, const char *label,
\& GUESTFS_MKSWAP_OPTS_UUID, const char *uuid,
.Ve
.PP
Linux swap パーティションを \f(CW\*(C`device\*(C'\fR に作成します。
.PP
The option arguments \f(CW\*(C`label\*(C'\fR and \f(CW\*(C`uuid\*(C'\fR allow you to set the label and/or
\&\s-1UUID\s0 of the new swap partition.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.55 において追加)
.SS "guestfs_mkswap_opts_va"
.IX Subsection "guestfs_mkswap_opts_va"
.Vb 4
\& int
\& guestfs_mkswap_opts_va (guestfs_h *g,
\&                         const char *device,
\&                         va_list args);
.Ve
.PP
これは \*(L"guestfs_mkswap_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mkswap_opts_argv"
.IX Subsection "guestfs_mkswap_opts_argv"
.Vb 4
\& int
\& guestfs_mkswap_opts_argv (guestfs_h *g,
\&                           const char *device,
\&                           const struct guestfs_mkswap_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_mkswap_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mkswap_L"
.IX Subsection "guestfs_mkswap_L"
.Vb 4
\& int
\& guestfs_mkswap_L (guestfs_h *g,
\&                   const char *label,
\&                   const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mkswap\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
ラベル \f(CW\*(C`label\*(C'\fR を持つ \f(CW\*(C`device\*(C'\fR に swap パーティションを作成します。
.PP
Note that you cannot attach a swap label to a block device
(eg. \fI/dev/sda\fR), just to a partition.  This appears to be a limitation of
the kernel or swap tools.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.55 において追加)
.SS "guestfs_mkswap_U"
.IX Subsection "guestfs_mkswap_U"
.Vb 4
\& int
\& guestfs_mkswap_U (guestfs_h *g,
\&                   const char *uuid,
\&                   const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_mkswap\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
\&\s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR の \f(CW\*(C`device\*(C'\fR に swap パーティションを作成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxfsuuid\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.55 において追加)
.SS "guestfs_mkswap_file"
.IX Subsection "guestfs_mkswap_file"
.Vb 3
\& int
\& guestfs_mkswap_file (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
swap ファイルを作成します。
.PP
This command just writes a swap file signature to an existing file.  To
create the file itself, use something like \f(CW\*(C`guestfs_fallocate\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_mktemp"
.IX Subsection "guestfs_mktemp"
.Vb 4
\& char *
\& guestfs_mktemp (guestfs_h *g,
\&                 const char *tmpl,
\&                 ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_MKTEMP_SUFFIX, const char *suffix,
.Ve
.PP
This command creates a temporary file.  The \f(CW\*(C`tmpl\*(C'\fR parameter should be a
full pathname for the temporary directory name with the final six characters
being \*(L"\s-1XXXXXX\*(R".\s0
.PP
例: \*(L"/tmp/myprogXXXXXX\*(R" または \*(L"/Temp/myprogXXXXXX\*(R"、2 つめの例は Windows
ファイルシステムに適しています。
.PP
The name of the temporary file that was created is returned.
.PP
The temporary file is created with mode 0600 and is owned by root.
.PP
The caller is responsible for deleting the temporary file after use.
.PP
If the optional \f(CW\*(C`suffix\*(C'\fR parameter is given, then the suffix (eg. \f(CW\*(C`.txt\*(C'\fR)
is appended to the temporary name.
.PP
関連項目: \f(CW\*(C`guestfs_mkdtemp\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.19.53 において追加)
.SS "guestfs_mktemp_va"
.IX Subsection "guestfs_mktemp_va"
.Vb 4
\& char *
\& guestfs_mktemp_va (guestfs_h *g,
\&                    const char *tmpl,
\&                    va_list args);
.Ve
.PP
これは \*(L"guestfs_mktemp\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mktemp_argv"
.IX Subsection "guestfs_mktemp_argv"
.Vb 4
\& char *
\& guestfs_mktemp_argv (guestfs_h *g,
\&                      const char *tmpl,
\&                      const struct guestfs_mktemp_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_mktemp\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_modprobe"
.IX Subsection "guestfs_modprobe"
.Vb 3
\& int
\& guestfs_modprobe (guestfs_h *g,
\&                   const char *modulename);
.Ve
.PP
アプライアンスにカーネルモジュールを読み込みます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxmodules\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.68 において追加)
.SS "guestfs_mount"
.IX Subsection "guestfs_mount"
.Vb 4
\& int
\& guestfs_mount (guestfs_h *g,
\&                const char *mountable,
\&                const char *mountpoint);
.Ve
.PP
Mount a guest disk at a position in the filesystem.  Block devices are named
\&\fI/dev/sda\fR, \fI/dev/sdb\fR and so on, as they were added to the guest.  If
those block devices contain partitions, they will have the usual names
(eg. \fI/dev/sda1\fR).  Also \s-1LVM\s0 \fI/dev/VG/LV\fR\-style names can be used, or
\&'mountable' strings returned by \f(CW\*(C`guestfs_list_filesystems\*(C'\fR or
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR.
.PP
The rules are the same as for \fImount\fR\|(2): A filesystem must first be
mounted on \fI/\fR before others can be mounted.  Other filesystems can only be
mounted on directories which already exist.
.PP
The mounted filesystem is writable, if we have sufficient permissions on the
underlying device.
.PP
Before libguestfs 1.13.16, this call implicitly added the options \f(CW\*(C`sync\*(C'\fR
and \f(CW\*(C`noatime\*(C'\fR.  The \f(CW\*(C`sync\*(C'\fR option greatly slowed writes and caused many
problems for users.  If your program might need to work with older versions
of libguestfs, use \f(CW\*(C`guestfs_mount_options\*(C'\fR instead (using an empty string
for the first parameter if you don't want any options).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_mount_9p"
.IX Subsection "guestfs_mount_9p"
.Vb 5
\& int
\& guestfs_mount_9p (guestfs_h *g,
\&                   const char *mounttag,
\&                   const char *mountpoint,
\&                   ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_MOUNT_9P_OPTIONS, const char *options,
.Ve
.PP
タグ \f(CW\*(C`mounttag\*(C'\fR を持つ virtio\-9p ファイルシステムをディレクトリ \f(CW\*(C`mountpoint\*(C'\fR にマウントします。
.PP
If required, \f(CW\*(C`trans=virtio\*(C'\fR will be automatically added to the options.
Any other options required can be passed in the optional \f(CW\*(C`options\*(C'\fR
parameter.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.11.12 において追加)
.SS "guestfs_mount_9p_va"
.IX Subsection "guestfs_mount_9p_va"
.Vb 5
\& int
\& guestfs_mount_9p_va (guestfs_h *g,
\&                      const char *mounttag,
\&                      const char *mountpoint,
\&                      va_list args);
.Ve
.PP
これは \*(L"guestfs_mount_9p\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mount_9p_argv"
.IX Subsection "guestfs_mount_9p_argv"
.Vb 5
\& int
\& guestfs_mount_9p_argv (guestfs_h *g,
\&                        const char *mounttag,
\&                        const char *mountpoint,
\&                        const struct guestfs_mount_9p_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_mount_9p\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mount_local"
.IX Subsection "guestfs_mount_local"
.Vb 4
\& int
\& guestfs_mount_local (guestfs_h *g,
\&                      const char *localmountpoint,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 4
\& GUESTFS_MOUNT_LOCAL_READONLY, int readonly,
\& GUESTFS_MOUNT_LOCAL_OPTIONS, const char *options,
\& GUESTFS_MOUNT_LOCAL_CACHETIMEOUT, int cachetimeout,
\& GUESTFS_MOUNT_LOCAL_DEBUGCALLS, int debugcalls,
.Ve
.PP
This call exports the libguestfs-accessible filesystem to a local mountpoint
(directory) called \f(CW\*(C`localmountpoint\*(C'\fR.  Ordinary reads and writes to files
and directories under \f(CW\*(C`localmountpoint\*(C'\fR are redirected through libguestfs.
.PP
If the optional \f(CW\*(C`readonly\*(C'\fR flag is set to true, then writes to the
filesystem return error \f(CW\*(C`EROFS\*(C'\fR.
.PP
\&\f(CW\*(C`options\*(C'\fR is a comma-separated list of mount options.  See \fIguestmount\fR\|(1)
for some useful options.
.PP
\&\f(CW\*(C`cachetimeout\*(C'\fR sets the timeout (in seconds) for cached directory entries.
The default is 60 seconds.  See \fIguestmount\fR\|(1) for further information.
.PP
If \f(CW\*(C`debugcalls\*(C'\fR is set to true, then additional debugging information is
generated for every \s-1FUSE\s0 call.
.PP
When \f(CW\*(C`guestfs_mount_local\*(C'\fR returns, the filesystem is ready, but is not
processing requests (access to it will block).  You have to call
\&\f(CW\*(C`guestfs_mount_local_run\*(C'\fR to run the main loop.
.PP
完全なドキュメントは \*(L"\s-1MOUNT LOCAL\*(R"\s0 を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.17.22 において追加)
.SS "guestfs_mount_local_va"
.IX Subsection "guestfs_mount_local_va"
.Vb 4
\& int
\& guestfs_mount_local_va (guestfs_h *g,
\&                         const char *localmountpoint,
\&                         va_list args);
.Ve
.PP
これは \*(L"guestfs_mount_local\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mount_local_argv"
.IX Subsection "guestfs_mount_local_argv"
.Vb 4
\& int
\& guestfs_mount_local_argv (guestfs_h *g,
\&                           const char *localmountpoint,
\&                           const struct guestfs_mount_local_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_mount_local\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_mount_local_run"
.IX Subsection "guestfs_mount_local_run"
.Vb 2
\& int
\& guestfs_mount_local_run (guestfs_h *g);
.Ve
.PP
Run the main loop which translates kernel calls to libguestfs calls.
.PP
This should only be called after \f(CW\*(C`guestfs_mount_local\*(C'\fR returns
successfully.  The call will not return until the filesystem is unmounted.
.PP
\&\fBNote\fR you must \fInot\fR make concurrent libguestfs calls on the same handle
from another thread.
.PP
You may call this from a different thread than the one which called
\&\f(CW\*(C`guestfs_mount_local\*(C'\fR, subject to the usual rules for threads and
libguestfs (see \*(L"\s-1MULTIPLE HANDLES AND MULTIPLE THREADS\*(R"\s0).
.PP
完全なドキュメントは \*(L"\s-1MOUNT LOCAL\*(R"\s0 を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.17.22 において追加)
.SS "guestfs_mount_loop"
.IX Subsection "guestfs_mount_loop"
.Vb 4
\& int
\& guestfs_mount_loop (guestfs_h *g,
\&                     const char *file,
\&                     const char *mountpoint);
.Ve
.PP
This command lets you mount \fIfile\fR (a filesystem image in a file) on a
mount point.  It is entirely equivalent to the command \f(CW\*(C`mount \-o loop file
mountpoint\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.54 において追加)
.SS "guestfs_mount_options"
.IX Subsection "guestfs_mount_options"
.Vb 5
\& int
\& guestfs_mount_options (guestfs_h *g,
\&                        const char *options,
\&                        const char *mountable,
\&                        const char *mountpoint);
.Ve
.PP
This is the same as the \f(CW\*(C`guestfs_mount\*(C'\fR command, but it allows you to set
the mount options as for the \fImount\fR\|(8) \fI\-o\fR flag.
.PP
If the \f(CW\*(C`options\*(C'\fR parameter is an empty string, then no options are passed
(all options default to whatever the filesystem uses).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.10 において追加)
.SS "guestfs_mount_ro"
.IX Subsection "guestfs_mount_ro"
.Vb 4
\& int
\& guestfs_mount_ro (guestfs_h *g,
\&                   const char *mountable,
\&                   const char *mountpoint);
.Ve
.PP
This is the same as the \f(CW\*(C`guestfs_mount\*(C'\fR command, but it mounts the
filesystem with the read-only (\fI\-o ro\fR) flag.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.10 において追加)
.SS "guestfs_mount_vfs"
.IX Subsection "guestfs_mount_vfs"
.Vb 6
\& int
\& guestfs_mount_vfs (guestfs_h *g,
\&                    const char *options,
\&                    const char *vfstype,
\&                    const char *mountable,
\&                    const char *mountpoint);
.Ve
.PP
This is the same as the \f(CW\*(C`guestfs_mount\*(C'\fR command, but it allows you to set
both the mount options and the vfstype as for the \fImount\fR\|(8) \fI\-o\fR and
\&\fI\-t\fR flags.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.10 において追加)
.SS "guestfs_mountable_device"
.IX Subsection "guestfs_mountable_device"
.Vb 3
\& char *
\& guestfs_mountable_device (guestfs_h *g,
\&                           const char *mountable);
.Ve
.PP
Returns the device name of a mountable. In quite a lot of cases, the
mountable is the device name.
.PP
However this doesn't apply for btrfs subvolumes, where the mountable is a
combination of both the device name and the subvolume path (see also
\&\f(CW\*(C`guestfs_mountable_subvolume\*(C'\fR to extract the subvolume path of the
mountable if any).
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.33.15)
.SS "guestfs_mountable_subvolume"
.IX Subsection "guestfs_mountable_subvolume"
.Vb 3
\& char *
\& guestfs_mountable_subvolume (guestfs_h *g,
\&                              const char *mountable);
.Ve
.PP
Returns the subvolume path of a mountable. Btrfs subvolumes mountables are a
combination of both the device name and the subvolume path (see also
\&\f(CW\*(C`guestfs_mountable_device\*(C'\fR to extract the device of the mountable).
.PP
If the mountable does not represent a btrfs subvolume, then this function
fails and the \f(CW\*(C`errno\*(C'\fR is set to \f(CW\*(C`EINVAL\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.33.15)
.SS "guestfs_mountpoints"
.IX Subsection "guestfs_mountpoints"
.Vb 2
\& char **
\& guestfs_mountpoints (guestfs_h *g);
.Ve
.PP
This call is similar to \f(CW\*(C`guestfs_mounts\*(C'\fR.  That call returns a list of
devices.  This one returns a hash table (map) of device name to directory
where the device is mounted.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(1.0.62 において追加)
.SS "guestfs_mounts"
.IX Subsection "guestfs_mounts"
.Vb 2
\& char **
\& guestfs_mounts (guestfs_h *g);
.Ve
.PP
This returns the list of currently mounted filesystems.  It returns the list
of devices (eg. \fI/dev/sda1\fR, \fI/dev/VG/LV\fR).
.PP
Some internal mounts are not shown.
.PP
関連項目: \f(CW\*(C`guestfs_mountpoints\*(C'\fR
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.8 において追加)
.SS "guestfs_mv"
.IX Subsection "guestfs_mv"
.Vb 4
\& int
\& guestfs_mv (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
This moves a file from \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR where \f(CW\*(C`dest\*(C'\fR is either a
destination filename or destination directory.
.PP
関連項目: \f(CW\*(C`guestfs_rename\*(C'\fR。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.18 において追加)
.SS "guestfs_nr_devices"
.IX Subsection "guestfs_nr_devices"
.Vb 2
\& int
\& guestfs_nr_devices (guestfs_h *g);
.Ve
.PP
This returns the number of whole block devices that were added.  This is the
same as the number of devices that would be returned if you called
\&\f(CW\*(C`guestfs_list_devices\*(C'\fR.
.PP
To find out the maximum number of devices that could be added, call
\&\f(CW\*(C`guestfs_max_disks\*(C'\fR.
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.19.15 において追加)
.SS "guestfs_ntfs_3g_probe"
.IX Subsection "guestfs_ntfs_3g_probe"
.Vb 4
\& int
\& guestfs_ntfs_3g_probe (guestfs_h *g,
\&                        int rw,
\&                        const char *device);
.Ve
.PP
This command runs the \fIntfs\-3g.probe\fR\|(8) command which probes an \s-1NTFS\s0
\&\f(CW\*(C`device\*(C'\fR for mountability.  (Not all \s-1NTFS\s0 volumes can be mounted
read-write, and some cannot be mounted at all).
.PP
\&\f(CW\*(C`rw\*(C'\fR is a boolean flag.  Set it to true if you want to test if the volume
can be mounted read-write.  Set it to false if you want to test if the
volume can be mounted read-only.
.PP
The return value is an integer which \f(CW0\fR if the operation would succeed, or
some non-zero value documented in the \fIntfs\-3g.probe\fR\|(8) manual page.
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ntfs3g\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.43 において追加)
.SS "guestfs_ntfscat_i"
.IX Subsection "guestfs_ntfscat_i"
.Vb 5
\& int
\& guestfs_ntfscat_i (guestfs_h *g,
\&                    const char *device,
\&                    int64_t inode,
\&                    const char *filename);
.Ve
.PP
Download a file given its inode from a \s-1NTFS\s0 filesystem and save it as
\&\fIfilename\fR on the local machine.
.PP
This allows to download some otherwise inaccessible files such as the ones
within the \f(CW$Extend\fR folder.
.PP
The filesystem from which to extract the file must be unmounted, otherwise
the call will fail.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(Added in 1.33.14)
.SS "guestfs_ntfsclone_in"
.IX Subsection "guestfs_ntfsclone_in"
.Vb 4
\& int
\& guestfs_ntfsclone_in (guestfs_h *g,
\&                       const char *backupfile,
\&                       const char *device);
.Ve
.PP
\&\f(CW\*(C`backupfile\*(C'\fR を(前に \f(CW\*(C`guestfs_ntfsclone_out\*(C'\fR を呼び出したところから)  \f(CW\*(C`device\*(C'\fR
に復元します。このデバイスの既存の内容はすべて上書きされます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ntfs3g\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.9 において追加)
.SS "guestfs_ntfsclone_out"
.IX Subsection "guestfs_ntfsclone_out"
.Vb 5
\& int
\& guestfs_ntfsclone_out (guestfs_h *g,
\&                        const char *device,
\&                        const char *backupfile,
\&                        ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 5
\& GUESTFS_NTFSCLONE_OUT_METADATAONLY, int metadataonly,
\& GUESTFS_NTFSCLONE_OUT_RESCUE, int rescue,
\& GUESTFS_NTFSCLONE_OUT_IGNOREFSCHECK, int ignorefscheck,
\& GUESTFS_NTFSCLONE_OUT_PRESERVETIMESTAMPS, int preservetimestamps,
\& GUESTFS_NTFSCLONE_OUT_FORCE, int force,
.Ve
.PP
Stream the \s-1NTFS\s0 filesystem \f(CW\*(C`device\*(C'\fR to the local file \f(CW\*(C`backupfile\*(C'\fR.  The
format used for the backup file is a special format used by the
\&\fIntfsclone\fR\|(8) tool.
.PP
If the optional \f(CW\*(C`metadataonly\*(C'\fR flag is true, then \fIonly\fR the metadata is
saved, losing all the user data (this is useful for diagnosing some
filesystem problems).
.PP
オプションの \f(CW\*(C`rescue\*(C'\fR, \f(CW\*(C`ignorefscheck\*(C'\fR, \f(CW\*(C`preservetimestamps\*(C'\fR および \f(CW\*(C`force\*(C'\fR フラグは
\&\fIntfsclone\fR\|(8) マニュアルページに詳細な意味が説明されています。
.PP
libguestfs デバイスにファイルを復元するには \f(CW\*(C`guestfs_ntfsclone_in\*(C'\fR を使用します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ntfs3g\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.9 において追加)
.SS "guestfs_ntfsclone_out_va"
.IX Subsection "guestfs_ntfsclone_out_va"
.Vb 5
\& int
\& guestfs_ntfsclone_out_va (guestfs_h *g,
\&                           const char *device,
\&                           const char *backupfile,
\&                           va_list args);
.Ve
.PP
これは \*(L"guestfs_ntfsclone_out\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_ntfsclone_out_argv"
.IX Subsection "guestfs_ntfsclone_out_argv"
.Vb 5
\& int
\& guestfs_ntfsclone_out_argv (guestfs_h *g,
\&                             const char *device,
\&                             const char *backupfile,
\&                             const struct guestfs_ntfsclone_out_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_ntfsclone_out\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_ntfsfix"
.IX Subsection "guestfs_ntfsfix"
.Vb 4
\& int
\& guestfs_ntfsfix (guestfs_h *g,
\&                  const char *device,
\&                  ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_NTFSFIX_CLEARBADSECTORS, int clearbadsectors,
.Ve
.PP
このコマンドは、いくつかの基本的な \s-1NTFS\s0 の不整合を修復し、 \s-1NTFS\s0 ジャーナルファイルをリセットし、次回 Windows 起動時に \s-1NTFS\s0
完全性チェックをスケジュール化します。
.PP
これは Windows の \f(CW\*(C`chkdsk\*(C'\fR と同等では \fIありません\fR 。不整合に対してファイルシステムをスキャン \fIしません\fR 。
.PP
オプションの \f(CW\*(C`clearbadsectors\*(C'\fR
フラグは不良セクターの一覧をクリアします。不良セクターを持つディスクを新しいディスクにクローンした後に有用です。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ntfs3g\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.9 において追加)
.SS "guestfs_ntfsfix_va"
.IX Subsection "guestfs_ntfsfix_va"
.Vb 4
\& int
\& guestfs_ntfsfix_va (guestfs_h *g,
\&                     const char *device,
\&                     va_list args);
.Ve
.PP
これは \*(L"guestfs_ntfsfix\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_ntfsfix_argv"
.IX Subsection "guestfs_ntfsfix_argv"
.Vb 4
\& int
\& guestfs_ntfsfix_argv (guestfs_h *g,
\&                       const char *device,
\&                       const struct guestfs_ntfsfix_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_ntfsfix\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_ntfsresize"
.IX Subsection "guestfs_ntfsresize"
.Vb 3
\& int
\& guestfs_ntfsresize (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_ntfsresize_opts\*(R" with no optional
arguments.
.PP
(1.3.2 において追加)
.SS "guestfs_ntfsresize_opts"
.IX Subsection "guestfs_ntfsresize_opts"
.Vb 4
\& int
\& guestfs_ntfsresize_opts (guestfs_h *g,
\&                          const char *device,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_NTFSRESIZE_OPTS_SIZE, int64_t size,
\& GUESTFS_NTFSRESIZE_OPTS_FORCE, int force,
.Ve
.PP
このコマンドは \s-1NTFS\s0 ファイルシステムの容量を変更します。基礎となるデバイスの容量まで拡張または縮小します。
.PP
オプションのパラメーターは次のとおりです:
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
ファイルシステムの新しい容量 (バイト単位)。省略されると、ファイルシステムはコンテナー (例: パーティション) に合うよう容量を変更されます。
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
If this option is true, then force the resize of the filesystem even if the
filesystem is marked as requiring a consistency check.
.Sp
After the resize operation, the filesystem is always marked as requiring a
consistency check (for safety).  You have to boot into Windows to perform
this check and clear this condition.  If you \fIdon't\fR set the \f(CW\*(C`force\*(C'\fR
option then it is not possible to call \f(CW\*(C`guestfs_ntfsresize\*(C'\fR multiple times
on a single filesystem without booting into Windows between each resize.
.PP
\&\fIntfsresize\fR\|(8) 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ntfsprogs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.3.2 において追加)
.SS "guestfs_ntfsresize_opts_va"
.IX Subsection "guestfs_ntfsresize_opts_va"
.Vb 4
\& int
\& guestfs_ntfsresize_opts_va (guestfs_h *g,
\&                             const char *device,
\&                             va_list args);
.Ve
.PP
これは \*(L"guestfs_ntfsresize_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_ntfsresize_opts_argv"
.IX Subsection "guestfs_ntfsresize_opts_argv"
.Vb 4
\& int
\& guestfs_ntfsresize_opts_argv (guestfs_h *g,
\&                               const char *device,
\&                               const struct guestfs_ntfsresize_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_ntfsresize_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_ntfsresize_size"
.IX Subsection "guestfs_ntfsresize_size"
.Vb 4
\& int
\& guestfs_ntfsresize_size (guestfs_h *g,
\&                          const char *device,
\&                          int64_t size);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_ntfsresize\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command is the same as \f(CW\*(C`guestfs_ntfsresize\*(C'\fR except that it allows you
to specify the new size (in bytes) explicitly.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`ntfsprogs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.3.14 において追加)
.SS "guestfs_parse_environment"
.IX Subsection "guestfs_parse_environment"
.Vb 2
\& int
\& guestfs_parse_environment (guestfs_h *g);
.Ve
.PP
Parse the program's environment and set flags in the handle accordingly.
For example if \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR then the 'verbose' flag is set in the
handle.
.PP
\&\fIMost programs do not need to call this\fR.  It is done implicitly when you
call \f(CW\*(C`guestfs_create\*(C'\fR.
.PP
See \*(L"\s-1ENVIRONMENT VARIABLES\*(R"\s0 for a list of environment variables
that can affect libguestfs handles.  See also
\&\*(L"guestfs_create_flags\*(R", and \f(CW\*(C`guestfs_parse_environment_list\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.53 において追加)
.SS "guestfs_parse_environment_list"
.IX Subsection "guestfs_parse_environment_list"
.Vb 3
\& int
\& guestfs_parse_environment_list (guestfs_h *g,
\&                                 char *const *environment);
.Ve
.PP
Parse the list of strings in the argument \f(CW\*(C`environment\*(C'\fR and set flags in
the handle accordingly.  For example if \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR is a string in
the list, then the 'verbose' flag is set in the handle.
.PP
This is the same as \f(CW\*(C`guestfs_parse_environment\*(C'\fR except that it parses an
explicit list of strings instead of the program's environment.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.53 において追加)
.SS "guestfs_part_add"
.IX Subsection "guestfs_part_add"
.Vb 6
\& int
\& guestfs_part_add (guestfs_h *g,
\&                   const char *device,
\&                   const char *prlogex,
\&                   int64_t startsect,
\&                   int64_t endsect);
.Ve
.PP
This command adds a partition to \f(CW\*(C`device\*(C'\fR.  If there is no partition table
on the device, call \f(CW\*(C`guestfs_part_init\*(C'\fR first.
.PP
The \f(CW\*(C`prlogex\*(C'\fR parameter is the type of partition.  Normally you should pass
\&\f(CW\*(C`p\*(C'\fR or \f(CW\*(C`primary\*(C'\fR here, but \s-1MBR\s0 partition tables also support \f(CW\*(C`l\*(C'\fR (or
\&\f(CW\*(C`logical\*(C'\fR) and \f(CW\*(C`e\*(C'\fR (or \f(CW\*(C`extended\*(C'\fR) partition types.
.PP
\&\f(CW\*(C`startsect\*(C'\fR and \f(CW\*(C`endsect\*(C'\fR are the start and end of the partition in
\&\fIsectors\fR.  \f(CW\*(C`endsect\*(C'\fR may be negative, which means it counts backwards
from the end of the disk (\f(CW\*(C`\-1\*(C'\fR is the last sector).
.PP
Creating a partition which covers the whole disk is not so easy.  Use
\&\f(CW\*(C`guestfs_part_disk\*(C'\fR to do that.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.78 において追加)
.SS "guestfs_part_del"
.IX Subsection "guestfs_part_del"
.Vb 4
\& int
\& guestfs_part_del (guestfs_h *g,
\&                   const char *device,
\&                   int partnum);
.Ve
.PP
このコマンドは \f(CW\*(C`device\*(C'\fR にある \f(CW\*(C`partnum\*(C'\fR 番のパーティションを削除します。
.PP
Note that in the case of \s-1MBR\s0 partitioning, deleting an extended partition
also deletes any logical partitions it contains.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.2 において追加)
.SS "guestfs_part_disk"
.IX Subsection "guestfs_part_disk"
.Vb 4
\& int
\& guestfs_part_disk (guestfs_h *g,
\&                    const char *device,
\&                    const char *parttype);
.Ve
.PP
This command is simply a combination of \f(CW\*(C`guestfs_part_init\*(C'\fR followed by
\&\f(CW\*(C`guestfs_part_add\*(C'\fR to create a single primary partition covering the whole
disk.
.PP
\&\f(CW\*(C`parttype\*(C'\fR is the partition table type, usually \f(CW\*(C`mbr\*(C'\fR or \f(CW\*(C`gpt\*(C'\fR, but other
possible values are described in \f(CW\*(C`guestfs_part_init\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.78 において追加)
.SS "guestfs_part_expand_gpt"
.IX Subsection "guestfs_part_expand_gpt"
.Vb 3
\& int
\& guestfs_part_expand_gpt (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Move backup \s-1GPT\s0 data structures to the end of the disk.  This is useful in
case of in-place image expand since disk space after backup \s-1GPT\s0 header is
not usable.  This is equivalent to \f(CW\*(C`sgdisk \-e\*(C'\fR.
.PP
See also \fIsgdisk\fR\|(8).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.2)
.SS "guestfs_part_get_bootable"
.IX Subsection "guestfs_part_get_bootable"
.Vb 4
\& int
\& guestfs_part_get_bootable (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR にあるパーティション \f(CW\*(C`partnum\*(C'\fR にブート可能フラグが設定されていると、このコマンドは真を返します。
.PP
\&\f(CW\*(C`guestfs_part_set_bootable\*(C'\fR 参照。
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(1.3.2 において追加)
.SS "guestfs_part_get_disk_guid"
.IX Subsection "guestfs_part_get_disk_guid"
.Vb 3
\& char *
\& guestfs_part_get_disk_guid (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
Return the disk identifier (\s-1GUID\s0) of a GPT-partitioned \f(CW\*(C`device\*(C'\fR.  Behaviour
is undefined for other partition types.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.2)
.SS "guestfs_part_get_gpt_guid"
.IX Subsection "guestfs_part_get_gpt_guid"
.Vb 4
\& char *
\& guestfs_part_get_gpt_guid (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
Return the \s-1GUID\s0 of numbered \s-1GPT\s0 partition \f(CW\*(C`partnum\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.25)
.SS "guestfs_part_get_gpt_type"
.IX Subsection "guestfs_part_get_gpt_type"
.Vb 4
\& char *
\& guestfs_part_get_gpt_type (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
Return the type \s-1GUID\s0 of numbered \s-1GPT\s0 partition \f(CW\*(C`partnum\*(C'\fR. For \s-1MBR\s0
partitions, return an appropriate \s-1GUID\s0 corresponding to the \s-1MBR\s0
type. Behaviour is undefined for other partition types.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.21.1 において追加)
.SS "guestfs_part_get_mbr_id"
.IX Subsection "guestfs_part_get_mbr_id"
.Vb 4
\& int
\& guestfs_part_get_mbr_id (guestfs_h *g,
\&                          const char *device,
\&                          int partnum);
.Ve
.PP
Returns the \s-1MBR\s0 type byte (also known as the \s-1ID\s0 byte) from the numbered
partition \f(CW\*(C`partnum\*(C'\fR.
.PP
Note that only \s-1MBR\s0 (old DOS-style) partitions have type bytes.  You will get
undefined results for other partition table types (see
\&\f(CW\*(C`guestfs_part_get_parttype\*(C'\fR).
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.3.2 において追加)
.SS "guestfs_part_get_mbr_part_type"
.IX Subsection "guestfs_part_get_mbr_part_type"
.Vb 4
\& char *
\& guestfs_part_get_mbr_part_type (guestfs_h *g,
\&                                 const char *device,
\&                                 int partnum);
.Ve
.PP
This returns the partition type of an \s-1MBR\s0 partition numbered \f(CW\*(C`partnum\*(C'\fR on
device \f(CW\*(C`device\*(C'\fR.
.PP
It returns \f(CW\*(C`primary\*(C'\fR, \f(CW\*(C`logical\*(C'\fR, or \f(CW\*(C`extended\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.29.32)
.SS "guestfs_part_get_name"
.IX Subsection "guestfs_part_get_name"
.Vb 4
\& char *
\& guestfs_part_get_name (guestfs_h *g,
\&                        const char *device,
\&                        int partnum);
.Ve
.PP
This gets the partition name on partition numbered \f(CW\*(C`partnum\*(C'\fR on device
\&\f(CW\*(C`device\*(C'\fR.  Note that partitions are numbered from 1.
.PP
The partition name can only be read on certain types of partition table.
This works on \f(CW\*(C`gpt\*(C'\fR but not on \f(CW\*(C`mbr\*(C'\fR partitions.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(Added in 1.25.33)
.SS "guestfs_part_get_parttype"
.IX Subsection "guestfs_part_get_parttype"
.Vb 3
\& char *
\& guestfs_part_get_parttype (guestfs_h *g,
\&                            const char *device);
.Ve
.PP
This command examines the partition table on \f(CW\*(C`device\*(C'\fR and returns the
partition table type (format) being used.
.PP
Common return values include: \f(CW\*(C`msdos\*(C'\fR (a DOS/Windows style \s-1MBR\s0 partition
table), \f(CW\*(C`gpt\*(C'\fR (a GPT/EFI\-style partition table).  Other values are
possible, although unusual.  See \f(CW\*(C`guestfs_part_init\*(C'\fR for a full list.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.78 において追加)
.SS "guestfs_part_init"
.IX Subsection "guestfs_part_init"
.Vb 4
\& int
\& guestfs_part_init (guestfs_h *g,
\&                    const char *device,
\&                    const char *parttype);
.Ve
.PP
This creates an empty partition table on \f(CW\*(C`device\*(C'\fR of one of the partition
types listed below.  Usually \f(CW\*(C`parttype\*(C'\fR should be either \f(CW\*(C`msdos\*(C'\fR or \f(CW\*(C`gpt\*(C'\fR
(for large disks).
.PP
Initially there are no partitions.  Following this, you should call
\&\f(CW\*(C`guestfs_part_add\*(C'\fR for each partition required.
.PP
Possible values for \f(CW\*(C`parttype\*(C'\fR are:
.IP "\fBefi\fR" 4
.IX Item "efi"
.PD 0
.IP "\fBgpt\fR" 4
.IX Item "gpt"
.PD
Intel \s-1EFI / GPT\s0 パーティションテーブル。
.Sp
This is recommended for >= 2 \s-1TB\s0 partitions that will be accessed from Linux
and Intel-based Mac \s-1OS X.\s0  It also has limited backwards compatibility with
the \f(CW\*(C`mbr\*(C'\fR format.
.IP "\fBmbr\fR" 4
.IX Item "mbr"
.PD 0
.IP "\fBmsdos\fR" 4
.IX Item "msdos"
.PD
The standard \s-1PC\s0 \*(L"Master Boot Record\*(R" (\s-1MBR\s0) format used by MS-DOS and
Windows.  This partition type will \fBonly\fR work for device sizes up to 2
\&\s-1TB.\s0  For large disks we recommend using \f(CW\*(C`gpt\*(C'\fR.
.PP
Other partition table types that may work but are not supported include:
.IP "\fBaix\fR" 4
.IX Item "aix"
\&\s-1AIX\s0 ディスクラベル。
.IP "\fBamiga\fR" 4
.IX Item "amiga"
.PD 0
.IP "\fBrdb\fR" 4
.IX Item "rdb"
.PD
Amiga \*(L"Rigid Disk Block\*(R" 形式。
.IP "\fBbsd\fR" 4
.IX Item "bsd"
\&\s-1BSD\s0 ディスクラベル.
.IP "\fBdasd\fR" 4
.IX Item "dasd"
\&\s-1DASD, IBM\s0 メインフレームにおいて使用.
.IP "\fBdvh\fR" 4
.IX Item "dvh"
\&\s-1MIPS/SGI\s0 ボリューム.
.IP "\fBmac\fR" 4
.IX Item "mac"
古い Mac パーティション形式。最近の Mac は \f(CW\*(C`gpt\*(C'\fR を使用します。
.IP "\fBpc98\fR" 4
.IX Item "pc98"
\&\s-1NEC PC\-98\s0 形式。日本において一般的に見られます。
.IP "\fBsun\fR" 4
.IX Item "sun"
Sun ディスクラベル
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.78 において追加)
.SS "guestfs_part_list"
.IX Subsection "guestfs_part_list"
.Vb 3
\& struct guestfs_partition_list *
\& guestfs_part_list (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This command parses the partition table on \f(CW\*(C`device\*(C'\fR and returns the list of
partitions found.
.PP
The fields in the returned structure are:
.IP "\fBpart_num\fR" 4
.IX Item "part_num"
パーティション番号。1 から数えます。
.IP "\fBpart_start\fR" 4
.IX Item "part_start"
Start of the partition \fIin bytes\fR.  To get sectors you have to divide by
the device's sector size, see \f(CW\*(C`guestfs_blockdev_getss\*(C'\fR.
.IP "\fBpart_end\fR" 4
.IX Item "part_end"
バイト単位のパーティションの終了位置。
.IP "\fBpart_size\fR" 4
.IX Item "part_size"
バイト単位のパーティション容量。
.PP
This function returns a \f(CW\*(C`struct guestfs_partition_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_partition_list\*(C'\fI after
use\fR.
.PP
(1.0.78 において追加)
.SS "guestfs_part_set_bootable"
.IX Subsection "guestfs_part_set_bootable"
.Vb 5
\& int
\& guestfs_part_set_bootable (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            int bootable);
.Ve
.PP
デバイス \f(CW\*(C`device\*(C'\fR のパーティション番号 \f(CW\*(C`partnum\*(C'\fR にブート可能フラグを設定します。パーティションは 1
から番号が始まることに注意してください。
.PP
The bootable flag is used by some operating systems (notably Windows) to
determine which partition to boot from.  It is by no means universally
recognized.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.78 において追加)
.SS "guestfs_part_set_disk_guid"
.IX Subsection "guestfs_part_set_disk_guid"
.Vb 4
\& int
\& guestfs_part_set_disk_guid (guestfs_h *g,
\&                             const char *device,
\&                             const char *guid);
.Ve
.PP
Set the disk identifier (\s-1GUID\s0) of a GPT-partitioned \f(CW\*(C`device\*(C'\fR to \f(CW\*(C`guid\*(C'\fR.
Return an error if the partition table of \f(CW\*(C`device\*(C'\fR isn't \s-1GPT,\s0 or if \f(CW\*(C`guid\*(C'\fR
is not a valid \s-1GUID.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.2)
.SS "guestfs_part_set_disk_guid_random"
.IX Subsection "guestfs_part_set_disk_guid_random"
.Vb 3
\& int
\& guestfs_part_set_disk_guid_random (guestfs_h *g,
\&                                    const char *device);
.Ve
.PP
Set the disk identifier (\s-1GUID\s0) of a GPT-partitioned \f(CW\*(C`device\*(C'\fR to a randomly
generated value.  Return an error if the partition table of \f(CW\*(C`device\*(C'\fR isn't
\&\s-1GPT.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.2)
.SS "guestfs_part_set_gpt_guid"
.IX Subsection "guestfs_part_set_gpt_guid"
.Vb 5
\& int
\& guestfs_part_set_gpt_guid (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            const char *guid);
.Ve
.PP
Set the \s-1GUID\s0 of numbered \s-1GPT\s0 partition \f(CW\*(C`partnum\*(C'\fR to \f(CW\*(C`guid\*(C'\fR.  Return an
error if the partition table of \f(CW\*(C`device\*(C'\fR isn't \s-1GPT,\s0 or if \f(CW\*(C`guid\*(C'\fR is not a
valid \s-1GUID.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.29.25)
.SS "guestfs_part_set_gpt_type"
.IX Subsection "guestfs_part_set_gpt_type"
.Vb 5
\& int
\& guestfs_part_set_gpt_type (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            const char *guid);
.Ve
.PP
Set the type \s-1GUID\s0 of numbered \s-1GPT\s0 partition \f(CW\*(C`partnum\*(C'\fR to \f(CW\*(C`guid\*(C'\fR. Return an
error if the partition table of \f(CW\*(C`device\*(C'\fR isn't \s-1GPT,\s0 or if \f(CW\*(C`guid\*(C'\fR is not a
valid \s-1GUID.\s0
.PP
See
http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
for a useful list of type GUIDs.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`gdisk\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.21.1 において追加)
.SS "guestfs_part_set_mbr_id"
.IX Subsection "guestfs_part_set_mbr_id"
.Vb 5
\& int
\& guestfs_part_set_mbr_id (guestfs_h *g,
\&                          const char *device,
\&                          int partnum,
\&                          int idbyte);
.Ve
.PP
Sets the \s-1MBR\s0 type byte (also known as the \s-1ID\s0 byte) of the numbered partition
\&\f(CW\*(C`partnum\*(C'\fR to \f(CW\*(C`idbyte\*(C'\fR.  Note that the type bytes quoted in most
documentation are in fact hexadecimal numbers, but usually documented
without any leading \*(L"0x\*(R" which might be confusing.
.PP
Note that only \s-1MBR\s0 (old DOS-style) partitions have type bytes.  You will get
undefined results for other partition table types (see
\&\f(CW\*(C`guestfs_part_get_parttype\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.2 において追加)
.SS "guestfs_part_set_name"
.IX Subsection "guestfs_part_set_name"
.Vb 5
\& int
\& guestfs_part_set_name (guestfs_h *g,
\&                        const char *device,
\&                        int partnum,
\&                        const char *name);
.Ve
.PP
This sets the partition name on partition numbered \f(CW\*(C`partnum\*(C'\fR on device
\&\f(CW\*(C`device\*(C'\fR.  Note that partitions are numbered from 1.
.PP
The partition name can only be set on certain types of partition table.
This works on \f(CW\*(C`gpt\*(C'\fR but not on \f(CW\*(C`mbr\*(C'\fR partitions.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.78 において追加)
.SS "guestfs_part_to_dev"
.IX Subsection "guestfs_part_to_dev"
.Vb 3
\& char *
\& guestfs_part_to_dev (guestfs_h *g,
\&                      const char *partition);
.Ve
.PP
This function takes a partition name (eg. \*(L"/dev/sdb1\*(R") and removes the
partition number, returning the device name (eg. \*(L"/dev/sdb\*(R").
.PP
The named partition must exist, for example as a string returned from
\&\f(CW\*(C`guestfs_list_partitions\*(C'\fR.
.PP
\&\f(CW\*(C`guestfs_part_to_partnum\*(C'\fR, \f(CW\*(C`guestfs_device_index\*(C'\fR 参照。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.5.15 において追加)
.SS "guestfs_part_to_partnum"
.IX Subsection "guestfs_part_to_partnum"
.Vb 3
\& int
\& guestfs_part_to_partnum (guestfs_h *g,
\&                          const char *partition);
.Ve
.PP
This function takes a partition name (eg. \*(L"/dev/sdb1\*(R") and returns the
partition number (eg. \f(CW1\fR).
.PP
The named partition must exist, for example as a string returned from
\&\f(CW\*(C`guestfs_list_partitions\*(C'\fR.
.PP
\&\f(CW\*(C`guestfs_part_to_dev\*(C'\fR 参照。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.13.25 において追加)
.SS "guestfs_ping_daemon"
.IX Subsection "guestfs_ping_daemon"
.Vb 2
\& int
\& guestfs_ping_daemon (guestfs_h *g);
.Ve
.PP
This is a test probe into the guestfs daemon running inside the libguestfs
appliance.  Calling this function checks that the daemon responds to the
ping message, without affecting the daemon or attached block device(s) in
any other way.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.18 において追加)
.SS "guestfs_pread"
.IX Subsection "guestfs_pread"
.Vb 6
\& char *
\& guestfs_pread (guestfs_h *g,
\&                const char *path,
\&                int count,
\&                int64_t offset,
\&                size_t *size_r);
.Ve
.PP
This command lets you read part of a file.  It reads \f(CW\*(C`count\*(C'\fR bytes of the
file, starting at \f(CW\*(C`offset\*(C'\fR, from file \f(CW\*(C`path\*(C'\fR.
.PP
This may read fewer bytes than requested.  For further details see the
\&\fIpread\fR\|(2) system call.
.PP
\&\f(CW\*(C`guestfs_pwrite\*(C'\fR, \f(CW\*(C`guestfs_pread_device\*(C'\fR 参照。
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.77 において追加)
.SS "guestfs_pread_device"
.IX Subsection "guestfs_pread_device"
.Vb 6
\& char *
\& guestfs_pread_device (guestfs_h *g,
\&                       const char *device,
\&                       int count,
\&                       int64_t offset,
\&                       size_t *size_r);
.Ve
.PP
This command lets you read part of a block device.  It reads \f(CW\*(C`count\*(C'\fR bytes
of \f(CW\*(C`device\*(C'\fR, starting at \f(CW\*(C`offset\*(C'\fR.
.PP
This may read fewer bytes than requested.  For further details see the
\&\fIpread\fR\|(2) system call.
.PP
\&\f(CW\*(C`guestfs_pread\*(C'\fR 参照。
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.5.21 において追加)
.SS "guestfs_pvchange_uuid"
.IX Subsection "guestfs_pvchange_uuid"
.Vb 3
\& int
\& guestfs_pvchange_uuid (guestfs_h *g,
\&                        const char *device);
.Ve
.PP
物理ボリューム \f(CW\*(C`device\*(C'\fR に対する新しいランダムな \s-1UUID\s0 を生成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.26 において追加)
.SS "guestfs_pvchange_uuid_all"
.IX Subsection "guestfs_pvchange_uuid_all"
.Vb 2
\& int
\& guestfs_pvchange_uuid_all (guestfs_h *g);
.Ve
.PP
すべての物理ボリュームに対する新しいランダムな \s-1UUID\s0 を生成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.26 において追加)
.SS "guestfs_pvcreate"
.IX Subsection "guestfs_pvcreate"
.Vb 3
\& int
\& guestfs_pvcreate (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This creates an \s-1LVM\s0 physical volume on the named \f(CW\*(C`device\*(C'\fR, where \f(CW\*(C`device\*(C'\fR
should usually be a partition name such as \fI/dev/sda1\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.8 において追加)
.SS "guestfs_pvremove"
.IX Subsection "guestfs_pvremove"
.Vb 3
\& int
\& guestfs_pvremove (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This wipes a physical volume \f(CW\*(C`device\*(C'\fR so that \s-1LVM\s0 will no longer recognise
it.
.PP
The implementation uses the \f(CW\*(C`pvremove\*(C'\fR command which refuses to wipe
physical volumes that contain any volume groups, so you have to remove those
first.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.13 において追加)
.SS "guestfs_pvresize"
.IX Subsection "guestfs_pvresize"
.Vb 3
\& int
\& guestfs_pvresize (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This resizes (expands or shrinks) an existing \s-1LVM\s0 physical volume to match
the new size of the underlying device.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.26 において追加)
.SS "guestfs_pvresize_size"
.IX Subsection "guestfs_pvresize_size"
.Vb 4
\& int
\& guestfs_pvresize_size (guestfs_h *g,
\&                        const char *device,
\&                        int64_t size);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_pvresize\*(C'\fR except that it allows you to
specify the new size (in bytes) explicitly.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.3.14 において追加)
.SS "guestfs_pvs"
.IX Subsection "guestfs_pvs"
.Vb 2
\& char **
\& guestfs_pvs (guestfs_h *g);
.Ve
.PP
List all the physical volumes detected.  This is the equivalent of the
\&\fIpvs\fR\|(8) command.
.PP
This returns a list of just the device names that contain PVs
(eg. \fI/dev/sda2\fR).
.PP
\&\f(CW\*(C`guestfs_pvs_full\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.4 において追加)
.SS "guestfs_pvs_full"
.IX Subsection "guestfs_pvs_full"
.Vb 2
\& struct guestfs_lvm_pv_list *
\& guestfs_pvs_full (guestfs_h *g);
.Ve
.PP
List all the physical volumes detected.  This is the equivalent of the
\&\fIpvs\fR\|(8) command.  The \*(L"full\*(R" version includes all fields.
.PP
This function returns a \f(CW\*(C`struct guestfs_lvm_pv_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_lvm_pv_list\*(C'\fI after
use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.4 において追加)
.SS "guestfs_pvuuid"
.IX Subsection "guestfs_pvuuid"
.Vb 3
\& char *
\& guestfs_pvuuid (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
このコマンドは \s-1LVM PV\s0 \f(CW\*(C`device\*(C'\fR の \s-1UUID\s0 を返します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.87 において追加)
.SS "guestfs_pwrite"
.IX Subsection "guestfs_pwrite"
.Vb 6
\& int
\& guestfs_pwrite (guestfs_h *g,
\&                 const char *path,
\&                 const char *content,
\&                 size_t content_size,
\&                 int64_t offset);
.Ve
.PP
This command writes to part of a file.  It writes the data buffer \f(CW\*(C`content\*(C'\fR
to the file \f(CW\*(C`path\*(C'\fR starting at offset \f(CW\*(C`offset\*(C'\fR.
.PP
This command implements the \fIpwrite\fR\|(2) system call, and like that system
call it may not write the full data requested.  The return value is the
number of bytes that were actually written to the file.  This could even be
0, although short writes are unlikely for regular files in ordinary
circumstances.
.PP
\&\f(CW\*(C`guestfs_pread\*(C'\fR, \f(CW\*(C`guestfs_pwrite_device\*(C'\fR 参照。
.PP
この関数はエラーのとき \-1 を返します。
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.3.14 において追加)
.SS "guestfs_pwrite_device"
.IX Subsection "guestfs_pwrite_device"
.Vb 6
\& int
\& guestfs_pwrite_device (guestfs_h *g,
\&                        const char *device,
\&                        const char *content,
\&                        size_t content_size,
\&                        int64_t offset);
.Ve
.PP
This command writes to part of a device.  It writes the data buffer
\&\f(CW\*(C`content\*(C'\fR to \f(CW\*(C`device\*(C'\fR starting at offset \f(CW\*(C`offset\*(C'\fR.
.PP
This command implements the \fIpwrite\fR\|(2) system call, and like that system
call it may not write the full data requested (although short writes to disk
devices and partitions are probably impossible with standard Linux kernels).
.PP
\&\f(CW\*(C`guestfs_pwrite\*(C'\fR 参照。
.PP
この関数はエラーのとき \-1 を返します。
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.5.20 において追加)
.SS "guestfs_read_file"
.IX Subsection "guestfs_read_file"
.Vb 4
\& char *
\& guestfs_read_file (guestfs_h *g,
\&                    const char *path,
\&                    size_t *size_r);
.Ve
.PP
This calls returns the contents of the file \f(CW\*(C`path\*(C'\fR as a buffer.
.PP
Unlike \f(CW\*(C`guestfs_cat\*(C'\fR, this function can correctly handle files that contain
embedded \s-1ASCII NUL\s0 characters.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
(1.0.63 において追加)
.SS "guestfs_read_lines"
.IX Subsection "guestfs_read_lines"
.Vb 3
\& char **
\& guestfs_read_lines (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR という名前のファイルの内容を返します。
.PP
The file contents are returned as a list of lines.  Trailing \f(CW\*(C`LF\*(C'\fR and
\&\f(CW\*(C`CRLF\*(C'\fR character sequences are \fInot\fR returned.
.PP
Note that this function cannot correctly handle binary files (specifically,
files containing \f(CW\*(C`\e0\*(C'\fR character which is treated as end of string).  For
those you need to use the \f(CW\*(C`guestfs_read_file\*(C'\fR function and split the buffer
into lines yourself.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(0.7 において追加)
.SS "guestfs_readdir"
.IX Subsection "guestfs_readdir"
.Vb 3
\& struct guestfs_dirent_list *
\& guestfs_readdir (guestfs_h *g,
\&                  const char *dir);
.Ve
.PP
This returns the list of directory entries in directory \f(CW\*(C`dir\*(C'\fR.
.PP
All entries in the directory are returned, including \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR.  The
entries are \fInot\fR sorted, but returned in the same order as the underlying
filesystem.
.PP
Also this call returns basic file type information about each file.  The
\&\f(CW\*(C`ftyp\*(C'\fR field will contain one of the following characters:
.IP "'b'" 4
.IX Item "'b'"
ブロック特殊
.IP "'c'" 4
.IX Item "'c'"
キャラクター特殊
.IP "'d'" 4
.IX Item "'d'"
ディレクトリ
.IP "'f'" 4
.IX Item "'f'"
\&\s-1FIFO\s0 (名前付きパイプ)
.IP "'l'" 4
.IX Item "'l'"
シンボリックリンク
.IP "'r'" 4
.IX Item "'r'"
通常のファイル
.IP "'s'" 4
.IX Item "'s'"
ソケット
.IP "'u'" 4
.IX Item "'u'"
未知のファイル種別
.IP "'?'" 4
The \fIreaddir\fR\|(3) call returned a \f(CW\*(C`d_type\*(C'\fR field with an unexpected value
.PP
This function is primarily intended for use by programs.  To get a simple
list of names, use \f(CW\*(C`guestfs_ls\*(C'\fR.  To get a printable directory for human
consumption, use \f(CW\*(C`guestfs_ll\*(C'\fR.
.PP
この関数は \f(CW\*(C`struct guestfs_dirent_list *\*(C'\fR を返します。もしくは、エラーが発生すると \s-1NULL\s0 を返します。
\&\fI呼び出し元は使用後に \f(CI\*(C`guestfs_free_dirent_list\*(C'\fI を呼び出す必要があります\fR。
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.55 において追加)
.SS "guestfs_readlink"
.IX Subsection "guestfs_readlink"
.Vb 3
\& char *
\& guestfs_readlink (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
このコマンドはシンボリックリンクの参照先を読み込みます。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.66 において追加)
.SS "guestfs_readlinklist"
.IX Subsection "guestfs_readlinklist"
.Vb 4
\& char **
\& guestfs_readlinklist (guestfs_h *g,
\&                       const char *path,
\&                       char *const *names);
.Ve
.PP
This call allows you to do a \f(CW\*(C`readlink\*(C'\fR operation on multiple files, where
all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list of files from
this directory.
.PP
On return you get a list of strings, with a one-to-one correspondence to the
\&\f(CW\*(C`names\*(C'\fR list.  Each string is the value of the symbolic link.
.PP
If the \fIreadlink\fR\|(2) operation fails on any name, then the corresponding
result string is the empty string \f(CW""\fR.  However the whole operation is
completed even if there were \fIreadlink\fR\|(2) errors, and so you can call this
function with names where you don't know if they are symbolic links already
(albeit slightly less efficient).
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.77 において追加)
.SS "guestfs_realpath"
.IX Subsection "guestfs_realpath"
.Vb 3
\& char *
\& guestfs_realpath (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
Return the canonicalized absolute pathname of \f(CW\*(C`path\*(C'\fR.  The returned path
has no \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`..\*(C'\fR or symbolic link path elements.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.66 において追加)
.SS "guestfs_remount"
.IX Subsection "guestfs_remount"
.Vb 4
\& int
\& guestfs_remount (guestfs_h *g,
\&                  const char *mountpoint,
\&                  ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_REMOUNT_RW, int rw,
.Ve
.PP
This call allows you to change the \f(CW\*(C`rw\*(C'\fR (readonly/read\-write)  flag on an
already mounted filesystem at \f(CW\*(C`mountpoint\*(C'\fR, converting a readonly
filesystem to be read-write, or vice-versa.
.PP
Note that at the moment you must supply the \*(L"optional\*(R" \f(CW\*(C`rw\*(C'\fR parameter.  In
future we may allow other flags to be adjusted.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.23.2)
.SS "guestfs_remount_va"
.IX Subsection "guestfs_remount_va"
.Vb 4
\& int
\& guestfs_remount_va (guestfs_h *g,
\&                     const char *mountpoint,
\&                     va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_remount\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_remount_argv"
.IX Subsection "guestfs_remount_argv"
.Vb 4
\& int
\& guestfs_remount_argv (guestfs_h *g,
\&                       const char *mountpoint,
\&                       const struct guestfs_remount_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_remount\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_remove_drive"
.IX Subsection "guestfs_remove_drive"
.Vb 3
\& int
\& guestfs_remove_drive (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
This function is conceptually the opposite of \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR.  It
removes the drive that was previously added with label \f(CW\*(C`label\*(C'\fR.
.PP
Note that in order to remove drives, you have to add them with labels (see
the optional \f(CW\*(C`label\*(C'\fR argument to \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR).  If you didn't
use a label, then they cannot be removed.
.PP
You can call this function before or after launching the handle.  If called
after launch, if the backend supports it, we try to hot unplug the drive:
see \*(L"\s-1HOTPLUGGING\*(R"\s0.  The disk \fBmust not\fR be in use (eg. mounted)
when you do this.  We try to detect if the disk is in use and stop you from
doing this.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.49 において追加)
.SS "guestfs_removexattr"
.IX Subsection "guestfs_removexattr"
.Vb 4
\& int
\& guestfs_removexattr (guestfs_h *g,
\&                      const char *xattr,
\&                      const char *path);
.Ve
.PP
This call removes the extended attribute named \f(CW\*(C`xattr\*(C'\fR of the file \f(CW\*(C`path\*(C'\fR.
.PP
関連項目: \f(CW\*(C`guestfs_lremovexattr\*(C'\fR, \fIattr\fR\|(5)
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.59 において追加)
.SS "guestfs_rename"
.IX Subsection "guestfs_rename"
.Vb 4
\& int
\& guestfs_rename (guestfs_h *g,
\&                 const char *oldpath,
\&                 const char *newpath);
.Ve
.PP
Rename a file to a new place on the same filesystem.  This is the same as
the Linux \fIrename\fR\|(2) system call.  In most cases you are better to use
\&\f(CW\*(C`guestfs_mv\*(C'\fR instead.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.21.5 において追加)
.SS "guestfs_resize2fs"
.IX Subsection "guestfs_resize2fs"
.Vb 3
\& int
\& guestfs_resize2fs (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This resizes an ext2, ext3 or ext4 filesystem to match the size of the
underlying device.
.PP
See also \*(L"\s-1RESIZE2FS ERRORS\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.27 において追加)
.SS "guestfs_resize2fs_M"
.IX Subsection "guestfs_resize2fs_M"
.Vb 3
\& int
\& guestfs_resize2fs_M (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_resize2fs\*(C'\fR, but the filesystem is
resized to its minimum size.  This works like the \fI\-M\fR option to the
\&\f(CW\*(C`resize2fs\*(C'\fR command.
.PP
To get the resulting size of the filesystem you should call
\&\f(CW\*(C`guestfs_tune2fs_l\*(C'\fR and read the \f(CW\*(C`Block size\*(C'\fR and \f(CW\*(C`Block count\*(C'\fR values.
These two numbers, multiplied together, give the resulting size of the
minimal filesystem in bytes.
.PP
See also \*(L"\s-1RESIZE2FS ERRORS\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.9.4 において追加)
.SS "guestfs_resize2fs_size"
.IX Subsection "guestfs_resize2fs_size"
.Vb 4
\& int
\& guestfs_resize2fs_size (guestfs_h *g,
\&                         const char *device,
\&                         int64_t size);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_resize2fs\*(C'\fR except that it allows you
to specify the new size (in bytes) explicitly.
.PP
See also \*(L"\s-1RESIZE2FS ERRORS\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.14 において追加)
.SS "guestfs_rm"
.IX Subsection "guestfs_rm"
.Vb 3
\& int
\& guestfs_rm (guestfs_h *g,
\&             const char *path);
.Ve
.PP
単一ファイル \f(CW\*(C`path\*(C'\fR を削除します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_rm_f"
.IX Subsection "guestfs_rm_f"
.Vb 3
\& int
\& guestfs_rm_f (guestfs_h *g,
\&               const char *path);
.Ve
.PP
ファイル \f(CW\*(C`path\*(C'\fR を削除します。
.PP
ファイルが存在しない場合、そのエラーは無視されます。（I/O エラーや不正なパスなど、他のエラーは無視されません）
.PP
This call cannot remove directories.  Use \f(CW\*(C`guestfs_rmdir\*(C'\fR to remove an
empty directory, or \f(CW\*(C`guestfs_rm_rf\*(C'\fR to remove directories recursively.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.42 において追加)
.SS "guestfs_rm_rf"
.IX Subsection "guestfs_rm_rf"
.Vb 3
\& int
\& guestfs_rm_rf (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Remove the file or directory \f(CW\*(C`path\*(C'\fR, recursively removing the contents if
its a directory.  This is like the \f(CW\*(C`rm \-rf\*(C'\fR shell command.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_rmdir"
.IX Subsection "guestfs_rmdir"
.Vb 3
\& int
\& guestfs_rmdir (guestfs_h *g,
\&                const char *path);
.Ve
.PP
単一ディレクトリ \f(CW\*(C`path\*(C'\fR を削除します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_rmmountpoint"
.IX Subsection "guestfs_rmmountpoint"
.Vb 3
\& int
\& guestfs_rmmountpoint (guestfs_h *g,
\&                       const char *exemptpath);
.Ve
.PP
This calls removes a mountpoint that was previously created with
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR.  See \f(CW\*(C`guestfs_mkmountpoint\*(C'\fR for full details.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.62 において追加)
.SS "guestfs_rsync"
.IX Subsection "guestfs_rsync"
.Vb 5
\& int
\& guestfs_rsync (guestfs_h *g,
\&                const char *src,
\&                const char *dest,
\&                ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_RSYNC_ARCHIVE, int archive,
\& GUESTFS_RSYNC_DELETEDEST, int deletedest,
.Ve
.PP
This call may be used to copy or synchronize two directories under the same
libguestfs handle.  This uses the \fIrsync\fR\|(1) program which uses a fast
algorithm that avoids copying files unnecessarily.
.PP
\&\f(CW\*(C`src\*(C'\fR and \f(CW\*(C`dest\*(C'\fR are the source and destination directories.  Files are
copied from \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR.
.PP
オプション引数は次のとおりです:
.ie n .IP """archive""" 4
.el .IP "\f(CWarchive\fR" 4
.IX Item "archive"
Turns on archive mode.  This is the same as passing the \fI\-\-archive\fR flag to
\&\f(CW\*(C`rsync\*(C'\fR.
.ie n .IP """deletedest""" 4
.el .IP "\f(CWdeletedest\fR" 4
.IX Item "deletedest"
Delete files at the destination that do not exist at the source.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`rsync\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.29 において追加)
.SS "guestfs_rsync_va"
.IX Subsection "guestfs_rsync_va"
.Vb 5
\& int
\& guestfs_rsync_va (guestfs_h *g,
\&                   const char *src,
\&                   const char *dest,
\&                   va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_rsync\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_rsync_argv"
.IX Subsection "guestfs_rsync_argv"
.Vb 5
\& int
\& guestfs_rsync_argv (guestfs_h *g,
\&                     const char *src,
\&                     const char *dest,
\&                     const struct guestfs_rsync_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_rsync\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_rsync_in"
.IX Subsection "guestfs_rsync_in"
.Vb 5
\& int
\& guestfs_rsync_in (guestfs_h *g,
\&                   const char *remote,
\&                   const char *dest,
\&                   ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_RSYNC_IN_ARCHIVE, int archive,
\& GUESTFS_RSYNC_IN_DELETEDEST, int deletedest,
.Ve
.PP
This call may be used to copy or synchronize the filesystem on the host or
on a remote computer with the filesystem within libguestfs.  This uses the
\&\fIrsync\fR\|(1) program which uses a fast algorithm that avoids copying files
unnecessarily.
.PP
This call only works if the network is enabled.  See \f(CW\*(C`guestfs_set_network\*(C'\fR
or the \fI\-\-network\fR option to various tools like \fIguestfish\fR\|(1).
.PP
Files are copied from the remote server and directory specified by \f(CW\*(C`remote\*(C'\fR
to the destination directory \f(CW\*(C`dest\*(C'\fR.
.PP
The format of the remote server string is defined by \fIrsync\fR\|(1).  Note that
there is no way to supply a password or passphrase so the target must be set
up not to require one.
.PP
オプションの引数は \f(CW\*(C`guestfs_rsync\*(C'\fR のものと同じです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`rsync\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.29 において追加)
.SS "guestfs_rsync_in_va"
.IX Subsection "guestfs_rsync_in_va"
.Vb 5
\& int
\& guestfs_rsync_in_va (guestfs_h *g,
\&                      const char *remote,
\&                      const char *dest,
\&                      va_list args);
.Ve
.PP
これは \*(L"guestfs_rsync_in\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_rsync_in_argv"
.IX Subsection "guestfs_rsync_in_argv"
.Vb 5
\& int
\& guestfs_rsync_in_argv (guestfs_h *g,
\&                        const char *remote,
\&                        const char *dest,
\&                        const struct guestfs_rsync_in_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_rsync_in\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_rsync_out"
.IX Subsection "guestfs_rsync_out"
.Vb 5
\& int
\& guestfs_rsync_out (guestfs_h *g,
\&                    const char *src,
\&                    const char *remote,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_RSYNC_OUT_ARCHIVE, int archive,
\& GUESTFS_RSYNC_OUT_DELETEDEST, int deletedest,
.Ve
.PP
This call may be used to copy or synchronize the filesystem within
libguestfs with a filesystem on the host or on a remote computer.  This uses
the \fIrsync\fR\|(1) program which uses a fast algorithm that avoids copying
files unnecessarily.
.PP
This call only works if the network is enabled.  See \f(CW\*(C`guestfs_set_network\*(C'\fR
or the \fI\-\-network\fR option to various tools like \fIguestfish\fR\|(1).
.PP
Files are copied from the source directory \f(CW\*(C`src\*(C'\fR to the remote server and
directory specified by \f(CW\*(C`remote\*(C'\fR.
.PP
The format of the remote server string is defined by \fIrsync\fR\|(1).  Note that
there is no way to supply a password or passphrase so the target must be set
up not to require one.
.PP
オプションの引数は \f(CW\*(C`guestfs_rsync\*(C'\fR のものと同じです。
.PP
Globbing does not happen on the \f(CW\*(C`src\*(C'\fR parameter.  In programs which use the
\&\s-1API\s0 directly you have to expand wildcards yourself (see
\&\f(CW\*(C`guestfs_glob_expand\*(C'\fR).  In guestfish you can use the \f(CW\*(C`glob\*(C'\fR command (see
\&\*(L"glob\*(R" in \fIguestfish\fR\|(1)), for example:
.PP
.Vb 1
\& ><fs> glob rsync\-out /* rsync://remote/
.Ve
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`rsync\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.29 において追加)
.SS "guestfs_rsync_out_va"
.IX Subsection "guestfs_rsync_out_va"
.Vb 5
\& int
\& guestfs_rsync_out_va (guestfs_h *g,
\&                       const char *src,
\&                       const char *remote,
\&                       va_list args);
.Ve
.PP
これは \*(L"guestfs_rsync_out\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_rsync_out_argv"
.IX Subsection "guestfs_rsync_out_argv"
.Vb 5
\& int
\& guestfs_rsync_out_argv (guestfs_h *g,
\&                         const char *src,
\&                         const char *remote,
\&                         const struct guestfs_rsync_out_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_rsync_out\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_scrub_device"
.IX Subsection "guestfs_scrub_device"
.Vb 3
\& int
\& guestfs_scrub_device (guestfs_h *g,
\&                       const char *device);
.Ve
.PP
This command writes patterns over \f(CW\*(C`device\*(C'\fR to make data retrieval more
difficult.
.PP
It is an interface to the \fIscrub\fR\|(1) program.  See that manual page for
more details.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`scrub\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.52 において追加)
.SS "guestfs_scrub_file"
.IX Subsection "guestfs_scrub_file"
.Vb 3
\& int
\& guestfs_scrub_file (guestfs_h *g,
\&                     const char *file);
.Ve
.PP
This command writes patterns over a file to make data retrieval more
difficult.
.PP
The file is \fIremoved\fR after scrubbing.
.PP
It is an interface to the \fIscrub\fR\|(1) program.  See that manual page for
more details.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`scrub\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.52 において追加)
.SS "guestfs_scrub_freespace"
.IX Subsection "guestfs_scrub_freespace"
.Vb 3
\& int
\& guestfs_scrub_freespace (guestfs_h *g,
\&                          const char *dir);
.Ve
.PP
This command creates the directory \f(CW\*(C`dir\*(C'\fR and then fills it with files until
the filesystem is full, and scrubs the files as for \f(CW\*(C`guestfs_scrub_file\*(C'\fR,
and deletes them.  The intention is to scrub any free space on the partition
containing \f(CW\*(C`dir\*(C'\fR.
.PP
It is an interface to the \fIscrub\fR\|(1) program.  See that manual page for
more details.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`scrub\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.52 において追加)
.SS "guestfs_selinux_relabel"
.IX Subsection "guestfs_selinux_relabel"
.Vb 5
\& int
\& guestfs_selinux_relabel (guestfs_h *g,
\&                          const char *specfile,
\&                          const char *path,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_SELINUX_RELABEL_FORCE, int force,
.Ve
.PP
SELinux relabel parts of the filesystem.
.PP
The \f(CW\*(C`specfile\*(C'\fR parameter controls the policy spec file used.  You have to
parse \f(CW\*(C`/etc/selinux/config\*(C'\fR to find the correct SELinux policy and then
pass the spec file, usually: \f(CW\*(C`/etc/selinux/\*(C'\fR + \fIselinuxtype\fR +
\&\f(CW\*(C`/contexts/files/file_contexts\*(C'\fR.
.PP
The required \f(CW\*(C`path\*(C'\fR parameter is the top level directory where relabelling
starts.  Normally you should pass \f(CW\*(C`path\*(C'\fR as \f(CW\*(C`/\*(C'\fR to relabel the whole guest
filesystem.
.PP
The optional \f(CW\*(C`force\*(C'\fR boolean controls whether the context is reset for
customizable files, and also whether the user, role and range parts of the
file context is changed.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`selinuxrelabel\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(Added in 1.33.43)
.SS "guestfs_selinux_relabel_va"
.IX Subsection "guestfs_selinux_relabel_va"
.Vb 5
\& int
\& guestfs_selinux_relabel_va (guestfs_h *g,
\&                             const char *specfile,
\&                             const char *path,
\&                             va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_selinux_relabel\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_selinux_relabel_argv"
.IX Subsection "guestfs_selinux_relabel_argv"
.Vb 5
\& int
\& guestfs_selinux_relabel_argv (guestfs_h *g,
\&                               const char *specfile,
\&                               const char *path,
\&                               const struct guestfs_selinux_relabel_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_selinux_relabel\*(R".
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_set_append"
.IX Subsection "guestfs_set_append"
.Vb 3
\& int
\& guestfs_set_append (guestfs_h *g,
\&                     const char *append);
.Ve
.PP
This function is used to add additional options to the libguestfs appliance
kernel command line.
.PP
\&\f(CW\*(C`LIBGUESTFS_APPEND\*(C'\fR 環境変数を設定して上書きされなければ、デフォルトは \f(CW\*(C`NULL\*(C'\fR です。
.PP
\&\f(CW\*(C`append\*(C'\fR を \f(CW\*(C`NULL\*(C'\fR に設定することは、追加のオプションが渡され \fIない\fR ことを意味します（libguestfs
は常に自身のいくつかを追加します）。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.26 において追加)
.SS "guestfs_set_attach_method"
.IX Subsection "guestfs_set_attach_method"
.Vb 3
\& int
\& guestfs_set_attach_method (guestfs_h *g,
\&                            const char *backend);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_set_backend\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
Set the method that libguestfs uses to connect to the backend guestfsd
daemon.
.PP
See \*(L"\s-1BACKEND\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.9.8 において追加)
.SS "guestfs_set_autosync"
.IX Subsection "guestfs_set_autosync"
.Vb 3
\& int
\& guestfs_set_autosync (guestfs_h *g,
\&                       int autosync);
.Ve
.PP
If \f(CW\*(C`autosync\*(C'\fR is true, this enables autosync.  Libguestfs will make a best
effort attempt to make filesystems consistent and synchronized when the
handle is closed (also if the program exits without closing handles).
.PP
デフォルトで有効です（libguestfs 1.5.24 以降、以前は デフォルトで無効でした）。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_set_backend"
.IX Subsection "guestfs_set_backend"
.Vb 3
\& int
\& guestfs_set_backend (guestfs_h *g,
\&                      const char *backend);
.Ve
.PP
Set the method that libguestfs uses to connect to the backend guestfsd
daemon.
.PP
This handle property was previously called the \*(L"attach method\*(R".
.PP
See \*(L"\s-1BACKEND\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.21.26 において追加)
.SS "guestfs_set_backend_setting"
.IX Subsection "guestfs_set_backend_setting"
.Vb 4
\& int
\& guestfs_set_backend_setting (guestfs_h *g,
\&                              const char *name,
\&                              const char *val);
.Ve
.PP
Append \f(CW"name=value"\fR to the backend settings string list.  However if a
string already exists matching \f(CW"name"\fR or beginning with \f(CW"name="\fR, then
that setting is replaced.
.PP
See \*(L"\s-1BACKEND\*(R"\s0, \*(L"\s-1BACKEND SETTINGS\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.27.2)
.SS "guestfs_set_backend_settings"
.IX Subsection "guestfs_set_backend_settings"
.Vb 3
\& int
\& guestfs_set_backend_settings (guestfs_h *g,
\&                               char *const *settings);
.Ve
.PP
Set a list of zero or more settings which are passed through to the current
backend.  Each setting is a string which is interpreted in a
backend-specific way, or ignored if not understood by the backend.
.PP
The default value is an empty list, unless the environment variable
\&\f(CW\*(C`LIBGUESTFS_BACKEND_SETTINGS\*(C'\fR was set when the handle was created.  This
environment variable contains a colon-separated list of settings.
.PP
This call replaces all backend settings.  If you want to replace a single
backend setting, see \f(CW\*(C`guestfs_set_backend_setting\*(C'\fR.  If you want to clear a
single backend setting, see \f(CW\*(C`guestfs_clear_backend_setting\*(C'\fR.
.PP
See \*(L"\s-1BACKEND\*(R"\s0, \*(L"\s-1BACKEND SETTINGS\*(R"\s0.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.25.24)
.SS "guestfs_set_cachedir"
.IX Subsection "guestfs_set_cachedir"
.Vb 3
\& int
\& guestfs_set_cachedir (guestfs_h *g,
\&                       const char *cachedir);
.Ve
.PP
Set the directory used by the handle to store the appliance cache, when
using a supermin appliance.  The appliance is cached and shared between all
handles which have the same effective user \s-1ID.\s0
.PP
The environment variables \f(CW\*(C`LIBGUESTFS_CACHEDIR\*(C'\fR and \f(CW\*(C`TMPDIR\*(C'\fR control the
default value: If \f(CW\*(C`LIBGUESTFS_CACHEDIR\*(C'\fR is set, then that is the default.
Else if \f(CW\*(C`TMPDIR\*(C'\fR is set, then that is the default.  Else \fI/var/tmp\fR is the
default.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.58 において追加)
.SS "guestfs_set_direct"
.IX Subsection "guestfs_set_direct"
.Vb 3
\& int
\& guestfs_set_direct (guestfs_h *g,
\&                     int direct);
.Ve
.PP
If the direct appliance mode flag is enabled, then stdin and stdout are
passed directly through to the appliance once it is launched.
.PP
One consequence of this is that log messages aren't caught by the library
and handled by \f(CW\*(C`guestfs_set_log_message_callback\*(C'\fR, but go straight to
stdout.
.PP
You probably don't want to use this unless you know what you are doing.
.PP
デフォルトは無効です。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.72 において追加)
.SS "guestfs_set_e2attrs"
.IX Subsection "guestfs_set_e2attrs"
.Vb 5
\& int
\& guestfs_set_e2attrs (guestfs_h *g,
\&                      const char *file,
\&                      const char *attrs,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_SET_E2ATTRS_CLEAR, int clear,
.Ve
.PP
This sets or clears the file attributes \f(CW\*(C`attrs\*(C'\fR associated with the inode
\&\fIfile\fR.
.PP
\&\f(CW\*(C`attrs\*(C'\fR はファイル属性を表す文字の列です。利用可能な属性の一覧は \f(CW\*(C`guestfs_get_e2attrs\*(C'\fR
を参照してください。すべての属性が変更できるわけではありません。
.PP
If optional boolean \f(CW\*(C`clear\*(C'\fR is not present or false, then the \f(CW\*(C`attrs\*(C'\fR
listed are set in the inode.
.PP
If \f(CW\*(C`clear\*(C'\fR is true, then the \f(CW\*(C`attrs\*(C'\fR listed are cleared in the inode.
.PP
In both cases, other attributes not present in the \f(CW\*(C`attrs\*(C'\fR string are left
unchanged.
.PP
These attributes are only present when the file is located on an ext2/3/4
filesystem.  Using this call on other filesystem types will result in an
error.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.17.31 において追加)
.SS "guestfs_set_e2attrs_va"
.IX Subsection "guestfs_set_e2attrs_va"
.Vb 5
\& int
\& guestfs_set_e2attrs_va (guestfs_h *g,
\&                         const char *file,
\&                         const char *attrs,
\&                         va_list args);
.Ve
.PP
これは \*(L"guestfs_set_e2attrs\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_set_e2attrs_argv"
.IX Subsection "guestfs_set_e2attrs_argv"
.Vb 5
\& int
\& guestfs_set_e2attrs_argv (guestfs_h *g,
\&                           const char *file,
\&                           const char *attrs,
\&                           const struct guestfs_set_e2attrs_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_set_e2attrs\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_set_e2generation"
.IX Subsection "guestfs_set_e2generation"
.Vb 4
\& int
\& guestfs_set_e2generation (guestfs_h *g,
\&                           const char *file,
\&                           int64_t generation);
.Ve
.PP
これはファイルの ext2 ファイル世代を設定します。
.PP
\&\f(CW\*(C`guestfs_get_e2generation\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.17.31 において追加)
.SS "guestfs_set_e2label"
.IX Subsection "guestfs_set_e2label"
.Vb 4
\& int
\& guestfs_set_e2label (guestfs_h *g,
\&                      const char *device,
\&                      const char *label);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_set_label\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This sets the ext2/3/4 filesystem label of the filesystem on \f(CW\*(C`device\*(C'\fR to
\&\f(CW\*(C`label\*(C'\fR.  Filesystem labels are limited to 16 characters.
.PP
You can use either \f(CW\*(C`guestfs_tune2fs_l\*(C'\fR or \f(CW\*(C`guestfs_get_e2label\*(C'\fR to return
the existing label on a filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.15 において追加)
.SS "guestfs_set_e2uuid"
.IX Subsection "guestfs_set_e2uuid"
.Vb 4
\& int
\& guestfs_set_e2uuid (guestfs_h *g,
\&                     const char *device,
\&                     const char *uuid);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_set_uuid\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This sets the ext2/3/4 filesystem \s-1UUID\s0 of the filesystem on \f(CW\*(C`device\*(C'\fR to
\&\f(CW\*(C`uuid\*(C'\fR.  The format of the \s-1UUID\s0 and alternatives such as \f(CW\*(C`clear\*(C'\fR,
\&\f(CW\*(C`random\*(C'\fR and \f(CW\*(C`time\*(C'\fR are described in the \fItune2fs\fR\|(8) manpage.
.PP
You can use \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR to return the existing \s-1UUID\s0 of a filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.15 において追加)
.SS "guestfs_set_hv"
.IX Subsection "guestfs_set_hv"
.Vb 3
\& int
\& guestfs_set_hv (guestfs_h *g,
\&                 const char *hv);
.Ve
.PP
Set the hypervisor binary that we will use.  The hypervisor depends on the
backend, but is usually the location of the qemu/KVM hypervisor.  For the
uml backend, it is the location of the \f(CW\*(C`linux\*(C'\fR or \f(CW\*(C`vmlinux\*(C'\fR binary.
.PP
The default is chosen when the library was compiled by the configure script.
.PP
You can also override this by setting the \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR environment
variable.
.PP
Note that you should call this function as early as possible after creating
the handle.  This is because some pre-launch operations depend on testing
qemu features (by running \f(CW\*(C`qemu \-help\*(C'\fR).  If the qemu binary changes, we
don't retest features, and so you might see inconsistent results.  Using the
environment variable \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR is safest of all since that picks the
qemu binary at the same time as the handle is created.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.23.17)
.SS "guestfs_set_identifier"
.IX Subsection "guestfs_set_identifier"
.Vb 3
\& int
\& guestfs_set_identifier (guestfs_h *g,
\&                         const char *identifier);
.Ve
.PP
This is an informative string which the caller may optionally set in the
handle.  It is printed in various places, allowing the current handle to be
identified in debugging output.
.PP
One important place is when tracing is enabled.  If the identifier string is
not an empty string, then trace messages change from this:
.PP
.Vb 2
\& libguestfs: trace: get_tmpdir
\& libguestfs: trace: get_tmpdir = "/tmp"
.Ve
.PP
to this:
.PP
.Vb 2
\& libguestfs: trace: ID: get_tmpdir
\& libguestfs: trace: ID: get_tmpdir = "/tmp"
.Ve
.PP
where \f(CW\*(C`ID\*(C'\fR is the identifier string set by this call.
.PP
The identifier must only contain alphanumeric \s-1ASCII\s0 characters, underscore
and minus sign.  The default is the empty string.
.PP
See also \f(CW\*(C`guestfs_set_program\*(C'\fR, \f(CW\*(C`guestfs_set_trace\*(C'\fR,
\&\f(CW\*(C`guestfs_get_identifier\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.31.14)
.SS "guestfs_set_label"
.IX Subsection "guestfs_set_label"
.Vb 4
\& int
\& guestfs_set_label (guestfs_h *g,
\&                    const char *mountable,
\&                    const char *label);
.Ve
.PP
Set the filesystem label on \f(CW\*(C`mountable\*(C'\fR to \f(CW\*(C`label\*(C'\fR.
.PP
いくつかのファイルシステム形式のみがラベルをサポートします。そして libguestfs はこれらのサブセットのみにおいてラベルの設定をサポートします。
.IP "ext2, ext3, ext4" 4
.IX Item "ext2, ext3, ext4"
Labels are limited to 16 bytes.
.IP "\s-1NTFS\s0" 4
.IX Item "NTFS"
Labels are limited to 128 unicode characters.
.IP "\s-1XFS\s0" 4
.IX Item "XFS"
The label is limited to 12 bytes.  The filesystem must not be mounted when
trying to set the label.
.IP "btrfs" 4
.IX Item "btrfs"
The label is limited to 255 bytes and some characters are not allowed.
Setting the label on a btrfs subvolume will set the label on its parent
filesystem.  The filesystem must not be mounted when trying to set the
label.
.IP "fat" 4
.IX Item "fat"
The label is limited to 11 bytes.
.IP "swap" 4
.IX Item "swap"
The label is limited to 16 bytes.
.PP
If there is no support for changing the label for the type of the specified
filesystem, set_label will fail and set errno as \s-1ENOTSUP.\s0
.PP
ファイルシステムにあるラベルを読み込むには \f(CW\*(C`guestfs_vfs_label\*(C'\fR を呼び出します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.17.9 において追加)
.SS "guestfs_set_libvirt_requested_credential"
.IX Subsection "guestfs_set_libvirt_requested_credential"
.Vb 5
\& int
\& guestfs_set_libvirt_requested_credential (guestfs_h *g,
\&                                           int index,
\&                                           const char *cred,
\&                                           size_t cred_size);
.Ve
.PP
After requesting the \f(CW\*(C`index\*(C'\fR'th credential from the user, call this
function to pass the answer back to libvirt.
.PP
See \*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 for documentation and example code.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.52 において追加))
.SS "guestfs_set_libvirt_supported_credentials"
.IX Subsection "guestfs_set_libvirt_supported_credentials"
.Vb 3
\& int
\& guestfs_set_libvirt_supported_credentials (guestfs_h *g,
\&                                            char *const *creds);
.Ve
.PP
Call this function before setting an event handler for
\&\f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR, to supply the list of credential types that
the program knows how to process.
.PP
\&\f(CW\*(C`creds\*(C'\fR 一覧は文字列の空ではない一覧にする必要があります。利用可能な文字列は次のとおりです:
.ie n .IP """username""" 4
.el .IP "\f(CWusername\fR" 4
.IX Item "username"
.PD 0
.ie n .IP """authname""" 4
.el .IP "\f(CWauthname\fR" 4
.IX Item "authname"
.ie n .IP """language""" 4
.el .IP "\f(CWlanguage\fR" 4
.IX Item "language"
.ie n .IP """cnonce""" 4
.el .IP "\f(CWcnonce\fR" 4
.IX Item "cnonce"
.ie n .IP """passphrase""" 4
.el .IP "\f(CWpassphrase\fR" 4
.IX Item "passphrase"
.ie n .IP """echoprompt""" 4
.el .IP "\f(CWechoprompt\fR" 4
.IX Item "echoprompt"
.ie n .IP """noechoprompt""" 4
.el .IP "\f(CWnoechoprompt\fR" 4
.IX Item "noechoprompt"
.ie n .IP """realm""" 4
.el .IP "\f(CWrealm\fR" 4
.IX Item "realm"
.ie n .IP """external""" 4
.el .IP "\f(CWexternal\fR" 4
.IX Item "external"
.PD
.PP
これらのクレデンシャル種別の意味は libvirt ドキュメントを参照してください。
.PP
See \*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 for documentation and example code.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.52 において追加))
.SS "guestfs_set_memsize"
.IX Subsection "guestfs_set_memsize"
.Vb 3
\& int
\& guestfs_set_memsize (guestfs_h *g,
\&                      int memsize);
.Ve
.PP
This sets the memory size in megabytes allocated to the hypervisor.  This
only has any effect if called before \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
ハンドルが設定される前に環境変数 \f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR を設定することにより、これを変更できます。
.PP
libguestfs のアーキテクチャーの詳細は \fIguestfs\fR\|(3) を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.55 において追加)
.SS "guestfs_set_network"
.IX Subsection "guestfs_set_network"
.Vb 3
\& int
\& guestfs_set_network (guestfs_h *g,
\&                      int network);
.Ve
.PP
\&\f(CW\*(C`network\*(C'\fR が真ならば、libguestfs アプライアンスにおいてネットワークが有効になります。デフォルトは偽です。
.PP
This affects whether commands are able to access the network (see
\&\*(L"\s-1RUNNING COMMANDS\*(R"\s0).
.PP
You must call this before calling \f(CW\*(C`guestfs_launch\*(C'\fR, otherwise it has no
effect.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.5.4 において追加)
.SS "guestfs_set_path"
.IX Subsection "guestfs_set_path"
.Vb 3
\& int
\& guestfs_set_path (guestfs_h *g,
\&                   const char *searchpath);
.Ve
.PP
libguestfs がカーネルおよび initrd.img を検索するパスを設定します。
.PP
The default is \f(CW\*(C`$libdir/guestfs\*(C'\fR unless overridden by setting
\&\f(CW\*(C`LIBGUESTFS_PATH\*(C'\fR environment variable.
.PP
\&\f(CW\*(C`path\*(C'\fR に \f(CW\*(C`NULL\*(C'\fR を設定することによりパスの初期値を復元します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_set_pgroup"
.IX Subsection "guestfs_set_pgroup"
.Vb 3
\& int
\& guestfs_set_pgroup (guestfs_h *g,
\&                     int pgroup);
.Ve
.PP
\&\f(CW\*(C`pgroup\*(C'\fR が真ならば、子プロセスは自身のプロセスグループの中に置かれます。
.PP
The practical upshot of this is that signals like \f(CW\*(C`SIGINT\*(C'\fR (from users
pressing \f(CW\*(C`^C\*(C'\fR) won't be received by the child process.
.PP
The default for this flag is false, because usually you want \f(CW\*(C`^C\*(C'\fR to kill
the subprocess.  Guestfish sets this flag to true when used interactively,
so that \f(CW\*(C`^C\*(C'\fR can cancel long-running commands gracefully (see
\&\f(CW\*(C`guestfs_user_cancel\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.11.18 において追加)
.SS "guestfs_set_program"
.IX Subsection "guestfs_set_program"
.Vb 3
\& int
\& guestfs_set_program (guestfs_h *g,
\&                      const char *program);
.Ve
.PP
Set the program name.  This is an informative string which the main program
may optionally set in the handle.
.PP
When the handle is created, the program name in the handle is set to the
basename from \f(CW\*(C`argv[0]\*(C'\fR.  The program name can never be \f(CW\*(C`NULL\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.21.29 において追加)
.SS "guestfs_set_qemu"
.IX Subsection "guestfs_set_qemu"
.Vb 3
\& int
\& guestfs_set_qemu (guestfs_h *g,
\&                   const char *hv);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_set_hv\*(R" call
instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
Set the hypervisor binary (usually qemu) that we will use.
.PP
The default is chosen when the library was compiled by the configure script.
.PP
You can also override this by setting the \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR environment
variable.
.PP
Setting \f(CW\*(C`hv\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR restores the default qemu binary.
.PP
Note that you should call this function as early as possible after creating
the handle.  This is because some pre-launch operations depend on testing
qemu features (by running \f(CW\*(C`qemu \-help\*(C'\fR).  If the qemu binary changes, we
don't retest features, and so you might see inconsistent results.  Using the
environment variable \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR is safest of all since that picks the
qemu binary at the same time as the handle is created.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.6 において追加)
.SS "guestfs_set_recovery_proc"
.IX Subsection "guestfs_set_recovery_proc"
.Vb 3
\& int
\& guestfs_set_recovery_proc (guestfs_h *g,
\&                            int recoveryproc);
.Ve
.PP
If this is called with the parameter \f(CW\*(C`false\*(C'\fR then \f(CW\*(C`guestfs_launch\*(C'\fR does
not create a recovery process.  The purpose of the recovery process is to
stop runaway hypervisor processes in the case where the main program aborts
abruptly.
.PP
This only has any effect if called before \f(CW\*(C`guestfs_launch\*(C'\fR, and the default
is true.
.PP
About the only time when you would want to disable this is if the main
process will fork itself into the background (\*(L"daemonize\*(R" itself).  In this
case the recovery process thinks that the main program has disappeared and
so kills the hypervisor, which is not very helpful.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.77 において追加)
.SS "guestfs_set_selinux"
.IX Subsection "guestfs_set_selinux"
.Vb 3
\& int
\& guestfs_set_selinux (guestfs_h *g,
\&                      int selinux);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_selinux_relabel\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This sets the selinux flag that is passed to the appliance at boot time.
The default is \f(CW\*(C`selinux=0\*(C'\fR (disabled).
.PP
Note that if SELinux is enabled, it is always in Permissive mode
(\f(CW\*(C`enforcing=0\*(C'\fR).
.PP
libguestfs のアーキテクチャーの詳細は \fIguestfs\fR\|(3) を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.67 において追加)
.SS "guestfs_set_smp"
.IX Subsection "guestfs_set_smp"
.Vb 3
\& int
\& guestfs_set_smp (guestfs_h *g,
\&                  int smp);
.Ve
.PP
アプライアンスに割り当てられる仮想 \s-1CPU\s0 数を変更します。初期値は \f(CW1\fR
です。これを増やすことにより性能を向上させられますが、ときどき効果がありません。
.PP
この関数は \f(CW\*(C`guestfs_launch\*(C'\fR の前に呼び出す必要があります。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.13.15 において追加)
.SS "guestfs_set_tmpdir"
.IX Subsection "guestfs_set_tmpdir"
.Vb 3
\& int
\& guestfs_set_tmpdir (guestfs_h *g,
\&                     const char *tmpdir);
.Ve
.PP
Set the directory used by the handle to store temporary files.
.PP
The environment variables \f(CW\*(C`LIBGUESTFS_TMPDIR\*(C'\fR and \f(CW\*(C`TMPDIR\*(C'\fR control the
default value: If \f(CW\*(C`LIBGUESTFS_TMPDIR\*(C'\fR is set, then that is the default.
Else if \f(CW\*(C`TMPDIR\*(C'\fR is set, then that is the default.  Else \fI/tmp\fR is the
default.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.58 において追加)
.SS "guestfs_set_trace"
.IX Subsection "guestfs_set_trace"
.Vb 3
\& int
\& guestfs_set_trace (guestfs_h *g,
\&                    int trace);
.Ve
.PP
If the command trace flag is set to 1, then libguestfs calls, parameters and
return values are traced.
.PP
If you want to trace C \s-1API\s0 calls into libguestfs (and other libraries) then
possibly a better way is to use the external \fIltrace\fR\|(1) command.
.PP
Command traces are disabled unless the environment variable
\&\f(CW\*(C`LIBGUESTFS_TRACE\*(C'\fR is defined and set to \f(CW1\fR.
.PP
Trace messages are normally sent to \f(CW\*(C`stderr\*(C'\fR, unless you register a
callback to send them somewhere else (see \f(CW\*(C`guestfs_set_event_callback\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.69 において追加)
.SS "guestfs_set_uuid"
.IX Subsection "guestfs_set_uuid"
.Vb 4
\& int
\& guestfs_set_uuid (guestfs_h *g,
\&                   const char *device,
\&                   const char *uuid);
.Ve
.PP
Set the filesystem \s-1UUID\s0 on \f(CW\*(C`device\*(C'\fR to \f(CW\*(C`uuid\*(C'\fR.  If this fails and the
errno is \s-1ENOTSUP,\s0 means that there is no support for changing the \s-1UUID\s0 for
the type of the specified filesystem.
.PP
Only some filesystem types support setting UUIDs.
.PP
To read the \s-1UUID\s0 on a filesystem, call \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.23.10)
.SS "guestfs_set_uuid_random"
.IX Subsection "guestfs_set_uuid_random"
.Vb 3
\& int
\& guestfs_set_uuid_random (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
Set the filesystem \s-1UUID\s0 on \f(CW\*(C`device\*(C'\fR to a random \s-1UUID.\s0  If this fails and
the errno is \s-1ENOTSUP,\s0 means that there is no support for changing the \s-1UUID\s0
for the type of the specified filesystem.
.PP
Only some filesystem types support setting UUIDs.
.PP
To read the \s-1UUID\s0 on a filesystem, call \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(Added in 1.29.50)
.SS "guestfs_set_verbose"
.IX Subsection "guestfs_set_verbose"
.Vb 3
\& int
\& guestfs_set_verbose (guestfs_h *g,
\&                      int verbose);
.Ve
.PP
\&\f(CW\*(C`verbose\*(C'\fR が真ならば、メッセージの冗長化を有効にします。
.PP
Verbose messages are disabled unless the environment variable
\&\f(CW\*(C`LIBGUESTFS_DEBUG\*(C'\fR is defined and set to \f(CW1\fR.
.PP
Verbose messages are normally sent to \f(CW\*(C`stderr\*(C'\fR, unless you register a
callback to send them somewhere else (see \f(CW\*(C`guestfs_set_event_callback\*(C'\fR).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_setcon"
.IX Subsection "guestfs_setcon"
.Vb 3
\& int
\& guestfs_setcon (guestfs_h *g,
\&                 const char *context);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_selinux_relabel\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This sets the SELinux security context of the daemon to the string
\&\f(CW\*(C`context\*(C'\fR.
.PP
\&\fIguestfs\fR\|(3) における SELinux に関するドキュメントを参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`selinux\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.67 において追加)
.SS "guestfs_setxattr"
.IX Subsection "guestfs_setxattr"
.Vb 6
\& int
\& guestfs_setxattr (guestfs_h *g,
\&                   const char *xattr,
\&                   const char *val,
\&                   int vallen,
\&                   const char *path);
.Ve
.PP
This call sets the extended attribute named \f(CW\*(C`xattr\*(C'\fR of the file \f(CW\*(C`path\*(C'\fR to
the value \f(CW\*(C`val\*(C'\fR (of length \f(CW\*(C`vallen\*(C'\fR).  The value is arbitrary 8 bit data.
.PP
関連項目: \f(CW\*(C`guestfs_lsetxattr\*(C'\fR, \fIattr\fR\|(5)
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxxattrs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.59 において追加)
.SS "guestfs_sfdisk"
.IX Subsection "guestfs_sfdisk"
.Vb 7
\& int
\& guestfs_sfdisk (guestfs_h *g,
\&                 const char *device,
\&                 int cyls,
\&                 int heads,
\&                 int sectors,
\&                 char *const *lines);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_part_add\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is a direct interface to the \fIsfdisk\fR\|(8) program for creating
partitions on block devices.
.PP
\&\f(CW\*(C`device\*(C'\fR should be a block device, for example \fI/dev/sda\fR.
.PP
\&\f(CW\*(C`cyls\*(C'\fR, \f(CW\*(C`heads\*(C'\fR and \f(CW\*(C`sectors\*(C'\fR are the number of cylinders, heads and
sectors on the device, which are passed directly to sfdisk as the \fI\-C\fR,
\&\fI\-H\fR and \fI\-S\fR parameters.  If you pass \f(CW0\fR for any of these, then the
corresponding parameter is omitted.  Usually for 'large' disks, you can just
pass \f(CW0\fR for these, but for small (floppy-sized) disks, sfdisk (or rather,
the kernel) cannot work out the right geometry and you will need to tell it.
.PP
\&\f(CW\*(C`lines\*(C'\fR is a list of lines that we feed to \f(CW\*(C`sfdisk\*(C'\fR.  For more information
refer to the \fIsfdisk\fR\|(8) manpage.
.PP
To create a single partition occupying the whole disk, you would pass
\&\f(CW\*(C`lines\*(C'\fR as a single element list, when the single element being the string
\&\f(CW\*(C`,\*(C'\fR (comma).
.PP
関連項目: \f(CW\*(C`guestfs_sfdisk_l\*(C'\fR, \f(CW\*(C`guestfs_sfdisk_N\*(C'\fR, \f(CW\*(C`guestfs_part_init\*(C'\fR
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_sfdiskM"
.IX Subsection "guestfs_sfdiskM"
.Vb 4
\& int
\& guestfs_sfdiskM (guestfs_h *g,
\&                  const char *device,
\&                  char *const *lines);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_part_add\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is a simplified interface to the \f(CW\*(C`guestfs_sfdisk\*(C'\fR command, where
partition sizes are specified in megabytes only (rounded to the nearest
cylinder) and you don't need to specify the cyls, heads and sectors
parameters which were rarely if ever used anyway.
.PP
関連項目: \f(CW\*(C`guestfs_sfdisk\*(C'\fR, \fIsfdisk\fR\|(8) マニュアルページおよび \f(CW\*(C`guestfs_part_disk\*(C'\fR
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.55 において追加)
.SS "guestfs_sfdisk_N"
.IX Subsection "guestfs_sfdisk_N"
.Vb 8
\& int
\& guestfs_sfdisk_N (guestfs_h *g,
\&                   const char *device,
\&                   int partnum,
\&                   int cyls,
\&                   int heads,
\&                   int sectors,
\&                   const char *line);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_part_add\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This runs \fIsfdisk\fR\|(8) option to modify just the single partition \f(CW\*(C`n\*(C'\fR
(note: \f(CW\*(C`n\*(C'\fR counts from 1).
.PP
For other parameters, see \f(CW\*(C`guestfs_sfdisk\*(C'\fR.  You should usually pass \f(CW0\fR
for the cyls/heads/sectors parameters.
.PP
関連項目: \f(CW\*(C`guestfs_part_add\*(C'\fR
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.26 において追加)
.SS "guestfs_sfdisk_disk_geometry"
.IX Subsection "guestfs_sfdisk_disk_geometry"
.Vb 3
\& char *
\& guestfs_sfdisk_disk_geometry (guestfs_h *g,
\&                               const char *device);
.Ve
.PP
This displays the disk geometry of \f(CW\*(C`device\*(C'\fR read from the partition table.
Especially in the case where the underlying block device has been resized,
this can be different from the kernel's idea of the geometry (see
\&\f(CW\*(C`guestfs_sfdisk_kernel_geometry\*(C'\fR).
.PP
The result is in human-readable format, and not designed to be parsed.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.26 において追加)
.SS "guestfs_sfdisk_kernel_geometry"
.IX Subsection "guestfs_sfdisk_kernel_geometry"
.Vb 3
\& char *
\& guestfs_sfdisk_kernel_geometry (guestfs_h *g,
\&                                 const char *device);
.Ve
.PP
This displays the kernel's idea of the geometry of \f(CW\*(C`device\*(C'\fR.
.PP
The result is in human-readable format, and not designed to be parsed.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.26 において追加)
.SS "guestfs_sfdisk_l"
.IX Subsection "guestfs_sfdisk_l"
.Vb 3
\& char *
\& guestfs_sfdisk_l (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_part_list\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This displays the partition table on \f(CW\*(C`device\*(C'\fR, in the human-readable output
of the \fIsfdisk\fR\|(8) command.  It is not intended to be parsed.
.PP
関連項目: \f(CW\*(C`guestfs_part_list\*(C'\fR
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.26 において追加)
.SS "guestfs_sh"
.IX Subsection "guestfs_sh"
.Vb 3
\& char *
\& guestfs_sh (guestfs_h *g,
\&             const char *command);
.Ve
.PP
This call runs a command from the guest filesystem via the guest's
\&\fI/bin/sh\fR.
.PP
This is like \f(CW\*(C`guestfs_command\*(C'\fR, but passes the command to:
.PP
.Vb 1
\& /bin/sh \-c "command"
.Ve
.PP
Depending on the guest's shell, this usually results in wildcards being
expanded, shell expressions being interpolated and so on.
.PP
All the provisos about \f(CW\*(C`guestfs_command\*(C'\fR apply to this call.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.50 において追加)
.SS "guestfs_sh_lines"
.IX Subsection "guestfs_sh_lines"
.Vb 3
\& char **
\& guestfs_sh_lines (guestfs_h *g,
\&                   const char *command);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_sh\*(C'\fR, but splits the result into a list of
lines.
.PP
関連項目: \f(CW\*(C`guestfs_command_lines\*(C'\fR
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.50 において追加)
.SS "guestfs_shutdown"
.IX Subsection "guestfs_shutdown"
.Vb 2
\& int
\& guestfs_shutdown (guestfs_h *g);
.Ve
.PP
This is the opposite of \f(CW\*(C`guestfs_launch\*(C'\fR.  It performs an orderly shutdown
of the backend process(es).  If the autosync flag is set (which is the
default) then the disk image is synchronized.
.PP
サブプロセスがエラーで終了すると、この関数はエラーを返します。これは（ディスクイメージが正しく書き出されていないことを意味する可能性があるので）無視すべき
\&\fIではありません\fR 。
.PP
It is safe to call this multiple times.  Extra calls are ignored.
.PP
This call does \fInot\fR close or free up the handle.  You still need to call
\&\f(CW\*(C`guestfs_close\*(C'\fR afterwards.
.PP
\&\f(CW\*(C`guestfs_close\*(C'\fR will call this if you don't do it explicitly, but note that
any errors are ignored in that case.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.19.16 において追加)
.SS "guestfs_sleep"
.IX Subsection "guestfs_sleep"
.Vb 3
\& int
\& guestfs_sleep (guestfs_h *g,
\&                int secs);
.Ve
.PP
\&\f(CW\*(C`secs\*(C'\fR 秒間スリープします。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.41 において追加)
.SS "guestfs_stat"
.IX Subsection "guestfs_stat"
.Vb 3
\& struct guestfs_stat *
\& guestfs_stat (guestfs_h *g,
\&               const char *path);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_statns\*(R" call
instead.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
与えられた \f(CW\*(C`path\*(C'\fR のファイル情報を返します。
.PP
This is the same as the \fIstat\fR\|(2) system call.
.PP
この関数は \f(CW\*(C`struct guestfs_stat *\*(C'\fR を返します。エラーがあれば \s-1NULL\s0 です。 \fI呼び出し元は使用後に
\&\f(CI\*(C`guestfs_free_stat\*(C'\fI を呼び出す必要があります\fR。
.PP
(Added in 1.9.2)
.SS "guestfs_statns"
.IX Subsection "guestfs_statns"
.Vb 3
\& struct guestfs_statns *
\& guestfs_statns (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
与えられた \f(CW\*(C`path\*(C'\fR のファイル情報を返します。
.PP
This is the same as the \fIstat\fR\|(2) system call.
.PP
This function returns a \f(CW\*(C`struct guestfs_statns *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_statns\*(C'\fI after use\fR.
.PP
(Added in 1.27.53)
.SS "guestfs_statvfs"
.IX Subsection "guestfs_statvfs"
.Vb 3
\& struct guestfs_statvfs *
\& guestfs_statvfs (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Returns file system statistics for any mounted file system.  \f(CW\*(C`path\*(C'\fR should
be a file or directory in the mounted file system (typically it is the mount
point itself, but it doesn't need to be).
.PP
This is the same as the \fIstatvfs\fR\|(2) system call.
.PP
This function returns a \f(CW\*(C`struct guestfs_statvfs *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_statvfs\*(C'\fI after use\fR.
.PP
(Added in 1.9.2)
.SS "guestfs_strings"
.IX Subsection "guestfs_strings"
.Vb 3
\& char **
\& guestfs_strings (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This runs the \fIstrings\fR\|(1) command on a file and returns the list of
printable strings found.
.PP
The \f(CW\*(C`strings\*(C'\fR command has, in the past, had problems with parsing untrusted
files.  These are mitigated in the current version of libguestfs, but see
\&\*(L"\s-1CVE\-2014\-8484\*(R"\s0.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.22 において追加)
.SS "guestfs_strings_e"
.IX Subsection "guestfs_strings_e"
.Vb 4
\& char **
\& guestfs_strings_e (guestfs_h *g,
\&                    const char *encoding,
\&                    const char *path);
.Ve
.PP
This is like the \f(CW\*(C`guestfs_strings\*(C'\fR command, but allows you to specify the
encoding of strings that are looked for in the source file \f(CW\*(C`path\*(C'\fR.
.PP
許可されるエンコードは次のとおりです:
.IP "s" 4
.IX Item "s"
\&\s-1ASCII\s0 および \s-1ISO\-8859\-X\s0 の \s-1ASCII\s0 (これは \f(CW\*(C`guestfs_strings\*(C'\fR が使用するものです) のような単一の 7
ビットのバイト文字。
.IP "S" 4
.IX Item "S"
単一の 8 ビットのバイト文字。
.IP "b" 4
.IX Item "b"
\&\s-1UTF\-16BE\s0 や \s-1UCS\-2BE\s0 でエンコードされたもののように 16 ビットのビッグエンディアン文字列。
.IP "l (小文字の L)" 4
.IX Item "l (小文字の L)"
\&\s-1UTF\-16LE\s0 や \s-1UCS\-2LE\s0 のような 16 ビットのリトルエンディアン。これは Windows
仮想マシンにあるバイナリーを検査するために有用です。
.IP "B" 4
.IX Item "B"
\&\s-1UCS\-4BE\s0 のような 32 ビットのビッグエンディアン。
.IP "L" 4
.IX Item "L"
\&\s-1UCS\-4LE\s0 のような 32 ビットのリトルエンディアン。
.PP
返される文字列は \s-1UTF\-8\s0 に変換されます。
.PP
The \f(CW\*(C`strings\*(C'\fR command has, in the past, had problems with parsing untrusted
files.  These are mitigated in the current version of libguestfs, but see
\&\*(L"\s-1CVE\-2014\-8484\*(R"\s0.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.22 において追加)
.SS "guestfs_swapoff_device"
.IX Subsection "guestfs_swapoff_device"
.Vb 3
\& int
\& guestfs_swapoff_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
このコマンドは libguestfs アプライアンスの swap デバイスまたは \f(CW\*(C`device\*(C'\fR という名前のパーティションを無効にします。
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_swapoff_file"
.IX Subsection "guestfs_swapoff_file"
.Vb 3
\& int
\& guestfs_swapoff_file (guestfs_h *g,
\&                       const char *file);
.Ve
.PP
このコマンドは libguestfs アプライアンスの swap on ファイルを無効にします。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_swapoff_label"
.IX Subsection "guestfs_swapoff_label"
.Vb 3
\& int
\& guestfs_swapoff_label (guestfs_h *g,
\&                        const char *label);
.Ve
.PP
このコマンドは libguestfs アプライアンスの swap on ラベル付き swap パーティションを無効にします。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_swapoff_uuid"
.IX Subsection "guestfs_swapoff_uuid"
.Vb 3
\& int
\& guestfs_swapoff_uuid (guestfs_h *g,
\&                       const char *uuid);
.Ve
.PP
このコマンドは libguestfs アプライアンスの指定された \s-1UUID\s0 を持つ swap パーティションを無効にします。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxfsuuid\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_swapon_device"
.IX Subsection "guestfs_swapon_device"
.Vb 3
\& int
\& guestfs_swapon_device (guestfs_h *g,
\&                        const char *device);
.Ve
.PP
This command enables the libguestfs appliance to use the swap device or
partition named \f(CW\*(C`device\*(C'\fR.  The increased memory is made available for all
commands, for example those run using \f(CW\*(C`guestfs_command\*(C'\fR or \f(CW\*(C`guestfs_sh\*(C'\fR.
.PP
Note that you should not swap to existing guest swap partitions unless you
know what you are doing.  They may contain hibernation information, or other
information that the guest doesn't want you to trash.  You also risk leaking
information about the host to the guest this way.  Instead, attach a new
host device to the guest and swap on that.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_swapon_file"
.IX Subsection "guestfs_swapon_file"
.Vb 3
\& int
\& guestfs_swapon_file (guestfs_h *g,
\&                      const char *file);
.Ve
.PP
This command enables swap to a file.  See \f(CW\*(C`guestfs_swapon_device\*(C'\fR for other
notes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_swapon_label"
.IX Subsection "guestfs_swapon_label"
.Vb 3
\& int
\& guestfs_swapon_label (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
This command enables swap to a labeled swap partition.  See
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR for other notes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.66 において追加)
.SS "guestfs_swapon_uuid"
.IX Subsection "guestfs_swapon_uuid"
.Vb 3
\& int
\& guestfs_swapon_uuid (guestfs_h *g,
\&                      const char *uuid);
.Ve
.PP
This command enables swap to a swap partition with the given \s-1UUID.\s0  See
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR for other notes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`linuxfsuuid\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.66 において追加)
.SS "guestfs_sync"
.IX Subsection "guestfs_sync"
.Vb 2
\& int
\& guestfs_sync (guestfs_h *g);
.Ve
.PP
This syncs the disk, so that any writes are flushed through to the
underlying disk image.
.PP
You should always call this if you have modified a disk image, before
closing the handle.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_syslinux"
.IX Subsection "guestfs_syslinux"
.Vb 4
\& int
\& guestfs_syslinux (guestfs_h *g,
\&                   const char *device,
\&                   ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_SYSLINUX_DIRECTORY, const char *directory,
.Ve
.PP
Install the \s-1SYSLINUX\s0 bootloader on \f(CW\*(C`device\*(C'\fR.
.PP
The device parameter must be either a whole disk formatted as a \s-1FAT\s0
filesystem, or a partition formatted as a \s-1FAT\s0 filesystem.  In the latter
case, the partition should be marked as \*(L"active\*(R"
(\f(CW\*(C`guestfs_part_set_bootable\*(C'\fR) and a Master Boot Record must be installed
(eg. using \f(CW\*(C`guestfs_pwrite_device\*(C'\fR) on the first sector of the whole disk.
The \s-1SYSLINUX\s0 package comes with some suitable Master Boot Records.  See the
\&\fIsyslinux\fR\|(1) man page for further information.
.PP
オプション引数は次のとおりです:
.IP "\fIdirectory\fR" 4
.IX Item "directory"
Install \s-1SYSLINUX\s0 in the named subdirectory, instead of in the root directory
of the \s-1FAT\s0 filesystem.
.PP
Additional configuration can be supplied to \s-1SYSLINUX\s0 by placing a file
called \fIsyslinux.cfg\fR on the \s-1FAT\s0 filesystem, either in the root directory,
or under \fIdirectory\fR if that optional argument is being used.  For further
information about the contents of this file, see \fIsyslinux\fR\|(1).
.PP
\&\f(CW\*(C`guestfs_extlinux\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`syslinux\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.21.27 において追加)
.SS "guestfs_syslinux_va"
.IX Subsection "guestfs_syslinux_va"
.Vb 4
\& int
\& guestfs_syslinux_va (guestfs_h *g,
\&                      const char *device,
\&                      va_list args);
.Ve
.PP
これは \*(L"guestfs_syslinux\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_syslinux_argv"
.IX Subsection "guestfs_syslinux_argv"
.Vb 4
\& int
\& guestfs_syslinux_argv (guestfs_h *g,
\&                        const char *device,
\&                        const struct guestfs_syslinux_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_syslinux\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tail"
.IX Subsection "guestfs_tail"
.Vb 3
\& char **
\& guestfs_tail (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This command returns up to the last 10 lines of a file as a list of strings.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.54 において追加)
.SS "guestfs_tail_n"
.IX Subsection "guestfs_tail_n"
.Vb 4
\& char **
\& guestfs_tail_n (guestfs_h *g,
\&                 int nrlines,
\&                 const char *path);
.Ve
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is a positive number, this returns the last
\&\f(CW\*(C`nrlines\*(C'\fR lines of the file \f(CW\*(C`path\*(C'\fR.
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is a negative number, this returns lines from
the file \f(CW\*(C`path\*(C'\fR, starting with the \f(CW\*(C`\-nrlines\*(C'\fRth line.
.PP
パラメーター \f(CW\*(C`nrlines\*(C'\fR が 0 ならば、空の一覧を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.54 において追加)
.SS "guestfs_tar_in"
.IX Subsection "guestfs_tar_in"
.Vb 4
\& int
\& guestfs_tar_in (guestfs_h *g,
\&                 const char *tarfile,
\&                 const char *directory);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_tar_in_opts\*(R" with no optional
arguments.
.PP
(1.0.3 において追加)
.SS "guestfs_tar_in_opts"
.IX Subsection "guestfs_tar_in_opts"
.Vb 5
\& int
\& guestfs_tar_in_opts (guestfs_h *g,
\&                      const char *tarfile,
\&                      const char *directory,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 4
\& GUESTFS_TAR_IN_OPTS_COMPRESS, const char *compress,
\& GUESTFS_TAR_IN_OPTS_XATTRS, int xattrs,
\& GUESTFS_TAR_IN_OPTS_SELINUX, int selinux,
\& GUESTFS_TAR_IN_OPTS_ACLS, int acls,
.Ve
.PP
This command uploads and unpacks local file \f(CW\*(C`tarfile\*(C'\fR into \fIdirectory\fR.
.PP
The optional \f(CW\*(C`compress\*(C'\fR flag controls compression.  If not given, then the
input should be an uncompressed tar file.  Otherwise one of the following
strings may be given to select the compression type of the input file:
\&\f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR, \f(CW\*(C`lzop\*(C'\fR.  (Note that not all builds
of libguestfs will support all of these compression types).
.PP
The other optional arguments are:
.ie n .IP """xattrs""" 4
.el .IP "\f(CWxattrs\fR" 4
.IX Item "xattrs"
If set to true, extended attributes are restored from the tar file.
.ie n .IP """selinux""" 4
.el .IP "\f(CWselinux\fR" 4
.IX Item "selinux"
If set to true, SELinux contexts are restored from the tar file.
.ie n .IP """acls""" 4
.el .IP "\f(CWacls\fR" 4
.IX Item "acls"
If set to true, \s-1POSIX\s0 ACLs are restored from the tar file.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.3 において追加)
.SS "guestfs_tar_in_opts_va"
.IX Subsection "guestfs_tar_in_opts_va"
.Vb 5
\& int
\& guestfs_tar_in_opts_va (guestfs_h *g,
\&                         const char *tarfile,
\&                         const char *directory,
\&                         va_list args);
.Ve
.PP
これは \*(L"guestfs_tar_in_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tar_in_opts_argv"
.IX Subsection "guestfs_tar_in_opts_argv"
.Vb 5
\& int
\& guestfs_tar_in_opts_argv (guestfs_h *g,
\&                           const char *tarfile,
\&                           const char *directory,
\&                           const struct guestfs_tar_in_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_tar_in_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tar_out"
.IX Subsection "guestfs_tar_out"
.Vb 4
\& int
\& guestfs_tar_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarfile);
.Ve
.PP
This function is provided for backwards compatibility with earlier versions
of libguestfs.  It simply calls \*(L"guestfs_tar_out_opts\*(R" with no optional
arguments.
.PP
(1.0.3 において追加)
.SS "guestfs_tar_out_opts"
.IX Subsection "guestfs_tar_out_opts"
.Vb 5
\& int
\& guestfs_tar_out_opts (guestfs_h *g,
\&                       const char *directory,
\&                       const char *tarfile,
\&                       ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 6
\& GUESTFS_TAR_OUT_OPTS_COMPRESS, const char *compress,
\& GUESTFS_TAR_OUT_OPTS_NUMERICOWNER, int numericowner,
\& GUESTFS_TAR_OUT_OPTS_EXCLUDES, char *const *excludes,
\& GUESTFS_TAR_OUT_OPTS_XATTRS, int xattrs,
\& GUESTFS_TAR_OUT_OPTS_SELINUX, int selinux,
\& GUESTFS_TAR_OUT_OPTS_ACLS, int acls,
.Ve
.PP
This command packs the contents of \fIdirectory\fR and downloads it to local
file \f(CW\*(C`tarfile\*(C'\fR.
.PP
The optional \f(CW\*(C`compress\*(C'\fR flag controls compression.  If not given, then the
output will be an uncompressed tar file.  Otherwise one of the following
strings may be given to select the compression type of the output file:
\&\f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR, \f(CW\*(C`lzop\*(C'\fR.  (Note that not all builds
of libguestfs will support all of these compression types).
.PP
The other optional arguments are:
.ie n .IP """excludes""" 4
.el .IP "\f(CWexcludes\fR" 4
.IX Item "excludes"
A list of wildcards.  Files are excluded if they match any of the wildcards.
.ie n .IP """numericowner""" 4
.el .IP "\f(CWnumericowner\fR" 4
.IX Item "numericowner"
If set to true, the output tar file will contain \s-1UID/GID\s0 numbers instead of
user/group names.
.ie n .IP """xattrs""" 4
.el .IP "\f(CWxattrs\fR" 4
.IX Item "xattrs"
If set to true, extended attributes are saved in the output tar.
.ie n .IP """selinux""" 4
.el .IP "\f(CWselinux\fR" 4
.IX Item "selinux"
If set to true, SELinux contexts are saved in the output tar.
.ie n .IP """acls""" 4
.el .IP "\f(CWacls\fR" 4
.IX Item "acls"
If set to true, \s-1POSIX\s0 ACLs are saved in the output tar.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.3 において追加)
.SS "guestfs_tar_out_opts_va"
.IX Subsection "guestfs_tar_out_opts_va"
.Vb 5
\& int
\& guestfs_tar_out_opts_va (guestfs_h *g,
\&                          const char *directory,
\&                          const char *tarfile,
\&                          va_list args);
.Ve
.PP
これは \*(L"guestfs_tar_out_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tar_out_opts_argv"
.IX Subsection "guestfs_tar_out_opts_argv"
.Vb 5
\& int
\& guestfs_tar_out_opts_argv (guestfs_h *g,
\&                            const char *directory,
\&                            const char *tarfile,
\&                            const struct guestfs_tar_out_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_tar_out_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tgz_in"
.IX Subsection "guestfs_tgz_in"
.Vb 4
\& int
\& guestfs_tgz_in (guestfs_h *g,
\&                 const char *tarball,
\&                 const char *directory);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_tar_in\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command uploads and unpacks local file \f(CW\*(C`tarball\*(C'\fR (a \fIgzip compressed\fR
tar file) into \fIdirectory\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.3 において追加)
.SS "guestfs_tgz_out"
.IX Subsection "guestfs_tgz_out"
.Vb 4
\& int
\& guestfs_tgz_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarball);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_tar_out\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command packs the contents of \fIdirectory\fR and downloads it to local
file \f(CW\*(C`tarball\*(C'\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.3 において追加)
.SS "guestfs_touch"
.IX Subsection "guestfs_touch"
.Vb 3
\& int
\& guestfs_touch (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Touch acts like the \fItouch\fR\|(1) command.  It can be used to update the
timestamps on a file, or, if the file does not exist, to create a new
zero-length file.
.PP
This command only works on regular files, and will fail on other file types
such as directories, symbolic links, block special etc.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_truncate"
.IX Subsection "guestfs_truncate"
.Vb 3
\& int
\& guestfs_truncate (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
This command truncates \f(CW\*(C`path\*(C'\fR to a zero-length file.  The file must exist
already.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.77 において追加)
.SS "guestfs_truncate_size"
.IX Subsection "guestfs_truncate_size"
.Vb 4
\& int
\& guestfs_truncate_size (guestfs_h *g,
\&                        const char *path,
\&                        int64_t size);
.Ve
.PP
This command truncates \f(CW\*(C`path\*(C'\fR to size \f(CW\*(C`size\*(C'\fR bytes.  The file must exist
already.
.PP
If the current file size is less than \f(CW\*(C`size\*(C'\fR then the file is extended to
the required size with zero bytes.  This creates a sparse file (ie. disk
blocks are not allocated for the file until you write to it).  To create a
non-sparse file of zeroes, use \f(CW\*(C`guestfs_fallocate64\*(C'\fR instead.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.77 において追加)
.SS "guestfs_tune2fs"
.IX Subsection "guestfs_tune2fs"
.Vb 4
\& int
\& guestfs_tune2fs (guestfs_h *g,
\&                  const char *device,
\&                  ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 10
\& GUESTFS_TUNE2FS_FORCE, int force,
\& GUESTFS_TUNE2FS_MAXMOUNTCOUNT, int maxmountcount,
\& GUESTFS_TUNE2FS_MOUNTCOUNT, int mountcount,
\& GUESTFS_TUNE2FS_ERRORBEHAVIOR, const char *errorbehavior,
\& GUESTFS_TUNE2FS_GROUP, int64_t group,
\& GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS, int intervalbetweenchecks,
\& GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
\& GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY, const char *lastmounteddirectory,
\& GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT, int64_t reservedblockscount,
\& GUESTFS_TUNE2FS_USER, int64_t user,
.Ve
.PP
This call allows you to adjust various filesystem parameters of an
ext2/ext3/ext4 filesystem called \f(CW\*(C`device\*(C'\fR.
.PP
オプションのパラメーターは次のとおりです:
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
Force tune2fs to complete the operation even in the face of errors.  This is
the same as the tune2fs \f(CW\*(C`\-f\*(C'\fR option.
.ie n .IP """maxmountcount""" 4
.el .IP "\f(CWmaxmountcount\fR" 4
.IX Item "maxmountcount"
Set the number of mounts after which the filesystem is checked by
\&\fIe2fsck\fR\|(8).  If this is \f(CW0\fR then the number of mounts is disregarded.
This is the same as the tune2fs \f(CW\*(C`\-c\*(C'\fR option.
.ie n .IP """mountcount""" 4
.el .IP "\f(CWmountcount\fR" 4
.IX Item "mountcount"
Set the number of times the filesystem has been mounted.  This is the same
as the tune2fs \f(CW\*(C`\-C\*(C'\fR option.
.ie n .IP """errorbehavior""" 4
.el .IP "\f(CWerrorbehavior\fR" 4
.IX Item "errorbehavior"
Change the behavior of the kernel code when errors are detected.  Possible
values currently are: \f(CW\*(C`continue\*(C'\fR, \f(CW\*(C`remount\-ro\*(C'\fR, \f(CW\*(C`panic\*(C'\fR.  In practice
these options don't really make any difference, particularly for write
errors.
.Sp
これは tune2fs \f(CW\*(C`\-e\*(C'\fR オプションと同じです。
.ie n .IP """group""" 4
.el .IP "\f(CWgroup\fR" 4
.IX Item "group"
Set the group which can use reserved filesystem blocks.  This is the same as
the tune2fs \f(CW\*(C`\-g\*(C'\fR option except that it can only be specified as a number.
.ie n .IP """intervalbetweenchecks""" 4
.el .IP "\f(CWintervalbetweenchecks\fR" 4
.IX Item "intervalbetweenchecks"
Adjust the maximal time between two filesystem checks (in seconds).  If the
option is passed as \f(CW0\fR then time-dependent checking is disabled.
.Sp
これは tune2fs \f(CW\*(C`\-i\*(C'\fR オプションと同じです。
.ie n .IP """reservedblockspercentage""" 4
.el .IP "\f(CWreservedblockspercentage\fR" 4
.IX Item "reservedblockspercentage"
Set the percentage of the filesystem which may only be allocated by
privileged processes.  This is the same as the tune2fs \f(CW\*(C`\-m\*(C'\fR option.
.ie n .IP """lastmounteddirectory""" 4
.el .IP "\f(CWlastmounteddirectory\fR" 4
.IX Item "lastmounteddirectory"
最後にマウントされたディレクトリーを設定します。これは tune2fs \f(CW\*(C`\-M\*(C'\fR オプションと同じです。
.ie n .IP """reservedblockscount"" Set the number of reserved filesystem blocks.  This is the same as the tune2fs ""\-r"" option." 4
.el .IP "\f(CWreservedblockscount\fR Set the number of reserved filesystem blocks.  This is the same as the tune2fs \f(CW\-r\fR option." 4
.IX Item "reservedblockscount Set the number of reserved filesystem blocks. This is the same as the tune2fs -r option."
.PD 0
.ie n .IP """user""" 4
.el .IP "\f(CWuser\fR" 4
.IX Item "user"
.PD
Set the user who can use the reserved filesystem blocks.  This is the same
as the tune2fs \f(CW\*(C`\-u\*(C'\fR option except that it can only be specified as a
number.
.PP
To get the current values of filesystem parameters, see
\&\f(CW\*(C`guestfs_tune2fs_l\*(C'\fR.  For precise details of how tune2fs works, see the
\&\fItune2fs\fR\|(8) man page.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.15.4 において追加)
.SS "guestfs_tune2fs_va"
.IX Subsection "guestfs_tune2fs_va"
.Vb 4
\& int
\& guestfs_tune2fs_va (guestfs_h *g,
\&                     const char *device,
\&                     va_list args);
.Ve
.PP
これは \*(L"guestfs_tune2fs\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tune2fs_argv"
.IX Subsection "guestfs_tune2fs_argv"
.Vb 4
\& int
\& guestfs_tune2fs_argv (guestfs_h *g,
\&                       const char *device,
\&                       const struct guestfs_tune2fs_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_tune2fs\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_tune2fs_l"
.IX Subsection "guestfs_tune2fs_l"
.Vb 3
\& char **
\& guestfs_tune2fs_l (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This returns the contents of the ext2, ext3 or ext4 filesystem superblock on
\&\f(CW\*(C`device\*(C'\fR.
.PP
It is the same as running \f(CW\*(C`tune2fs \-l device\*(C'\fR.  See \fItune2fs\fR\|(8) manpage
for more details.  The list of fields returned isn't clearly defined, and
depends on both the version of \f(CW\*(C`tune2fs\*(C'\fR that libguestfs was built against,
and the filesystem itself.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.9.2)
.SS "guestfs_txz_in"
.IX Subsection "guestfs_txz_in"
.Vb 4
\& int
\& guestfs_txz_in (guestfs_h *g,
\&                 const char *tarball,
\&                 const char *directory);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_tar_in\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command uploads and unpacks local file \f(CW\*(C`tarball\*(C'\fR (an \fIxz compressed\fR
tar file) into \fIdirectory\fR.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`xz\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.3.2 において追加)
.SS "guestfs_txz_out"
.IX Subsection "guestfs_txz_out"
.Vb 4
\& int
\& guestfs_txz_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarball);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_tar_out\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command packs the contents of \fIdirectory\fR and downloads it to local
file \f(CW\*(C`tarball\*(C'\fR (as an xz compressed tar archive).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`xz\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.3.2 において追加)
.SS "guestfs_umask"
.IX Subsection "guestfs_umask"
.Vb 3
\& int
\& guestfs_umask (guestfs_h *g,
\&                int mask);
.Ve
.PP
This function sets the mask used for creating new files and device nodes to
\&\f(CW\*(C`mask & 0777\*(C'\fR.
.PP
Typical umask values would be \f(CW022\fR which creates new files with
permissions like \*(L"\-rw\-r\*(--r\-\-\*(R" or \*(L"\-rwxr\-xr\-x\*(R", and \f(CW002\fR which creates new
files with permissions like \*(L"\-rw\-rw\-r\-\-\*(R" or \*(L"\-rwxrwxr\-x\*(R".
.PP
The default umask is \f(CW022\fR.  This is important because it means that
directories and device nodes will be created with \f(CW0644\fR or \f(CW0755\fR mode
even if you specify \f(CW0777\fR.
.PP
\&\f(CW\*(C`guestfs_get_umask\*(C'\fR, \fIumask\fR\|(2), \f(CW\*(C`guestfs_mknod\*(C'\fR, \f(CW\*(C`guestfs_mkdir\*(C'\fR 参照。
.PP
この呼び出しは元の umask を返します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.55 において追加)
.SS "guestfs_umount"
.IX Subsection "guestfs_umount"
.Vb 3
\& int
\& guestfs_umount (guestfs_h *g,
\&                 const char *pathordevice);
.Ve
.PP
この関数は以前のバージョンの libguestfs との後方互換性のために提供されています。単にオプション引数なしで
\&\*(L"guestfs_umount_opts\*(R" を呼び出します。
.PP
(0.8 において追加)
.SS "guestfs_umount_opts"
.IX Subsection "guestfs_umount_opts"
.Vb 4
\& int
\& guestfs_umount_opts (guestfs_h *g,
\&                      const char *pathordevice,
\&                      ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 2
\& GUESTFS_UMOUNT_OPTS_FORCE, int force,
\& GUESTFS_UMOUNT_OPTS_LAZYUNMOUNT, int lazyunmount,
.Ve
.PP
これは与えられたファイルシステムをアンマウントします。ファイルシステムは、そのマウントポイント
(path)、またはファイルシステムを含むデバイスにより指定されます。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_umount_opts_va"
.IX Subsection "guestfs_umount_opts_va"
.Vb 4
\& int
\& guestfs_umount_opts_va (guestfs_h *g,
\&                         const char *pathordevice,
\&                         va_list args);
.Ve
.PP
これは \*(L"guestfs_umount_opts\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_umount_opts_argv"
.IX Subsection "guestfs_umount_opts_argv"
.Vb 4
\& int
\& guestfs_umount_opts_argv (guestfs_h *g,
\&                           const char *pathordevice,
\&                           const struct guestfs_umount_opts_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_umount_opts\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_umount_all"
.IX Subsection "guestfs_umount_all"
.Vb 2
\& int
\& guestfs_umount_all (guestfs_h *g);
.Ve
.PP
これはマウントされたファイルシステムをすべてアンマウントします。
.PP
いくつかの内部マウントはこの呼び出しによりアンマウントされません。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.8 において追加)
.SS "guestfs_umount_local"
.IX Subsection "guestfs_umount_local"
.Vb 3
\& int
\& guestfs_umount_local (guestfs_h *g,
\&                       ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 1
\& GUESTFS_UMOUNT_LOCAL_RETRY, int retry,
.Ve
.PP
libguestfs がローカルマウントポイントにあるファイルシステムをエクスポートしているならば、これによりアンマウントされます。
.PP
完全なドキュメントは \*(L"\s-1MOUNT LOCAL\*(R"\s0 を参照してください。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.17.22 において追加)
.SS "guestfs_umount_local_va"
.IX Subsection "guestfs_umount_local_va"
.Vb 3
\& int
\& guestfs_umount_local_va (guestfs_h *g,
\&                          va_list args);
.Ve
.PP
これは \*(L"guestfs_umount_local\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_umount_local_argv"
.IX Subsection "guestfs_umount_local_argv"
.Vb 3
\& int
\& guestfs_umount_local_argv (guestfs_h *g,
\&                            const struct guestfs_umount_local_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_umount_local\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_upload"
.IX Subsection "guestfs_upload"
.Vb 4
\& int
\& guestfs_upload (guestfs_h *g,
\&                 const char *filename,
\&                 const char *remotefilename);
.Ve
.PP
Upload local file \fIfilename\fR to \fIremotefilename\fR on the filesystem.
.PP
\&\fIfilename\fR can also be a named pipe.
.PP
\&\f(CW\*(C`guestfs_download\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.0.2 において追加)
.SS "guestfs_upload_offset"
.IX Subsection "guestfs_upload_offset"
.Vb 5
\& int
\& guestfs_upload_offset (guestfs_h *g,
\&                        const char *filename,
\&                        const char *remotefilename,
\&                        int64_t offset);
.Ve
.PP
Upload local file \fIfilename\fR to \fIremotefilename\fR on the filesystem.
.PP
\&\fIremotefilename\fR is overwritten starting at the byte \f(CW\*(C`offset\*(C'\fR specified.
The intention is to overwrite parts of existing files or devices, although
if a non-existent file is specified then it is created with a \*(L"hole\*(R" before
\&\f(CW\*(C`offset\*(C'\fR.  The size of the data written is implicit in the size of the
source \fIfilename\fR.
.PP
Note that there is no limit on the amount of data that can be uploaded with
this call, unlike with \f(CW\*(C`guestfs_pwrite\*(C'\fR, and this call always writes the
full amount unless an error occurs.
.PP
\&\f(CW\*(C`guestfs_upload\*(C'\fR, \f(CW\*(C`guestfs_pwrite\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.5.17 において追加)
.SS "guestfs_user_cancel"
.IX Subsection "guestfs_user_cancel"
.Vb 2
\& int
\& guestfs_user_cancel (guestfs_h *g);
.Ve
.PP
This function cancels the current upload or download operation.
.PP
Unlike most other libguestfs calls, this function is signal safe and thread
safe.  You can call it from a signal handler or from another thread, without
needing to do any locking.
.PP
The transfer that was in progress (if there is one) will stop shortly
afterwards, and will return an error.  The errno (see
\&\*(L"guestfs_last_errno\*(R") is set to \f(CW\*(C`EINTR\*(C'\fR, so you can test for this to find
out if the operation was cancelled or failed because of another error.
.PP
No cleanup is performed: for example, if a file was being uploaded then
after cancellation there may be a partially uploaded file.  It is the
caller's responsibility to clean up if necessary.
.PP
There are two common places that you might call \f(CW\*(C`guestfs_user_cancel\*(C'\fR:
.PP
In an interactive text-based program, you might call it from a \f(CW\*(C`SIGINT\*(C'\fR
signal handler so that pressing \f(CW\*(C`^C\*(C'\fR cancels the current operation.  (You
also need to call \*(L"guestfs_set_pgroup\*(R" so that child processes don't
receive the \f(CW\*(C`^C\*(C'\fR signal).
.PP
In a graphical program, when the main thread is displaying a progress bar
with a cancel button, wire up the cancel button to call this function.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.11.18 において追加)
.SS "guestfs_utimens"
.IX Subsection "guestfs_utimens"
.Vb 7
\& int
\& guestfs_utimens (guestfs_h *g,
\&                  const char *path,
\&                  int64_t atsecs,
\&                  int64_t atnsecs,
\&                  int64_t mtsecs,
\&                  int64_t mtnsecs);
.Ve
.PP
このコマンドはファイルのタイムスタンプをナノ秒単位で設定します。
.PP
\&\f(CW\*(C`atsecs, atnsecs\*(C'\fR are the last access time (atime) in secs and nanoseconds
from the epoch.
.PP
\&\f(CW\*(C`mtsecs, mtnsecs\*(C'\fR are the last modification time (mtime) in secs and
nanoseconds from the epoch.
.PP
If the \f(CW*nsecs\fR field contains the special value \f(CW\*(C`\-1\*(C'\fR then the
corresponding timestamp is set to the current time.  (The \f(CW*secs\fR field is
ignored in this case).
.PP
If the \f(CW*nsecs\fR field contains the special value \f(CW\*(C`\-2\*(C'\fR then the
corresponding timestamp is left unchanged.  (The \f(CW*secs\fR field is ignored
in this case).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.77 において追加)
.SS "guestfs_utsname"
.IX Subsection "guestfs_utsname"
.Vb 2
\& struct guestfs_utsname *
\& guestfs_utsname (guestfs_h *g);
.Ve
.PP
This returns the kernel version of the appliance, where this is available.
This information is only useful for debugging.  Nothing in the returned
structure is defined by the \s-1API.\s0
.PP
この関数は \f(CW\*(C`struct guestfs_utsname *\*(C'\fR を返します。エラーが起きた場合 \s-1NULL\s0 を返します。 \fI呼び出し元は使用した後に
\&\f(CI\*(C`guestfs_free_utsname\*(C'\fI を呼び出す必要があります\fR。
.PP
(1.19.27 において追加)
.SS "guestfs_version"
.IX Subsection "guestfs_version"
.Vb 2
\& struct guestfs_version *
\& guestfs_version (guestfs_h *g);
.Ve
.PP
プログラムがリンクしている libguestfs バージョン番号を返します。
.PP
Note that because of dynamic linking this is not necessarily the version of
libguestfs that you compiled against.  You can compile the program, and then
at runtime dynamically link against a completely different \fIlibguestfs.so\fR
library.
.PP
This call was added in version \f(CW1.0.58\fR.  In previous versions of
libguestfs there was no way to get the version number.  From C code you can
use dynamic linker functions to find out if this symbol exists (if it
doesn't, then it's an earlier version).
.PP
The call returns a structure with four elements.  The first three (\f(CW\*(C`major\*(C'\fR,
\&\f(CW\*(C`minor\*(C'\fR and \f(CW\*(C`release\*(C'\fR) are numbers and correspond to the usual version
triplet.  The fourth element (\f(CW\*(C`extra\*(C'\fR) is a string and is normally empty,
but may be used for distro-specific information.
.PP
To construct the original version string: \f(CW\*(C`$major.$minor.$release$extra\*(C'\fR
.PP
関連項目: \*(L"\s-1LIBGUESTFS VERSION NUMBERS\*(R"\s0
.PP
\&\fINote:\fR Don't use this call to test for availability of features.  In
enterprise distributions we backport features from later versions into
earlier versions, making this an unreliable way to test for features.  Use
\&\f(CW\*(C`guestfs_available\*(C'\fR or \f(CW\*(C`guestfs_feature_available\*(C'\fR instead.
.PP
This function returns a \f(CW\*(C`struct guestfs_version *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_version\*(C'\fI after use\fR.
.PP
(1.0.58 において追加)
.SS "guestfs_vfs_label"
.IX Subsection "guestfs_vfs_label"
.Vb 3
\& char *
\& guestfs_vfs_label (guestfs_h *g,
\&                    const char *mountable);
.Ve
.PP
This returns the label of the filesystem on \f(CW\*(C`mountable\*(C'\fR.
.PP
ファイルシステムにラベルが付いていないと、空の文字列が返されます。
.PP
ラベルからファイルシステムを検索するには \f(CW\*(C`guestfs_findfs_label\*(C'\fR を使用します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.3.18 において追加)
.SS "guestfs_vfs_minimum_size"
.IX Subsection "guestfs_vfs_minimum_size"
.Vb 3
\& int64_t
\& guestfs_vfs_minimum_size (guestfs_h *g,
\&                           const char *mountable);
.Ve
.PP
Get the minimum size of filesystem in bytes.  This is the minimum possible
size for filesystem shrinking.
.PP
If getting minimum size of specified filesystem is not supported, this will
fail and set errno as \s-1ENOTSUP.\s0
.PP
See also \fIntfsresize\fR\|(8), \fIresize2fs\fR\|(8), \fIbtrfs\fR\|(8), \fIxfs_info\fR\|(8).
.PP
この関数はエラーのとき \-1 を返します。
.PP
(Added in 1.31.18)
.SS "guestfs_vfs_type"
.IX Subsection "guestfs_vfs_type"
.Vb 3
\& char *
\& guestfs_vfs_type (guestfs_h *g,
\&                   const char *mountable);
.Ve
.PP
This command gets the filesystem type corresponding to the filesystem on
\&\f(CW\*(C`mountable\*(C'\fR.
.PP
For most filesystems, the result is the name of the Linux \s-1VFS\s0 module which
would be used to mount this filesystem if you mounted it without specifying
the filesystem type.  For example a string such as \f(CW\*(C`ext3\*(C'\fR or \f(CW\*(C`ntfs\*(C'\fR.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.75 において追加)
.SS "guestfs_vfs_uuid"
.IX Subsection "guestfs_vfs_uuid"
.Vb 3
\& char *
\& guestfs_vfs_uuid (guestfs_h *g,
\&                   const char *mountable);
.Ve
.PP
This returns the filesystem \s-1UUID\s0 of the filesystem on \f(CW\*(C`mountable\*(C'\fR.
.PP
ファイルシステムが \s-1UUID\s0 を持っていないと、空の文字列を返します。
.PP
\&\s-1UUID\s0 からファイルシステムを検索するには \f(CW\*(C`guestfs_findfs_uuid\*(C'\fR を使用します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.3.18 において追加)
.SS "guestfs_vg_activate"
.IX Subsection "guestfs_vg_activate"
.Vb 4
\& int
\& guestfs_vg_activate (guestfs_h *g,
\&                      int activate,
\&                      char *const *volgroups);
.Ve
.PP
This command activates or (if \f(CW\*(C`activate\*(C'\fR is false) deactivates all logical
volumes in the listed volume groups \f(CW\*(C`volgroups\*(C'\fR.
.PP
このコマンドは \f(CW\*(C`vgchange \-a y|n volgroups...\*(C'\fR を実行するときと同じです。
.PP
Note that if \f(CW\*(C`volgroups\*(C'\fR is an empty list then \fBall\fR volume groups are
activated or deactivated.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.26 において追加)
.SS "guestfs_vg_activate_all"
.IX Subsection "guestfs_vg_activate_all"
.Vb 3
\& int
\& guestfs_vg_activate_all (guestfs_h *g,
\&                          int activate);
.Ve
.PP
This command activates or (if \f(CW\*(C`activate\*(C'\fR is false) deactivates all logical
volumes in all volume groups.
.PP
This command is the same as running \f(CW\*(C`vgchange \-a y|n\*(C'\fR
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.26 において追加)
.SS "guestfs_vgchange_uuid"
.IX Subsection "guestfs_vgchange_uuid"
.Vb 3
\& int
\& guestfs_vgchange_uuid (guestfs_h *g,
\&                        const char *vg);
.Ve
.PP
ランダムな新しい \s-1UUID\s0 をボリュームグループ \f(CW\*(C`vg\*(C'\fR に対して生成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.26 において追加)
.SS "guestfs_vgchange_uuid_all"
.IX Subsection "guestfs_vgchange_uuid_all"
.Vb 2
\& int
\& guestfs_vgchange_uuid_all (guestfs_h *g);
.Ve
.PP
すべての物理ボリュームに対する新しいランダムな \s-1UUID\s0 を生成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.26 において追加)
.SS "guestfs_vgcreate"
.IX Subsection "guestfs_vgcreate"
.Vb 4
\& int
\& guestfs_vgcreate (guestfs_h *g,
\&                   const char *volgroup,
\&                   char *const *physvols);
.Ve
.PP
これは、物理ボリューム \f(CW\*(C`physvols\*(C'\fR の空ではない一覧から、\f(CW\*(C`volgroup\*(C'\fR という名前の \s-1LVM\s0 ボリュームグループを作成します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.8 において追加)
.SS "guestfs_vglvuuids"
.IX Subsection "guestfs_vglvuuids"
.Vb 3
\& char **
\& guestfs_vglvuuids (guestfs_h *g,
\&                    const char *vgname);
.Ve
.PP
\&\f(CW\*(C`vgname\*(C'\fR という \s-1VG\s0 が指定されると、これはこのボリュームグループに作成されたすべての論理ボリュームの \s-1UUID\s0 を返します。
.PP
You can use this along with \f(CW\*(C`guestfs_lvs\*(C'\fR and \f(CW\*(C`guestfs_lvuuid\*(C'\fR calls to
associate logical volumes and volume groups.
.PP
\&\f(CW\*(C`guestfs_vgpvuuids\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.87 において追加)
.SS "guestfs_vgmeta"
.IX Subsection "guestfs_vgmeta"
.Vb 4
\& char *
\& guestfs_vgmeta (guestfs_h *g,
\&                 const char *vgname,
\&                 size_t *size_r);
.Ve
.PP
\&\f(CW\*(C`vgname\*(C'\fR は \s-1LVM\s0 ボリュームグループです。このコマンドは、ボリュームグループを検査して、そのメタ情報を返します。
.PP
メタ情報は、LVM により使用される内部構造で、いつでも変更を強制され、情報に対してのみ提供されることに注意してください。
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.20 において追加)
.SS "guestfs_vgpvuuids"
.IX Subsection "guestfs_vgpvuuids"
.Vb 3
\& char **
\& guestfs_vgpvuuids (guestfs_h *g,
\&                    const char *vgname);
.Ve
.PP
Given a \s-1VG\s0 called \f(CW\*(C`vgname\*(C'\fR, this returns the UUIDs of all the physical
volumes that this volume group resides on.
.PP
You can use this along with \f(CW\*(C`guestfs_pvs\*(C'\fR and \f(CW\*(C`guestfs_pvuuid\*(C'\fR calls to
associate physical volumes and volume groups.
.PP
\&\f(CW\*(C`guestfs_vglvuuids\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(1.0.87 において追加)
.SS "guestfs_vgremove"
.IX Subsection "guestfs_vgremove"
.Vb 3
\& int
\& guestfs_vgremove (guestfs_h *g,
\&                   const char *vgname);
.Ve
.PP
\&\s-1LVM\s0 ボリュームグループ \f(CW\*(C`vgname\*(C'\fR を削除します（例: \f(CW\*(C`VG\*(C'\fR）。
.PP
This also forcibly removes all logical volumes in the volume group (if any).
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.13 において追加)
.SS "guestfs_vgrename"
.IX Subsection "guestfs_vgrename"
.Vb 4
\& int
\& guestfs_vgrename (guestfs_h *g,
\&                   const char *volgroup,
\&                   const char *newvolgroup);
.Ve
.PP
ボリュームグループ \f(CW\*(C`volgroup\*(C'\fR の名前を新しい名前 \f(CW\*(C`newvolgroup\*(C'\fR に変更します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.0.83 において追加)
.SS "guestfs_vgs"
.IX Subsection "guestfs_vgs"
.Vb 2
\& char **
\& guestfs_vgs (guestfs_h *g);
.Ve
.PP
List all the volumes groups detected.  This is the equivalent of the
\&\fIvgs\fR\|(8) command.
.PP
This returns a list of just the volume group names that were detected
(eg. \f(CW\*(C`VolGroup00\*(C'\fR).
.PP
\&\f(CW\*(C`guestfs_vgs_full\*(C'\fR 参照。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.4 において追加)
.SS "guestfs_vgs_full"
.IX Subsection "guestfs_vgs_full"
.Vb 2
\& struct guestfs_lvm_vg_list *
\& guestfs_vgs_full (guestfs_h *g);
.Ve
.PP
List all the volumes groups detected.  This is the equivalent of the
\&\fIvgs\fR\|(8) command.  The \*(L"full\*(R" version includes all fields.
.PP
This function returns a \f(CW\*(C`struct guestfs_lvm_vg_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_lvm_vg_list\*(C'\fI after
use\fR.
.PP
This function depends on the feature \f(CW\*(C`lvm2\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(0.4 において追加)
.SS "guestfs_vgscan"
.IX Subsection "guestfs_vgscan"
.Vb 2
\& int
\& guestfs_vgscan (guestfs_h *g);
.Ve
.PP
This rescans all block devices and rebuilds the list of \s-1LVM\s0 physical
volumes, volume groups and logical volumes.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.2 において追加)
.SS "guestfs_vguuid"
.IX Subsection "guestfs_vguuid"
.Vb 3
\& char *
\& guestfs_vguuid (guestfs_h *g,
\&                 const char *vgname);
.Ve
.PP
このコマンドは \f(CW\*(C`vgname\*(C'\fR という名前の \s-1LVM\s0 ボリュームグループの \s-1UUID\s0 を返します。
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.87 において追加)
.SS "guestfs_wait_ready"
.IX Subsection "guestfs_wait_ready"
.Vb 2
\& int
\& guestfs_wait_ready (guestfs_h *g);
.Ve
.PP
\&\fIThis function is deprecated.\fR There is no replacement.  Consult the \s-1API\s0
documentation in \fIguestfs\fR\|(3) for further information.
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This function is a no op.
.PP
In versions of the \s-1API\s0 < 1.0.71 you had to call this function just after
calling \f(CW\*(C`guestfs_launch\*(C'\fR to wait for the launch to complete.  However this
is no longer necessary because \f(CW\*(C`guestfs_launch\*(C'\fR now does the waiting.
.PP
If you see any calls to this function in code then you can just remove them,
unless you want to retain compatibility with older versions of the \s-1API.\s0
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(0.3 において追加)
.SS "guestfs_wc_c"
.IX Subsection "guestfs_wc_c"
.Vb 3
\& int
\& guestfs_wc_c (guestfs_h *g,
\&               const char *path);
.Ve
.PP
このコマンドは \f(CW\*(C`wc \-c\*(C'\fR 外部コマンドを使用して、ファイルにある文字数を集計します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.54 において追加)
.SS "guestfs_wc_l"
.IX Subsection "guestfs_wc_l"
.Vb 3
\& int
\& guestfs_wc_l (guestfs_h *g,
\&               const char *path);
.Ve
.PP
このコマンドは \f(CW\*(C`wc \-l\*(C'\fR 外部コマンドを使用して、ファイルにある行数を集計します。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.54 において追加)
.SS "guestfs_wc_w"
.IX Subsection "guestfs_wc_w"
.Vb 3
\& int
\& guestfs_wc_w (guestfs_h *g,
\&               const char *path);
.Ve
.PP
このコマンドは \f(CW\*(C`wc \-w\*(C'\fR 外部コマンドを使用して、ファイルにある単語を数えます。
.PP
この関数はエラーのとき \-1 を返します。
.PP
(1.0.54 において追加)
.SS "guestfs_wipefs"
.IX Subsection "guestfs_wipefs"
.Vb 3
\& int
\& guestfs_wipefs (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
This command erases filesystem or \s-1RAID\s0 signatures from the specified
\&\f(CW\*(C`device\*(C'\fR to make the filesystem invisible to libblkid.
.PP
これは、ファイルシステム自身を削除しません、また \f(CW\*(C`device\*(C'\fR から他のどんなデータも削除しません。
.PP
デバイスの先頭数ブロックにゼロを書き込む \f(CW\*(C`guestfs_zero\*(C'\fR と比較します。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`wipefs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.17.6 において追加)
.SS "guestfs_write"
.IX Subsection "guestfs_write"
.Vb 5
\& int
\& guestfs_write (guestfs_h *g,
\&                const char *path,
\&                const char *content,
\&                size_t content_size);
.Ve
.PP
This call creates a file called \f(CW\*(C`path\*(C'\fR.  The content of the file is the
string \f(CW\*(C`content\*(C'\fR (which can contain any 8 bit data).
.PP
\&\f(CW\*(C`guestfs_write_append\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.3.14 において追加)
.SS "guestfs_write_append"
.IX Subsection "guestfs_write_append"
.Vb 5
\& int
\& guestfs_write_append (guestfs_h *g,
\&                       const char *path,
\&                       const char *content,
\&                       size_t content_size);
.Ve
.PP
この関数は \f(CW\*(C`content\*(C'\fR を \f(CW\*(C`path\*(C'\fR ファイルの最後に追加します。もし \f(CW\*(C`path\*(C'\fR が存在しなければ、新しいファイルが作成されます。
.PP
\&\f(CW\*(C`guestfs_write\*(C'\fR 参照。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
(1.11.18 において追加)
.SS "guestfs_write_file"
.IX Subsection "guestfs_write_file"
.Vb 5
\& int
\& guestfs_write_file (guestfs_h *g,
\&                     const char *path,
\&                     const char *content,
\&                     int size);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_write\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This call creates a file called \f(CW\*(C`path\*(C'\fR.  The contents of the file is the
string \f(CW\*(C`content\*(C'\fR (which can contain any 8 bit data), with length \f(CW\*(C`size\*(C'\fR.
.PP
As a special case, if \f(CW\*(C`size\*(C'\fR is \f(CW0\fR then the length is calculated using
\&\f(CW\*(C`strlen\*(C'\fR (so in this case the content cannot contain embedded \s-1ASCII\s0 NULs).
.PP
\&\fI\s-1NB.\s0\fR Owing to a bug, writing content containing \s-1ASCII NUL\s0 characters does
\&\fInot\fR work, even if the length is specified.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(0.8 において追加)
.SS "guestfs_xfs_admin"
.IX Subsection "guestfs_xfs_admin"
.Vb 4
\& int
\& guestfs_xfs_admin (guestfs_h *g,
\&                    const char *device,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 7
\& GUESTFS_XFS_ADMIN_EXTUNWRITTEN, int extunwritten,
\& GUESTFS_XFS_ADMIN_IMGFILE, int imgfile,
\& GUESTFS_XFS_ADMIN_V2LOG, int v2log,
\& GUESTFS_XFS_ADMIN_PROJID32BIT, int projid32bit,
\& GUESTFS_XFS_ADMIN_LAZYCOUNTER, int lazycounter,
\& GUESTFS_XFS_ADMIN_LABEL, const char *label,
\& GUESTFS_XFS_ADMIN_UUID, const char *uuid,
.Ve
.PP
\&\f(CW\*(C`device\*(C'\fR において \s-1XFS\s0 ファイルシステムのパラメーターを変更します。
.PP
Devices that are mounted cannot be modified.  Administrators must unmount
filesystems before this call can modify parameters.
.PP
Some of the parameters of a mounted filesystem can be examined and modified
using the \f(CW\*(C`guestfs_xfs_info\*(C'\fR and \f(CW\*(C`guestfs_xfs_growfs\*(C'\fR calls.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`xfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.33 において追加)
.SS "guestfs_xfs_admin_va"
.IX Subsection "guestfs_xfs_admin_va"
.Vb 4
\& int
\& guestfs_xfs_admin_va (guestfs_h *g,
\&                       const char *device,
\&                       va_list args);
.Ve
.PP
これは \*(L"guestfs_xfs_admin\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_xfs_admin_argv"
.IX Subsection "guestfs_xfs_admin_argv"
.Vb 4
\& int
\& guestfs_xfs_admin_argv (guestfs_h *g,
\&                         const char *device,
\&                         const struct guestfs_xfs_admin_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_xfs_admin\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_xfs_growfs"
.IX Subsection "guestfs_xfs_growfs"
.Vb 4
\& int
\& guestfs_xfs_growfs (guestfs_h *g,
\&                     const char *path,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 8
\& GUESTFS_XFS_GROWFS_DATASEC, int datasec,
\& GUESTFS_XFS_GROWFS_LOGSEC, int logsec,
\& GUESTFS_XFS_GROWFS_RTSEC, int rtsec,
\& GUESTFS_XFS_GROWFS_DATASIZE, int64_t datasize,
\& GUESTFS_XFS_GROWFS_LOGSIZE, int64_t logsize,
\& GUESTFS_XFS_GROWFS_RTSIZE, int64_t rtsize,
\& GUESTFS_XFS_GROWFS_RTEXTSIZE, int64_t rtextsize,
\& GUESTFS_XFS_GROWFS_MAXPCT, int maxpct,
.Ve
.PP
\&\f(CW\*(C`path\*(C'\fR にマウントされた \s-1XFS\s0 ファイルシステムを拡大します。
.PP
The returned struct contains geometry information.  Missing fields are
returned as \f(CW\*(C`\-1\*(C'\fR (for numeric fields) or empty string.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`xfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.28 において追加)
.SS "guestfs_xfs_growfs_va"
.IX Subsection "guestfs_xfs_growfs_va"
.Vb 4
\& int
\& guestfs_xfs_growfs_va (guestfs_h *g,
\&                        const char *path,
\&                        va_list args);
.Ve
.PP
これは \*(L"guestfs_xfs_growfs\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_xfs_growfs_argv"
.IX Subsection "guestfs_xfs_growfs_argv"
.Vb 4
\& int
\& guestfs_xfs_growfs_argv (guestfs_h *g,
\&                          const char *path,
\&                          const struct guestfs_xfs_growfs_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_xfs_growfs\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_xfs_info"
.IX Subsection "guestfs_xfs_info"
.Vb 3
\& struct guestfs_xfsinfo *
\& guestfs_xfs_info (guestfs_h *g,
\&                   const char *pathordevice);
.Ve
.PP
\&\f(CW\*(C`pathordevice\*(C'\fR は、マウントされた \s-1XFS\s0 ファイルシステム、または \s-1XFS\s0
ファイルシステムを含むデバイスです。このコマンドはファイルシステムのジオメトリーを返します。
.PP
The returned struct contains geometry information.  Missing fields are
returned as \f(CW\*(C`\-1\*(C'\fR (for numeric fields) or empty string.
.PP
この関数は \f(CW\*(C`struct guestfs_xfsinfo *\*(C'\fR を返します。エラーが起きた場合 \s-1NULL\s0 を返します。\fI呼び出し元は使用した後に
\&\f(CI\*(C`guestfs_free_xfsinfo\*(C'\fI を呼び出す必要があります\fR。
.PP
This function depends on the feature \f(CW\*(C`xfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.21 において追加)
.SS "guestfs_xfs_repair"
.IX Subsection "guestfs_xfs_repair"
.Vb 4
\& int
\& guestfs_xfs_repair (guestfs_h *g,
\&                     const char *device,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0.
.PP
.Vb 10
\& GUESTFS_XFS_REPAIR_FORCELOGZERO, int forcelogzero,
\& GUESTFS_XFS_REPAIR_NOMODIFY, int nomodify,
\& GUESTFS_XFS_REPAIR_NOPREFETCH, int noprefetch,
\& GUESTFS_XFS_REPAIR_FORCEGEOMETRY, int forcegeometry,
\& GUESTFS_XFS_REPAIR_MAXMEM, int64_t maxmem,
\& GUESTFS_XFS_REPAIR_IHASHSIZE, int64_t ihashsize,
\& GUESTFS_XFS_REPAIR_BHASHSIZE, int64_t bhashsize,
\& GUESTFS_XFS_REPAIR_AGSTRIDE, int64_t agstride,
\& GUESTFS_XFS_REPAIR_LOGDEV, const char *logdev,
\& GUESTFS_XFS_REPAIR_RTDEV, const char *rtdev,
.Ve
.PP
破損または破壊された \f(CW\*(C`device\*(C'\fR の \s-1XFS\s0 ファイルシステムを修復します。
.PP
The filesystem is specified using the \f(CW\*(C`device\*(C'\fR argument which should be the
device name of the disk partition or volume containing the filesystem.  If
given the name of a block device, \f(CW\*(C`xfs_repair\*(C'\fR will attempt to find the raw
device associated with the specified block device and will use the raw
device instead.
.PP
Regardless, the filesystem to be repaired must be unmounted, otherwise, the
resulting filesystem may be inconsistent or corrupt.
.PP
The returned status indicates whether filesystem corruption was detected
(returns \f(CW1\fR) or was not detected (returns \f(CW0\fR).
.PP
この関数はエラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`xfs\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.19.36 において追加)
.SS "guestfs_xfs_repair_va"
.IX Subsection "guestfs_xfs_repair_va"
.Vb 4
\& int
\& guestfs_xfs_repair_va (guestfs_h *g,
\&                        const char *device,
\&                        va_list args);
.Ve
.PP
これは \*(L"guestfs_xfs_repair\*(R" の \*(L"va_list variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_xfs_repair_argv"
.IX Subsection "guestfs_xfs_repair_argv"
.Vb 4
\& int
\& guestfs_xfs_repair_argv (guestfs_h *g,
\&                          const char *device,
\&                          const struct guestfs_xfs_repair_argv *optargs);
.Ve
.PP
これは \*(L"guestfs_xfs_repair\*(R" の \*(L"argv variant\*(R" です。
.PP
\&\*(L"\s-1CALLS WITH OPTIONAL ARGUMENTS\*(R"\s0 参照。
.SS "guestfs_zegrep"
.IX Subsection "guestfs_zegrep"
.Vb 4
\& char **
\& guestfs_zegrep (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`zegrep\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_zegrepi"
.IX Subsection "guestfs_zegrepi"
.Vb 4
\& char **
\& guestfs_zegrepi (guestfs_h *g,
\&                  const char *regex,
\&                  const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`zegrep \-i\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_zero"
.IX Subsection "guestfs_zero"
.Vb 3
\& int
\& guestfs_zero (guestfs_h *g,
\&               const char *device);
.Ve
.PP
This command writes zeroes over the first few blocks of \f(CW\*(C`device\*(C'\fR.
.PP
How many blocks are zeroed isn't specified (but it's \fInot\fR enough to
securely wipe the device).  It should be sufficient to remove any partition
tables, filesystem superblocks and so on.
.PP
ブロックデバイスがすでに 0 ならば、このコマンドは 0
を書き込みません。これは、下にあるブロックデバイスが不必要に非スパース化されたり大きくなったりすることを避けるためです。
.PP
関連項目: \f(CW\*(C`guestfs_zero_device\*(C'\fR, \f(CW\*(C`guestfs_scrub_device\*(C'\fR,
\&\f(CW\*(C`guestfs_is_zero_device\*(C'\fR
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.0.16 において追加)
.SS "guestfs_zero_device"
.IX Subsection "guestfs_zero_device"
.Vb 3
\& int
\& guestfs_zero_device (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
This command writes zeroes over the entire \f(CW\*(C`device\*(C'\fR.  Compare with
\&\f(CW\*(C`guestfs_zero\*(C'\fR which just zeroes the first few blocks of a device.
.PP
ブロックデバイスがすでに 0 ならば、このコマンドは 0
を書き込みません。これは、下にあるブロックデバイスが不必要に非スパース化されたり大きくなったりすることを避けるためです。
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.3.1 において追加)
.SS "guestfs_zero_free_space"
.IX Subsection "guestfs_zero_free_space"
.Vb 3
\& int
\& guestfs_zero_free_space (guestfs_h *g,
\&                          const char *directory);
.Ve
.PP
Zero the free space in the filesystem mounted on \fIdirectory\fR.  The
filesystem must be mounted read-write.
.PP
ファイルシステムの内容は影響を受けません。しかし、ファイルシステムにある空き領域はすべて開放されます。
.PP
Free space is not \*(L"trimmed\*(R".  You may want to call \f(CW\*(C`guestfs_fstrim\*(C'\fR either
as an alternative to this, or after calling this, depending on your
requirements.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\*(R"\s0.
.PP
(1.17.18 において追加)
.SS "guestfs_zerofree"
.IX Subsection "guestfs_zerofree"
.Vb 3
\& int
\& guestfs_zerofree (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This runs the \fIzerofree\fR program on \f(CW\*(C`device\*(C'\fR.  This program claims to zero
unused inodes and disk blocks on an ext2/3 filesystem, thus making it
possible to compress the filesystem more effectively.
.PP
You should \fBnot\fR run this program if the filesystem is mounted.
.PP
It is possible that using this program can damage the filesystem or data on
the filesystem.
.PP
この関数は、成功のとき 0 を、エラーのとき \-1 を返します。
.PP
This function depends on the feature \f(CW\*(C`zerofree\*(C'\fR.  See also
\&\*(L"guestfs_feature_available\*(R".
.PP
(1.0.26 において追加)
.SS "guestfs_zfgrep"
.IX Subsection "guestfs_zfgrep"
.Vb 4
\& char **
\& guestfs_zfgrep (guestfs_h *g,
\&                 const char *pattern,
\&                 const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`zfgrep\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_zfgrepi"
.IX Subsection "guestfs_zfgrepi"
.Vb 4
\& char **
\& guestfs_zfgrepi (guestfs_h *g,
\&                  const char *pattern,
\&                  const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
これは外部の \f(CW\*(C`zfgrep \-i\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_zfile"
.IX Subsection "guestfs_zfile"
.Vb 4
\& char *
\& guestfs_zfile (guestfs_h *g,
\&                const char *meth,
\&                const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_file\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command runs \fIfile\fR after first decompressing \f(CW\*(C`path\*(C'\fR using \f(CW\*(C`method\*(C'\fR.
.PP
\&\f(CW\*(C`method\*(C'\fR は \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`compress\*(C'\fR または \f(CW\*(C`bzip2\*(C'\fR のいずれかである必要があります。
.PP
Since 1.0.63, use \f(CW\*(C`guestfs_file\*(C'\fR instead which can now process compressed
files.
.PP
この関数は文字列を返します。エラー時は \s-1NULL\s0 です。 \fI呼び出し元は使用後に返された文字列を開放する必要があります\fR。
.PP
(1.0.59 において追加)
.SS "guestfs_zgrep"
.IX Subsection "guestfs_zgrep"
.Vb 4
\& char **
\& guestfs_zgrep (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
外部 \f(CW\*(C`zgrep\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SS "guestfs_zgrepi"
.IX Subsection "guestfs_zgrepi"
.Vb 4
\& char **
\& guestfs_zgrepi (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_grep\*(R" を使用してください。
.PP
Deprecated functions will not be removed from the \s-1API,\s0 but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
外部 \f(CW\*(C`zgrep \-i\*(C'\fR プログラムを呼び出し、一致する行を返します。
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL LIMITS\*(R"\s0.
.PP
(1.0.66 において追加)
.SH "構造"
.IX Header "構造"
.SS "guestfs_int_bool"
.IX Subsection "guestfs_int_bool"
.Vb 4
\& struct guestfs_int_bool {
\&   int32_t i;
\&   int32_t b;
\& };
\& 
\& struct guestfs_int_bool_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_int_bool *val; /* Elements. */
\& };
\&
\& int guestfs_compare_int_bool (const struct guestfs_int_bool *, const struct guestfs_int_bool *);
\& int guestfs_compare_int_bool_list (const struct guestfs_int_bool_list *, const struct guestfs_int_bool_list *);
\& 
\& struct guestfs_int_bool *guestfs_copy_int_bool (const struct guestfs_int_bool *);
\& struct guestfs_int_bool_list *guestfs_copy_int_bool_list (const struct guestfs_int_bool_list *);
\& 
\& void guestfs_free_int_bool (struct guestfs_int_bool *);
\& void guestfs_free_int_bool_list (struct guestfs_int_bool_list *);
.Ve
.SS "guestfs_lvm_pv"
.IX Subsection "guestfs_lvm_pv"
.Vb 10
\& struct guestfs_lvm_pv {
\&   char *pv_name;
\&   /* 以下の項目は NULL 終了していないので、表示するときに注意してください: */
\&   char pv_uuid[32];
\&   char *pv_fmt;
\&   uint64_t pv_size;
\&   uint64_t dev_size;
\&   uint64_t pv_free;
\&   uint64_t pv_used;
\&   char *pv_attr;
\&   int64_t pv_pe_count;
\&   int64_t pv_pe_alloc_count;
\&   char *pv_tags;
\&   uint64_t pe_start;
\&   int64_t pv_mda_count;
\&   uint64_t pv_mda_free;
\& };
\& 
\& struct guestfs_lvm_pv_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_lvm_pv *val; /* Elements. */
\& };
\&
\& int guestfs_compare_lvm_pv (const struct guestfs_lvm_pv *, const struct guestfs_lvm_pv *);
\& int guestfs_compare_lvm_pv_list (const struct guestfs_lvm_pv_list *, const struct guestfs_lvm_pv_list *);
\& 
\& struct guestfs_lvm_pv *guestfs_copy_lvm_pv (const struct guestfs_lvm_pv *);
\& struct guestfs_lvm_pv_list *guestfs_copy_lvm_pv_list (const struct guestfs_lvm_pv_list *);
\& 
\& void guestfs_free_lvm_pv (struct guestfs_lvm_pv *);
\& void guestfs_free_lvm_pv_list (struct guestfs_lvm_pv_list *);
.Ve
.SS "guestfs_lvm_vg"
.IX Subsection "guestfs_lvm_vg"
.Vb 10
\& struct guestfs_lvm_vg {
\&   char *vg_name;
\&   /* 以下の項目は NULL 終了していないので、表示するときに注意してください: */
\&   char vg_uuid[32];
\&   char *vg_fmt;
\&   char *vg_attr;
\&   uint64_t vg_size;
\&   uint64_t vg_free;
\&   char *vg_sysid;
\&   uint64_t vg_extent_size;
\&   int64_t vg_extent_count;
\&   int64_t vg_free_count;
\&   int64_t max_lv;
\&   int64_t max_pv;
\&   int64_t pv_count;
\&   int64_t lv_count;
\&   int64_t snap_count;
\&   int64_t vg_seqno;
\&   char *vg_tags;
\&   int64_t vg_mda_count;
\&   uint64_t vg_mda_free;
\& };
\& 
\& struct guestfs_lvm_vg_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_lvm_vg *val; /* Elements. */
\& };
\&
\& int guestfs_compare_lvm_vg (const struct guestfs_lvm_vg *, const struct guestfs_lvm_vg *);
\& int guestfs_compare_lvm_vg_list (const struct guestfs_lvm_vg_list *, const struct guestfs_lvm_vg_list *);
\& 
\& struct guestfs_lvm_vg *guestfs_copy_lvm_vg (const struct guestfs_lvm_vg *);
\& struct guestfs_lvm_vg_list *guestfs_copy_lvm_vg_list (const struct guestfs_lvm_vg_list *);
\& 
\& void guestfs_free_lvm_vg (struct guestfs_lvm_vg *);
\& void guestfs_free_lvm_vg_list (struct guestfs_lvm_vg_list *);
.Ve
.SS "guestfs_lvm_lv"
.IX Subsection "guestfs_lvm_lv"
.Vb 10
\& struct guestfs_lvm_lv {
\&   char *lv_name;
\&   /* 以下の項目は NULL 終了していないので、表示するときに注意してください: */
\&   char lv_uuid[32];
\&   char *lv_attr;
\&   int64_t lv_major;
\&   int64_t lv_minor;
\&   int64_t lv_kernel_major;
\&   int64_t lv_kernel_minor;
\&   uint64_t lv_size;
\&   int64_t seg_count;
\&   char *origin;
\&   /* 以下の項目は [0..100] または存在しないことを意味する \-1 : */
\&   float snap_percent;
\&   /* 以下の項目は [0..100] または存在しないことを意味する \-1 : */
\&   float copy_percent;
\&   char *move_pv;
\&   char *lv_tags;
\&   char *mirror_log;
\&   char *modules;
\& };
\& 
\& struct guestfs_lvm_lv_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_lvm_lv *val; /* Elements. */
\& };
\&
\& int guestfs_compare_lvm_lv (const struct guestfs_lvm_lv *, const struct guestfs_lvm_lv *);
\& int guestfs_compare_lvm_lv_list (const struct guestfs_lvm_lv_list *, const struct guestfs_lvm_lv_list *);
\& 
\& struct guestfs_lvm_lv *guestfs_copy_lvm_lv (const struct guestfs_lvm_lv *);
\& struct guestfs_lvm_lv_list *guestfs_copy_lvm_lv_list (const struct guestfs_lvm_lv_list *);
\& 
\& void guestfs_free_lvm_lv (struct guestfs_lvm_lv *);
\& void guestfs_free_lvm_lv_list (struct guestfs_lvm_lv_list *);
.Ve
.SS "guestfs_stat"
.IX Subsection "guestfs_stat"
.Vb 10
\& struct guestfs_stat {
\&   int64_t dev;
\&   int64_t ino;
\&   int64_t mode;
\&   int64_t nlink;
\&   int64_t uid;
\&   int64_t gid;
\&   int64_t rdev;
\&   int64_t size;
\&   int64_t blksize;
\&   int64_t blocks;
\&   int64_t atime;
\&   int64_t mtime;
\&   int64_t ctime;
\& };
\& 
\& struct guestfs_stat_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_stat *val; /* Elements. */
\& };
\&
\& int guestfs_compare_stat (const struct guestfs_stat *, const struct guestfs_stat *);
\& int guestfs_compare_stat_list (const struct guestfs_stat_list *, const struct guestfs_stat_list *);
\& 
\& struct guestfs_stat *guestfs_copy_stat (const struct guestfs_stat *);
\& struct guestfs_stat_list *guestfs_copy_stat_list (const struct guestfs_stat_list *);
\& 
\& void guestfs_free_stat (struct guestfs_stat *);
\& void guestfs_free_stat_list (struct guestfs_stat_list *);
.Ve
.SS "guestfs_statns"
.IX Subsection "guestfs_statns"
.Vb 10
\& struct guestfs_statns {
\&   int64_t st_dev;
\&   int64_t st_ino;
\&   int64_t st_mode;
\&   int64_t st_nlink;
\&   int64_t st_uid;
\&   int64_t st_gid;
\&   int64_t st_rdev;
\&   int64_t st_size;
\&   int64_t st_blksize;
\&   int64_t st_blocks;
\&   int64_t st_atime_sec;
\&   int64_t st_atime_nsec;
\&   int64_t st_mtime_sec;
\&   int64_t st_mtime_nsec;
\&   int64_t st_ctime_sec;
\&   int64_t st_ctime_nsec;
\&   int64_t st_spare1;
\&   int64_t st_spare2;
\&   int64_t st_spare3;
\&   int64_t st_spare4;
\&   int64_t st_spare5;
\&   int64_t st_spare6;
\& };
\& 
\& struct guestfs_statns_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_statns *val; /* Elements. */
\& };
\&
\& int guestfs_compare_statns (const struct guestfs_statns *, const struct guestfs_statns *);
\& int guestfs_compare_statns_list (const struct guestfs_statns_list *, const struct guestfs_statns_list *);
\& 
\& struct guestfs_statns *guestfs_copy_statns (const struct guestfs_statns *);
\& struct guestfs_statns_list *guestfs_copy_statns_list (const struct guestfs_statns_list *);
\& 
\& void guestfs_free_statns (struct guestfs_statns *);
\& void guestfs_free_statns_list (struct guestfs_statns_list *);
.Ve
.SS "guestfs_statvfs"
.IX Subsection "guestfs_statvfs"
.Vb 10
\& struct guestfs_statvfs {
\&   int64_t bsize;
\&   int64_t frsize;
\&   int64_t blocks;
\&   int64_t bfree;
\&   int64_t bavail;
\&   int64_t files;
\&   int64_t ffree;
\&   int64_t favail;
\&   int64_t fsid;
\&   int64_t flag;
\&   int64_t namemax;
\& };
\& 
\& struct guestfs_statvfs_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_statvfs *val; /* Elements. */
\& };
\&
\& int guestfs_compare_statvfs (const struct guestfs_statvfs *, const struct guestfs_statvfs *);
\& int guestfs_compare_statvfs_list (const struct guestfs_statvfs_list *, const struct guestfs_statvfs_list *);
\& 
\& struct guestfs_statvfs *guestfs_copy_statvfs (const struct guestfs_statvfs *);
\& struct guestfs_statvfs_list *guestfs_copy_statvfs_list (const struct guestfs_statvfs_list *);
\& 
\& void guestfs_free_statvfs (struct guestfs_statvfs *);
\& void guestfs_free_statvfs_list (struct guestfs_statvfs_list *);
.Ve
.SS "guestfs_dirent"
.IX Subsection "guestfs_dirent"
.Vb 5
\& struct guestfs_dirent {
\&   int64_t ino;
\&   char ftyp;
\&   char *name;
\& };
\& 
\& struct guestfs_dirent_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_dirent *val; /* Elements. */
\& };
\&
\& int guestfs_compare_dirent (const struct guestfs_dirent *, const struct guestfs_dirent *);
\& int guestfs_compare_dirent_list (const struct guestfs_dirent_list *, const struct guestfs_dirent_list *);
\& 
\& struct guestfs_dirent *guestfs_copy_dirent (const struct guestfs_dirent *);
\& struct guestfs_dirent_list *guestfs_copy_dirent_list (const struct guestfs_dirent_list *);
\& 
\& void guestfs_free_dirent (struct guestfs_dirent *);
\& void guestfs_free_dirent_list (struct guestfs_dirent_list *);
.Ve
.SS "guestfs_version"
.IX Subsection "guestfs_version"
.Vb 6
\& struct guestfs_version {
\&   int64_t major;
\&   int64_t minor;
\&   int64_t release;
\&   char *extra;
\& };
\& 
\& struct guestfs_version_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_version *val; /* Elements. */
\& };
\&
\& int guestfs_compare_version (const struct guestfs_version *, const struct guestfs_version *);
\& int guestfs_compare_version_list (const struct guestfs_version_list *, const struct guestfs_version_list *);
\& 
\& struct guestfs_version *guestfs_copy_version (const struct guestfs_version *);
\& struct guestfs_version_list *guestfs_copy_version_list (const struct guestfs_version_list *);
\& 
\& void guestfs_free_version (struct guestfs_version *);
\& void guestfs_free_version_list (struct guestfs_version_list *);
.Ve
.SS "guestfs_xattr"
.IX Subsection "guestfs_xattr"
.Vb 6
\& struct guestfs_xattr {
\&   char *attrname;
\&   /* 以下の 2 項目はバイト列を表します。 */
\&   uint32_t attrval_len;
\&   char *attrval;
\& };
\& 
\& struct guestfs_xattr_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_xattr *val; /* Elements. */
\& };
\&
\& int guestfs_compare_xattr (const struct guestfs_xattr *, const struct guestfs_xattr *);
\& int guestfs_compare_xattr_list (const struct guestfs_xattr_list *, const struct guestfs_xattr_list *);
\& 
\& struct guestfs_xattr *guestfs_copy_xattr (const struct guestfs_xattr *);
\& struct guestfs_xattr_list *guestfs_copy_xattr_list (const struct guestfs_xattr_list *);
\& 
\& void guestfs_free_xattr (struct guestfs_xattr *);
\& void guestfs_free_xattr_list (struct guestfs_xattr_list *);
.Ve
.SS "guestfs_inotify_event"
.IX Subsection "guestfs_inotify_event"
.Vb 6
\& struct guestfs_inotify_event {
\&   int64_t in_wd;
\&   uint32_t in_mask;
\&   uint32_t in_cookie;
\&   char *in_name;
\& };
\& 
\& struct guestfs_inotify_event_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_inotify_event *val; /* Elements. */
\& };
\&
\& int guestfs_compare_inotify_event (const struct guestfs_inotify_event *, const struct guestfs_inotify_event *);
\& int guestfs_compare_inotify_event_list (const struct guestfs_inotify_event_list *, const struct guestfs_inotify_event_list *);
\& 
\& struct guestfs_inotify_event *guestfs_copy_inotify_event (const struct guestfs_inotify_event *);
\& struct guestfs_inotify_event_list *guestfs_copy_inotify_event_list (const struct guestfs_inotify_event_list *);
\& 
\& void guestfs_free_inotify_event (struct guestfs_inotify_event *);
\& void guestfs_free_inotify_event_list (struct guestfs_inotify_event_list *);
.Ve
.SS "guestfs_partition"
.IX Subsection "guestfs_partition"
.Vb 6
\& struct guestfs_partition {
\&   int32_t part_num;
\&   uint64_t part_start;
\&   uint64_t part_end;
\&   uint64_t part_size;
\& };
\& 
\& struct guestfs_partition_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_partition *val; /* Elements. */
\& };
\&
\& int guestfs_compare_partition (const struct guestfs_partition *, const struct guestfs_partition *);
\& int guestfs_compare_partition_list (const struct guestfs_partition_list *, const struct guestfs_partition_list *);
\& 
\& struct guestfs_partition *guestfs_copy_partition (const struct guestfs_partition *);
\& struct guestfs_partition_list *guestfs_copy_partition_list (const struct guestfs_partition_list *);
\& 
\& void guestfs_free_partition (struct guestfs_partition *);
\& void guestfs_free_partition_list (struct guestfs_partition_list *);
.Ve
.SS "guestfs_application"
.IX Subsection "guestfs_application"
.Vb 10
\& struct guestfs_application {
\&   char *app_name;
\&   char *app_display_name;
\&   int32_t app_epoch;
\&   char *app_version;
\&   char *app_release;
\&   char *app_install_path;
\&   char *app_trans_path;
\&   char *app_publisher;
\&   char *app_url;
\&   char *app_source_package;
\&   char *app_summary;
\&   char *app_description;
\& };
\& 
\& struct guestfs_application_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_application *val; /* Elements. */
\& };
\&
\& int guestfs_compare_application (const struct guestfs_application *, const struct guestfs_application *);
\& int guestfs_compare_application_list (const struct guestfs_application_list *, const struct guestfs_application_list *);
\& 
\& struct guestfs_application *guestfs_copy_application (const struct guestfs_application *);
\& struct guestfs_application_list *guestfs_copy_application_list (const struct guestfs_application_list *);
\& 
\& void guestfs_free_application (struct guestfs_application *);
\& void guestfs_free_application_list (struct guestfs_application_list *);
.Ve
.SS "guestfs_application2"
.IX Subsection "guestfs_application2"
.Vb 10
\& struct guestfs_application2 {
\&   char *app2_name;
\&   char *app2_display_name;
\&   int32_t app2_epoch;
\&   char *app2_version;
\&   char *app2_release;
\&   char *app2_arch;
\&   char *app2_install_path;
\&   char *app2_trans_path;
\&   char *app2_publisher;
\&   char *app2_url;
\&   char *app2_source_package;
\&   char *app2_summary;
\&   char *app2_description;
\&   char *app2_spare1;
\&   char *app2_spare2;
\&   char *app2_spare3;
\&   char *app2_spare4;
\& };
\& 
\& struct guestfs_application2_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_application2 *val; /* Elements. */
\& };
\&
\& int guestfs_compare_application2 (const struct guestfs_application2 *, const struct guestfs_application2 *);
\& int guestfs_compare_application2_list (const struct guestfs_application2_list *, const struct guestfs_application2_list *);
\& 
\& struct guestfs_application2 *guestfs_copy_application2 (const struct guestfs_application2 *);
\& struct guestfs_application2_list *guestfs_copy_application2_list (const struct guestfs_application2_list *);
\& 
\& void guestfs_free_application2 (struct guestfs_application2 *);
\& void guestfs_free_application2_list (struct guestfs_application2_list *);
.Ve
.SS "guestfs_isoinfo"
.IX Subsection "guestfs_isoinfo"
.Vb 10
\& struct guestfs_isoinfo {
\&   char *iso_system_id;
\&   char *iso_volume_id;
\&   uint32_t iso_volume_space_size;
\&   uint32_t iso_volume_set_size;
\&   uint32_t iso_volume_sequence_number;
\&   uint32_t iso_logical_block_size;
\&   char *iso_volume_set_id;
\&   char *iso_publisher_id;
\&   char *iso_data_preparer_id;
\&   char *iso_application_id;
\&   char *iso_copyright_file_id;
\&   char *iso_abstract_file_id;
\&   char *iso_bibliographic_file_id;
\&   int64_t iso_volume_creation_t;
\&   int64_t iso_volume_modification_t;
\&   int64_t iso_volume_expiration_t;
\&   int64_t iso_volume_effective_t;
\& };
\& 
\& struct guestfs_isoinfo_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_isoinfo *val; /* Elements. */
\& };
\&
\& int guestfs_compare_isoinfo (const struct guestfs_isoinfo *, const struct guestfs_isoinfo *);
\& int guestfs_compare_isoinfo_list (const struct guestfs_isoinfo_list *, const struct guestfs_isoinfo_list *);
\& 
\& struct guestfs_isoinfo *guestfs_copy_isoinfo (const struct guestfs_isoinfo *);
\& struct guestfs_isoinfo_list *guestfs_copy_isoinfo_list (const struct guestfs_isoinfo_list *);
\& 
\& void guestfs_free_isoinfo (struct guestfs_isoinfo *);
\& void guestfs_free_isoinfo_list (struct guestfs_isoinfo_list *);
.Ve
.SS "guestfs_mdstat"
.IX Subsection "guestfs_mdstat"
.Vb 5
\& struct guestfs_mdstat {
\&   char *mdstat_device;
\&   int32_t mdstat_index;
\&   char *mdstat_flags;
\& };
\& 
\& struct guestfs_mdstat_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_mdstat *val; /* Elements. */
\& };
\&
\& int guestfs_compare_mdstat (const struct guestfs_mdstat *, const struct guestfs_mdstat *);
\& int guestfs_compare_mdstat_list (const struct guestfs_mdstat_list *, const struct guestfs_mdstat_list *);
\& 
\& struct guestfs_mdstat *guestfs_copy_mdstat (const struct guestfs_mdstat *);
\& struct guestfs_mdstat_list *guestfs_copy_mdstat_list (const struct guestfs_mdstat_list *);
\& 
\& void guestfs_free_mdstat (struct guestfs_mdstat *);
\& void guestfs_free_mdstat_list (struct guestfs_mdstat_list *);
.Ve
.SS "guestfs_btrfssubvolume"
.IX Subsection "guestfs_btrfssubvolume"
.Vb 5
\& struct guestfs_btrfssubvolume {
\&   uint64_t btrfssubvolume_id;
\&   uint64_t btrfssubvolume_top_level_id;
\&   char *btrfssubvolume_path;
\& };
\& 
\& struct guestfs_btrfssubvolume_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_btrfssubvolume *val; /* Elements. */
\& };
\&
\& int guestfs_compare_btrfssubvolume (const struct guestfs_btrfssubvolume *, const struct guestfs_btrfssubvolume *);
\& int guestfs_compare_btrfssubvolume_list (const struct guestfs_btrfssubvolume_list *, const struct guestfs_btrfssubvolume_list *);
\& 
\& struct guestfs_btrfssubvolume *guestfs_copy_btrfssubvolume (const struct guestfs_btrfssubvolume *);
\& struct guestfs_btrfssubvolume_list *guestfs_copy_btrfssubvolume_list (const struct guestfs_btrfssubvolume_list *);
\& 
\& void guestfs_free_btrfssubvolume (struct guestfs_btrfssubvolume *);
\& void guestfs_free_btrfssubvolume_list (struct guestfs_btrfssubvolume_list *);
.Ve
.SS "guestfs_btrfsqgroup"
.IX Subsection "guestfs_btrfsqgroup"
.Vb 5
\& struct guestfs_btrfsqgroup {
\&   char *btrfsqgroup_id;
\&   uint64_t btrfsqgroup_rfer;
\&   uint64_t btrfsqgroup_excl;
\& };
\& 
\& struct guestfs_btrfsqgroup_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_btrfsqgroup *val; /* Elements. */
\& };
\&
\& int guestfs_compare_btrfsqgroup (const struct guestfs_btrfsqgroup *, const struct guestfs_btrfsqgroup *);
\& int guestfs_compare_btrfsqgroup_list (const struct guestfs_btrfsqgroup_list *, const struct guestfs_btrfsqgroup_list *);
\& 
\& struct guestfs_btrfsqgroup *guestfs_copy_btrfsqgroup (const struct guestfs_btrfsqgroup *);
\& struct guestfs_btrfsqgroup_list *guestfs_copy_btrfsqgroup_list (const struct guestfs_btrfsqgroup_list *);
\& 
\& void guestfs_free_btrfsqgroup (struct guestfs_btrfsqgroup *);
\& void guestfs_free_btrfsqgroup_list (struct guestfs_btrfsqgroup_list *);
.Ve
.SS "guestfs_btrfsbalance"
.IX Subsection "guestfs_btrfsbalance"
.Vb 7
\& struct guestfs_btrfsbalance {
\&   char *btrfsbalance_status;
\&   uint64_t btrfsbalance_total;
\&   uint64_t btrfsbalance_balanced;
\&   uint64_t btrfsbalance_considered;
\&   uint64_t btrfsbalance_left;
\& };
\& 
\& struct guestfs_btrfsbalance_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_btrfsbalance *val; /* Elements. */
\& };
\&
\& int guestfs_compare_btrfsbalance (const struct guestfs_btrfsbalance *, const struct guestfs_btrfsbalance *);
\& int guestfs_compare_btrfsbalance_list (const struct guestfs_btrfsbalance_list *, const struct guestfs_btrfsbalance_list *);
\& 
\& struct guestfs_btrfsbalance *guestfs_copy_btrfsbalance (const struct guestfs_btrfsbalance *);
\& struct guestfs_btrfsbalance_list *guestfs_copy_btrfsbalance_list (const struct guestfs_btrfsbalance_list *);
\& 
\& void guestfs_free_btrfsbalance (struct guestfs_btrfsbalance *);
\& void guestfs_free_btrfsbalance_list (struct guestfs_btrfsbalance_list *);
.Ve
.SS "guestfs_btrfsscrub"
.IX Subsection "guestfs_btrfsscrub"
.Vb 10
\& struct guestfs_btrfsscrub {
\&   uint64_t btrfsscrub_data_extents_scrubbed;
\&   uint64_t btrfsscrub_tree_extents_scrubbed;
\&   uint64_t btrfsscrub_data_bytes_scrubbed;
\&   uint64_t btrfsscrub_tree_bytes_scrubbed;
\&   uint64_t btrfsscrub_read_errors;
\&   uint64_t btrfsscrub_csum_errors;
\&   uint64_t btrfsscrub_verify_errors;
\&   uint64_t btrfsscrub_no_csum;
\&   uint64_t btrfsscrub_csum_discards;
\&   uint64_t btrfsscrub_super_errors;
\&   uint64_t btrfsscrub_malloc_errors;
\&   uint64_t btrfsscrub_uncorrectable_errors;
\&   uint64_t btrfsscrub_unverified_errors;
\&   uint64_t btrfsscrub_corrected_errors;
\&   uint64_t btrfsscrub_last_physical;
\& };
\& 
\& struct guestfs_btrfsscrub_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_btrfsscrub *val; /* Elements. */
\& };
\&
\& int guestfs_compare_btrfsscrub (const struct guestfs_btrfsscrub *, const struct guestfs_btrfsscrub *);
\& int guestfs_compare_btrfsscrub_list (const struct guestfs_btrfsscrub_list *, const struct guestfs_btrfsscrub_list *);
\& 
\& struct guestfs_btrfsscrub *guestfs_copy_btrfsscrub (const struct guestfs_btrfsscrub *);
\& struct guestfs_btrfsscrub_list *guestfs_copy_btrfsscrub_list (const struct guestfs_btrfsscrub_list *);
\& 
\& void guestfs_free_btrfsscrub (struct guestfs_btrfsscrub *);
\& void guestfs_free_btrfsscrub_list (struct guestfs_btrfsscrub_list *);
.Ve
.SS "guestfs_xfsinfo"
.IX Subsection "guestfs_xfsinfo"
.Vb 10
\& struct guestfs_xfsinfo {
\&   char *xfs_mntpoint;
\&   uint32_t xfs_inodesize;
\&   uint32_t xfs_agcount;
\&   uint32_t xfs_agsize;
\&   uint32_t xfs_sectsize;
\&   uint32_t xfs_attr;
\&   uint32_t xfs_blocksize;
\&   uint64_t xfs_datablocks;
\&   uint32_t xfs_imaxpct;
\&   uint32_t xfs_sunit;
\&   uint32_t xfs_swidth;
\&   uint32_t xfs_dirversion;
\&   uint32_t xfs_dirblocksize;
\&   uint32_t xfs_cimode;
\&   char *xfs_logname;
\&   uint32_t xfs_logblocksize;
\&   uint32_t xfs_logblocks;
\&   uint32_t xfs_logversion;
\&   uint32_t xfs_logsectsize;
\&   uint32_t xfs_logsunit;
\&   uint32_t xfs_lazycount;
\&   char *xfs_rtname;
\&   uint32_t xfs_rtextsize;
\&   uint64_t xfs_rtblocks;
\&   uint64_t xfs_rtextents;
\& };
\& 
\& struct guestfs_xfsinfo_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_xfsinfo *val; /* Elements. */
\& };
\&
\& int guestfs_compare_xfsinfo (const struct guestfs_xfsinfo *, const struct guestfs_xfsinfo *);
\& int guestfs_compare_xfsinfo_list (const struct guestfs_xfsinfo_list *, const struct guestfs_xfsinfo_list *);
\& 
\& struct guestfs_xfsinfo *guestfs_copy_xfsinfo (const struct guestfs_xfsinfo *);
\& struct guestfs_xfsinfo_list *guestfs_copy_xfsinfo_list (const struct guestfs_xfsinfo_list *);
\& 
\& void guestfs_free_xfsinfo (struct guestfs_xfsinfo *);
\& void guestfs_free_xfsinfo_list (struct guestfs_xfsinfo_list *);
.Ve
.SS "guestfs_utsname"
.IX Subsection "guestfs_utsname"
.Vb 6
\& struct guestfs_utsname {
\&   char *uts_sysname;
\&   char *uts_release;
\&   char *uts_version;
\&   char *uts_machine;
\& };
\& 
\& struct guestfs_utsname_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_utsname *val; /* Elements. */
\& };
\&
\& int guestfs_compare_utsname (const struct guestfs_utsname *, const struct guestfs_utsname *);
\& int guestfs_compare_utsname_list (const struct guestfs_utsname_list *, const struct guestfs_utsname_list *);
\& 
\& struct guestfs_utsname *guestfs_copy_utsname (const struct guestfs_utsname *);
\& struct guestfs_utsname_list *guestfs_copy_utsname_list (const struct guestfs_utsname_list *);
\& 
\& void guestfs_free_utsname (struct guestfs_utsname *);
\& void guestfs_free_utsname_list (struct guestfs_utsname_list *);
.Ve
.SS "guestfs_hivex_node"
.IX Subsection "guestfs_hivex_node"
.Vb 3
\& struct guestfs_hivex_node {
\&   int64_t hivex_node_h;
\& };
\& 
\& struct guestfs_hivex_node_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_hivex_node *val; /* Elements. */
\& };
\&
\& int guestfs_compare_hivex_node (const struct guestfs_hivex_node *, const struct guestfs_hivex_node *);
\& int guestfs_compare_hivex_node_list (const struct guestfs_hivex_node_list *, const struct guestfs_hivex_node_list *);
\& 
\& struct guestfs_hivex_node *guestfs_copy_hivex_node (const struct guestfs_hivex_node *);
\& struct guestfs_hivex_node_list *guestfs_copy_hivex_node_list (const struct guestfs_hivex_node_list *);
\& 
\& void guestfs_free_hivex_node (struct guestfs_hivex_node *);
\& void guestfs_free_hivex_node_list (struct guestfs_hivex_node_list *);
.Ve
.SS "guestfs_hivex_value"
.IX Subsection "guestfs_hivex_value"
.Vb 3
\& struct guestfs_hivex_value {
\&   int64_t hivex_value_h;
\& };
\& 
\& struct guestfs_hivex_value_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_hivex_value *val; /* Elements. */
\& };
\&
\& int guestfs_compare_hivex_value (const struct guestfs_hivex_value *, const struct guestfs_hivex_value *);
\& int guestfs_compare_hivex_value_list (const struct guestfs_hivex_value_list *, const struct guestfs_hivex_value_list *);
\& 
\& struct guestfs_hivex_value *guestfs_copy_hivex_value (const struct guestfs_hivex_value *);
\& struct guestfs_hivex_value_list *guestfs_copy_hivex_value_list (const struct guestfs_hivex_value_list *);
\& 
\& void guestfs_free_hivex_value (struct guestfs_hivex_value *);
\& void guestfs_free_hivex_value_list (struct guestfs_hivex_value_list *);
.Ve
.SS "guestfs_internal_mountable"
.IX Subsection "guestfs_internal_mountable"
.Vb 5
\& struct guestfs_internal_mountable {
\&   int32_t im_type;
\&   char *im_device;
\&   char *im_volume;
\& };
\& 
\& struct guestfs_internal_mountable_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_internal_mountable *val; /* Elements. */
\& };
\&
\& int guestfs_compare_internal_mountable (const struct guestfs_internal_mountable *, const struct guestfs_internal_mountable *);
\& int guestfs_compare_internal_mountable_list (const struct guestfs_internal_mountable_list *, const struct guestfs_internal_mountable_list *);
\& 
\& struct guestfs_internal_mountable *guestfs_copy_internal_mountable (const struct guestfs_internal_mountable *);
\& struct guestfs_internal_mountable_list *guestfs_copy_internal_mountable_list (const struct guestfs_internal_mountable_list *);
\& 
\& void guestfs_free_internal_mountable (struct guestfs_internal_mountable *);
\& void guestfs_free_internal_mountable_list (struct guestfs_internal_mountable_list *);
.Ve
.SS "guestfs_tsk_dirent"
.IX Subsection "guestfs_tsk_dirent"
.Vb 10
\& struct guestfs_tsk_dirent {
\&   uint64_t tsk_inode;
\&   char tsk_type;
\&   int64_t tsk_size;
\&   char *tsk_name;
\&   uint32_t tsk_flags;
\&   int64_t tsk_atime_sec;
\&   int64_t tsk_atime_nsec;
\&   int64_t tsk_mtime_sec;
\&   int64_t tsk_mtime_nsec;
\&   int64_t tsk_ctime_sec;
\&   int64_t tsk_ctime_nsec;
\&   int64_t tsk_crtime_sec;
\&   int64_t tsk_crtime_nsec;
\&   int64_t tsk_nlink;
\&   char *tsk_link;
\&   int64_t tsk_spare1;
\& };
\& 
\& struct guestfs_tsk_dirent_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_tsk_dirent *val; /* Elements. */
\& };
\&
\& int guestfs_compare_tsk_dirent (const struct guestfs_tsk_dirent *, const struct guestfs_tsk_dirent *);
\& int guestfs_compare_tsk_dirent_list (const struct guestfs_tsk_dirent_list *, const struct guestfs_tsk_dirent_list *);
\& 
\& struct guestfs_tsk_dirent *guestfs_copy_tsk_dirent (const struct guestfs_tsk_dirent *);
\& struct guestfs_tsk_dirent_list *guestfs_copy_tsk_dirent_list (const struct guestfs_tsk_dirent_list *);
\& 
\& void guestfs_free_tsk_dirent (struct guestfs_tsk_dirent *);
\& void guestfs_free_tsk_dirent_list (struct guestfs_tsk_dirent_list *);
.Ve
.SH "可用性"
.IX Header "可用性"
.SS "アプライアンスの機能のグループ"
.IX Subsection "アプライアンスの機能のグループ"
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"part_add\*(R" を使用してください。
.IP "\fBacl\fR" 4
.IX Item "acl"
次の関数: \*(L"guestfs_acl_delete_def_file\*(R" \*(L"guestfs_acl_get_file\*(R"
\&\*(L"guestfs_acl_set_file\*(R"
.IP "\fBblkdiscard\fR" 4
.IX Item "blkdiscard"
The following functions: \*(L"guestfs_blkdiscard\*(R"
.IP "\fBblkdiscardzeroes\fR" 4
.IX Item "blkdiscardzeroes"
The following functions: \*(L"guestfs_blkdiscardzeroes\*(R"
.IP "\fBbtrfs\fR" 4
.IX Item "btrfs"
The following functions: \*(L"guestfs_btrfs_balance_cancel\*(R"
\&\*(L"guestfs_btrfs_balance_pause\*(R" \*(L"guestfs_btrfs_balance_resume\*(R"
\&\*(L"guestfs_btrfs_balance_status\*(R" \*(L"guestfs_btrfs_device_add\*(R"
\&\*(L"guestfs_btrfs_device_delete\*(R" \*(L"guestfs_btrfs_filesystem_balance\*(R"
\&\*(L"guestfs_btrfs_filesystem_defragment\*(R" \*(L"guestfs_btrfs_filesystem_resize\*(R"
\&\*(L"guestfs_btrfs_filesystem_show\*(R" \*(L"guestfs_btrfs_filesystem_sync\*(R"
\&\*(L"guestfs_btrfs_fsck\*(R" \*(L"guestfs_btrfs_image\*(R"
\&\*(L"guestfs_btrfs_qgroup_assign\*(R" \*(L"guestfs_btrfs_qgroup_create\*(R"
\&\*(L"guestfs_btrfs_qgroup_destroy\*(R" \*(L"guestfs_btrfs_qgroup_limit\*(R"
\&\*(L"guestfs_btrfs_qgroup_remove\*(R" \*(L"guestfs_btrfs_qgroup_show\*(R"
\&\*(L"guestfs_btrfs_quota_enable\*(R" \*(L"guestfs_btrfs_quota_rescan\*(R"
\&\*(L"guestfs_btrfs_replace\*(R" \*(L"guestfs_btrfs_rescue_chunk_recover\*(R"
\&\*(L"guestfs_btrfs_rescue_super_recover\*(R" \*(L"guestfs_btrfs_scrub_cancel\*(R"
\&\*(L"guestfs_btrfs_scrub_resume\*(R" \*(L"guestfs_btrfs_scrub_start\*(R"
\&\*(L"guestfs_btrfs_scrub_status\*(R" \*(L"guestfs_btrfs_set_seeding\*(R"
\&\*(L"guestfs_btrfs_subvolume_create\*(R" \*(L"guestfs_btrfs_subvolume_delete\*(R"
\&\*(L"guestfs_btrfs_subvolume_get_default\*(R" \*(L"guestfs_btrfs_subvolume_list\*(R"
\&\*(L"guestfs_btrfs_subvolume_set_default\*(R" \*(L"guestfs_btrfs_subvolume_show\*(R"
\&\*(L"guestfs_btrfs_subvolume_snapshot\*(R"
\&\*(L"guestfs_btrfstune_enable_extended_inode_refs\*(R"
\&\*(L"guestfs_btrfstune_enable_skinny_metadata_extent_refs\*(R"
\&\*(L"guestfs_btrfstune_seeding\*(R" \*(L"guestfs_mkfs_btrfs\*(R"
.IP "\fBextlinux\fR" 4
.IX Item "extlinux"
次の関数: \*(L"guestfs_extlinux\*(R"
.IP "\fBfstrim\fR" 4
.IX Item "fstrim"
次の関数: \*(L"guestfs_fstrim\*(R"
.IP "\fBgdisk\fR" 4
.IX Item "gdisk"
The following functions: \*(L"guestfs_part_expand_gpt\*(R"
\&\*(L"guestfs_part_get_disk_guid\*(R" \*(L"guestfs_part_get_gpt_guid\*(R"
\&\*(L"guestfs_part_get_gpt_type\*(R" \*(L"guestfs_part_set_disk_guid\*(R"
\&\*(L"guestfs_part_set_disk_guid_random\*(R" \*(L"guestfs_part_set_gpt_guid\*(R"
\&\*(L"guestfs_part_set_gpt_type\*(R"
.IP "\fBgrub\fR" 4
.IX Item "grub"
次の関数: \*(L"guestfs_grub_install\*(R"
.IP "\fBhivex\fR" 4
.IX Item "hivex"
次の関数: \*(L"guestfs_hivex_close\*(R" \*(L"guestfs_hivex_commit\*(R"
\&\*(L"guestfs_hivex_node_add_child\*(R" \*(L"guestfs_hivex_node_children\*(R"
\&\*(L"guestfs_hivex_node_delete_child\*(R" \*(L"guestfs_hivex_node_get_child\*(R"
\&\*(L"guestfs_hivex_node_get_value\*(R" \*(L"guestfs_hivex_node_name\*(R"
\&\*(L"guestfs_hivex_node_parent\*(R" \*(L"guestfs_hivex_node_set_value\*(R"
\&\*(L"guestfs_hivex_node_values\*(R" \*(L"guestfs_hivex_open\*(R" \*(L"guestfs_hivex_root\*(R"
\&\*(L"guestfs_hivex_value_key\*(R" \*(L"guestfs_hivex_value_type\*(R"
\&\*(L"guestfs_hivex_value_value\*(R"
.IP "\fBinotify\fR" 4
.IX Item "inotify"
次の関数: \*(L"guestfs_inotify_add_watch\*(R" \*(L"guestfs_inotify_close\*(R"
\&\*(L"guestfs_inotify_files\*(R" \*(L"guestfs_inotify_init\*(R" \*(L"guestfs_inotify_read\*(R"
\&\*(L"guestfs_inotify_rm_watch\*(R"
.IP "\fBjournal\fR" 4
.IX Item "journal"
The following functions: \*(L"guestfs_internal_journal_get\*(R"
\&\*(L"guestfs_journal_close\*(R" \*(L"guestfs_journal_get_data_threshold\*(R"
\&\*(L"guestfs_journal_get_realtime_usec\*(R" \*(L"guestfs_journal_next\*(R"
\&\*(L"guestfs_journal_open\*(R" \*(L"guestfs_journal_set_data_threshold\*(R"
\&\*(L"guestfs_journal_skip\*(R"
.IP "\fBldm\fR" 4
.IX Item "ldm"
次の関数: \*(L"guestfs_ldmtool_create_all\*(R" \*(L"guestfs_ldmtool_diskgroup_disks\*(R"
\&\*(L"guestfs_ldmtool_diskgroup_name\*(R" \*(L"guestfs_ldmtool_diskgroup_volumes\*(R"
\&\*(L"guestfs_ldmtool_remove_all\*(R" \*(L"guestfs_ldmtool_scan\*(R"
\&\*(L"guestfs_ldmtool_scan_devices\*(R" \*(L"guestfs_ldmtool_volume_hint\*(R"
\&\*(L"guestfs_ldmtool_volume_partitions\*(R" \*(L"guestfs_ldmtool_volume_type\*(R"
\&\*(L"guestfs_list_ldm_partitions\*(R" \*(L"guestfs_list_ldm_volumes\*(R"
.IP "\fBlibtsk\fR" 4
.IX Item "libtsk"
The following functions: \*(L"guestfs_internal_filesystem_walk\*(R"
\&\*(L"guestfs_internal_find_inode\*(R"
.IP "\fBlinuxcaps\fR" 4
.IX Item "linuxcaps"
次の関数: \*(L"guestfs_cap_get_file\*(R" \*(L"guestfs_cap_set_file\*(R"
.IP "\fBlinuxfsuuid\fR" 4
.IX Item "linuxfsuuid"
次の関数: \*(L"guestfs_mke2fs_JU\*(R" \*(L"guestfs_mke2journal_U\*(R" \*(L"guestfs_mkswap_U\*(R"
\&\*(L"guestfs_swapoff_uuid\*(R" \*(L"guestfs_swapon_uuid\*(R"
.IP "\fBlinuxmodules\fR" 4
.IX Item "linuxmodules"
次の関数: \*(L"guestfs_modprobe\*(R"
.IP "\fBlinuxxattrs\fR" 4
.IX Item "linuxxattrs"
次の関数: \*(L"guestfs_getxattr\*(R" \*(L"guestfs_getxattrs\*(R"
\&\*(L"guestfs_internal_lxattrlist\*(R" \*(L"guestfs_lgetxattr\*(R" \*(L"guestfs_lgetxattrs\*(R"
\&\*(L"guestfs_lremovexattr\*(R" \*(L"guestfs_lsetxattr\*(R" \*(L"guestfs_removexattr\*(R"
\&\*(L"guestfs_setxattr\*(R"
.IP "\fBluks\fR" 4
.IX Item "luks"
次の関数: \*(L"guestfs_luks_add_key\*(R" \*(L"guestfs_luks_close\*(R"
\&\*(L"guestfs_luks_format\*(R" \*(L"guestfs_luks_format_cipher\*(R"
\&\*(L"guestfs_luks_kill_slot\*(R" \*(L"guestfs_luks_open\*(R" \*(L"guestfs_luks_open_ro\*(R"
.IP "\fBlvm2\fR" 4
.IX Item "lvm2"
次の関数: \*(L"guestfs_lvcreate\*(R" \*(L"guestfs_lvcreate_free\*(R"
\&\*(L"guestfs_lvm_remove_all\*(R" \*(L"guestfs_lvm_set_filter\*(R" \*(L"guestfs_lvremove\*(R"
\&\*(L"guestfs_lvresize\*(R" \*(L"guestfs_lvresize_free\*(R" \*(L"guestfs_lvs\*(R"
\&\*(L"guestfs_lvs_full\*(R" \*(L"guestfs_pvchange_uuid\*(R" \*(L"guestfs_pvchange_uuid_all\*(R"
\&\*(L"guestfs_pvcreate\*(R" \*(L"guestfs_pvremove\*(R" \*(L"guestfs_pvresize\*(R"
\&\*(L"guestfs_pvresize_size\*(R" \*(L"guestfs_pvs\*(R" \*(L"guestfs_pvs_full\*(R"
\&\*(L"guestfs_vg_activate\*(R" \*(L"guestfs_vg_activate_all\*(R"
\&\*(L"guestfs_vgchange_uuid\*(R" \*(L"guestfs_vgchange_uuid_all\*(R" \*(L"guestfs_vgcreate\*(R"
\&\*(L"guestfs_vgmeta\*(R" \*(L"guestfs_vgremove\*(R" \*(L"guestfs_vgs\*(R" \*(L"guestfs_vgs_full\*(R"
.IP "\fBmdadm\fR" 4
.IX Item "mdadm"
次の関数: \*(L"guestfs_md_create\*(R" \*(L"guestfs_md_detail\*(R" \*(L"guestfs_md_stat\*(R"
\&\*(L"guestfs_md_stop\*(R"
.IP "\fBmknod\fR" 4
.IX Item "mknod"
次の関数: \*(L"guestfs_mkfifo\*(R" \*(L"guestfs_mknod\*(R" \*(L"guestfs_mknod_b\*(R"
\&\*(L"guestfs_mknod_c\*(R"
.IP "\fBntfs3g\fR" 4
.IX Item "ntfs3g"
次の関数: \*(L"guestfs_ntfs_3g_probe\*(R" \*(L"guestfs_ntfsclone_in\*(R"
\&\*(L"guestfs_ntfsclone_out\*(R" \*(L"guestfs_ntfsfix\*(R"
.IP "\fBntfsprogs\fR" 4
.IX Item "ntfsprogs"
次の関数: \*(L"guestfs_ntfsresize\*(R" \*(L"guestfs_ntfsresize_size\*(R"
.IP "\fBrsync\fR" 4
.IX Item "rsync"
次の関数: \*(L"guestfs_rsync\*(R" \*(L"guestfs_rsync_in\*(R" \*(L"guestfs_rsync_out\*(R"
.IP "\fBscrub\fR" 4
.IX Item "scrub"
次の関数: \*(L"guestfs_scrub_device\*(R" \*(L"guestfs_scrub_file\*(R"
\&\*(L"guestfs_scrub_freespace\*(R"
.IP "\fBselinux\fR" 4
.IX Item "selinux"
次の関数: \*(L"guestfs_getcon\*(R" \*(L"guestfs_setcon\*(R"
.IP "\fBselinuxrelabel\fR" 4
.IX Item "selinuxrelabel"
The following functions: \*(L"guestfs_selinux_relabel\*(R"
.IP "\fBsleuthkit\fR" 4
.IX Item "sleuthkit"
The following functions: \*(L"guestfs_download_blocks\*(R"
\&\*(L"guestfs_download_inode\*(R"
.IP "\fBsquashfs\fR" 4
.IX Item "squashfs"
The following functions: \*(L"guestfs_mksquashfs\*(R"
.IP "\fBsyslinux\fR" 4
.IX Item "syslinux"
次の関数: \*(L"guestfs_syslinux\*(R"
.IP "\fBwipefs\fR" 4
.IX Item "wipefs"
次の関数: \*(L"guestfs_wipefs\*(R"
.IP "\fBxfs\fR" 4
.IX Item "xfs"
次の関数: \*(L"guestfs_xfs_admin\*(R" \*(L"guestfs_xfs_growfs\*(R" \*(L"guestfs_xfs_info\*(R"
\&\*(L"guestfs_xfs_repair\*(R"
.IP "\fBxz\fR" 4
.IX Item "xz"
次の関数: \*(L"guestfs_txz_in\*(R" \*(L"guestfs_txz_out\*(R"
.IP "\fBzerofree\fR" 4
.IX Item "zerofree"
次の関数: \*(L"guestfs_zerofree\*(R"
.SS "利用可能なファイルシステム"
.IX Subsection "利用可能なファイルシステム"
The \*(L"guestfs_filesystem_available\*(R" call tests whether a filesystem type is
supported by the appliance kernel.
.PP
This is mainly useful as a negative test.  If this returns true, it doesn't
mean that a particular filesystem can be mounted, since filesystems can fail
for other reasons such as it being a later version of the filesystem, or
having incompatible features.
.SS "guestfish がサポートするコマンド"
.IX Subsection "guestfish がサポートするコマンド"
In \fIguestfish\fR\|(3) there is a handy interactive command \f(CW\*(C`supported\*(C'\fR which
prints out the available groups and whether they are supported by this build
of libguestfs.  Note however that you have to do \f(CW\*(C`run\*(C'\fR first.
.SS "\s-1SINGLE CALLS AT COMPILE TIME\s0"
.IX Subsection "SINGLE CALLS AT COMPILE TIME"
バージョン 1.5.8 から \f(CW\*(C`<guestfs.h>\*(C'\fR に定義されたシンボルの C \s-1API\s0
関数があります。次のようなものがあります:
.PP
.Vb 1
\& #define GUESTFS_HAVE_DD 1
.Ve
.PP
\&\*(L"guestfs_dd\*(R" が利用可能な場合。
.PP
Before version 1.5.8, if you needed to test whether a single libguestfs
function is available at compile time, we recommended using build tools such
as autoconf or cmake.  For example in autotools you could use:
.PP
.Vb 2
\& AC_CHECK_LIB([guestfs],[guestfs_create])
\& AC_CHECK_FUNCS([guestfs_dd])
.Ve
.PP
which would result in \f(CW\*(C`HAVE_GUESTFS_DD\*(C'\fR being either defined or not defined
in your program.
.SS "\s-1SINGLE CALLS AT RUN TIME\s0"
.IX Subsection "SINGLE CALLS AT RUN TIME"
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"part_list\*(R" を使用してください。
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"write\*(R" を使用してください。
.PP
.Vb 5
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <unistd.h>
\& #include <dlfcn.h>
\& #include <guestfs.h>
\& 
\& main ()
\& {
\& #ifdef GUESTFS_HAVE_DD
\&   void *dl;
\&   int has_function;
\& 
\&   /* guestfs_dd 関数が本当に利用可能かを確認します。 */
\&   dl = dlopen (NULL, RTLD_LAZY);
\&   if (!dl) {
\&     fprintf (stderr, "dlopen: %s\en", dlerror ());
\&     exit (EXIT_FAILURE);
\&   }
\&   has_function = dlsym (dl, "guestfs_dd") != NULL;
\&   dlclose (dl);
\& 
\&   if (!has_function)
\&     printf ("この libguestfs.so は guestfs_dd 関数がありません\en");
\&   else {
\&     printf ("この libguestfs.so は guestfs_dd 関数があります\en");
\&     /* Now it\*(Aqs safe to call
\&     guestfs_dd (g, "foo", "bar");
\&     */
\&   }
\& #else
\&   printf ("guestfs_dd 関数がコンパイル時に見つかりませんでした\en");
\& #endif
\&  }
.Ve
.PP
You may think the above is an awful lot of hassle, and it is.  There are
other ways outside of the C linking system to ensure that this kind of
incompatibility never arises, such as using package versioning:
.PP
.Vb 1
\& Requires: libguestfs >= 1.0.80
.Ve
.SH "CALLS WITH OPTIONAL ARGUMENTS"
.IX Header "CALLS WITH OPTIONAL ARGUMENTS"
A recent feature of the \s-1API\s0 is the introduction of calls which take optional
arguments.  In C these are declared 3 ways.  The main way is as a call which
takes variable arguments (ie. \f(CW\*(C`...\*(C'\fR), as in this example:
.PP
.Vb 1
\& int guestfs_add_drive_opts (guestfs_h *g, const char *filename, ...);
.Ve
.PP
Call this with a list of optional arguments, terminated by \f(CW\*(C`\-1\*(C'\fR.  So to
call with no optional arguments specified:
.PP
.Vb 1
\& guestfs_add_drive_opts (g, filename, \-1);
.Ve
.PP
単一の引数の場合:
.PP
.Vb 3
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
\&                         \-1);
.Ve
.PP
2つの引数の場合:
.PP
.Vb 4
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
\&                         GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
\&                         \-1);
.Ve
.PP
and so forth.  Don't forget the terminating \f(CW\*(C`\-1\*(C'\fR otherwise Bad Things will
happen!
.SS "\s-1USING\s0 va_list \s-1FOR OPTIONAL ARGUMENTS\s0"
.IX Subsection "USING va_list FOR OPTIONAL ARGUMENTS"
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_add_drive_opts\*(R" を使用してください。
.PP
.Vb 2
\& int guestfs_add_drive_opts_va (guestfs_h *g, const char *filename,
\&                                va_list args);
.Ve
.SS "オプション引数の構築"
.IX Subsection "オプション引数の構築"
The third variant is useful where you need to construct these calls.  You
pass in a structure where you fill in the optional fields.  The structure
has a bitmask as the first element which you must set to indicate which
fields you have filled in.  For our example function the structure and call
are declared:
.PP
.Vb 8
\& struct guestfs_add_drive_opts_argv {
\&   uint64_t bitmask;
\&   int readonly;
\&   const char *format;
\&   /* ... */
\& };
\& int guestfs_add_drive_opts_argv (guestfs_h *g, const char *filename,
\&              const struct guestfs_add_drive_opts_argv *optargs);
.Ve
.PP
次のように呼び出すことができます。
.PP
.Vb 6
\& struct guestfs_add_drive_opts_argv optargs = {
\&   .bitmask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK |
\&              GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK,
\&   .readonly = 1,
\&   .format = "qcow2"
\& };
\& 
\& guestfs_add_drive_opts_argv (g, filename, &optargs);
.Ve
.PP
注:
.IP "\(bu" 4
The \f(CW\*(C`_BITMASK\*(C'\fR suffix on each option name when specifying the bitmask.
.IP "\(bu" 4
You do not need to fill in all fields of the structure.
.IP "\(bu" 4
There must be a one-to-one correspondence between fields of the structure
that are filled in, and bits set in the bitmask.
.SS "\s-1OPTIONAL ARGUMENTS IN OTHER LANGUAGES\s0"
.IX Subsection "OPTIONAL ARGUMENTS IN OTHER LANGUAGES"
In other languages, optional arguments are expressed in the way that is
natural for that language.  We refer you to the language-specific
documentation for more details on that.
.PP
guestfish は \*(L"\s-1OPTIONAL ARGUMENTS\*(R"\s0 in \fIguestfish\fR\|(1) を参照してください。
.SH "イベント"
.IX Header "イベント"
.SS "\s-1SETTING CALLBACKS TO HANDLE EVENTS\s0"
.IX Subsection "SETTING CALLBACKS TO HANDLE EVENTS"
\&\fBNote:\fR This section documents the generic event mechanism introduced in
libguestfs 1.10, which you should use in new code if possible.  The old
functions \f(CW\*(C`guestfs_set_log_message_callback\*(C'\fR,
\&\f(CW\*(C`guestfs_set_subprocess_quit_callback\*(C'\fR,
\&\f(CW\*(C`guestfs_set_launch_done_callback\*(C'\fR, \f(CW\*(C`guestfs_set_close_callback\*(C'\fR and
\&\f(CW\*(C`guestfs_set_progress_callback\*(C'\fR are no longer documented in this manual
page.  Because of the \s-1ABI\s0 guarantee, the old functions continue to work.
.PP
Handles generate events when certain things happen, such as log messages
being generated, progress messages during long-running operations, or the
handle being closed.  The \s-1API\s0 calls described below let you register a
callback to be called when events happen.  You can register multiple
callbacks (for the same, different or overlapping sets of events), and
individually remove callbacks.  If callbacks are not removed, then they
remain in force until the handle is closed.
.PP
In the current implementation, events are only generated synchronously: that
means that events (and hence callbacks) can only happen while you are in the
middle of making another libguestfs call.  The callback is called in the
same thread.
.PP
Events may contain a payload, usually nothing (void), an array of 64 bit
unsigned integers, or a message buffer.  Payloads are discussed later on.
.SS "イベントのクラス"
.IX Subsection "イベントのクラス"
.IP "\s-1GUESTFS_EVENT_CLOSE\s0 (ペイロード形式: void)" 4
.IX Item "GUESTFS_EVENT_CLOSE (ペイロード形式: void)"
The callback function will be called while the handle is being closed
(synchronously from \*(L"guestfs_close\*(R").
.Sp
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_fallocate64\*(R" を使用してください。
.Sp
If no callback is registered: the handle is closed without any callback
being invoked.
.IP "\s-1GUESTFS_EVENT_SUBPROCESS_QUIT\s0 (ペイロード形式: void)" 4
.IX Item "GUESTFS_EVENT_SUBPROCESS_QUIT (ペイロード形式: void)"
The callback function will be called when the child process quits, either
asynchronously or if killed by \*(L"guestfs_kill_subprocess\*(R".  (This
corresponds to a transition from any state to the \s-1CONFIG\s0 state).
.Sp
If no callback is registered: the event is ignored.
.IP "\s-1GUESTFS_EVENT_LAUNCH_DONE\s0 (ペイロード形式: void)" 4
.IX Item "GUESTFS_EVENT_LAUNCH_DONE (ペイロード形式: void)"
The callback function will be called when the child process becomes ready
first time after it has been launched.  (This corresponds to a transition
from \s-1LAUNCHING\s0 to the \s-1READY\s0 state).
.Sp
If no callback is registered: the event is ignored.
.IP "\s-1GUESTFS_EVENT_PROGRESS\s0 (ペイロード形式: 4 x uint64_t の配列)" 4
.IX Item "GUESTFS_EVENT_PROGRESS (ペイロード形式: 4 x uint64_t の配列)"
Some long-running operations can generate progress messages.  If this
callback is registered, then it will be called each time a progress message
is generated (usually two seconds after the operation started, and three
times per second thereafter until it completes, although the frequency may
change in future versions).
.Sp
The callback receives in the payload four unsigned 64 bit numbers which are
(in order): \f(CW\*(C`proc_nr\*(C'\fR, \f(CW\*(C`serial\*(C'\fR, \f(CW\*(C`position\*(C'\fR, \f(CW\*(C`total\*(C'\fR.
.Sp
The units of \f(CW\*(C`total\*(C'\fR are not defined, although for some operations \f(CW\*(C`total\*(C'\fR
may relate in some way to the amount of data to be transferred (eg. in bytes
or megabytes), and \f(CW\*(C`position\*(C'\fR may be the portion which has been
transferred.
.Sp
The only defined and stable parts of the \s-1API\s0 are:
.RS 4
.IP "\(bu" 4
The callback can display to the user some type of progress bar or indicator
which shows the ratio of \f(CW\*(C`position\*(C'\fR:\f(CW\*(C`total\*(C'\fR.
.IP "\(bu" 4
0 <= \f(CW\*(C`position\*(C'\fR <= \f(CW\*(C`total\*(C'\fR
.IP "\(bu" 4
If any progress notification is sent during a call, then a final progress
notification is always sent when \f(CW\*(C`position\*(C'\fR = \f(CW\*(C`total\*(C'\fR (\fIunless\fR the call
fails with an error).
.Sp
This is to simplify caller code, so callers can easily set the progress
indicator to \*(L"100%\*(R" at the end of the operation, without requiring special
code to detect this case.
.IP "\(bu" 4
For some calls we are unable to estimate the progress of the call, but we
can still generate progress messages to indicate activity.  This is known as
\&\*(L"pulse mode\*(R", and is directly supported by certain progress bar
implementations (eg. GtkProgressBar).
.Sp
For these calls, zero or more progress messages are generated with
\&\f(CW\*(C`position = 0\*(C'\fR and \f(CW\*(C`total = 1\*(C'\fR, followed by a final message with
\&\f(CW\*(C`position = total = 1\*(C'\fR.
.Sp
As noted above, if the call fails with an error then the final message may
not be generated.
.RE
.RS 4
.Sp
The callback also receives the procedure number (\f(CW\*(C`proc_nr\*(C'\fR) and serial
number (\f(CW\*(C`serial\*(C'\fR) of the call.  These are only useful for debugging
protocol issues, and the callback can normally ignore them.  The callback
may want to print these numbers in error messages or debugging messages.
.Sp
If no callback is registered: progress messages are discarded.
.RE
.IP "\s-1GUESTFS_EVENT_APPLIANCE\s0 (ペイロード形式: メッセージバッファー)" 4
.IX Item "GUESTFS_EVENT_APPLIANCE (ペイロード形式: メッセージバッファー)"
The callback function is called whenever a log message is generated by qemu,
the appliance kernel, guestfsd (daemon), or utility programs.
.Sp
If the verbose flag (\*(L"guestfs_set_verbose\*(R") is set before launch
(\*(L"guestfs_launch\*(R") then additional debug messages are generated.
.Sp
If no callback is registered: the messages are discarded unless the verbose
flag is set in which case they are sent to stderr.  You can override the
printing of verbose messages to stderr by setting up a callback.
.IP "\s-1GUESTFS_EVENT_LIBRARY\s0 (payload type: message buffer)" 4
.IX Item "GUESTFS_EVENT_LIBRARY (payload type: message buffer)"
The callback function is called whenever a log message is generated by the
library part of libguestfs.
.Sp
If the verbose flag (\*(L"guestfs_set_verbose\*(R") is set then additional debug
messages are generated.
.Sp
If no callback is registered: the messages are discarded unless the verbose
flag is set in which case they are sent to stderr.  You can override the
printing of verbose messages to stderr by setting up a callback.
.IP "\s-1GUESTFS_EVENT_WARNING\s0 (payload type: message buffer)" 4
.IX Item "GUESTFS_EVENT_WARNING (payload type: message buffer)"
The callback function is called whenever a warning message is generated by
the library part of libguestfs.
.Sp
If no callback is registered: the messages are printed to stderr.  You can
override the printing of warning messages to stderr by setting up a
callback.
.IP "\s-1GUESTFS_EVENT_TRACE\s0 (ペイロード形式: メッセージバッファー)" 4
.IX Item "GUESTFS_EVENT_TRACE (ペイロード形式: メッセージバッファー)"
The callback function is called whenever a trace message is generated.  This
only applies if the trace flag (\*(L"guestfs_set_trace\*(R") is set.
.Sp
If no callback is registered: the messages are sent to stderr.  You can
override the printing of trace messages to stderr by setting up a callback.
.IP "\s-1GUESTFS_EVENT_ENTER\s0 (payload type: function name)" 4
.IX Item "GUESTFS_EVENT_ENTER (payload type: function name)"
The callback function is called whenever a libguestfs function is entered.
.Sp
The payload is a string which contains the name of the function that we are
entering (not including \f(CW\*(C`guestfs_\*(C'\fR prefix).
.Sp
Note that libguestfs functions can call themselves, so you may see many
events from a single call.  A few libguestfs functions do not generate this
event.
.Sp
If no callback is registered: the event is ignored.
.IP "\s-1GUESTFS_EVENT_LIBVIRT_AUTH\s0 (payload type: libvirt \s-1URI\s0)" 4
.IX Item "GUESTFS_EVENT_LIBVIRT_AUTH (payload type: libvirt URI)"
For any \s-1API\s0 function that opens a libvirt connection, this event may be
generated to indicate that libvirt demands authentication information.  See
\&\*(L"\s-1LIBVIRT AUTHENTICATION\*(R"\s0 below.
.Sp
If no callback is registered: \f(CW\*(C`virConnectAuthPtrDefault\*(C'\fR is used (suitable
for command-line programs only).
.SS "イベント \s-1API\s0"
.IX Subsection "イベント API"
\fIguestfs_set_event_callback\fR
.IX Subsection "guestfs_set_event_callback"
.PP
.Vb 5
\& int guestfs_set_event_callback (guestfs_h *g,
\&                                 guestfs_event_callback cb,
\&                                 uint64_t event_bitmask,
\&                                 int flags,
\&                                 void *opaque);
.Ve
.PP
This function registers a callback (\f(CW\*(C`cb\*(C'\fR) for all event classes in the
\&\f(CW\*(C`event_bitmask\*(C'\fR.
.PP
For example, to register for all log message events, you could call this
function with the bitmask
\&\f(CW\*(C`GUESTFS_EVENT_APPLIANCE|GUESTFS_EVENT_LIBRARY|GUESTFS_EVENT_WARNING\*(C'\fR.  To
register a single callback for all possible classes of events, use
\&\f(CW\*(C`GUESTFS_EVENT_ALL\*(C'\fR.
.PP
\&\f(CW\*(C`flags\*(C'\fR should always be passed as 0.
.PP
\&\f(CW\*(C`opaque\*(C'\fR is an opaque pointer which is passed to the callback.  You can use
it for any purpose.
.PP
The return value is the event handle (an integer) which you can use to
delete the callback (see below).
.PP
If there is an error, this function returns \f(CW\*(C`\-1\*(C'\fR, and sets the error in the
handle in the usual way (see \*(L"guestfs_last_error\*(R" etc.)
.PP
Callbacks remain in effect until they are deleted, or until the handle is
closed.
.PP
In the case where multiple callbacks are registered for a particular event
class, all of the callbacks are called.  The order in which multiple
callbacks are called is not defined.
.PP
\fIguestfs_delete_event_callback\fR
.IX Subsection "guestfs_delete_event_callback"
.PP
.Vb 1
\& void guestfs_delete_event_callback (guestfs_h *g, int event_handle);
.Ve
.PP
Delete a callback that was previously registered.  \f(CW\*(C`event_handle\*(C'\fR should be
the integer that was returned by a previous call to
\&\f(CW\*(C`guestfs_set_event_callback\*(C'\fR on the same handle.
.PP
\fIguestfs_event_to_string\fR
.IX Subsection "guestfs_event_to_string"
.PP
.Vb 1
\& char *guestfs_event_to_string (uint64_t event);
.Ve
.PP
\&\f(CW\*(C`event\*(C'\fR is either a single event or a bitmask of events.  This returns a
string representation (useful for debugging or printing events).
.PP
A single event is returned as the name in lower case, eg. \f(CW"close"\fR.
.PP
A bitmask of several events is returned as a comma-separated list,
eg. \f(CW"close,progress"\fR.
.PP
If zero is passed, then the empty string \f(CW""\fR is returned.
.PP
On success this returns a string.  On error it returns \s-1NULL\s0 and sets
\&\f(CW\*(C`errno\*(C'\fR.
.PP
The returned string must be freed by the caller.
.PP
\fIguestfs_event_callback\fR
.IX Subsection "guestfs_event_callback"
.PP
.Vb 8
\& typedef void (*guestfs_event_callback) (
\&                  guestfs_h *g,
\&                  void *opaque,
\&                  uint64_t event,
\&                  int event_handle,
\&                  int flags,
\&                  const char *buf, size_t buf_len,
\&                  const uint64_t *array, size_t array_len);
.Ve
.PP
This is the type of the event callback function that you have to provide.
.PP
The basic parameters are: the handle (\f(CW\*(C`g\*(C'\fR), the opaque user pointer
(\f(CW\*(C`opaque\*(C'\fR), the event class (eg. \f(CW\*(C`GUESTFS_EVENT_PROGRESS\*(C'\fR), the event
handle, and \f(CW\*(C`flags\*(C'\fR which in the current \s-1API\s0 you should ignore.
.PP
The remaining parameters contain the event payload (if any).  Each event may
contain a payload, which usually relates to the event class, but for future
proofing your code should be written to handle any payload for any event
class.
.PP
\&\f(CW\*(C`buf\*(C'\fR and \f(CW\*(C`buf_len\*(C'\fR contain a message buffer (if \f(CW\*(C`buf_len == 0\*(C'\fR, then
there is no message buffer).  Note that this message buffer can contain
arbitrary 8 bit data, including \s-1NUL\s0 bytes.
.PP
\&\f(CW\*(C`array\*(C'\fR and \f(CW\*(C`array_len\*(C'\fR is an array of 64 bit unsigned integers.  At the
moment this is only used for progress messages.
.SS "\s-1EXAMPLE: CAPTURING LOG MESSAGES\s0"
.IX Subsection "EXAMPLE: CAPTURING LOG MESSAGES"
A working program demonstrating this can be found in
\&\fIexamples/debug\-logging.c\fR in the source of libguestfs.
.PP
One motivation for the generic event \s-1API\s0 was to allow \s-1GUI\s0 programs to
capture debug and other messages.  In libguestfs ≤ 1.8 these were sent
unconditionally to \f(CW\*(C`stderr\*(C'\fR.
.PP
Events associated with log messages are: \f(CW\*(C`GUESTFS_EVENT_LIBRARY\*(C'\fR,
\&\f(CW\*(C`GUESTFS_EVENT_APPLIANCE\*(C'\fR, \f(CW\*(C`GUESTFS_EVENT_WARNING\*(C'\fR and
\&\f(CW\*(C`GUESTFS_EVENT_TRACE\*(C'\fR.  (Note that error messages are not events; you must
capture error messages separately).
.PP
Programs have to set up a callback to capture the classes of events of
interest:
.PP
.Vb 9
\& int eh =
\&   guestfs_set_event_callback
\&     (g, message_callback,
\&      GUESTFS_EVENT_LIBRARY | GUESTFS_EVENT_APPLIANCE |
\&      GUESTFS_EVENT_WARNING | GUESTFS_EVENT_TRACE,
\&      0, NULL) == \-1)
\& if (eh == \-1) {
\&   // handle error in the usual way
\& }
.Ve
.PP
The callback can then direct messages to the appropriate place.  In this
example, messages are directed to syslog:
.PP
.Vb 10
\& static void
\& message_callback (
\&         guestfs_h *g,
\&         void *opaque,
\&         uint64_t event,
\&         int event_handle,
\&         int flags,
\&         const char *buf, size_t buf_len,
\&         const uint64_t *array, size_t array_len)
\& {
\&   const int priority = LOG_USER|LOG_INFO;
\&   if (buf_len > 0)
\&     syslog (priority, "event 0x%lx: %s", event, buf);
\& }
.Ve
.SS "libvirt 認証"
.IX Subsection "libvirt 認証"
Some libguestfs \s-1API\s0 calls can open libvirt connections.  Currently the only
ones are \*(L"guestfs_add_domain\*(R"; and \*(L"guestfs_launch\*(R" if the libvirt
backend has been selected.  Libvirt connections may require authentication,
for example if they need to access a remote server or to access root
services from non-root.  Libvirt authentication happens via a callback
mechanism, see
http://libvirt.org/guide/html/Application_Development_Guide\-Connections.html
.PP
You may provide libvirt authentication data by registering a callback for
events of type \f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR.
.PP
If no such event is registered, then libguestfs uses a libvirt function that
provides command-line prompts (\f(CW\*(C`virConnectAuthPtrDefault\*(C'\fR).  This is only
suitable for command-line libguestfs programs.
.PP
To provide authentication, first call
\&\*(L"guestfs_set_libvirt_supported_credentials\*(R" with the list of credentials
your program knows how to provide.  Second, register a callback for the
\&\f(CW\*(C`GUESTFS_EVENT_LIBVIRT_AUTH\*(C'\fR event.  The event handler will be called when
libvirt is requesting authentication information.
.PP
In the event handler, call \*(L"guestfs_get_libvirt_requested_credentials\*(R" to
get a list of the credentials that libvirt is asking for.  You then need to
ask (eg. the user) for each credential, and call
\&\*(L"guestfs_set_libvirt_requested_credential\*(R" with the answer.  Note that for
each credential, additional information may be available via the calls
\&\*(L"guestfs_get_libvirt_requested_credential_prompt\*(R",
\&\*(L"guestfs_get_libvirt_requested_credential_challenge\*(R" or
\&\*(L"guestfs_get_libvirt_requested_credential_defresult\*(R".
.PP
The example program below should make this clearer.
.PP
There is also a more substantial working example program supplied with the
libguestfs sources, called \fIlibvirt\-auth.c\fR.
.PP
.Vb 5
\& main ()
\& {
\&   guestfs_h *g;
\&   char *creds[] = { "authname", "passphrase", NULL };
\&   int r, eh;
\& 
\&   g = guestfs_create ();
\&   if (!g) exit (EXIT_FAILURE);
\& 
\&   /* プログラムがサポートするクレデンシャルを libvirt に伝える。 */
\&   r = guestfs_set_libvirt_supported_credentials (g, creds);
\&   if (r == \-1)
\&     exit (EXIT_FAILURE);
\& 
\&   /* イベントハンドラーをセットアップする。 */
\&   eh = guestfs_set_event_callback (
\&       g, do_auth,
\&       GUESTFS_EVENT_LIBVIRT_AUTH, 0, NULL);
\&   if (eh == \-1)
\&     exit (EXIT_FAILURE);
\& 
\&   /* An example of a call that may ask for credentials. */
\&   r = guestfs_add_domain (
\&       g, "dom",
\&       GUESTFS_ADD_DOMAIN_LIBVIRTURI, "qemu:///system",
\&       \-1);
\&   if (r == \-1)
\&     exit (EXIT_FAILURE);
\& 
\&   exit (EXIT_SUCCESS);
\& }
\& 
\& static void
\& do_auth (guestfs_h *g,
\&          void *opaque,
\&          uint64_t event,
\&          int event_handle,
\&          int flags,
\&          const char *buf, size_t buf_len,
\&          const uint64_t *array, size_t array_len)
\& {
\&   char **creds;
\&   size_t i;
\&   char *prompt;
\&   char *reply;
\&   size_t replylen;
\&   int r;
\& 
\&   // buf will be the libvirt URI.  buf_len may be ignored.
\&   printf ("Authentication required for libvirt conn \*(Aq%s\*(Aq\en",
\&           buf);
\& 
\&   // Ask libguestfs what credentials libvirt is demanding.
\&   creds = guestfs_get_libvirt_requested_credentials (g);
\&   if (creds == NULL)
\&     exit (EXIT_FAILURE);
\& 
\&   // Now ask the user for answers.
\&   for (i = 0; creds[i] != NULL; ++i)
\&   {
\&     if (strcmp (creds[i], "authname") == 0 ||
\&         strcmp (creds[i], "passphrase") == 0)
\&     {
\&       prompt =
\&         guestfs_get_libvirt_requested_credential_prompt (g, i);
\&       if (prompt && strcmp (prompt, "") != 0)
\&         printf ("%s: ", prompt);
\&       free (prompt);
\& 
\&       // Some code here to ask for the credential.
\&       // ...
\&       // Put the reply in \*(Aqreply\*(Aq, length \*(Aqreplylen\*(Aq (bytes).
\& 
\&      r = guestfs_set_libvirt_requested_credential (g, i,
\&          reply, replylen);
\&      if (r == \-1)
\&        exit (EXIT_FAILURE);
\&     }
\& 
\&     free (creds[i]);
\&   }
\& 
\&   free (creds);
\& }
.Ve
.SH "CANCELLING LONG TRANSFERS"
.IX Header "CANCELLING LONG TRANSFERS"
Some operations can be cancelled by the caller while they are in progress.
Currently only operations that involve uploading or downloading data can be
cancelled (technically: operations that have \f(CW\*(C`FileIn\*(C'\fR or \f(CW\*(C`FileOut\*(C'\fR
parameters in the generator).
.PP
To cancel the transfer, call \*(L"guestfs_user_cancel\*(R".  For more information,
read the description of \*(L"guestfs_user_cancel\*(R".
.SH "プライベートデータ領域"
.IX Header "プライベートデータ領域"
You can attach named pieces of private data to the libguestfs handle, fetch
them by name, and walk over them, for the lifetime of the handle.  This is
called the private data area and is only available from the C \s-1API.\s0
.PP
データの名前付き部分を接続するには、以下の呼び出しを使用します:
.PP
.Vb 1
\& void guestfs_set_private (guestfs_h *g, const char *key, void *data);
.Ve
.PP
\&\f(CW\*(C`key\*(C'\fR is the name to associate with this data, and \f(CW\*(C`data\*(C'\fR is an arbitrary
pointer (which can be \f(CW\*(C`NULL\*(C'\fR).  Any previous item with the same key is
overwritten.
.PP
You can use any \f(CW\*(C`key\*(C'\fR string you want, but avoid keys beginning with an
underscore character (libguestfs uses those for its own internal purposes,
such as implementing language bindings).  It is recommended that you prefix
the key with some unique string to avoid collisions with other users.
.PP
ポインターを取り出すには、次を使用します:
.PP
.Vb 1
\& void *guestfs_get_private (guestfs_h *g, const char *key);
.Ve
.PP
\&\fIこの関数は推奨されません。\fR 新しいコードでは、代わりに \*(L"guestfs_vfs_label\*(R" を使用してください。
.PP
Libguestfs does not try to look at or interpret the \f(CW\*(C`data\*(C'\fR pointer in any
way.  As far as libguestfs is concerned, it need not be a valid pointer at
all.  In particular, libguestfs does \fInot\fR try to free the data when the
handle is closed.  If the data must be freed, then the caller must either
free it before calling \*(L"guestfs_close\*(R" or must set up a close callback to
do it (see \*(L"\s-1GUESTFS_EVENT_CLOSE\*(R"\s0).
.PP
To walk over all entries, use these two functions:
.PP
.Vb 1
\& void *guestfs_first_private (guestfs_h *g, const char **key_rtn);
\&
\& void *guestfs_next_private (guestfs_h *g, const char **key_rtn);
.Ve
.PP
\&\f(CW\*(C`guestfs_first_private\*(C'\fR returns the first key, pointer pair (\*(L"first\*(R" does
not have any particular meaning \*(-- keys are not returned in any defined
order).  A pointer to the key is returned in \f(CW*key_rtn\fR and the
corresponding data pointer is returned from the function.  \f(CW\*(C`NULL\*(C'\fR is
returned if there are no keys stored in the handle.
.PP
\&\f(CW\*(C`guestfs_next_private\*(C'\fR returns the next key, pointer pair.  The return
value of this function is \f(CW\*(C`NULL\*(C'\fR if there are no further entries to return.
.PP
Notes about walking over entries:
.IP "\(bu" 4
You must not call \f(CW\*(C`guestfs_set_private\*(C'\fR while walking over the entries.
.IP "\(bu" 4
The handle maintains an internal iterator which is reset when you call
\&\f(CW\*(C`guestfs_first_private\*(C'\fR.  This internal iterator is invalidated when you
call \f(CW\*(C`guestfs_set_private\*(C'\fR.
.IP "\(bu" 4
If you have set the data pointer associated with a key to \f(CW\*(C`NULL\*(C'\fR, ie:
.Sp
.Vb 1
\& guestfs_set_private (g, key, NULL);
.Ve
.Sp
then that \f(CW\*(C`key\*(C'\fR is not returned when walking.
.IP "\(bu" 4
\&\f(CW*key_rtn\fR is only valid until the next call to \f(CW\*(C`guestfs_first_private\*(C'\fR,
\&\f(CW\*(C`guestfs_next_private\*(C'\fR or \f(CW\*(C`guestfs_set_private\*(C'\fR.
.PP
The following example code shows how to print all keys and data pointers
that are associated with the handle \f(CW\*(C`g\*(C'\fR:
.PP
.Vb 7
\& const char *key;
\& void *data = guestfs_first_private (g, &key);
\& while (data != NULL)
\&   {
\&     printf ("key = %s, data = %p\en", key, data);
\&     data = guestfs_next_private (g, &key);
\&   }
.Ve
.PP
More commonly you are only interested in keys that begin with an
application-specific prefix \f(CW\*(C`foo_\*(C'\fR.  Modify the loop like so:
.PP
.Vb 8
\& const char *key;
\& void *data = guestfs_first_private (g, &key);
\& while (data != NULL)
\&   {
\&     if (strncmp (key, "foo_", strlen ("foo_")) == 0)
\&       printf ("key = %s, data = %p\en", key, data);
\&     data = guestfs_next_private (g, &key);
\&   }
.Ve
.PP
If you need to modify keys while walking, then you have to jump back to the
beginning of the loop.  For example, to delete all keys prefixed with
\&\f(CW\*(C`foo_\*(C'\fR:
.PP
.Vb 10
\&  const char *key;
\&  void *data;
\& again:
\&  data = guestfs_first_private (g, &key);
\&  while (data != NULL)
\&    {
\&      if (strncmp (key, "foo_", strlen ("foo_")) == 0)
\&        {
\&          guestfs_set_private (g, key, NULL);
\&          /* note that \*(Aqkey\*(Aq pointer is now invalid, and so is
\&             the internal iterator */
\&          goto again;
\&        }
\&      data = guestfs_next_private (g, &key);
\&    }
.Ve
.PP
Note that the above loop is guaranteed to terminate because the keys are
being deleted, but other manipulations of keys within the loop might not
terminate unless you also maintain an indication of which keys have been
visited.
.SH "SYSTEMTAP"
.IX Header "SYSTEMTAP"
The libguestfs C library can be probed using systemtap or DTrace.  This is
true of any library, not just libguestfs.  However libguestfs also contains
static markers to help in probing internal operations.
.PP
You can list all the static markers by doing:
.PP
.Vb 2
\& stap \-l \*(Aqprocess("/usr/lib*/libguestfs.so.0")
\&              .provider("guestfs").mark("*")\*(Aq
.Ve
.PP
\&\fBNote:\fR These static markers are \fInot\fR part of the stable \s-1API\s0 and may
change in future versions.
.SS "\s-1SYSTEMTAP SCRIPT EXAMPLE\s0"
.IX Subsection "SYSTEMTAP SCRIPT EXAMPLE"
This script contains examples of displaying both the static markers and some
ordinary C entry points:
.PP
.Vb 1
\& global last;
\& 
\& function display_time () {
\&       now = gettimeofday_us ();
\&       delta = 0;
\&       if (last > 0)
\&             delta = now \- last;
\&       last = now;
\& 
\&       printf ("%d (+%d):", now, delta);
\& }
\& 
\& probe begin {
\&       last = 0;
\&       printf ("ready\en");
\& }
\& 
\& /* Display all calls to static markers. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .provider("guestfs").mark("*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", $$name, $$parms);
\& }
\& 
\& /* guestfs_mkfs* 関数へのすべての呼び出しを一覧表示します。 */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .function("guestfs_mkfs*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", probefunc(), $$parms);
\& }
.Ve
.PP
The script above can be saved to \fItest.stap\fR and run using the \fIstap\fR\|(1)
program.  Note that you either have to be root, or you have to add yourself
to several special stap groups.  Consult the systemtap documentation for
more information.
.PP
.Vb 2
\& # stap /tmp/test.stap
\& ready
.Ve
.PP
他の端末において、このように guestfish コマンドを実行します:
.PP
.Vb 1
\& guestfish \-N fs
.Ve
.PP
In the first terminal, stap trace output similar to this is shown:
.PP
.Vb 6
\& 1318248056692655 (+0): launch_start
\& 1318248056692850 (+195):       launch_build_appliance_start
\& 1318248056818285 (+125435):    launch_build_appliance_end
\& 1318248056838059 (+19774):     launch_run_qemu
\& 1318248061071167 (+4233108):   launch_end
\& 1318248061280324 (+209157):    guestfs_mkfs g=0x1024ab0 fstype=0x46116f device=0x1024e60
.Ve
.SH "LIBGUESTFS VERSION NUMBERS"
.IX Header "LIBGUESTFS VERSION NUMBERS"
Since April 2010, libguestfs has started to make separate development and
stable releases, along with corresponding branches in our git repository.
These separate releases can be identified by version number:
.PP
.Vb 10
\&                 偶数は安定版: 1.2.x, 1.4.x, ...
\&       .\-\-\-\-\-\-\-\- 奇数は開発版: 1.3.x, 1.5.x, ...
\&       |
\&       v
\& 1  .  3  .  5
\& ^           ^
\& |           |
\& |           \`\-\-\-\-\-\-\-\- サブバージョン
\& |
\& \`\-\-\-\-\-\- ABI を変更しないので、必ず \*(Aq1\*(Aq です
.Ve
.PP
このように \*(L"1.3.5\*(R" は開発ブランチ \*(L"1.3\*(R" の 5 番目のアップデートです。
.PP
As time passes we cherry pick fixes from the development branch and backport
those into the stable branch, the effect being that the stable branch should
get more stable and less buggy over time.  So the stable releases are ideal
for people who don't need new features but would just like the software to
work.
.PP
バックポートする変更に対する私たちの基準は次のとおりです:
.IP "\(bu" 4
コードに何も影響しないドキュメントの変更は、ドキュメントが安定版にない将来の機能を参照していなければ、バックポートされます。
.IP "\(bu" 4
議論の余地がなく、明らかな問題を修正する、十分にテストされたバグ修正はバックポートされます。
.IP "\(bu" 4
Simple rearrangements of code which shouldn't affect how it works get
backported.  This is so that the code in the two branches doesn't get too
far out of step, allowing us to backport future fixes more easily.
.IP "\(bu" 4
We \fIdon't\fR backport new features, new APIs, new tools etc, except in one
exceptional case: the new feature is required in order to implement an
important bug fix.
.PP
A new stable branch starts when we think the new features in development are
substantial and compelling enough over the current stable branch to warrant
it.  When that happens we create new stable and development versions 1.N.0
and 1.(N+1).0 [N is even].  The new dot-oh release won't necessarily be so
stable at this point, but by backporting fixes from development, that branch
will stabilize over time.
.SH "制限"
.IX Header "制限"
.SS "プロトコル制限"
.IX Subsection "プロトコル制限"
Internally libguestfs uses a message-based protocol to pass \s-1API\s0 calls and
their responses to and from a small \*(L"appliance\*(R" (see \fIguestfs\-internals\fR\|(1)
for plenty more detail about this).  The maximum message size used by the
protocol is slightly less than 4 \s-1MB.\s0  For some \s-1API\s0 calls you may need to be
aware of this limit.  The \s-1API\s0 calls which may be affected are individually
documented, with a link back to this section of the documentation.
.PP
In libguestfs < 1.19.32, several calls had to encode either their entire
argument list or their entire return value (or sometimes both)  in a single
protocol message, and this gave them an arbitrary limitation on how much
data they could handle.  For example, \*(L"guestfs_cat\*(R" could only download a
file if it was less than around 4 \s-1MB\s0 in size.  In later versions of
libguestfs, some of these limits have been removed.  The APIs which were
previously limited but are now unlimited (except perhaps by available
memory) are listed below.  To find out if a specific \s-1API\s0 is subject to
protocol limits, check for the warning in the \s-1API\s0 documentation which links
to this section, and remember to check the version of the documentation that
matches the version of libguestfs you are using.
.PP
\&\*(L"guestfs_cat\*(R", \*(L"guestfs_find\*(R", \*(L"guestfs_read_file\*(R",
\&\*(L"guestfs_read_lines\*(R", \*(L"guestfs_write\*(R", \*(L"guestfs_write_append\*(R",
\&\*(L"guestfs_lstatlist\*(R", \*(L"guestfs_lxattrlist\*(R", \*(L"guestfs_readlinklist\*(R",
\&\*(L"guestfs_ls\*(R".
.PP
See also \*(L"\s-1UPLOADING\*(R"\s0 and \*(L"\s-1DOWNLOADING\*(R"\s0 for further information about
copying large amounts of data into or out of a filesystem.
.SS "ディスクの最大数"
.IX Subsection "ディスクの最大数"
In libguestfs ≥ 1.19.7, you can query the maximum number of disks that
may be added by calling \*(L"guestfs_max_disks\*(R".  In earlier versions of
libguestfs (ie. where this call is not available) you should assume the
maximum is 25.
.PP
The rest of this section covers implementation details, which could change
in future.
.PP
virtio-scsi ディスク (\s-1QEMU\s0 において利用可能ならば初期値) を使用しているとき、現在の制限は \fB255\fR
個のディスクです。virtio\-blk (古い初期値) を使用しているとき、約 \fB27\fR
個のディスクです。しかし、実装の詳細やネットワークが有効化されているかどうかにより、変化する可能性があります。
.PP
libguestfs により使用される virtio-scsi はディスクあたり一つのターゲットを使用するよう設定されます。256
個のターゲットが利用可能です。
.PP
virtio-blk はディスクあたり 1 仮想 \s-1PCI\s0 を消費します。PCI は 31
スロットに制限されます。これらのいくつかは他の目的のために使用されます。
.PP
一つの仮想ディスクが libguestfs により内部的に使用されます。
.PP
Before libguestfs 1.19.7, disk names had to be a single character
(eg. \fI/dev/sda\fR through \fI/dev/sdz\fR), and since one disk is reserved, that
meant the limit was 25.  This has been fixed in more recent versions.
.PP
libguestfs ≥ 1.20 はディスクの活性挿入をできます。 \*(L"\s-1HOTPLUGGING\*(R"\s0 参照。
.SS "ディスクあたりの最大パーティション数"
.IX Subsection "ディスクあたりの最大パーティション数"
virtio はディスクあたりの最大パーティション数を \fB15\fR に制限します。
.PP
This is because it reserves 4 bits for the minor device number (thus
\&\fI/dev/vda\fR, and \fI/dev/vda1\fR through \fI/dev/vda15\fR).
.PP
15 よりも多くのパーティションを持つディスクを接続すると、追加のパーティションは libguestfs により無視されます。
.SS "ディスクの最大容量"
.IX Subsection "ディスクの最大容量"
制限はおそらく 2**63\-1 から 2**64\-1 バイトの間です。
.PP
We have tested block devices up to 1 exabyte (2**60 or
1,152,921,504,606,846,976 bytes) using sparse files backed by an \s-1XFS\s0 host
filesystem.
.PP
Although libguestfs probably does not impose any limit, the underlying host
storage will.  If you store disk images on a host ext4 filesystem, then the
maximum size will be limited by the maximum ext4 file size (currently 16
\&\s-1TB\s0).  If you store disk images as host logical volumes then you are limited
by the maximum size of an \s-1LV.\s0
.PP
For the hugest disk image files, we recommend using \s-1XFS\s0 on the host for
storage.
.SS "パーティションの最大容量"
.IX Subsection "パーティションの最大容量"
The \s-1MBR\s0 (ie. classic MS-DOS) partitioning scheme uses 32 bit sector
numbers.  Assuming a 512 byte sector size, this means that \s-1MBR\s0 cannot
address a partition located beyond 2 \s-1TB\s0 on the disk.
.PP
It is recommended that you use \s-1GPT\s0 partitions on disks which are larger than
this size.  \s-1GPT\s0 uses 64 bit sector numbers and so can address partitions
which are theoretically larger than the largest disk we could support.
.SS "ファイルシステム、ファイル、ディレクトリーの最大容量"
.IX Subsection "ファイルシステム、ファイル、ディレクトリーの最大容量"
This depends on the filesystem type.  libguestfs itself does not impose any
known limit.  Consult Wikipedia or the filesystem documentation to find out
what these limits are.
.SS "最大アップロード数およびダウンロード数"
.IX Subsection "最大アップロード数およびダウンロード数"
\&\s-1API\s0 関数 \*(L"guestfs_upload\*(R", \*(L"guestfs_download\*(R", \*(L"guestfs_tar_in\*(R",
\&\*(L"guestfs_tar_out\*(R" および類似のものは、アップロードとダウンロードの数量に制限がありません。
.SS "検査の制限"
.IX Subsection "検査の制限"
The inspection code has several arbitrary limits on things like the size of
Windows Registry hive it will read, and the length of product name.  These
are intended to stop a malicious guest from consuming arbitrary amounts of
memory and disk space on the host, and should not be reached in practice.
See the source code for more information.
.SH "環境変数"
.IX Header "環境変数"
.IP "\s-1LIBGUESTFS_APPEND\s0" 4
.IX Item "LIBGUESTFS_APPEND"
仮想マシンのカーネルに追加のオプションを渡します。
.IP "\s-1LIBGUESTFS_ATTACH_METHOD\s0" 4
.IX Item "LIBGUESTFS_ATTACH_METHOD"
This is the old way to set \f(CW\*(C`LIBGUESTFS_BACKEND\*(C'\fR.
.IP "\s-1LIBGUESTFS_BACKEND\s0" 4
.IX Item "LIBGUESTFS_BACKEND"
Choose the default way to create the appliance.  See \*(L"guestfs_set_backend\*(R"
and \*(L"\s-1BACKEND\*(R"\s0.
.IP "\s-1LIBGUESTFS_BACKEND_SETTINGS\s0" 4
.IX Item "LIBGUESTFS_BACKEND_SETTINGS"
A colon-separated list of backend-specific settings.  See \*(L"\s-1BACKEND\*(R"\s0,
\&\*(L"\s-1BACKEND SETTINGS\*(R"\s0.
.IP "\s-1LIBGUESTFS_CACHEDIR\s0" 4
.IX Item "LIBGUESTFS_CACHEDIR"
The location where libguestfs will cache its appliance, when using a
supermin appliance.  The appliance is cached and shared between all handles
which have the same effective user \s-1ID.\s0
.Sp
If \f(CW\*(C`LIBGUESTFS_CACHEDIR\*(C'\fR is not set, then \f(CW\*(C`TMPDIR\*(C'\fR is used.  If \f(CW\*(C`TMPDIR\*(C'\fR
is not set, then \fI/var/tmp\fR is used.
.Sp
See also \*(L"\s-1LIBGUESTFS_TMPDIR\*(R"\s0, \*(L"guestfs_set_cachedir\*(R".
.IP "\s-1LIBGUESTFS_DEBUG\s0" 4
.IX Item "LIBGUESTFS_DEBUG"
Set \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR to enable verbose messages.  This has the same
effect as calling \f(CW\*(C`guestfs_set_verbose (g, 1)\*(C'\fR.
.IP "\s-1LIBGUESTFS_HV\s0" 4
.IX Item "LIBGUESTFS_HV"
Set the default hypervisor (usually qemu) binary that libguestfs uses.  If
not set, then the qemu which was found at compile time by the configure
script is used.
.Sp
上の \*(L"\s-1QEMU WRAPPERS\*(R"\s0 参照。
.IP "\s-1LIBGUESTFS_MEMSIZE\s0" 4
.IX Item "LIBGUESTFS_MEMSIZE"
Set the memory allocated to the qemu process, in megabytes.  For example:
.Sp
.Vb 1
\& LIBGUESTFS_MEMSIZE=700
.Ve
.IP "\s-1LIBGUESTFS_PATH\s0" 4
.IX Item "LIBGUESTFS_PATH"
Set the path that libguestfs uses to search for a supermin appliance.  See
the discussion of paths in section \*(L"\s-1PATH\*(R"\s0 above.
.IP "\s-1LIBGUESTFS_QEMU\s0" 4
.IX Item "LIBGUESTFS_QEMU"
This is the old way to set \f(CW\*(C`LIBGUESTFS_HV\*(C'\fR.
.IP "\s-1LIBGUESTFS_TMPDIR\s0" 4
.IX Item "LIBGUESTFS_TMPDIR"
The location where libguestfs will store temporary files used by each
handle.
.Sp
If \f(CW\*(C`LIBGUESTFS_TMPDIR\*(C'\fR is not set, then \f(CW\*(C`TMPDIR\*(C'\fR is used.  If \f(CW\*(C`TMPDIR\*(C'\fR is
not set, then \fI/tmp\fR is used.
.Sp
See also \*(L"\s-1LIBGUESTFS_CACHEDIR\*(R"\s0, \*(L"guestfs_set_tmpdir\*(R".
.IP "\s-1LIBGUESTFS_TRACE\s0" 4
.IX Item "LIBGUESTFS_TRACE"
コマンドトレースを有効にするには \f(CW\*(C`LIBGUESTFS_TRACE=1\*(C'\fR を設定します。これは \f(CW\*(C`guestfs_set_trace (g,
1)\*(C'\fR の呼び出しと同じ効果があります。
.IP "パス" 4
.IX Item "パス"
Libguestfs may run some external programs, and relies on \f(CW$PATH\fR being set
to a reasonable value.  If using the libvirt backend, libvirt will not work
at all unless \f(CW$PATH\fR contains the path of qemu/KVM.  Note that \s-1PHP\s0 by
default removes \f(CW$PATH\fR from the environment which tends to break
everything.
.IP "\s-1SUPERMIN_KERNEL\s0" 4
.IX Item "SUPERMIN_KERNEL"
.PD 0
.IP "\s-1SUPERMIN_KERNEL_VERSION\s0" 4
.IX Item "SUPERMIN_KERNEL_VERSION"
.IP "\s-1SUPERMIN_MODULES\s0" 4
.IX Item "SUPERMIN_MODULES"
.PD
These three environment variables allow the kernel that libguestfs uses in
the appliance to be selected.  If \f(CW$SUPERMIN_KERNEL\fR is not set, then the
most recent host kernel is chosen.  For more information about kernel
selection, see \fIsupermin\fR\|(1).
.IP "\s-1TMPDIR\s0" 4
.IX Item "TMPDIR"
See \*(L"\s-1LIBGUESTFS_CACHEDIR\*(R"\s0, \*(L"\s-1LIBGUESTFS_TMPDIR\*(R"\s0.
.IP "\s-1XDG_RUNTIME_DIR\s0" 4
.IX Item "XDG_RUNTIME_DIR"
This directory represents a user-specific directory for storing
non-essential runtime files.
.Sp
If it is set, then is used to store temporary sockets.  Otherwise, \fI/tmp\fR
is used.
.Sp
See also \*(L"get-sockdir\*(R",
http://www.freedesktop.org/wiki/Specifications/basedir\-spec/.
.SH "関連項目"
.IX Header "関連項目"
Examples written in C: \fIguestfs\-examples\fR\|(3).
.PP
Language bindings: \fIguestfs\-erlang\fR\|(3), \fIguestfs\-golang\fR\|(3),
\&\fIguestfs\-java\fR\|(3), \fIguestfs\-lua\fR\|(3), \fIguestfs\-ocaml\fR\|(3),
\&\fIguestfs\-perl\fR\|(3), \fIguestfs\-python\fR\|(3), \fIguestfs\-ruby\fR\|(3).
.PP
Tools: \fIguestfish\fR\|(1), \fIguestmount\fR\|(1), \fIvirt\-alignment\-scan\fR\|(1),
\&\fIvirt\-builder\fR\|(1), \fIvirt\-cat\fR\|(1), \fIvirt\-copy\-in\fR\|(1), \fIvirt\-copy\-out\fR\|(1),
\&\fIvirt\-customize\fR\|(1), \fIvirt\-df\fR\|(1), \fIvirt\-diff\fR\|(1), \fIvirt\-edit\fR\|(1),
\&\fIvirt\-filesystems\fR\|(1), \fIvirt\-format\fR\|(1), \fIvirt\-inspector\fR\|(1),
\&\fIvirt\-list\-filesystems\fR\|(1), \fIvirt\-list\-partitions\fR\|(1), \fIvirt\-log\fR\|(1),
\&\fIvirt\-ls\fR\|(1), \fIvirt\-make\-fs\fR\|(1), \fIvirt\-p2v\fR\|(1), \fIvirt\-rescue\fR\|(1),
\&\fIvirt\-resize\fR\|(1), \fIvirt\-sparsify\fR\|(1), \fIvirt\-sysprep\fR\|(1), \fIvirt\-tail\fR\|(1),
\&\fIvirt\-tar\fR\|(1), \fIvirt\-tar\-in\fR\|(1), \fIvirt\-tar\-out\fR\|(1), \fIvirt\-v2v\fR\|(1),
\&\fIvirt\-win\-reg\fR\|(1).
.PP
Other libguestfs topics: \fIguestfs\-building\fR\|(1), \fIguestfs\-faq\fR\|(1),
\&\fIguestfs\-hacking\fR\|(1), \fIguestfs\-internals\fR\|(1), \fIguestfs\-performance\fR\|(1),
\&\fIguestfs\-release\-notes\fR\|(1), \fIguestfs\-security\fR\|(1), \fIguestfs\-testing\fR\|(1),
\&\fIlibguestfs\-test\-tool\fR\|(1), \fIlibguestfs\-make\-fixed\-appliance\fR\|(1).
.PP
Related manual pages: \fIsupermin\fR\|(1), \fIqemu\fR\|(1), \fIhivex\fR\|(3), \fIstap\fR\|(1),
\&\fIsd\-journal\fR\|(3).
.PP
Website: http://libguestfs.org/
.PP
同じ目的を持つツール: \fIfdisk\fR\|(8), \fIparted\fR\|(8), \fIkpartx\fR\|(8), \fIlvm\fR\|(8),
\&\fIdisktype\fR\|(1).
.SH "著者"
.IX Header "著者"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2009\-2017 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 Lesser General Public License as published
by the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
This library is distributed in the hope that it will be useful, but
\&\s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See the \s-1GNU\s0
Lesser General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, \s-1MA
02110\-1301 USA\s0
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools
.PP
To report a new bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools
.PP
When reporting a bug, please supply:
.IP "\(bu" 4
The version of libguestfs.
.IP "\(bu" 4
Where you got libguestfs (eg. which Linux distro, compiled from source, etc)
.IP "\(bu" 4
Describe the bug accurately and give a way to reproduce it.
.IP "\(bu" 4
Run \fIlibguestfs\-test\-tool\fR\|(1) and paste the \fBcomplete, unedited\fR
output into the bug report.
