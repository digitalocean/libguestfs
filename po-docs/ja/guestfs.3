.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "guestfs 3"
.TH guestfs 3 "2012-03-08" "libguestfs-1.16.9" "Virtualization Support"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "名前"
.IX Header "名前"
guestfs \- Library for accessing and modifying virtual machine images
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
#include <guestfs.h>
 guestfs_h *g = guestfs_create ();
 guestfs_add_drive (g, \*(L"guest.img\*(R");
 guestfs_launch (g);
 guestfs_mount (g, \*(L"/dev/sda1\*(R", \*(L"/\*(R");
 guestfs_touch (g, \*(L"/hello\*(R");
 guestfs_umount (g, \*(L"/\*(R");
 guestfs_close (g);
.PP
.Vb 3
\& cc prog.c \-o prog \-lguestfs
\&or:
\& cc prog.c \-o prog \`pkg\-config libguestfs \-\-cflags \-\-libs\`
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Libguestfs is a library for accessing and modifying guest disk images.
Amongst the things this is good for: making batch configuration changes to
guests, getting disk used/free statistics (see also: virt-df), migrating
between virtualization systems (see also: virt\-p2v), performing partial
backups, performing partial guest clones, cloning guests and changing
registry/UUID/hostname info, and much else besides.
.PP
Libguestfs uses Linux kernel and qemu code, and can access any type of guest
filesystem that Linux and qemu can, including but not limited to: ext2/3/4,
btrfs, \s-1FAT\s0 and \s-1NTFS\s0, \s-1LVM\s0, many different disk partition schemes, qcow,
qcow2, vmdk.
.PP
Libguestfs provides ways to enumerate guest storage (eg. partitions, LVs,
what filesystem is in each \s-1LV\s0, etc.).  It can also run commands in the
context of the guest.  Also you can access filesystems over \s-1FUSE\s0.
.PP
Libguestfs is a library that can be linked with C and \*(C+ management
programs (or management programs written in OCaml, Perl, Python, Ruby, Java,
\&\s-1PHP\s0, Erlang, Haskell or C#).  You can also use it from shell scripts or the
command line.
.PP
You don't need to be root to use libguestfs, although obviously you do need
enough permissions to access the disk images.
.PP
Libguestfs is a large \s-1API\s0 because it can do many things.  For a gentle
introduction, please read the \*(L"\s-1API\s0 \s-1OVERVIEW\s0\*(R" section next.
.PP
There are also some example programs in the \fIguestfs\-examples\fR\|(3) manual
page.
.SH "API OVERVIEW"
.IX Header "API OVERVIEW"
This section provides a gentler overview of the libguestfs \s-1API\s0.  We also try
to group \s-1API\s0 calls together, where that may not be obvious from reading
about the individual calls in the main section of this manual.
.SS "\s-1HANDLES\s0"
.IX Subsection "HANDLES"
Before you can use libguestfs calls, you have to create a handle.  Then you
must add at least one disk image to the handle, followed by launching the
handle, then performing whatever operations you want, and finally closing
the handle.  By convention we use the single letter \f(CW\*(C`g\*(C'\fR for the name of the
handle variable, although of course you can use any name you want.
.PP
The general structure of all libguestfs-using programs looks like this:
.PP
.Vb 1
\& guestfs_h *g = guestfs_create ();
\& 
\& /* Call guestfs_add_drive additional times if there are
\&  * multiple disk images.
\&  */
\& guestfs_add_drive (g, "guest.img");
\& 
\& /* Most manipulation calls won\*(Aqt work until you\*(Aqve launched
\&  * the handle \*(Aqg\*(Aq.  You have to do this _after_ adding drives
\&  * and _before_ other commands.
\&  */
\& guestfs_launch (g);
\& 
\& /* Now you can examine what partitions, LVs etc are available.
\&  */
\& char **partitions = guestfs_list_partitions (g);
\& char **logvols = guestfs_lvs (g);
\& 
\& /* To access a filesystem in the image, you must mount it.
\&  */
\& guestfs_mount (g, "/dev/sda1", "/");
\& 
\& /* Now you can perform filesystem actions on the guest
\&  * disk image.
\&  */
\& guestfs_touch (g, "/hello");
\& 
\& /* This is only needed for libguestfs < 1.5.24.  Since then
\&  * it is done automatically when you close the handle.  See
\&  * discussion of autosync in this page.
\&  */
\& guestfs_sync (g);
\& 
\& /* Close the handle \*(Aqg\*(Aq. */
\& guestfs_close (g);
.Ve
.PP
The code above doesn't include any error checking.  In real code you should
check return values carefully for errors.  In general all functions that
return integers return \f(CW\*(C`\-1\*(C'\fR on error, and all functions that return
pointers return \f(CW\*(C`NULL\*(C'\fR on error.  See section \*(L"\s-1ERROR\s0 \s-1HANDLING\s0\*(R" below for
how to handle errors, and consult the documentation for each function call
below to see precisely how they return error indications.  See
\&\fIguestfs\-examples\fR\|(3) for fully worked examples.
.SS "\s-1DISK\s0 \s-1IMAGES\s0"
.IX Subsection "DISK IMAGES"
The image filename (\f(CW"guest.img"\fR in the example above) could be a disk
image from a virtual machine, a \fIdd\fR\|(1) copy of a physical hard disk, an
actual block device, or simply an empty file of zeroes that you have created
through \fIposix_fallocate\fR\|(3).  Libguestfs lets you do useful things to all
of these.
.PP
The call you should use in modern code for adding drives is
\&\*(L"guestfs_add_drive_opts\*(R".  To add a disk image, allowing writes, and
specifying that the format is raw, do:
.PP
.Vb 3
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         \-1);
.Ve
.PP
You can add a disk read-only using:
.PP
.Vb 4
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw",
\&                         GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
\&                         \-1);
.Ve
.PP
or by calling the older function \*(L"guestfs_add_drive_ro\*(R".  In either case
libguestfs won't modify the file.
.PP
Be extremely cautious if the disk image is in use, eg. if it is being used
by a virtual machine.  Adding it read-write will almost certainly cause disk
corruption, but adding it read-only is safe.
.PP
You must add at least one disk image, and you may add multiple disk images.
In the \s-1API\s0, the disk images are usually referred to as \f(CW\*(C`/dev/sda\*(C'\fR (for the
first one you added), \f(CW\*(C`/dev/sdb\*(C'\fR (for the second one you added), etc.
.PP
Once \*(L"guestfs_launch\*(R" has been called you cannot add any more images.  You
can call \*(L"guestfs_list_devices\*(R" to get a list of the device names, in the
order that you added them.  See also \*(L"\s-1BLOCK\s0 \s-1DEVICE\s0 \s-1NAMING\s0\*(R" below.
.SS "\s-1MOUNTING\s0"
.IX Subsection "MOUNTING"
Before you can read or write files, create directories and so on in a disk
image that contains filesystems, you have to mount those filesystems using
\&\*(L"guestfs_mount_options\*(R" or \*(L"guestfs_mount_ro\*(R".  If you already know that
a disk image contains (for example) one partition with a filesystem on that
partition, then you can mount it directly:
.PP
.Vb 1
\& guestfs_mount_options (g, "", "/dev/sda1", "/");
.Ve
.PP
where \f(CW\*(C`/dev/sda1\*(C'\fR means literally the first partition (\f(CW1\fR) of the first
disk image that we added (\f(CW\*(C`/dev/sda\*(C'\fR).  If the disk contains Linux \s-1LVM2\s0
logical volumes you could refer to those instead (eg. \f(CW\*(C`/dev/VG/LV\*(C'\fR).  Note
that these are libguestfs virtual devices, and are nothing to do with host
devices.
.PP
If you are given a disk image and you don't know what it contains then you
have to find out.  Libguestfs can do that too: use
\&\*(L"guestfs_list_partitions\*(R" and \*(L"guestfs_lvs\*(R" to list possible partitions
and LVs, and either try mounting each to see what is mountable, or else
examine them with \*(L"guestfs_vfs_type\*(R" or \*(L"guestfs_file\*(R".  To list just
filesystems, use \*(L"guestfs_list_filesystems\*(R".
.PP
Libguestfs also has a set of APIs for inspection of unknown disk images (see
\&\*(L"\s-1INSPECTION\s0\*(R" below).  But you might find it easier to look at higher level
programs built on top of libguestfs, in particular \fIvirt\-inspector\fR\|(1).
.PP
To mount a filesystem read-only, use \*(L"guestfs_mount_ro\*(R".  There are
several other variations of the \f(CW\*(C`guestfs_mount_*\*(C'\fR call.
.SS "\s-1FILESYSTEM\s0 \s-1ACCESS\s0 \s-1AND\s0 \s-1MODIFICATION\s0"
.IX Subsection "FILESYSTEM ACCESS AND MODIFICATION"
The majority of the libguestfs \s-1API\s0 consists of fairly low-level calls for
accessing and modifying the files, directories, symlinks etc on mounted
filesystems.  There are over a hundred such calls which you can find listed
in detail below in this man page, and we don't even pretend to cover them
all in this overview.
.PP
Specify filenames as full paths, starting with \f(CW"/"\fR and including the
mount point.
.PP
For example, if you mounted a filesystem at \f(CW"/"\fR and you want to read the
file called \f(CW"etc/passwd"\fR then you could do:
.PP
.Vb 1
\& char *data = guestfs_cat (g, "/etc/passwd");
.Ve
.PP
This would return \f(CW\*(C`data\*(C'\fR as a newly allocated buffer containing the full
content of that file (with some conditions: see also \*(L"\s-1DOWNLOADING\s0\*(R" below),
or \f(CW\*(C`NULL\*(C'\fR if there was an error.
.PP
As another example, to create a top-level directory on that filesystem
called \f(CW"var"\fR you would do:
.PP
.Vb 1
\& guestfs_mkdir (g, "/var");
.Ve
.PP
To create a symlink you could do:
.PP
.Vb 2
\& guestfs_ln_s (g, "/etc/init.d/portmap",
\&               "/etc/rc3.d/S30portmap");
.Ve
.PP
Libguestfs will reject attempts to use relative paths and there is no
concept of a current working directory.
.PP
Libguestfs can return errors in many situations: for example if the
filesystem isn't writable, or if a file or directory that you requested
doesn't exist.  If you are using the C \s-1API\s0 (documented here)  you have to
check for those error conditions after each call.  (Other language bindings
turn these errors into exceptions).
.PP
File writes are affected by the per-handle umask, set by calling
\&\*(L"guestfs_umask\*(R" and defaulting to 022.  See \*(L"\s-1UMASK\s0\*(R".
.SS "\s-1PARTITIONING\s0"
.IX Subsection "PARTITIONING"
Libguestfs contains \s-1API\s0 calls to read, create and modify partition tables on
disk images.
.PP
In the common case where you want to create a single partition covering the
whole disk, you should use the \*(L"guestfs_part_disk\*(R" call:
.PP
.Vb 4
\& const char *parttype = "mbr";
\& if (disk_is_larger_than_2TB)
\&   parttype = "gpt";
\& guestfs_part_disk (g, "/dev/sda", parttype);
.Ve
.PP
Obviously this effectively wipes anything that was on that disk image
before.
.SS "\s-1LVM2\s0"
.IX Subsection "LVM2"
Libguestfs provides access to a large part of the \s-1LVM2\s0 \s-1API\s0, such as
\&\*(L"guestfs_lvcreate\*(R" and \*(L"guestfs_vgremove\*(R".  It won't make much sense
unless you familiarize yourself with the concepts of physical volumes,
volume groups and logical volumes.
.PP
This author strongly recommends reading the \s-1LVM\s0 \s-1HOWTO\s0, online at
http://tldp.org/HOWTO/LVM\-HOWTO/ <http://tldp.org/HOWTO/LVM-HOWTO/>.
.SS "\s-1DOWNLOADING\s0"
.IX Subsection "DOWNLOADING"
Use \*(L"guestfs_cat\*(R" to download small, text only files.  This call is
limited to files which are less than 2 \s-1MB\s0 and which cannot contain any \s-1ASCII\s0
\&\s-1NUL\s0 (\f(CW\*(C`\e0\*(C'\fR) characters.  However the \s-1API\s0 is very simple to use.
.PP
\&\*(L"guestfs_read_file\*(R" can be used to read files which contain arbitrary 8
bit data, since it returns a (pointer, size) pair.  However it is still
limited to \*(L"small\*(R" files, less than 2 \s-1MB\s0.
.PP
\&\*(L"guestfs_download\*(R" can be used to download any file, with no limits on
content or size (even files larger than 4 \s-1GB\s0).
.PP
To download multiple files, see \*(L"guestfs_tar_out\*(R" and \*(L"guestfs_tgz_out\*(R".
.SS "\s-1UPLOADING\s0"
.IX Subsection "UPLOADING"
It's often the case that you want to write a file or files to the disk
image.
.PP
To write a small file with fixed content, use \*(L"guestfs_write\*(R".  To create
a file of all zeroes, use \*(L"guestfs_truncate_size\*(R" (sparse) or
\&\*(L"guestfs_fallocate64\*(R" (with all disk blocks allocated).  There are a
variety of other functions for creating test files, for example
\&\*(L"guestfs_fill\*(R" and \*(L"guestfs_fill_pattern\*(R".
.PP
To upload a single file, use \*(L"guestfs_upload\*(R".  This call has no limits on
file content or size (even files larger than 4 \s-1GB\s0).
.PP
To upload multiple files, see \*(L"guestfs_tar_in\*(R" and \*(L"guestfs_tgz_in\*(R".
.PP
However the fastest way to upload \fIlarge numbers of arbitrary files\fR is to
turn them into a squashfs or \s-1CD\s0 \s-1ISO\s0 (see \fImksquashfs\fR\|(8) and
\&\fImkisofs\fR\|(8)), then attach this using \*(L"guestfs_add_drive_ro\*(R".  If you add
the drive in a predictable way (eg. adding it last after all other drives)
then you can get the device name from \*(L"guestfs_list_devices\*(R" and mount it
directly using \*(L"guestfs_mount_ro\*(R".  Note that squashfs images are
sometimes non-portable between kernel versions, and they don't support
labels or UUIDs.  If you want to pre-build an image or you need to mount it
using a label or \s-1UUID\s0, use an \s-1ISO\s0 image instead.
.SS "\s-1COPYING\s0"
.IX Subsection "COPYING"
There are various different commands for copying between files and devices
and in and out of the guest filesystem.  These are summarised in the table
below.
.IP "\fBfile\fR to \fBfile\fR" 4
.IX Item "file to file"
Use \*(L"guestfs_cp\*(R" to copy a single file, or \*(L"guestfs_cp_a\*(R" to copy
directories recursively.
.Sp
To copy part of a file (offset and size) use \*(L"guestfs_copy_file_to_file\*(R".
.IP "\fBfile\fR to \fBdevice\fR" 4
.IX Item "file to device"
.PD 0
.IP "\fBdevice\fR to \fBfile\fR" 4
.IX Item "device to file"
.IP "\fBdevice\fR to \fBdevice\fR" 4
.IX Item "device to device"
.PD
Use \*(L"guestfs_copy_file_to_device\*(R", \*(L"guestfs_copy_device_to_file\*(R", or
\&\*(L"guestfs_copy_device_to_device\*(R".
.Sp
Example: duplicate the contents of an \s-1LV:\s0
.Sp
.Vb 4
\& guestfs_copy_device_to_device (g,
\&         "/dev/VG/Original", "/dev/VG/Copy",
\&         /* \-1 marks the end of the list of optional parameters */
\&         \-1);
.Ve
.Sp
The destination (\f(CW\*(C`/dev/VG/Copy\*(C'\fR) must be at least as large as the source
(\f(CW\*(C`/dev/VG/Original\*(C'\fR).  To copy less than the whole source device, use the
optional \f(CW\*(C`size\*(C'\fR parameter:
.Sp
.Vb 4
\& guestfs_copy_device_to_device (g,
\&         "/dev/VG/Original", "/dev/VG/Copy",
\&         GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, 10000,
\&         \-1);
.Ve
.IP "\fBfile on the host\fR to \fBfile or device\fR" 4
.IX Item "file on the host to file or device"
Use \*(L"guestfs_upload\*(R".  See \*(L"\s-1UPLOADING\s0\*(R" above.
.IP "\fBfile or device\fR to \fBfile on the host\fR" 4
.IX Item "file or device to file on the host"
Use \*(L"guestfs_download\*(R".  See \*(L"\s-1DOWNLOADING\s0\*(R" above.
.SS "\s-1UPLOADING\s0 \s-1AND\s0 \s-1DOWNLOADING\s0 \s-1TO\s0 \s-1PIPES\s0 \s-1AND\s0 \s-1FILE\s0 \s-1DESCRIPTORS\s0"
.IX Subsection "UPLOADING AND DOWNLOADING TO PIPES AND FILE DESCRIPTORS"
Calls like \*(L"guestfs_upload\*(R", \*(L"guestfs_download\*(R", \*(L"guestfs_tar_in\*(R",
\&\*(L"guestfs_tar_out\*(R" etc appear to only take filenames as arguments, so it
appears you can only upload and download to files.  However many Un*x\-like
hosts let you use the special device files \f(CW\*(C`/dev/stdin\*(C'\fR, \f(CW\*(C`/dev/stdout\*(C'\fR,
\&\f(CW\*(C`/dev/stderr\*(C'\fR and \f(CW\*(C`/dev/fd/N\*(C'\fR to read and write from stdin, stdout,
stderr, and arbitrary file descriptor N.
.PP
For example, \fIvirt\-cat\fR\|(1) writes its output to stdout by doing:
.PP
.Vb 1
\& guestfs_download (g, filename, "/dev/stdout");
.Ve
.PP
and you can write tar output to a file descriptor \f(CW\*(C`fd\*(C'\fR by doing:
.PP
.Vb 3
\& char devfd[64];
\& snprintf (devfd, sizeof devfd, "/dev/fd/%d", fd);
\& guestfs_tar_out (g, "/", devfd);
.Ve
.SS "\s-1LISTING\s0 \s-1FILES\s0"
.IX Subsection "LISTING FILES"
\&\*(L"guestfs_ll\*(R" is just designed for humans to read (mainly when using the
\&\fIguestfish\fR\|(1)\-equivalent command \f(CW\*(C`ll\*(C'\fR).
.PP
\&\*(L"guestfs_ls\*(R" is a quick way to get a list of files in a directory from
programs, as a flat list of strings.
.PP
\&\*(L"guestfs_readdir\*(R" is a programmatic way to get a list of files in a
directory, plus additional information about each one.  It is more
equivalent to using the \fIreaddir\fR\|(3) call on a local filesystem.
.PP
\&\*(L"guestfs_find\*(R" and \*(L"guestfs_find0\*(R" can be used to recursively list
files.
.SS "\s-1RUNNING\s0 \s-1COMMANDS\s0"
.IX Subsection "RUNNING COMMANDS"
Although libguestfs is primarily an \s-1API\s0 for manipulating files inside guest
images, we also provide some limited facilities for running commands inside
guests.
.PP
There are many limitations to this:
.IP "\(bu" 4
The kernel version that the command runs under will be different from what
it expects.
.IP "\(bu" 4
If the command needs to communicate with daemons, then most likely they
won't be running.
.IP "\(bu" 4
The command will be running in limited memory.
.IP "\(bu" 4
The network may not be available unless you enable it (see
\&\*(L"guestfs_set_network\*(R").
.IP "\(bu" 4
Only supports Linux guests (not Windows, \s-1BSD\s0, etc).
.IP "\(bu" 4
Architecture limitations (eg. won't work for a \s-1PPC\s0 guest on an X86 host).
.IP "\(bu" 4
For SELinux guests, you may need to enable SELinux and load policy first.
See \*(L"\s-1SELINUX\s0\*(R" in this manpage.
.IP "\(bu" 4
\&\fISecurity:\fR It is not safe to run commands from untrusted, possibly
malicious guests.  These commands may attempt to exploit your program by
sending unexpected output.  They could also try to exploit the Linux kernel
or qemu provided by the libguestfs appliance.  They could use the network
provided by the libguestfs appliance to bypass ordinary network partitions
and firewalls.  They could use the elevated privileges or different SELinux
context of your program to their advantage.
.Sp
A secure alternative is to use libguestfs to install a \*(L"firstboot\*(R" script (a
script which runs when the guest next boots normally), and to have this
script run the commands you want in the normal context of the running guest,
network security and so on.  For information about other security issues,
see \*(L"\s-1SECURITY\s0\*(R".
.PP
The two main \s-1API\s0 calls to run commands are \*(L"guestfs_command\*(R" and
\&\*(L"guestfs_sh\*(R" (there are also variations).
.PP
The difference is that \*(L"guestfs_sh\*(R" runs commands using the shell, so any
shell globs, redirections, etc will work.
.SS "\s-1CONFIGURATION\s0 \s-1FILES\s0"
.IX Subsection "CONFIGURATION FILES"
To read and write configuration files in Linux guest filesystems, we
strongly recommend using Augeas.  For example, Augeas understands how to
read and write, say, a Linux shadow password file or X.org configuration
file, and so avoids you having to write that code.
.PP
The main Augeas calls are bound through the \f(CW\*(C`guestfs_aug_*\*(C'\fR APIs.  We don't
document Augeas itself here because there is excellent documentation on the
<http://augeas.net/> website.
.PP
If you don't want to use Augeas (you fool!) then try calling
\&\*(L"guestfs_read_lines\*(R" to get the file as a list of lines which you can
iterate over.
.SS "\s-1SELINUX\s0"
.IX Subsection "SELINUX"
We support SELinux guests.  To ensure that labeling happens correctly in
SELinux guests, you need to enable SELinux and load the guest's policy:
.IP "1." 4
Before launching, do:
.Sp
.Vb 1
\& guestfs_set_selinux (g, 1);
.Ve
.IP "2." 4
After mounting the guest's filesystem(s), load the policy.  This is best
done by running the \fIload_policy\fR\|(8) command in the guest itself:
.Sp
.Vb 1
\& guestfs_sh (g, "/usr/sbin/load_policy");
.Ve
.Sp
(Older versions of \f(CW\*(C`load_policy\*(C'\fR require you to specify the name of the
policy file).
.IP "3." 4
Optionally, set the security context for the \s-1API\s0.  The correct security
context to use can only be known by inspecting the guest.  As an example:
.Sp
.Vb 1
\& guestfs_setcon (g, "unconfined_u:unconfined_r:unconfined_t:s0");
.Ve
.PP
This will work for running commands and editing existing files.
.PP
When new files are created, you may need to label them explicitly, for
example by running the external command \f(CW\*(C`restorecon pathname\*(C'\fR.
.SS "\s-1UMASK\s0"
.IX Subsection "UMASK"
Certain calls are affected by the current file mode creation mask (the
\&\*(L"umask\*(R").  In particular ones which create files or directories, such as
\&\*(L"guestfs_touch\*(R", \*(L"guestfs_mknod\*(R" or \*(L"guestfs_mkdir\*(R".  This affects
either the default mode that the file is created with or modifies the mode
that you supply.
.PP
The default umask is \f(CW022\fR, so files are created with modes such as \f(CW0644\fR
and directories with \f(CW0755\fR.
.PP
There are two ways to avoid being affected by umask.  Either set umask to 0
(call \f(CW\*(C`guestfs_umask (g, 0)\*(C'\fR early after launching).  Or call
\&\*(L"guestfs_chmod\*(R" after creating each file or directory.
.PP
For more information about umask, see \fIumask\fR\|(2).
.SS "\s-1ENCRYPTED\s0 \s-1DISKS\s0"
.IX Subsection "ENCRYPTED DISKS"
Libguestfs allows you to access Linux guests which have been encrypted using
whole disk encryption that conforms to the Linux Unified Key Setup (\s-1LUKS\s0)
standard.  This includes nearly all whole disk encryption systems used by
modern Linux guests.
.PP
Use \*(L"guestfs_vfs_type\*(R" to identify LUKS-encrypted block devices (it
returns the string \f(CW\*(C`crypto_LUKS\*(C'\fR).
.PP
Then open these devices by calling \*(L"guestfs_luks_open\*(R".  Obviously you
will require the passphrase!
.PP
Opening a \s-1LUKS\s0 device creates a new device mapper device called
\&\f(CW\*(C`/dev/mapper/mapname\*(C'\fR (where \f(CW\*(C`mapname\*(C'\fR is the string you supply to
\&\*(L"guestfs_luks_open\*(R").  Reads and writes to this mapper device are
decrypted from and encrypted to the underlying block device respectively.
.PP
\&\s-1LVM\s0 volume groups on the device can be made visible by calling
\&\*(L"guestfs_vgscan\*(R" followed by \*(L"guestfs_vg_activate_all\*(R".  The logical
volume(s) can now be mounted in the usual way.
.PP
Use the reverse process to close a \s-1LUKS\s0 device.  Unmount any logical volumes
on it, deactivate the volume groups by caling \f(CW\*(C`guestfs_vg_activate (g, 0,
["/dev/VG"])\*(C'\fR.  Then close the mapper device by calling
\&\*(L"guestfs_luks_close\*(R" on the \f(CW\*(C`/dev/mapper/mapname\*(C'\fR device (\fInot\fR the
underlying encrypted block device).
.SS "\s-1INSPECTION\s0"
.IX Subsection "INSPECTION"
Libguestfs has APIs for inspecting an unknown disk image to find out if it
contains operating systems, an install \s-1CD\s0 or a live \s-1CD\s0.  (These APIs used to
be in a separate Perl-only library called \fISys::Guestfs::Lib\fR\|(3) but since
version 1.5.3 the most frequently used part of this library has been
rewritten in C and moved into the core code).
.PP
Add all disks belonging to the unknown virtual machine and call
\&\*(L"guestfs_launch\*(R" in the usual way.
.PP
Then call \*(L"guestfs_inspect_os\*(R".  This function uses other libguestfs calls
and certain heuristics, and returns a list of operating systems that were
found.  An empty list means none were found.  A single element is the root
filesystem of the operating system.  For dual\- or multi-boot guests,
multiple roots can be returned, each one corresponding to a separate
operating system.  (Multi-boot virtual machines are extremely rare in the
world of virtualization, but since this scenario can happen, we have built
libguestfs to deal with it.)
.PP
For each root, you can then call various \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR functions
to get additional details about that operating system.  For example, call
\&\*(L"guestfs_inspect_get_type\*(R" to return the string \f(CW\*(C`windows\*(C'\fR or \f(CW\*(C`linux\*(C'\fR for
Windows and Linux-based operating systems respectively.
.PP
Un*x\-like and Linux-based operating systems usually consist of several
filesystems which are mounted at boot time (for example, a separate boot
partition mounted on \f(CW\*(C`/boot\*(C'\fR).  The inspection rules are able to detect how
filesystems correspond to mount points.  Call
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR to get this mapping.  It might return a
hash table like this example:
.PP
.Vb 3
\& /boot => /dev/sda1
\& /     => /dev/vg_guest/lv_root
\& /usr  => /dev/vg_guest/lv_usr
.Ve
.PP
The caller can then make calls to \*(L"guestfs_mount_options\*(R" to mount the
filesystems as suggested.
.PP
Be careful to mount filesystems in the right order (eg. \f(CW\*(C`/\*(C'\fR before
\&\f(CW\*(C`/usr\*(C'\fR).  Sorting the keys of the hash by length, shortest first, should
work.
.PP
Inspection currently only works for some common operating systems.
Contributors are welcome to send patches for other operating systems that we
currently cannot detect.
.PP
Encrypted disks must be opened before inspection.  See \*(L"\s-1ENCRYPTED\s0 \s-1DISKS\s0\*(R"
for more details.  The \*(L"guestfs_inspect_os\*(R" function just ignores any
encrypted devices.
.PP
A note on the implementation: The call \*(L"guestfs_inspect_os\*(R" performs
inspection and caches the results in the guest handle.  Subsequent calls to
\&\f(CW\*(C`guestfs_inspect_get_*\*(C'\fR return this cached information, but \fIdo not\fR
re-read the disks.  If you change the content of the guest disks, you can
redo inspection by calling \*(L"guestfs_inspect_os\*(R" again.
(\*(L"guestfs_inspect_list_applications\*(R" works a little differently from the
other calls and does read the disks.  See documentation for that function
for details).
.PP
\fI\s-1INSPECTING\s0 \s-1INSTALL\s0 \s-1DISKS\s0\fR
.IX Subsection "INSPECTING INSTALL DISKS"
.PP
Libguestfs (since 1.9.4) can detect some install disks, install CDs, live
CDs and more.
.PP
Call \*(L"guestfs_inspect_get_format\*(R" to return the format of the operating
system, which currently can be \f(CW\*(C`installed\*(C'\fR (a regular operating system) or
\&\f(CW\*(C`installer\*(C'\fR (some sort of install disk).
.PP
Further information is available about the operating system that can be
installed using the regular inspection APIs like
\&\*(L"guestfs_inspect_get_product_name\*(R", \*(L"guestfs_inspect_get_major_version\*(R"
etc.
.PP
Some additional information specific to installer disks is also available
from the \*(L"guestfs_inspect_is_live\*(R", \*(L"guestfs_inspect_is_netinst\*(R" and
\&\*(L"guestfs_inspect_is_multipart\*(R" calls.
.SS "\s-1SPECIAL\s0 \s-1CONSIDERATIONS\s0 \s-1FOR\s0 \s-1WINDOWS\s0 \s-1GUESTS\s0"
.IX Subsection "SPECIAL CONSIDERATIONS FOR WINDOWS GUESTS"
Libguestfs can mount \s-1NTFS\s0 partitions.  It does this using the
http://www.ntfs\-3g.org/ <http://www.ntfs-3g.org/> driver.
.PP
\fI\s-1DRIVE\s0 \s-1LETTERS\s0 \s-1AND\s0 \s-1PATHS\s0\fR
.IX Subsection "DRIVE LETTERS AND PATHS"
.PP
\&\s-1DOS\s0 and Windows still use drive letters, and the filesystems are always
treated as case insensitive by Windows itself, and therefore you might find
a Windows configuration file referring to a path like
\&\f(CW\*(C`c:\ewindows\esystem32\*(C'\fR.  When the filesystem is mounted in libguestfs, that
directory might be referred to as \f(CW\*(C`/WINDOWS/System32\*(C'\fR.
.PP
Drive letter mappings can be found using inspection (see \*(L"\s-1INSPECTION\s0\*(R" and
\&\*(L"guestfs_inspect_get_drive_mappings\*(R")
.PP
Dealing with separator characters (backslash vs forward slash) is outside
the scope of libguestfs, but usually a simple character replacement will
work.
.PP
To resolve the case insensitivity of paths, call
\&\*(L"guestfs_case_sensitive_path\*(R".
.PP
\fI\s-1ACCESSING\s0 \s-1THE\s0 \s-1WINDOWS\s0 \s-1REGISTRY\s0\fR
.IX Subsection "ACCESSING THE WINDOWS REGISTRY"
.PP
Libguestfs also provides some help for decoding Windows Registry \*(L"hive\*(R"
files, through the library \f(CW\*(C`hivex\*(C'\fR which is part of the libguestfs project
although ships as a separate tarball.  You have to locate and download the
hive file(s) yourself, and then pass them to \f(CW\*(C`hivex\*(C'\fR functions.  See also
the programs \fIhivexml\fR\|(1), \fIhivexsh\fR\|(1), \fIhivexregedit\fR\|(1) and
\&\fIvirt\-win\-reg\fR\|(1) for more help on this issue.
.PP
\fI\s-1SYMLINKS\s0 \s-1ON\s0 \s-1NTFS\-3G\s0 \s-1FILESYSTEMS\s0\fR
.IX Subsection "SYMLINKS ON NTFS-3G FILESYSTEMS"
.PP
Ntfs\-3g tries to rewrite \*(L"Junction Points\*(R" and \s-1NTFS\s0 \*(L"symbolic links\*(R" to
provide something which looks like a Linux symlink.  The way it tries to do
the rewriting is described here:
.PP
http://www.tuxera.com/community/ntfs\-3g\-advanced/junction\-points\-and\-symbolic\-links/ <http://www.tuxera.com/community/ntfs-3g-advanced/junction-points-and-symbolic-links/>
.PP
The essential problem is that ntfs\-3g simply does not have enough
information to do a correct job.  \s-1NTFS\s0 links can contain drive letters and
references to external device GUIDs that ntfs\-3g has no way of resolving.
It is almost certainly the case that libguestfs callers should ignore what
ntfs\-3g does (ie. don't use \*(L"guestfs_readlink\*(R" on \s-1NTFS\s0 volumes).
.PP
Instead if you encounter a symbolic link on an ntfs\-3g filesystem, use
\&\*(L"guestfs_lgetxattr\*(R" to read the \f(CW\*(C`system.ntfs_reparse_data\*(C'\fR extended
attribute, and read the raw reparse data from that (you can find the format
documented in various places around the web).
.PP
\fI\s-1EXTENDED\s0 \s-1ATTRIBUTES\s0 \s-1ON\s0 \s-1NTFS\-3G\s0 \s-1FILESYSTEMS\s0\fR
.IX Subsection "EXTENDED ATTRIBUTES ON NTFS-3G FILESYSTEMS"
.PP
There are other useful extended attributes that can be read from ntfs\-3g
filesystems (using \*(L"guestfs_getxattr\*(R").  See:
.PP
http://www.tuxera.com/community/ntfs\-3g\-advanced/extended\-attributes/ <http://www.tuxera.com/community/ntfs-3g-advanced/extended-attributes/>
.SS "\s-1USING\s0 \s-1LIBGUESTFS\s0 \s-1WITH\s0 \s-1OTHER\s0 \s-1PROGRAMMING\s0 \s-1LANGUAGES\s0"
.IX Subsection "USING LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES"
Although we don't want to discourage you from using the C \s-1API\s0, we will
mention here that the same \s-1API\s0 is also available in other languages.
.PP
The \s-1API\s0 is broadly identical in all supported languages.  This means that
the C call \f(CW\*(C`guestfs_add_drive_ro(g,file)\*(C'\fR is \f(CW\*(C`$g\->add_drive_ro($file)\*(C'\fR
in Perl, \f(CW\*(C`g.add_drive_ro(file)\*(C'\fR in Python, and \f(CW\*(C`g#add_drive_ro file\*(C'\fR in
OCaml.  In other words, a straightforward, predictable isomorphism between
each language.
.PP
Error messages are automatically transformed into exceptions if the language
supports it.
.PP
We don't try to \*(L"object orientify\*(R" parts of the \s-1API\s0 in \s-1OO\s0 languages,
although contributors are welcome to write higher level APIs above what we
provide in their favourite languages if they wish.
.IP "\fB\*(C+\fR" 4
.IX Item ""
You can use the \fIguestfs.h\fR header file from \*(C+ programs.  The \*(C+ \s-1API\s0 is
identical to the C \s-1API\s0.  \*(C+ classes and exceptions are not used.
.IP "\fBC#\fR" 4
.IX Item "C#"
The C# bindings are highly experimental.  Please read the warnings at the
top of \f(CW\*(C`csharp/Libguestfs.cs\*(C'\fR.
.IP "\fBErlang\fR" 4
.IX Item "Erlang"
See \fIguestfs\-erlang\fR\|(3).
.IP "\fBGObject\fR" 4
.IX Item "GObject"
Experimental GObject bindings (with GObject Introspection support) are
available.  See the \f(CW\*(C`gobject\*(C'\fR directory in the source.
.IP "\fBHaskell\fR" 4
.IX Item "Haskell"
This is the only language binding that is working but incomplete.  Only
calls which return simple integers have been bound in Haskell, and we are
looking for help to complete this binding.
.IP "\fBJava\fR" 4
.IX Item "Java"
Full documentation is contained in the Javadoc which is distributed with
libguestfs.  For examples, see \fIguestfs\-java\fR\|(3).
.IP "\fBOCaml\fR" 4
.IX Item "OCaml"
See \fIguestfs\-ocaml\fR\|(3).
.IP "\fBPerl\fR" 4
.IX Item "Perl"
See \fIguestfs\-perl\fR\|(3) and \fISys::Guestfs\fR\|(3).
.IP "\fB\s-1PHP\s0\fR" 4
.IX Item "PHP"
For documentation see \f(CW\*(C`README\-PHP\*(C'\fR supplied with libguestfs sources or in
the php-libguestfs package for your distribution.
.Sp
The \s-1PHP\s0 binding only works correctly on 64 bit machines.
.IP "\fBPython\fR" 4
.IX Item "Python"
See \fIguestfs\-python\fR\|(3).
.IP "\fBRuby\fR" 4
.IX Item "Ruby"
See \fIguestfs\-ruby\fR\|(3).
.Sp
For JRuby, use the Java bindings.
.IP "\fBshell scripts\fR" 4
.IX Item "shell scripts"
See \fIguestfish\fR\|(1).
.SS "\s-1LIBGUESTFS\s0 \s-1GOTCHAS\s0"
.IX Subsection "LIBGUESTFS GOTCHAS"
<http://en.wikipedia.org/wiki/Gotcha_(programming)>: \*(L"A feature of a system
[...] that works in the way it is documented but is counterintuitive and
almost invites mistakes.\*(R"
.PP
Since we developed libguestfs and the associated tools, there are several
things we would have designed differently, but are now stuck with for
backwards compatibility or other reasons.  If there is ever a libguestfs 2.0
release, you can expect these to change.  Beware of them.
.IP "Autosync / forgetting to sync." 4
.IX Item "Autosync / forgetting to sync."
\&\fIUpdate:\fR Autosync is enabled by default for all \s-1API\s0 users starting from
libguestfs 1.5.24.  This section only applies to older versions.
.Sp
When modifying a filesystem from C or another language, you \fBmust\fR unmount
all filesystems and call \*(L"guestfs_sync\*(R" explicitly before you close the
libguestfs handle.  You can also call:
.Sp
.Vb 1
\& guestfs_set_autosync (g, 1);
.Ve
.Sp
to have the unmount/sync done automatically for you when the handle 'g' is
closed.  (This feature is called \*(L"autosync\*(R", \*(L"guestfs_set_autosync\*(R" q.v.)
.Sp
If you forget to do this, then it is entirely possible that your changes
won't be written out, or will be partially written, or (very rarely) that
you'll get disk corruption.
.Sp
Note that in \fIguestfish\fR\|(3) autosync is the default.  So quick and dirty
guestfish scripts that forget to sync will work just fine, which can make
this very puzzling if you are trying to debug a problem.
.ie n .IP "Mount option ""\-o sync"" should not be the default." 4
.el .IP "Mount option \f(CW\-o sync\fR should not be the default." 4
.IX Item "Mount option -o sync should not be the default."
\&\fIUpdate:\fR \*(L"guestfs_mount\*(R" no longer adds any options starting from
libguestfs 1.13.16.  This section only applies to older versions.
.Sp
If you use \*(L"guestfs_mount\*(R", then \f(CW\*(C`\-o sync,noatime\*(C'\fR are added implicitly.
However \f(CW\*(C`\-o sync\*(C'\fR does not add any reliability benefit, but does have a
very large performance impact.
.Sp
The work around is to use \*(L"guestfs_mount_options\*(R" and set the mount
options that you actually want to use.
.IP "Read-only should be the default." 4
.IX Item "Read-only should be the default."
In \fIguestfish\fR\|(3), \fI\-\-ro\fR should be the default, and you should have to
specify \fI\-\-rw\fR if you want to make changes to the image.
.Sp
This would reduce the potential to corrupt live \s-1VM\s0 images.
.Sp
Note that many filesystems change the disk when you just mount and unmount,
even if you didn't perform any writes.  You need to use
\&\*(L"guestfs_add_drive_ro\*(R" to guarantee that the disk is not changed.
.IP "guestfish command line is hard to use." 4
.IX Item "guestfish command line is hard to use."
\&\f(CW\*(C`guestfish disk.img\*(C'\fR doesn't do what people expect (open \f(CW\*(C`disk.img\*(C'\fR for
examination).  It tries to run a guestfish command \f(CW\*(C`disk.img\*(C'\fR which doesn't
exist, so it fails.  In earlier versions of guestfish the error message was
also unintuitive, but we have corrected this since.  Like the Bourne shell,
we should have used \f(CW\*(C`guestfish \-c command\*(C'\fR to run commands.
.IP "guestfish megabyte modifiers don't work right on all commands" 4
.IX Item "guestfish megabyte modifiers don't work right on all commands"
In recent guestfish you can use \f(CW\*(C`1M\*(C'\fR to mean 1 megabyte (and similarly for
other modifiers).  What guestfish actually does is to multiply the number
part by the modifier part and pass the result to the C \s-1API\s0.  However this
doesn't work for a few APIs which aren't expecting bytes, but are already
expecting some other unit (eg. megabytes).
.Sp
The most common is \*(L"guestfs_lvcreate\*(R".  The guestfish command:
.Sp
.Vb 1
\& lvcreate LV VG 100M
.Ve
.Sp
does not do what you might expect.  Instead because \*(L"guestfs_lvcreate\*(R" is
already expecting megabytes, this tries to create a 100 \fIterabyte\fR (100
megabytes * megabytes) logical volume.  The error message you get from this
is also a little obscure.
.Sp
This could be fixed in the generator by specially marking parameters and
return values which take bytes or other units.
.IP "Ambiguity between devices and paths" 4
.IX Item "Ambiguity between devices and paths"
There is a subtle ambiguity in the \s-1API\s0 between a device name
(eg. \f(CW\*(C`/dev/sdb2\*(C'\fR) and a similar pathname.  A file might just happen to be
called \f(CW\*(C`sdb2\*(C'\fR in the directory \f(CW\*(C`/dev\*(C'\fR (consider some non-Unix \s-1VM\s0 image).
.Sp
In the current \s-1API\s0 we usually resolve this ambiguity by having two separate
calls, for example \*(L"guestfs_checksum\*(R" and \*(L"guestfs_checksum_device\*(R".
Some \s-1API\s0 calls are ambiguous and (incorrectly) resolve the problem by
detecting if the path supplied begins with \f(CW\*(C`/dev/\*(C'\fR.
.Sp
To avoid both the ambiguity and the need to duplicate some calls, we could
make paths/devices into structured names.  One way to do this would be to
use a notation like grub (\f(CW\*(C`hd(0,0)\*(C'\fR), although nobody really likes this
aspect of grub.  Another way would be to use a structured type, equivalent
to this OCaml type:
.Sp
.Vb 1
\& type path = Path of string | Device of int | Partition of int * int
.Ve
.Sp
which would allow you to pass arguments like:
.Sp
.Vb 4
\& Path "/foo/bar"
\& Device 1            (* /dev/sdb, or perhaps /dev/sda *)
\& Partition (1, 2)    (* /dev/sdb2 (or is it /dev/sda2 or /dev/sdb3?) *)
\& Path "/dev/sdb2"    (* not a device *)
.Ve
.Sp
As you can see there are still problems to resolve even with this
representation.  Also consider how it might work in guestfish.
.SS "\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0"
.IX Subsection "KEYS AND PASSPHRASES"
Certain libguestfs calls take a parameter that contains sensitive key
material, passed in as a C string.
.PP
In the future we would hope to change the libguestfs implementation so that
keys are \fImlock\fR\|(2)\-ed into physical \s-1RAM\s0, and thus can never end up in
swap.  However this is \fInot\fR done at the moment, because of the complexity
of such an implementation.
.PP
Therefore you should be aware that any key parameter you pass to libguestfs
might end up being written out to the swap partition.  If this is a concern,
scrub the swap partition or don't use libguestfs on encrypted devices.
.SS "\s-1MULTIPLE\s0 \s-1HANDLES\s0 \s-1AND\s0 \s-1MULTIPLE\s0 \s-1THREADS\s0"
.IX Subsection "MULTIPLE HANDLES AND MULTIPLE THREADS"
All high-level libguestfs actions are synchronous.  If you want to use
libguestfs asynchronously then you must create a thread.
.PP
Only use the handle from a single thread.  Either use the handle exclusively
from one thread, or provide your own mutex so that two threads cannot issue
calls on the same handle at the same time.
.PP
See the graphical program guestfs-browser for one possible architecture for
multithreaded programs using libvirt and libguestfs.
.SS "\s-1PATH\s0"
.IX Subsection "PATH"
Libguestfs needs a supermin appliance, which it finds by looking along an
internal path.
.PP
By default it looks for these in the directory \f(CW\*(C`$libdir/guestfs\*(C'\fR
(eg. \f(CW\*(C`/usr/local/lib/guestfs\*(C'\fR or \f(CW\*(C`/usr/lib64/guestfs\*(C'\fR).
.PP
Use \*(L"guestfs_set_path\*(R" or set the environment variable \*(L"\s-1LIBGUESTFS_PATH\s0\*(R"
to change the directories that libguestfs will search in.  The value is a
colon-separated list of paths.  The current directory is \fInot\fR searched
unless the path contains an empty element or \f(CW\*(C`.\*(C'\fR.  For example
\&\f(CW\*(C`LIBGUESTFS_PATH=:/usr/lib/guestfs\*(C'\fR would search the current directory and
then \f(CW\*(C`/usr/lib/guestfs\*(C'\fR.
.SS "\s-1QEMU\s0 \s-1WRAPPERS\s0"
.IX Subsection "QEMU WRAPPERS"
If you want to compile your own qemu, run qemu from a non-standard location,
or pass extra arguments to qemu, then you can write a shell-script wrapper
around qemu.
.PP
There is one important rule to remember: you \fImust \f(CI\*(C`exec qemu\*(C'\fI\fR as the
last command in the shell script (so that qemu replaces the shell and
becomes the direct child of the libguestfs-using program).  If you don't do
this, then the qemu process won't be cleaned up correctly.
.PP
Here is an example of a wrapper, where I have built my own copy of qemu from
source:
.PP
.Vb 3
\& #!/bin/sh \-
\& qemudir=/home/rjones/d/qemu
\& exec $qemudir/x86_64\-softmmu/qemu\-system\-x86_64 \-L $qemudir/pc\-bios "$@"
.Ve
.PP
Save this script as \f(CW\*(C`/tmp/qemu.wrapper\*(C'\fR (or wherever), \f(CW\*(C`chmod +x\*(C'\fR, and
then use it by setting the \s-1LIBGUESTFS_QEMU\s0 environment variable.  For
example:
.PP
.Vb 1
\& LIBGUESTFS_QEMU=/tmp/qemu.wrapper guestfish
.Ve
.PP
Note that libguestfs also calls qemu with the \-help and \-version options in
order to determine features.
.PP
Wrappers can also be used to edit the options passed to qemu.  In the
following example, the \f(CW\*(C`\-machine ...\*(C'\fR option (\f(CW\*(C`\-machine\*(C'\fR and the following
argument) are removed from the command line and replaced with \f(CW\*(C`\-machine
pc,accel=tcg\*(C'\fR.  The while loop iterates over the options until it finds the
right one to remove, putting the remaining options into the \f(CW\*(C`args\*(C'\fR array.
.PP
.Vb 1
\& #!/bin/bash \-
\& 
\& i=0
\& while [ $# \-gt 0 ]; do
\&     case "$1" in
\&     \-machine)
\&         shift 2;;
\&     *)
\&         args[i]="$1"
\&         (( i++ ))
\&         shift ;;
\&     esac
\& done
\& 
\& exec qemu\-kvm \-machine pc,accel=tcg "${args[@]}"
.Ve
.SS "\s-1ATTACHING\s0 \s-1TO\s0 \s-1RUNNING\s0 \s-1DAEMONS\s0"
.IX Subsection "ATTACHING TO RUNNING DAEMONS"
\&\fINote (1):\fR This is \fBhighly experimental\fR and has a tendency to eat
babies.  Use with caution.
.PP
\&\fINote (2):\fR This section explains how to attach to a running daemon from a
low level perspective.  For most users, simply using virt tools such as
\&\fIguestfish\fR\|(1) with the \fI\-\-live\fR option will \*(L"just work\*(R".
.PP
\fIUsing guestfs_set_attach_method\fR
.IX Subsection "Using guestfs_set_attach_method"
.PP
By calling \*(L"guestfs_set_attach_method\*(R" you can change how the library
connects to the \f(CW\*(C`guestfsd\*(C'\fR daemon in \*(L"guestfs_launch\*(R" (read
\&\*(L"\s-1ARCHITECTURE\s0\*(R" for some background).
.PP
The normal attach method is \f(CW\*(C`appliance\*(C'\fR, where a small appliance is created
containing the daemon, and then the library connects to this.
.PP
Setting attach method to \f(CW\*(C`unix:\f(CIpath\f(CW\*(C'\fR (where \fIpath\fR is the path of a
Unix domain socket) causes \*(L"guestfs_launch\*(R" to connect to an existing
daemon over the Unix domain socket.
.PP
The normal use for this is to connect to a running virtual machine that
contains a \f(CW\*(C`guestfsd\*(C'\fR daemon, and send commands so you can read and write
files inside the live virtual machine.
.PP
\fIUsing guestfs_add_domain with live flag\fR
.IX Subsection "Using guestfs_add_domain with live flag"
.PP
\&\*(L"guestfs_add_domain\*(R" provides some help for getting the correct attach
method.  If you pass the \f(CW\*(C`live\*(C'\fR option to this function, then (if the
virtual machine is running) it will examine the libvirt \s-1XML\s0 looking for a
virtio-serial channel to connect to:
.PP
.Vb 11
\& <domain>
\&   ...
\&   <devices>
\&     ...
\&     <channel type=\*(Aqunix\*(Aq>
\&       <source mode=\*(Aqbind\*(Aq path=\*(Aq/path/to/socket\*(Aq/>
\&       <target type=\*(Aqvirtio\*(Aq name=\*(Aqorg.libguestfs.channel.0\*(Aq/>
\&     </channel>
\&     ...
\&   </devices>
\& </domain>
.Ve
.PP
\&\*(L"guestfs_add_domain\*(R" extracts \f(CW\*(C`/path/to/socket\*(C'\fR and sets the attach
method to \f(CW\*(C`unix:/path/to/socket\*(C'\fR.
.PP
Some of the libguestfs tools (including guestfish) support a \fI\-\-live\fR
option which is passed through to \*(L"guestfs_add_domain\*(R" thus allowing you
to attach to and modify live virtual machines.
.PP
The virtual machine needs to have been set up beforehand so that it has the
virtio-serial channel and so that guestfsd is running inside it.
.SS "\s-1ABI\s0 \s-1GUARANTEE\s0"
.IX Subsection "ABI GUARANTEE"
We guarantee the libguestfs \s-1ABI\s0 (binary interface), for public, high-level
actions as outlined in this section.  Although we will deprecate some
actions, for example if they get replaced by newer calls, we will keep the
old actions forever.  This allows you the developer to program in confidence
against the libguestfs \s-1API\s0.
.SS "\s-1BLOCK\s0 \s-1DEVICE\s0 \s-1NAMING\s0"
.IX Subsection "BLOCK DEVICE NAMING"
In the kernel there is now quite a profusion of schemata for naming block
devices (in this context, by \fIblock device\fR I mean a physical or virtual
hard drive).  The original Linux \s-1IDE\s0 driver used names starting with
\&\f(CW\*(C`/dev/hd*\*(C'\fR.  \s-1SCSI\s0 devices have historically used a different naming scheme,
\&\f(CW\*(C`/dev/sd*\*(C'\fR.  When the Linux kernel \fIlibata\fR driver became a popular
replacement for the old \s-1IDE\s0 driver (particularly for \s-1SATA\s0 devices) those
devices also used the \f(CW\*(C`/dev/sd*\*(C'\fR scheme.  Additionally we now have virtual
machines with paravirtualized drivers.  This has created several different
naming systems, such as \f(CW\*(C`/dev/vd*\*(C'\fR for virtio disks and \f(CW\*(C`/dev/xvd*\*(C'\fR for
Xen \s-1PV\s0 disks.
.PP
As discussed above, libguestfs uses a qemu appliance running an embedded
Linux kernel to access block devices.  We can run a variety of appliances
based on a variety of Linux kernels.
.PP
This causes a problem for libguestfs because many \s-1API\s0 calls use device or
partition names.  Working scripts and the recipe (example) scripts that we
make available over the internet could fail if the naming scheme changes.
.PP
Therefore libguestfs defines \f(CW\*(C`/dev/sd*\*(C'\fR as the \fIstandard naming scheme\fR.
Internally \f(CW\*(C`/dev/sd*\*(C'\fR names are translated, if necessary, to other names as
required.  For example, under \s-1RHEL\s0 5 which uses the \f(CW\*(C`/dev/hd*\*(C'\fR scheme, any
device parameter \f(CW\*(C`/dev/sda2\*(C'\fR is translated to \f(CW\*(C`/dev/hda2\*(C'\fR transparently.
.PP
Note that this \fIonly\fR applies to parameters.  The \*(L"guestfs_list_devices\*(R",
\&\*(L"guestfs_list_partitions\*(R" and similar calls return the true names of the
devices and partitions as known to the appliance.
.PP
\fI\s-1ALGORITHM\s0 \s-1FOR\s0 \s-1BLOCK\s0 \s-1DEVICE\s0 \s-1NAME\s0 \s-1TRANSLATION\s0\fR
.IX Subsection "ALGORITHM FOR BLOCK DEVICE NAME TRANSLATION"
.PP
Usually this translation is transparent.  However in some (very rare)  cases
you may need to know the exact algorithm.  Such cases include where you use
\&\*(L"guestfs_config\*(R" to add a mixture of virtio and \s-1IDE\s0 devices to the
qemu-based appliance, so have a mixture of \f(CW\*(C`/dev/sd*\*(C'\fR and \f(CW\*(C`/dev/vd*\*(C'\fR
devices.
.PP
The algorithm is applied only to \fIparameters\fR which are known to be either
device or partition names.  Return values from functions such as
\&\*(L"guestfs_list_devices\*(R" are never changed.
.IP "\(bu" 4
Is the string a parameter which is a device or partition name?
.IP "\(bu" 4
Does the string begin with \f(CW\*(C`/dev/sd\*(C'\fR?
.IP "\(bu" 4
Does the named device exist? If so, we use that device.  However if \fInot\fR
then we continue with this algorithm.
.IP "\(bu" 4
Replace initial \f(CW\*(C`/dev/sd\*(C'\fR string with \f(CW\*(C`/dev/hd\*(C'\fR.
.Sp
For example, change \f(CW\*(C`/dev/sda2\*(C'\fR to \f(CW\*(C`/dev/hda2\*(C'\fR.
.Sp
If that named device exists, use it.  If not, continue.
.IP "\(bu" 4
Replace initial \f(CW\*(C`/dev/sd\*(C'\fR string with \f(CW\*(C`/dev/vd\*(C'\fR.
.Sp
If that named device exists, use it.  If not, return an error.
.PP
\fI\s-1PORTABILITY\s0 \s-1CONCERNS\s0 \s-1WITH\s0 \s-1BLOCK\s0 \s-1DEVICE\s0 \s-1NAMING\s0\fR
.IX Subsection "PORTABILITY CONCERNS WITH BLOCK DEVICE NAMING"
.PP
Although the standard naming scheme and automatic translation is useful for
simple programs and guestfish scripts, for larger programs it is best not to
rely on this mechanism.
.PP
Where possible for maximum future portability programs using libguestfs
should use these future-proof techniques:
.IP "\(bu" 4
Use \*(L"guestfs_list_devices\*(R" or \*(L"guestfs_list_partitions\*(R" to list actual
device names, and then use those names directly.
.Sp
Since those device names exist by definition, they will never be translated.
.IP "\(bu" 4
Use higher level ways to identify filesystems, such as \s-1LVM\s0 names, UUIDs and
filesystem labels.
.SH "SECURITY"
.IX Header "SECURITY"
This section discusses security implications of using libguestfs,
particularly with untrusted or malicious guests or disk images.
.SS "\s-1GENERAL\s0 \s-1SECURITY\s0 \s-1CONSIDERATIONS\s0"
.IX Subsection "GENERAL SECURITY CONSIDERATIONS"
Be careful with any files or data that you download from a guest (by
\&\*(L"download\*(R" we mean not just the \*(L"guestfs_download\*(R" command but any command
that reads files, filenames, directories or anything else from a disk
image).  An attacker could manipulate the data to fool your program into
doing the wrong thing.  Consider cases such as:
.IP "\(bu" 4
the data (file etc) not being present
.IP "\(bu" 4
being present but empty
.IP "\(bu" 4
being much larger than normal
.IP "\(bu" 4
containing arbitrary 8 bit data
.IP "\(bu" 4
being in an unexpected character encoding
.IP "\(bu" 4
containing homoglyphs.
.SS "\s-1SECURITY\s0 \s-1OF\s0 \s-1MOUNTING\s0 \s-1FILESYSTEMS\s0"
.IX Subsection "SECURITY OF MOUNTING FILESYSTEMS"
When you mount a filesystem under Linux, mistakes in the kernel filesystem
(\s-1VFS\s0) module can sometimes be escalated into exploits by deliberately
creating a malicious, malformed filesystem.  These exploits are very severe
for two reasons.  Firstly there are very many filesystem drivers in the
kernel, and many of them are infrequently used and not much developer
attention has been paid to the code.  Linux userspace helps potential
crackers by detecting the filesystem type and automatically choosing the
right \s-1VFS\s0 driver, even if that filesystem type is obscure or unexpected for
the administrator.  Secondly, a kernel-level exploit is like a local root
exploit (worse in some ways), giving immediate and total access to the
system right down to the hardware level.
.PP
That explains why you should never mount a filesystem from an untrusted
guest on your host kernel.  How about libguestfs? We run a Linux kernel
inside a qemu virtual machine, usually running as a non-root user.  The
attacker would need to write a filesystem which first exploited the kernel,
and then exploited either qemu virtualization (eg. a faulty qemu driver) or
the libguestfs protocol, and finally to be as serious as the host kernel
exploit it would need to escalate its privileges to root.  This multi-step
escalation, performed by a static piece of data, is thought to be extremely
hard to do, although we never say 'never' about security issues.
.PP
In any case callers can reduce the attack surface by forcing the filesystem
type when mounting (use \*(L"guestfs_mount_vfs\*(R").
.SS "\s-1PROTOCOL\s0 \s-1SECURITY\s0"
.IX Subsection "PROTOCOL SECURITY"
The protocol is designed to be secure, being based on \s-1RFC\s0 4506 (\s-1XDR\s0)  with a
defined upper message size.  However a program that uses libguestfs must
also take care \- for example you can write a program that downloads a binary
from a disk image and executes it locally, and no amount of protocol
security will save you from the consequences.
.SS "\s-1INSPECTION\s0 \s-1SECURITY\s0"
.IX Subsection "INSPECTION SECURITY"
Parts of the inspection \s-1API\s0 (see \*(L"\s-1INSPECTION\s0\*(R") return untrusted strings
directly from the guest, and these could contain any 8 bit data.  Callers
should be careful to escape these before printing them to a structured file
(for example, use \s-1HTML\s0 escaping if creating a web page).
.PP
Guest configuration may be altered in unusual ways by the administrator of
the virtual machine, and may not reflect reality (particularly for untrusted
or actively malicious guests).  For example we parse the hostname from
configuration files like \f(CW\*(C`/etc/sysconfig/network\*(C'\fR that we find in the
guest, but the guest administrator can easily manipulate these files to
provide the wrong hostname.
.PP
The inspection \s-1API\s0 parses guest configuration using two external libraries:
Augeas (Linux configuration) and hivex (Windows Registry).  Both are
designed to be robust in the face of malicious data, although denial of
service attacks are still possible, for example with oversized configuration
files.
.SS "\s-1RUNNING\s0 \s-1UNTRUSTED\s0 \s-1GUEST\s0 \s-1COMMANDS\s0"
.IX Subsection "RUNNING UNTRUSTED GUEST COMMANDS"
Be very cautious about running commands from the guest.  By running a
command in the guest, you are giving \s-1CPU\s0 time to a binary that you do not
control, under the same user account as the library, albeit wrapped in qemu
virtualization.  More information and alternatives can be found in the
section \*(L"\s-1RUNNING\s0 \s-1COMMANDS\s0\*(R".
.SS "\s-1CVE\-2010\-3851\s0"
.IX Subsection "CVE-2010-3851"
https://bugzilla.redhat.com/642934
.PP
This security bug concerns the automatic disk format detection that qemu
does on disk images.
.PP
A raw disk image is just the raw bytes, there is no header.  Other disk
images like qcow2 contain a special header.  Qemu deals with this by looking
for one of the known headers, and if none is found then assuming the disk
image must be raw.
.PP
This allows a guest which has been given a raw disk image to write some
other header.  At next boot (or when the disk image is accessed by
libguestfs) qemu would do autodetection and think the disk image format was,
say, qcow2 based on the header written by the guest.
.PP
This in itself would not be a problem, but qcow2 offers many features, one
of which is to allow a disk image to refer to another image (called the
\&\*(L"backing disk\*(R").  It does this by placing the path to the backing disk into
the qcow2 header.  This path is not validated and could point to any host
file (eg. \*(L"/etc/passwd\*(R").  The backing disk is then exposed through \*(L"holes\*(R"
in the qcow2 disk image, which of course is completely under the control of
the attacker.
.PP
In libguestfs this is rather hard to exploit except under two circumstances:
.IP "1." 4
You have enabled the network or have opened the disk in write mode.
.IP "2." 4
You are also running untrusted code from the guest (see \*(L"\s-1RUNNING\s0
\&\s-1COMMANDS\s0\*(R").
.PP
The way to avoid this is to specify the expected disk format when adding
disks (the optional \f(CW\*(C`format\*(C'\fR option to \*(L"guestfs_add_drive_opts\*(R").  You
should always do this if the disk is raw format, and it's a good idea for
other cases too.
.PP
For disks added from libvirt using calls like \*(L"guestfs_add_domain\*(R", the
format is fetched from libvirt and passed through.
.PP
For libguestfs tools, use the \fI\-\-format\fR command line parameter as
appropriate.
.SH "CONNECTION MANAGEMENT"
.IX Header "CONNECTION MANAGEMENT"
.SS "guestfs_h *"
.IX Subsection "guestfs_h *"
\&\f(CW\*(C`guestfs_h\*(C'\fR is the opaque type representing a connection handle.  Create a
handle by calling \*(L"guestfs_create\*(R".  Call \*(L"guestfs_close\*(R" to free the
handle and release all resources used.
.PP
For information on using multiple handles and threads, see the section
\&\*(L"\s-1MULTIPLE\s0 \s-1HANDLES\s0 \s-1AND\s0 \s-1MULTIPLE\s0 \s-1THREADS\s0\*(R" above.
.SS "guestfs_create"
.IX Subsection "guestfs_create"
.Vb 1
\& guestfs_h *guestfs_create (void);
.Ve
.PP
Create a connection handle.
.PP
On success this returns a non-NULL pointer to a handle.  On error it returns
\&\s-1NULL\s0.
.PP
You have to \*(L"configure\*(R" the handle after creating it.  This includes calling
\&\*(L"guestfs_add_drive_opts\*(R" (or one of the equivalent calls) on the handle at
least once.
.PP
After configuring the handle, you have to call \*(L"guestfs_launch\*(R".
.PP
You may also want to configure error handling for the handle.  See the
\&\*(L"\s-1ERROR\s0 \s-1HANDLING\s0\*(R" section below.
.SS "guestfs_close"
.IX Subsection "guestfs_close"
.Vb 1
\& void guestfs_close (guestfs_h *g);
.Ve
.PP
This closes the connection handle and frees up all resources used.
.PP
If autosync was set on the handle and the handle was launched, then this
implicitly calls various functions to unmount filesystems and sync the
disk.  See \*(L"guestfs_set_autosync\*(R" for more details.
.PP
If a close callback was set on the handle, then it is called.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
\&\s-1API\s0 functions can return errors.  For example, almost all functions that
return \f(CW\*(C`int\*(C'\fR will return \f(CW\*(C`\-1\*(C'\fR to indicate an error.
.PP
Additional information is available for errors: an error message string and
optionally an error number (errno) if the thing that failed was a system
call.
.PP
You can get at the additional information about the last error on the handle
by calling \*(L"guestfs_last_error\*(R", \*(L"guestfs_last_errno\*(R", and/or by setting
up an error handler with \*(L"guestfs_set_error_handler\*(R".
.PP
When the handle is created, a default error handler is installed which
prints the error message string to \f(CW\*(C`stderr\*(C'\fR.  For small short-running
command line programs it is sufficient to do:
.PP
.Vb 2
\& if (guestfs_launch (g) == \-1)
\&   exit (EXIT_FAILURE);
.Ve
.PP
since the default error handler will ensure that an error message has been
printed to \f(CW\*(C`stderr\*(C'\fR before the program exits.
.PP
For other programs the caller will almost certainly want to install an
alternate error handler or do error handling in-line like this:
.PP
.Vb 3
\& /* This disables the default behaviour of printing errors
\&    on stderr. */
\& guestfs_set_error_handler (g, NULL, NULL);
\& 
\& if (guestfs_launch (g) == \-1) {
\&   /* Examine the error message and print it etc. */
\&   char *msg = guestfs_last_error (g);
\&   int errnum = guestfs_last_errno (g);
\&   fprintf (stderr, "%s", msg);
\&   if (errnum != 0)
\&     fprintf (stderr, ": %s", strerror (errnum));
\&   fprintf (stderr, "\en");
\&   /* ... */
\& }
.Ve
.PP
Out of memory errors are handled differently.  The default action is to call
\&\fIabort\fR\|(3).  If this is undesirable, then you can set a handler using
\&\*(L"guestfs_set_out_of_memory_handler\*(R".
.PP
\&\*(L"guestfs_create\*(R" returns \f(CW\*(C`NULL\*(C'\fR if the handle cannot be created, and
because there is no handle if this happens there is no way to get additional
error information.  However \*(L"guestfs_create\*(R" is supposed to be a
lightweight operation which can only fail because of insufficient memory (it
returns \s-1NULL\s0 in this case).
.SS "guestfs_last_error"
.IX Subsection "guestfs_last_error"
.Vb 1
\& const char *guestfs_last_error (guestfs_h *g);
.Ve
.PP
This returns the last error message that happened on \f(CW\*(C`g\*(C'\fR.  If there has not
been an error since the handle was created, then this returns \f(CW\*(C`NULL\*(C'\fR.
.PP
The lifetime of the returned string is until the next error occurs, or
\&\*(L"guestfs_close\*(R" is called.
.SS "guestfs_last_errno"
.IX Subsection "guestfs_last_errno"
.Vb 1
\& int guestfs_last_errno (guestfs_h *g);
.Ve
.PP
This returns the last error number (errno) that happened on \f(CW\*(C`g\*(C'\fR.
.PP
If successful, an errno integer not equal to zero is returned.
.PP
If no error, this returns 0.  This call can return 0 in three situations:
.IP "1." 4
There has not been any error on the handle.
.IP "2." 4
There has been an error but the errno was meaningless.  This corresponds to
the case where the error did not come from a failed system call, but for
some other reason.
.IP "3." 4
There was an error from a failed system call, but for some reason the errno
was not captured and returned.  This usually indicates a bug in libguestfs.
.PP
Libguestfs tries to convert the errno from inside the applicance into a
corresponding errno for the caller (not entirely trivial: the appliance
might be running a completely different operating system from the library
and error numbers are not standardized across Un*xen).  If this could not be
done, then the error is translated to \f(CW\*(C`EINVAL\*(C'\fR.  In practice this should
only happen in very rare circumstances.
.SS "guestfs_set_error_handler"
.IX Subsection "guestfs_set_error_handler"
.Vb 6
\& typedef void (*guestfs_error_handler_cb) (guestfs_h *g,
\&                                           void *opaque,
\&                                           const char *msg);
\& void guestfs_set_error_handler (guestfs_h *g,
\&                                 guestfs_error_handler_cb cb,
\&                                 void *opaque);
.Ve
.PP
The callback \f(CW\*(C`cb\*(C'\fR will be called if there is an error.  The parameters
passed to the callback are an opaque data pointer and the error message
string.
.PP
\&\f(CW\*(C`errno\*(C'\fR is not passed to the callback.  To get that the callback must call
\&\*(L"guestfs_last_errno\*(R".
.PP
Note that the message string \f(CW\*(C`msg\*(C'\fR is freed as soon as the callback
function returns, so if you want to stash it somewhere you must make your
own copy.
.PP
The default handler prints messages on \f(CW\*(C`stderr\*(C'\fR.
.PP
If you set \f(CW\*(C`cb\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR then \fIno\fR handler is called.
.SS "guestfs_get_error_handler"
.IX Subsection "guestfs_get_error_handler"
.Vb 2
\& guestfs_error_handler_cb guestfs_get_error_handler (guestfs_h *g,
\&                                                     void **opaque_rtn);
.Ve
.PP
Returns the current error handler callback.
.SS "guestfs_set_out_of_memory_handler"
.IX Subsection "guestfs_set_out_of_memory_handler"
.Vb 3
\& typedef void (*guestfs_abort_cb) (void);
\& void guestfs_set_out_of_memory_handler (guestfs_h *g,
\&                                         guestfs_abort_cb);
.Ve
.PP
The callback \f(CW\*(C`cb\*(C'\fR will be called if there is an out of memory situation.
\&\fINote this callback must not return\fR.
.PP
The default is to call \fIabort\fR\|(3).
.PP
You cannot set \f(CW\*(C`cb\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR.  You can't ignore out of memory situations.
.SS "guestfs_get_out_of_memory_handler"
.IX Subsection "guestfs_get_out_of_memory_handler"
.Vb 1
\& guestfs_abort_fn guestfs_get_out_of_memory_handler (guestfs_h *g);
.Ve
.PP
This returns the current out of memory handler.
.SH "API CALLS"
.IX Header "API CALLS"
.SS "guestfs_add_cdrom"
.IX Subsection "guestfs_add_cdrom"
.Vb 3
\& int
\& guestfs_add_cdrom (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_add_drive_opts\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This function adds a virtual CD-ROM disk image to the guest.
.PP
This is equivalent to the qemu parameter \fI\-cdrom filename\fR.
.PP
Notes:
.IP "\(bu" 4
This call checks for the existence of \f(CW\*(C`filename\*(C'\fR.  This stops you from
specifying other types of drive which are supported by qemu such as \f(CW\*(C`nbd:\*(C'\fR
and \f(CW\*(C`http:\*(C'\fR URLs.  To specify those, use the general \f(CW\*(C`guestfs_config\*(C'\fR call
instead.
.IP "\(bu" 4
If you just want to add an \s-1ISO\s0 file (often you use this as an efficient way
to transfer large files into the guest), then you should probably use
\&\f(CW\*(C`guestfs_add_drive_ro\*(C'\fR instead.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_add_domain"
.IX Subsection "guestfs_add_domain"
.Vb 4
\& int
\& guestfs_add_domain (guestfs_h *g,
\&                     const char *dom,
\&                     ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 6
\& GUESTFS_ADD_DOMAIN_LIBVIRTURI, const char *libvirturi,
\& GUESTFS_ADD_DOMAIN_READONLY, int readonly,
\& GUESTFS_ADD_DOMAIN_IFACE, const char *iface,
\& GUESTFS_ADD_DOMAIN_LIVE, int live,
\& GUESTFS_ADD_DOMAIN_ALLOWUUID, int allowuuid,
\& GUESTFS_ADD_DOMAIN_READONLYDISK, const char *readonlydisk,
.Ve
.PP
This function adds the disk(s) attached to the named libvirt domain \f(CW\*(C`dom\*(C'\fR.
It works by connecting to libvirt, requesting the domain and domain \s-1XML\s0 from
libvirt, parsing it for disks, and calling \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR on each
one.
.PP
The number of disks added is returned.  This operation is atomic: if an
error is returned, then no disks are added.
.PP
This function does some minimal checks to make sure the libvirt domain is
not running (unless \f(CW\*(C`readonly\*(C'\fR is true).  In a future version we will try
to acquire the libvirt lock on each disk.
.PP
Disks must be accessible locally.  This often means that adding disks from a
remote libvirt connection (see <http://libvirt.org/remote.html>)  will fail
unless those disks are accessible via the same device path locally too.
.PP
The optional \f(CW\*(C`libvirturi\*(C'\fR parameter sets the libvirt \s-1URI\s0 (see
<http://libvirt.org/uri.html>).  If this is not set then we connect to the
default libvirt \s-1URI\s0 (or one set through an environment variable, see the
libvirt documentation for full details).
.PP
The optional \f(CW\*(C`live\*(C'\fR flag controls whether this call will try to connect to
a running virtual machine \f(CW\*(C`guestfsd\*(C'\fR process if it sees a suitable
<channel> element in the libvirt \s-1XML\s0 definition.  The default (if
the flag is omitted) is never to try.  See \*(L"\s-1ATTACHING\s0 \s-1TO\s0 \s-1RUNNING\s0
\&\s-1DAEMONS\s0\*(R" in \fIguestfs\fR\|(3) for more information.
.PP
If the \f(CW\*(C`allowuuid\*(C'\fR flag is true (default is false) then a \s-1UUID\s0 \fImay\fR be
passed instead of the domain name.  The \f(CW\*(C`dom\*(C'\fR string is treated as a \s-1UUID\s0
first and looked up, and if that lookup fails then we treat \f(CW\*(C`dom\*(C'\fR as a name
as usual.
.PP
The optional \f(CW\*(C`readonlydisk\*(C'\fR parameter controls what we do for disks which
are marked <readonly/> in the libvirt \s-1XML\s0.  Possible values are:
.ie n .IP "readonlydisk = ""error""" 4
.el .IP "readonlydisk = ``error''" 4
.IX Item "readonlydisk = error"
If \f(CW\*(C`readonly\*(C'\fR is false:
.Sp
The whole call is aborted with an error if any disk with the
<readonly/> flag is found.
.Sp
If \f(CW\*(C`readonly\*(C'\fR is true:
.Sp
Disks with the <readonly/> flag are added read-only.
.ie n .IP "readonlydisk = ""read""" 4
.el .IP "readonlydisk = ``read''" 4
.IX Item "readonlydisk = read"
If \f(CW\*(C`readonly\*(C'\fR is false:
.Sp
Disks with the <readonly/> flag are added read-only.  Other disks
are added read/write.
.Sp
If \f(CW\*(C`readonly\*(C'\fR is true:
.Sp
Disks with the <readonly/> flag are added read-only.
.ie n .IP "readonlydisk = ""write"" (default)" 4
.el .IP "readonlydisk = ``write'' (default)" 4
.IX Item "readonlydisk = write (default)"
If \f(CW\*(C`readonly\*(C'\fR is false:
.Sp
Disks with the <readonly/> flag are added read/write.
.Sp
If \f(CW\*(C`readonly\*(C'\fR is true:
.Sp
Disks with the <readonly/> flag are added read-only.
.ie n .IP "readonlydisk = ""ignore""" 4
.el .IP "readonlydisk = ``ignore''" 4
.IX Item "readonlydisk = ignore"
If \f(CW\*(C`readonly\*(C'\fR is true or false:
.Sp
Disks with the <readonly/> flag are skipped.
.PP
The other optional parameters are passed directly through to
\&\f(CW\*(C`guestfs_add_drive_opts\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.7.4)
.SS "guestfs_add_domain_va"
.IX Subsection "guestfs_add_domain_va"
.Vb 4
\& int
\& guestfs_add_domain_va (guestfs_h *g,
\&                        const char *dom,
\&                        va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_add_domain\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_add_domain_argv"
.IX Subsection "guestfs_add_domain_argv"
.Vb 4
\& int
\& guestfs_add_domain_argv (guestfs_h *g,
\&                          const char *dom,
\&                          const struct guestfs_add_domain_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_add_domain\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_add_drive"
.IX Subsection "guestfs_add_drive"
.Vb 3
\& int
\& guestfs_add_drive (guestfs_h *g,
\&                    const char *filename);
.Ve
.PP
This function is the equivalent of calling \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR with no
optional parameters, so the disk is added writable, with the format being
detected automatically.
.PP
Automatic detection of the format opens you up to a potential security hole
when dealing with untrusted raw-format images.  See \s-1CVE\-2010\-3851\s0 and
RHBZ#642934.  Specifying the format closes this security hole.  Therefore
you should think about replacing calls to this function with calls to
\&\f(CW\*(C`guestfs_add_drive_opts\*(C'\fR, and specifying the format.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_add_drive_opts"
.IX Subsection "guestfs_add_drive_opts"
.Vb 4
\& int
\& guestfs_add_drive_opts (guestfs_h *g,
\&                         const char *filename,
\&                         ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 4
\& GUESTFS_ADD_DRIVE_OPTS_READONLY, int readonly,
\& GUESTFS_ADD_DRIVE_OPTS_FORMAT, const char *format,
\& GUESTFS_ADD_DRIVE_OPTS_IFACE, const char *iface,
\& GUESTFS_ADD_DRIVE_OPTS_NAME, const char *name,
.Ve
.PP
This function adds a virtual machine disk image \f(CW\*(C`filename\*(C'\fR to libguestfs.
The first time you call this function, the disk appears as \f(CW\*(C`/dev/sda\*(C'\fR, the
second time as \f(CW\*(C`/dev/sdb\*(C'\fR, and so on.
.PP
You don't necessarily need to be root when using libguestfs.  However you
obviously do need sufficient permissions to access the filename for whatever
operations you want to perform (ie. read access if you just want to read the
image or write access if you want to modify the image).
.PP
This call checks that \f(CW\*(C`filename\*(C'\fR exists.
.PP
The optional arguments are:
.ie n .IP """readonly""" 4
.el .IP "\f(CWreadonly\fR" 4
.IX Item "readonly"
If true then the image is treated as read-only.  Writes are still allowed,
but they are stored in a temporary snapshot overlay which is discarded at
the end.  The disk that you add is not modified.
.ie n .IP """format""" 4
.el .IP "\f(CWformat\fR" 4
.IX Item "format"
This forces the image format.  If you omit this (or use \f(CW\*(C`guestfs_add_drive\*(C'\fR
or \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR) then the format is automatically detected.
Possible formats include \f(CW\*(C`raw\*(C'\fR and \f(CW\*(C`qcow2\*(C'\fR.
.Sp
Automatic detection of the format opens you up to a potential security hole
when dealing with untrusted raw-format images.  See \s-1CVE\-2010\-3851\s0 and
RHBZ#642934.  Specifying the format closes this security hole.
.ie n .IP """iface""" 4
.el .IP "\f(CWiface\fR" 4
.IX Item "iface"
This rarely-used option lets you emulate the behaviour of the deprecated
\&\f(CW\*(C`guestfs_add_drive_with_if\*(C'\fR call (q.v.)
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The name the drive had in the original guest, e.g. /dev/sdb. This is used as
a hint to the guest inspection process if it is available.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.5.23)
.SS "guestfs_add_drive_opts_va"
.IX Subsection "guestfs_add_drive_opts_va"
.Vb 4
\& int
\& guestfs_add_drive_opts_va (guestfs_h *g,
\&                            const char *filename,
\&                            va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_add_drive_opts\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_add_drive_opts_argv"
.IX Subsection "guestfs_add_drive_opts_argv"
.Vb 4
\& int
\& guestfs_add_drive_opts_argv (guestfs_h *g,
\&                              const char *filename,
\&                              const struct guestfs_add_drive_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_add_drive_opts\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_add_drive_ro"
.IX Subsection "guestfs_add_drive_ro"
.Vb 3
\& int
\& guestfs_add_drive_ro (guestfs_h *g,
\&                       const char *filename);
.Ve
.PP
This function is the equivalent of calling \f(CW\*(C`guestfs_add_drive_opts\*(C'\fR with
the optional parameter \f(CW\*(C`GUESTFS_ADD_DRIVE_OPTS_READONLY\*(C'\fR set to 1, so the
disk is added read-only, with the format being detected automatically.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.38)
.SS "guestfs_add_drive_ro_with_if"
.IX Subsection "guestfs_add_drive_ro_with_if"
.Vb 4
\& int
\& guestfs_add_drive_ro_with_if (guestfs_h *g,
\&                               const char *filename,
\&                               const char *iface);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_add_drive_opts\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is the same as \f(CW\*(C`guestfs_add_drive_ro\*(C'\fR but it allows you to specify the
\&\s-1QEMU\s0 interface emulation to use at run time.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.84)
.SS "guestfs_add_drive_with_if"
.IX Subsection "guestfs_add_drive_with_if"
.Vb 4
\& int
\& guestfs_add_drive_with_if (guestfs_h *g,
\&                            const char *filename,
\&                            const char *iface);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_add_drive_opts\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is the same as \f(CW\*(C`guestfs_add_drive\*(C'\fR but it allows you to specify the
\&\s-1QEMU\s0 interface emulation to use at run time.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.84)
.SS "guestfs_aug_clear"
.IX Subsection "guestfs_aug_clear"
.Vb 3
\& int
\& guestfs_aug_clear (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Set the value associated with \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR.  This is the same as the
\&\fIaugtool\fR\|(1) \f(CW\*(C`clear\*(C'\fR command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.4)
.SS "guestfs_aug_close"
.IX Subsection "guestfs_aug_close"
.Vb 2
\& int
\& guestfs_aug_close (guestfs_h *g);
.Ve
.PP
Close the current Augeas handle and free up any resources used by it.  After
calling this, you have to call \f(CW\*(C`guestfs_aug_init\*(C'\fR again before you can use
any other Augeas functions.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_aug_defnode"
.IX Subsection "guestfs_aug_defnode"
.Vb 5
\& struct guestfs_int_bool *
\& guestfs_aug_defnode (guestfs_h *g,
\&                      const char *name,
\&                      const char *expr,
\&                      const char *val);
.Ve
.PP
Defines a variable \f(CW\*(C`name\*(C'\fR whose value is the result of evaluating \f(CW\*(C`expr\*(C'\fR.
.PP
If \f(CW\*(C`expr\*(C'\fR evaluates to an empty nodeset, a node is created, equivalent to
calling \f(CW\*(C`guestfs_aug_set\*(C'\fR \f(CW\*(C`expr\*(C'\fR, \f(CW\*(C`value\*(C'\fR.  \f(CW\*(C`name\*(C'\fR will be the nodeset
containing that single node.
.PP
On success this returns a pair containing the number of nodes in the
nodeset, and a boolean flag if a node was created.
.PP
This function returns a \f(CW\*(C`struct guestfs_int_bool *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_int_bool\*(C'\fI after use\fR.
.PP
(Added in 0.7)
.SS "guestfs_aug_defvar"
.IX Subsection "guestfs_aug_defvar"
.Vb 4
\& int
\& guestfs_aug_defvar (guestfs_h *g,
\&                     const char *name,
\&                     const char *expr);
.Ve
.PP
Defines an Augeas variable \f(CW\*(C`name\*(C'\fR whose value is the result of evaluating
\&\f(CW\*(C`expr\*(C'\fR.  If \f(CW\*(C`expr\*(C'\fR is \s-1NULL\s0, then \f(CW\*(C`name\*(C'\fR is undefined.
.PP
On success this returns the number of nodes in \f(CW\*(C`expr\*(C'\fR, or \f(CW0\fR if \f(CW\*(C`expr\*(C'\fR
evaluates to something which is not a nodeset.
.PP
On error this function returns \-1.
.PP
(Added in 0.7)
.SS "guestfs_aug_get"
.IX Subsection "guestfs_aug_get"
.Vb 3
\& char *
\& guestfs_aug_get (guestfs_h *g,
\&                  const char *augpath);
.Ve
.PP
Look up the value associated with \f(CW\*(C`path\*(C'\fR.  If \f(CW\*(C`path\*(C'\fR matches exactly one
node, the \f(CW\*(C`value\*(C'\fR is returned.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 0.7)
.SS "guestfs_aug_init"
.IX Subsection "guestfs_aug_init"
.Vb 4
\& int
\& guestfs_aug_init (guestfs_h *g,
\&                   const char *root,
\&                   int flags);
.Ve
.PP
Create a new Augeas handle for editing configuration files.  If there was
any previous Augeas handle associated with this guestfs session, then it is
closed.
.PP
You must call this before using any other \f(CW\*(C`guestfs_aug_*\*(C'\fR commands.
.PP
\&\f(CW\*(C`root\*(C'\fR is the filesystem root.  \f(CW\*(C`root\*(C'\fR must not be \s-1NULL\s0, use \f(CW\*(C`/\*(C'\fR instead.
.PP
The flags are the same as the flags defined in <augeas.h>, the
logical \fIor\fR of the following integers:
.ie n .IP """AUG_SAVE_BACKUP"" = 1" 4
.el .IP "\f(CWAUG_SAVE_BACKUP\fR = 1" 4
.IX Item "AUG_SAVE_BACKUP = 1"
Keep the original file with a \f(CW\*(C`.augsave\*(C'\fR extension.
.ie n .IP """AUG_SAVE_NEWFILE"" = 2" 4
.el .IP "\f(CWAUG_SAVE_NEWFILE\fR = 2" 4
.IX Item "AUG_SAVE_NEWFILE = 2"
Save changes into a file with extension \f(CW\*(C`.augnew\*(C'\fR, and do not overwrite
original.  Overrides \f(CW\*(C`AUG_SAVE_BACKUP\*(C'\fR.
.ie n .IP """AUG_TYPE_CHECK"" = 4" 4
.el .IP "\f(CWAUG_TYPE_CHECK\fR = 4" 4
.IX Item "AUG_TYPE_CHECK = 4"
Typecheck lenses.
.Sp
This option is only useful when debugging Augeas lenses.  Use of this option
may require additional memory for the libguestfs appliance.  You may need to
set the \f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR environment variable or call
\&\f(CW\*(C`guestfs_set_memsize\*(C'\fR.
.ie n .IP """AUG_NO_STDINC"" = 8" 4
.el .IP "\f(CWAUG_NO_STDINC\fR = 8" 4
.IX Item "AUG_NO_STDINC = 8"
Do not use standard load path for modules.
.ie n .IP """AUG_SAVE_NOOP"" = 16" 4
.el .IP "\f(CWAUG_SAVE_NOOP\fR = 16" 4
.IX Item "AUG_SAVE_NOOP = 16"
Make save a no-op, just record what would have been changed.
.ie n .IP """AUG_NO_LOAD"" = 32" 4
.el .IP "\f(CWAUG_NO_LOAD\fR = 32" 4
.IX Item "AUG_NO_LOAD = 32"
Do not load the tree in \f(CW\*(C`guestfs_aug_init\*(C'\fR.
.PP
To close the handle, you can call \f(CW\*(C`guestfs_aug_close\*(C'\fR.
.PP
To find out more about Augeas, see <http://augeas.net/>.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_aug_insert"
.IX Subsection "guestfs_aug_insert"
.Vb 5
\& int
\& guestfs_aug_insert (guestfs_h *g,
\&                     const char *augpath,
\&                     const char *label,
\&                     int before);
.Ve
.PP
Create a new sibling \f(CW\*(C`label\*(C'\fR for \f(CW\*(C`path\*(C'\fR, inserting it into the tree before
or after \f(CW\*(C`path\*(C'\fR (depending on the boolean flag \f(CW\*(C`before\*(C'\fR).
.PP
\&\f(CW\*(C`path\*(C'\fR must match exactly one existing node in the tree, and \f(CW\*(C`label\*(C'\fR must
be a label, ie. not contain \f(CW\*(C`/\*(C'\fR, \f(CW\*(C`*\*(C'\fR or end with a bracketed index \f(CW\*(C`[N]\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_aug_load"
.IX Subsection "guestfs_aug_load"
.Vb 2
\& int
\& guestfs_aug_load (guestfs_h *g);
.Ve
.PP
Load files into the tree.
.PP
See \f(CW\*(C`aug_load\*(C'\fR in the Augeas documentation for the full gory details.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_aug_ls"
.IX Subsection "guestfs_aug_ls"
.Vb 3
\& char **
\& guestfs_aug_ls (guestfs_h *g,
\&                 const char *augpath);
.Ve
.PP
This is just a shortcut for listing \f(CW\*(C`guestfs_aug_match\*(C'\fR \f(CW\*(C`path/*\*(C'\fR and
sorting the resulting nodes into alphabetical order.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.8)
.SS "guestfs_aug_match"
.IX Subsection "guestfs_aug_match"
.Vb 3
\& char **
\& guestfs_aug_match (guestfs_h *g,
\&                    const char *augpath);
.Ve
.PP
Returns a list of paths which match the path expression \f(CW\*(C`path\*(C'\fR.  The
returned paths are sufficiently qualified so that they match exactly one
node in the current tree.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.7)
.SS "guestfs_aug_mv"
.IX Subsection "guestfs_aug_mv"
.Vb 4
\& int
\& guestfs_aug_mv (guestfs_h *g,
\&                 const char *src,
\&                 const char *dest);
.Ve
.PP
Move the node \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR.  \f(CW\*(C`src\*(C'\fR must match exactly one node.
\&\f(CW\*(C`dest\*(C'\fR is overwritten if it exists.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_aug_rm"
.IX Subsection "guestfs_aug_rm"
.Vb 3
\& int
\& guestfs_aug_rm (guestfs_h *g,
\&                 const char *augpath);
.Ve
.PP
Remove \f(CW\*(C`path\*(C'\fR and all of its children.
.PP
On success this returns the number of entries which were removed.
.PP
On error this function returns \-1.
.PP
(Added in 0.7)
.SS "guestfs_aug_save"
.IX Subsection "guestfs_aug_save"
.Vb 2
\& int
\& guestfs_aug_save (guestfs_h *g);
.Ve
.PP
This writes all pending changes to disk.
.PP
The flags which were passed to \f(CW\*(C`guestfs_aug_init\*(C'\fR affect exactly how files
are saved.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_aug_set"
.IX Subsection "guestfs_aug_set"
.Vb 4
\& int
\& guestfs_aug_set (guestfs_h *g,
\&                  const char *augpath,
\&                  const char *val);
.Ve
.PP
Set the value associated with \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`val\*(C'\fR.
.PP
In the Augeas \s-1API\s0, it is possible to clear a node by setting the value to
\&\s-1NULL\s0.  Due to an oversight in the libguestfs \s-1API\s0 you cannot do that with
this call.  Instead you must use the \f(CW\*(C`guestfs_aug_clear\*(C'\fR call.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.7)
.SS "guestfs_available"
.IX Subsection "guestfs_available"
.Vb 3
\& int
\& guestfs_available (guestfs_h *g,
\&                    char *const *groups);
.Ve
.PP
This command is used to check the availability of some groups of
functionality in the appliance, which not all builds of the libguestfs
appliance will be able to provide.
.PP
The libguestfs groups, and the functions that those groups correspond to,
are listed in \*(L"\s-1AVAILABILITY\s0\*(R" in \fIguestfs\fR\|(3).  You can also fetch this list at
runtime by calling \f(CW\*(C`guestfs_available_all_groups\*(C'\fR.
.PP
The argument \f(CW\*(C`groups\*(C'\fR is a list of group names, eg: \f(CW\*(C`["inotify",
"augeas"]\*(C'\fR would check for the availability of the Linux inotify functions
and Augeas (configuration file editing) functions.
.PP
The command returns no error if \fIall\fR requested groups are available.
.PP
It fails with an error if one or more of the requested groups is unavailable
in the appliance.
.PP
If an unknown group name is included in the list of groups then an error is
always returned.
.PP
\&\fINotes:\fR
.IP "\(bu" 4
You must call \f(CW\*(C`guestfs_launch\*(C'\fR before calling this function.
.Sp
The reason is because we don't know what groups are supported by the
appliance/daemon until it is running and can be queried.
.IP "\(bu" 4
If a group of functions is available, this does not necessarily mean that
they will work.  You still have to check for errors when calling individual
\&\s-1API\s0 functions even if they are available.
.IP "\(bu" 4
It is usually the job of distro packagers to build complete functionality
into the libguestfs appliance.  Upstream libguestfs, if built from source
with all requirements satisfied, will support everything.
.IP "\(bu" 4
This call was added in version \f(CW1.0.80\fR.  In previous versions of
libguestfs all you could do would be to speculatively execute a command to
find out if the daemon implemented it.  See also \f(CW\*(C`guestfs_version\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.80)
.SS "guestfs_available_all_groups"
.IX Subsection "guestfs_available_all_groups"
.Vb 2
\& char **
\& guestfs_available_all_groups (guestfs_h *g);
.Ve
.PP
This command returns a list of all optional groups that this daemon knows
about.  Note this returns both supported and unsupported groups.  To find
out which ones the daemon can actually support you have to call
\&\f(CW\*(C`guestfs_available\*(C'\fR on each member of the returned list.
.PP
See also \f(CW\*(C`guestfs_available\*(C'\fR and \*(L"\s-1AVAILABILITY\s0\*(R" in \fIguestfs\fR\|(3).
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.3.15)
.SS "guestfs_base64_in"
.IX Subsection "guestfs_base64_in"
.Vb 4
\& int
\& guestfs_base64_in (guestfs_h *g,
\&                    const char *base64file,
\&                    const char *filename);
.Ve
.PP
This command uploads base64\-encoded data from \f(CW\*(C`base64file\*(C'\fR to \f(CW\*(C`filename\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.5)
.SS "guestfs_base64_out"
.IX Subsection "guestfs_base64_out"
.Vb 4
\& int
\& guestfs_base64_out (guestfs_h *g,
\&                     const char *filename,
\&                     const char *base64file);
.Ve
.PP
This command downloads the contents of \f(CW\*(C`filename\*(C'\fR, writing it out to local
file \f(CW\*(C`base64file\*(C'\fR encoded as base64.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.5)
.SS "guestfs_blkid"
.IX Subsection "guestfs_blkid"
.Vb 3
\& char **
\& guestfs_blkid (guestfs_h *g,
\&                const char *device);
.Ve
.PP
This command returns block device attributes for \f(CW\*(C`device\*(C'\fR. The following
fields are usually present in the returned hash. Other fields may also be
present.
.ie n .IP """UUID""" 4
.el .IP "\f(CWUUID\fR" 4
.IX Item "UUID"
The uuid of this device.
.ie n .IP """LABEL""" 4
.el .IP "\f(CWLABEL\fR" 4
.IX Item "LABEL"
The label of this device.
.ie n .IP """VERSION""" 4
.el .IP "\f(CWVERSION\fR" 4
.IX Item "VERSION"
The version of blkid command.
.ie n .IP """TYPE""" 4
.el .IP "\f(CWTYPE\fR" 4
.IX Item "TYPE"
The filesystem type or \s-1RAID\s0 of this device.
.ie n .IP """USAGE""" 4
.el .IP "\f(CWUSAGE\fR" 4
.IX Item "USAGE"
The usage of this device, for example \f(CW\*(C`filesystem\*(C'\fR or \f(CW\*(C`raid\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.15.9)
.SS "guestfs_blockdev_flushbufs"
.IX Subsection "guestfs_blockdev_flushbufs"
.Vb 3
\& int
\& guestfs_blockdev_flushbufs (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
This tells the kernel to flush internal buffers associated with \f(CW\*(C`device\*(C'\fR.
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_getbsz"
.IX Subsection "guestfs_blockdev_getbsz"
.Vb 3
\& int
\& guestfs_blockdev_getbsz (guestfs_h *g,
\&                          const char *device);
.Ve
.PP
This returns the block size of a device.
.PP
(Note this is different from both \fIsize in blocks\fR and \fIfilesystem block
size\fR).
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
On error this function returns \-1.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_getro"
.IX Subsection "guestfs_blockdev_getro"
.Vb 3
\& int
\& guestfs_blockdev_getro (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Returns a boolean indicating if the block device is read-only (true if
read-only, false if not).
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_getsize64"
.IX Subsection "guestfs_blockdev_getsize64"
.Vb 3
\& int64_t
\& guestfs_blockdev_getsize64 (guestfs_h *g,
\&                             const char *device);
.Ve
.PP
This returns the size of the device in bytes.
.PP
See also \f(CW\*(C`guestfs_blockdev_getsz\*(C'\fR.
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
On error this function returns \-1.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_getss"
.IX Subsection "guestfs_blockdev_getss"
.Vb 3
\& int
\& guestfs_blockdev_getss (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
This returns the size of sectors on a block device.  Usually 512, but can be
larger for modern devices.
.PP
(Note, this is not the size in sectors, use \f(CW\*(C`guestfs_blockdev_getsz\*(C'\fR for
that).
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
On error this function returns \-1.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_getsz"
.IX Subsection "guestfs_blockdev_getsz"
.Vb 3
\& int64_t
\& guestfs_blockdev_getsz (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
This returns the size of the device in units of 512\-byte sectors (even if
the sectorsize isn't 512 bytes ... weird).
.PP
See also \f(CW\*(C`guestfs_blockdev_getss\*(C'\fR for the real sector size of the device,
and \f(CW\*(C`guestfs_blockdev_getsize64\*(C'\fR for the more useful \fIsize in bytes\fR.
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
On error this function returns \-1.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_rereadpt"
.IX Subsection "guestfs_blockdev_rereadpt"
.Vb 3
\& int
\& guestfs_blockdev_rereadpt (guestfs_h *g,
\&                            const char *device);
.Ve
.PP
Reread the partition table on \f(CW\*(C`device\*(C'\fR.
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_setbsz"
.IX Subsection "guestfs_blockdev_setbsz"
.Vb 4
\& int
\& guestfs_blockdev_setbsz (guestfs_h *g,
\&                          const char *device,
\&                          int blocksize);
.Ve
.PP
This sets the block size of a device.
.PP
(Note this is different from both \fIsize in blocks\fR and \fIfilesystem block
size\fR).
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_setro"
.IX Subsection "guestfs_blockdev_setro"
.Vb 3
\& int
\& guestfs_blockdev_setro (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Sets the block device named \f(CW\*(C`device\*(C'\fR to read-only.
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.9.3)
.SS "guestfs_blockdev_setrw"
.IX Subsection "guestfs_blockdev_setrw"
.Vb 3
\& int
\& guestfs_blockdev_setrw (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
Sets the block device named \f(CW\*(C`device\*(C'\fR to read-write.
.PP
This uses the \fIblockdev\fR\|(8) command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.9.3)
.SS "guestfs_btrfs_filesystem_resize"
.IX Subsection "guestfs_btrfs_filesystem_resize"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize (guestfs_h *g,
\&                                  const char *mountpoint,
\&                                  ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 1
\& GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE, int64_t size,
.Ve
.PP
This command resizes a btrfs filesystem.
.PP
Note that unlike other resize calls, the filesystem has to be mounted and
the parameter is the mountpoint not the device (this is a requirement of
btrfs itself).
.PP
The optional parameters are:
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
The new size (in bytes) of the filesystem.  If omitted, the filesystem is
resized to the maximum size.
.PP
See also \fIbtrfs\fR\|(8).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.11.17)
.SS "guestfs_btrfs_filesystem_resize_va"
.IX Subsection "guestfs_btrfs_filesystem_resize_va"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize_va (guestfs_h *g,
\&                                     const char *mountpoint,
\&                                     va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_btrfs_filesystem_resize\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_btrfs_filesystem_resize_argv"
.IX Subsection "guestfs_btrfs_filesystem_resize_argv"
.Vb 4
\& int
\& guestfs_btrfs_filesystem_resize_argv (guestfs_h *g,
\&                                       const char *mountpoint,
\&                                       const struct guestfs_btrfs_filesystem_resize_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_btrfs_filesystem_resize\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_case_sensitive_path"
.IX Subsection "guestfs_case_sensitive_path"
.Vb 3
\& char *
\& guestfs_case_sensitive_path (guestfs_h *g,
\&                              const char *path);
.Ve
.PP
This can be used to resolve case insensitive paths on a filesystem which is
case sensitive.  The use case is to resolve paths which you have read from
Windows configuration files or the Windows Registry, to the true path.
.PP
The command handles a peculiarity of the Linux ntfs\-3g filesystem driver
(and probably others), which is that although the underlying filesystem is
case-insensitive, the driver exports the filesystem to Linux as
case-sensitive.
.PP
One consequence of this is that special directories such as \f(CW\*(C`c:\ewindows\*(C'\fR
may appear as \f(CW\*(C`/WINDOWS\*(C'\fR or \f(CW\*(C`/windows\*(C'\fR (or other things) depending on the
precise details of how they were created.  In Windows itself this would not
be a problem.
.PP
Bug or feature? You decide:
http://www.tuxera.com/community/ntfs\-3g\-faq/#posixfilenames1 <http://www.tuxera.com/community/ntfs-3g-faq/#posixfilenames1>
.PP
This function resolves the true case of each element in the path and returns
the case-sensitive path.
.PP
Thus \f(CW\*(C`guestfs_case_sensitive_path\*(C'\fR (\*(L"/Windows/System32\*(R")  might return
\&\f(CW"/WINDOWS/system32"\fR (the exact return value would depend on details of
how the directories were originally created under Windows).
.PP
\&\fINote\fR: This function does not handle drive names, backslashes etc.
.PP
See also \f(CW\*(C`guestfs_realpath\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.75)
.SS "guestfs_cat"
.IX Subsection "guestfs_cat"
.Vb 3
\& char *
\& guestfs_cat (guestfs_h *g,
\&              const char *path);
.Ve
.PP
Return the contents of the file named \f(CW\*(C`path\*(C'\fR.
.PP
Note that this function cannot correctly handle binary files (specifically,
files containing \f(CW\*(C`\e0\*(C'\fR character which is treated as end of string).  For
those you need to use the \f(CW\*(C`guestfs_read_file\*(C'\fR or \f(CW\*(C`guestfs_download\*(C'\fR
functions which have a more complex interface.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 0.4)
.SS "guestfs_checksum"
.IX Subsection "guestfs_checksum"
.Vb 4
\& char *
\& guestfs_checksum (guestfs_h *g,
\&                   const char *csumtype,
\&                   const char *path);
.Ve
.PP
This call computes the \s-1MD5\s0, SHAx or \s-1CRC\s0 checksum of the file named \f(CW\*(C`path\*(C'\fR.
.PP
The type of checksum to compute is given by the \f(CW\*(C`csumtype\*(C'\fR parameter which
must have one of the following values:
.ie n .IP """crc""" 4
.el .IP "\f(CWcrc\fR" 4
.IX Item "crc"
Compute the cyclic redundancy check (\s-1CRC\s0) specified by \s-1POSIX\s0 for the
\&\f(CW\*(C`cksum\*(C'\fR command.
.ie n .IP """md5""" 4
.el .IP "\f(CWmd5\fR" 4
.IX Item "md5"
Compute the \s-1MD5\s0 hash (using the \f(CW\*(C`md5sum\*(C'\fR program).
.ie n .IP """sha1""" 4
.el .IP "\f(CWsha1\fR" 4
.IX Item "sha1"
Compute the \s-1SHA1\s0 hash (using the \f(CW\*(C`sha1sum\*(C'\fR program).
.ie n .IP """sha224""" 4
.el .IP "\f(CWsha224\fR" 4
.IX Item "sha224"
Compute the \s-1SHA224\s0 hash (using the \f(CW\*(C`sha224sum\*(C'\fR program).
.ie n .IP """sha256""" 4
.el .IP "\f(CWsha256\fR" 4
.IX Item "sha256"
Compute the \s-1SHA256\s0 hash (using the \f(CW\*(C`sha256sum\*(C'\fR program).
.ie n .IP """sha384""" 4
.el .IP "\f(CWsha384\fR" 4
.IX Item "sha384"
Compute the \s-1SHA384\s0 hash (using the \f(CW\*(C`sha384sum\*(C'\fR program).
.ie n .IP """sha512""" 4
.el .IP "\f(CWsha512\fR" 4
.IX Item "sha512"
Compute the \s-1SHA512\s0 hash (using the \f(CW\*(C`sha512sum\*(C'\fR program).
.PP
The checksum is returned as a printable string.
.PP
To get the checksum for a device, use \f(CW\*(C`guestfs_checksum_device\*(C'\fR.
.PP
To get the checksums for many files, use \f(CW\*(C`guestfs_checksums_out\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.2)
.SS "guestfs_checksum_device"
.IX Subsection "guestfs_checksum_device"
.Vb 4
\& char *
\& guestfs_checksum_device (guestfs_h *g,
\&                          const char *csumtype,
\&                          const char *device);
.Ve
.PP
This call computes the \s-1MD5\s0, SHAx or \s-1CRC\s0 checksum of the contents of the
device named \f(CW\*(C`device\*(C'\fR.  For the types of checksums supported see the
\&\f(CW\*(C`guestfs_checksum\*(C'\fR command.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.3.2)
.SS "guestfs_checksums_out"
.IX Subsection "guestfs_checksums_out"
.Vb 5
\& int
\& guestfs_checksums_out (guestfs_h *g,
\&                        const char *csumtype,
\&                        const char *directory,
\&                        const char *sumsfile);
.Ve
.PP
This command computes the checksums of all regular files in \f(CW\*(C`directory\*(C'\fR and
then emits a list of those checksums to the local output file \f(CW\*(C`sumsfile\*(C'\fR.
.PP
This can be used for verifying the integrity of a virtual machine.  However
to be properly secure you should pay attention to the output of the checksum
command (it uses the ones from \s-1GNU\s0 coreutils).  In particular when the
filename is not printable, coreutils uses a special backslash syntax.  For
more information, see the \s-1GNU\s0 coreutils info file.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.7)
.SS "guestfs_chmod"
.IX Subsection "guestfs_chmod"
.Vb 4
\& int
\& guestfs_chmod (guestfs_h *g,
\&                int mode,
\&                const char *path);
.Ve
.PP
Change the mode (permissions) of \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`mode\*(C'\fR.  Only numeric modes are
supported.
.PP
\&\fINote\fR: When using this command from guestfish, \f(CW\*(C`mode\*(C'\fR by default would be
decimal, unless you prefix it with \f(CW0\fR to get octal, ie. use \f(CW0700\fR not
\&\f(CW700\fR.
.PP
The mode actually set is affected by the umask.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_chown"
.IX Subsection "guestfs_chown"
.Vb 5
\& int
\& guestfs_chown (guestfs_h *g,
\&                int owner,
\&                int group,
\&                const char *path);
.Ve
.PP
Change the file owner to \f(CW\*(C`owner\*(C'\fR and group to \f(CW\*(C`group\*(C'\fR.
.PP
Only numeric uid and gid are supported.  If you want to use names, you will
need to locate and parse the password file yourself (Augeas support makes
this relatively easy).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_command"
.IX Subsection "guestfs_command"
.Vb 3
\& char *
\& guestfs_command (guestfs_h *g,
\&                  char *const *arguments);
.Ve
.PP
This call runs a command from the guest filesystem.  The filesystem must be
mounted, and must contain a compatible operating system (ie. something
Linux, with the same or compatible processor architecture).
.PP
The single parameter is an argv-style list of arguments.  The first element
is the name of the program to run.  Subsequent elements are parameters.  The
list must be non-empty (ie. must contain a program name).  Note that the
command runs directly, and is \fInot\fR invoked via the shell (see
\&\f(CW\*(C`guestfs_sh\*(C'\fR).
.PP
The return value is anything printed to \fIstdout\fR by the command.
.PP
If the command returns a non-zero exit status, then this function returns an
error message.  The error message string is the content of \fIstderr\fR from
the command.
.PP
The \f(CW$PATH\fR environment variable will contain at least \f(CW\*(C`/usr/bin\*(C'\fR and
\&\f(CW\*(C`/bin\*(C'\fR.  If you require a program from another location, you should provide
the full path in the first parameter.
.PP
Shared libraries and data files required by the program must be available on
filesystems which are mounted in the correct places.  It is the caller's
responsibility to ensure all filesystems that are needed are mounted at the
right locations.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 0.9.1)
.SS "guestfs_command_lines"
.IX Subsection "guestfs_command_lines"
.Vb 3
\& char **
\& guestfs_command_lines (guestfs_h *g,
\&                        char *const *arguments);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_command\*(C'\fR, but splits the result into a list of
lines.
.PP
See also: \f(CW\*(C`guestfs_sh_lines\*(C'\fR
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 0.9.1)
.SS "guestfs_compress_device_out"
.IX Subsection "guestfs_compress_device_out"
.Vb 6
\& int
\& guestfs_compress_device_out (guestfs_h *g,
\&                              const char *ctype,
\&                              const char *device,
\&                              const char *zdevice,
\&                              ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 1
\& GUESTFS_COMPRESS_DEVICE_OUT_LEVEL, int level,
.Ve
.PP
This command compresses \f(CW\*(C`device\*(C'\fR and writes it out to the local file
\&\f(CW\*(C`zdevice\*(C'\fR.
.PP
The \f(CW\*(C`ctype\*(C'\fR and optional \f(CW\*(C`level\*(C'\fR parameters have the same meaning as in
\&\f(CW\*(C`guestfs_compress_out\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.13.15)
.SS "guestfs_compress_device_out_va"
.IX Subsection "guestfs_compress_device_out_va"
.Vb 6
\& int
\& guestfs_compress_device_out_va (guestfs_h *g,
\&                                 const char *ctype,
\&                                 const char *device,
\&                                 const char *zdevice,
\&                                 va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_compress_device_out\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_compress_device_out_argv"
.IX Subsection "guestfs_compress_device_out_argv"
.Vb 6
\& int
\& guestfs_compress_device_out_argv (guestfs_h *g,
\&                                   const char *ctype,
\&                                   const char *device,
\&                                   const char *zdevice,
\&                                   const struct guestfs_compress_device_out_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_compress_device_out\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_compress_out"
.IX Subsection "guestfs_compress_out"
.Vb 6
\& int
\& guestfs_compress_out (guestfs_h *g,
\&                       const char *ctype,
\&                       const char *file,
\&                       const char *zfile,
\&                       ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 1
\& GUESTFS_COMPRESS_OUT_LEVEL, int level,
.Ve
.PP
This command compresses \f(CW\*(C`file\*(C'\fR and writes it out to the local file
\&\f(CW\*(C`zfile\*(C'\fR.
.PP
The compression program used is controlled by the \f(CW\*(C`ctype\*(C'\fR parameter.
Currently this includes: \f(CW\*(C`compress\*(C'\fR, \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`bzip2\*(C'\fR, \f(CW\*(C`xz\*(C'\fR or \f(CW\*(C`lzop\*(C'\fR.
Some compression types may not be supported by particular builds of
libguestfs, in which case you will get an error containing the substring
\&\*(L"not supported\*(R".
.PP
The optional \f(CW\*(C`level\*(C'\fR parameter controls compression level.  The meaning and
default for this parameter depends on the compression program being used.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.13.15)
.SS "guestfs_compress_out_va"
.IX Subsection "guestfs_compress_out_va"
.Vb 6
\& int
\& guestfs_compress_out_va (guestfs_h *g,
\&                          const char *ctype,
\&                          const char *file,
\&                          const char *zfile,
\&                          va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_compress_out\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_compress_out_argv"
.IX Subsection "guestfs_compress_out_argv"
.Vb 6
\& int
\& guestfs_compress_out_argv (guestfs_h *g,
\&                            const char *ctype,
\&                            const char *file,
\&                            const char *zfile,
\&                            const struct guestfs_compress_out_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_compress_out\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_config"
.IX Subsection "guestfs_config"
.Vb 4
\& int
\& guestfs_config (guestfs_h *g,
\&                 const char *qemuparam,
\&                 const char *qemuvalue);
.Ve
.PP
This can be used to add arbitrary qemu command line parameters of the form
\&\fI\-param value\fR.  Actually it's not quite arbitrary \- we prevent you from
setting some parameters which would interfere with parameters that we use.
.PP
The first character of \f(CW\*(C`param\*(C'\fR string must be a \f(CW\*(C`\-\*(C'\fR (dash).
.PP
\&\f(CW\*(C`value\*(C'\fR can be \s-1NULL\s0.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_copy_device_to_device"
.IX Subsection "guestfs_copy_device_to_device"
.Vb 5
\& int
\& guestfs_copy_device_to_device (guestfs_h *g,
\&                                const char *src,
\&                                const char *dest,
\&                                ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 3
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, int64_t size,
.Ve
.PP
The four calls \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR,
\&\f(CW\*(C`guestfs_copy_device_to_file\*(C'\fR, \f(CW\*(C`guestfs_copy_file_to_device\*(C'\fR, and
\&\f(CW\*(C`guestfs_copy_file_to_file\*(C'\fR let you copy from a source (device|file) to a
destination (device|file).
.PP
Partial copies can be made since you can specify optionally the source
offset, destination offset and size to copy.  These values are all specified
in bytes.  If not given, the offsets both default to zero, and the size
defaults to copying as much as possible until we hit the end of the source.
.PP
The source and destination may be the same object.  However overlapping
regions may not be copied correctly.
.PP
If the destination is a file, it is created if required.  If the destination
file is not large enough, it is extended.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.13.25)
.SS "guestfs_copy_device_to_device_va"
.IX Subsection "guestfs_copy_device_to_device_va"
.Vb 5
\& int
\& guestfs_copy_device_to_device_va (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_copy_device_to_device\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_device_to_device_argv"
.IX Subsection "guestfs_copy_device_to_device_argv"
.Vb 5
\& int
\& guestfs_copy_device_to_device_argv (guestfs_h *g,
\&                                     const char *src,
\&                                     const char *dest,
\&                                     const struct guestfs_copy_device_to_device_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_copy_device_to_device\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_device_to_file"
.IX Subsection "guestfs_copy_device_to_file"
.Vb 5
\& int
\& guestfs_copy_device_to_file (guestfs_h *g,
\&                              const char *src,
\&                              const char *dest,
\&                              ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 3
\& GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_DEVICE_TO_FILE_SIZE, int64_t size,
.Ve
.PP
See \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR for a general overview of this call.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.13.25)
.SS "guestfs_copy_device_to_file_va"
.IX Subsection "guestfs_copy_device_to_file_va"
.Vb 5
\& int
\& guestfs_copy_device_to_file_va (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_copy_device_to_file\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_device_to_file_argv"
.IX Subsection "guestfs_copy_device_to_file_argv"
.Vb 5
\& int
\& guestfs_copy_device_to_file_argv (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   const struct guestfs_copy_device_to_file_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_copy_device_to_file\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_file_to_device"
.IX Subsection "guestfs_copy_file_to_device"
.Vb 5
\& int
\& guestfs_copy_file_to_device (guestfs_h *g,
\&                              const char *src,
\&                              const char *dest,
\&                              ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 3
\& GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_FILE_TO_DEVICE_SIZE, int64_t size,
.Ve
.PP
See \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR for a general overview of this call.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.13.25)
.SS "guestfs_copy_file_to_device_va"
.IX Subsection "guestfs_copy_file_to_device_va"
.Vb 5
\& int
\& guestfs_copy_file_to_device_va (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_copy_file_to_device\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_file_to_device_argv"
.IX Subsection "guestfs_copy_file_to_device_argv"
.Vb 5
\& int
\& guestfs_copy_file_to_device_argv (guestfs_h *g,
\&                                   const char *src,
\&                                   const char *dest,
\&                                   const struct guestfs_copy_file_to_device_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_copy_file_to_device\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_file_to_file"
.IX Subsection "guestfs_copy_file_to_file"
.Vb 5
\& int
\& guestfs_copy_file_to_file (guestfs_h *g,
\&                            const char *src,
\&                            const char *dest,
\&                            ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 3
\& GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET, int64_t srcoffset,
\& GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET, int64_t destoffset,
\& GUESTFS_COPY_FILE_TO_FILE_SIZE, int64_t size,
.Ve
.PP
See \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR for a general overview of this call.
.PP
This is \fBnot\fR the function you want for copying files.  This is for copying
blocks within existing files.  See \f(CW\*(C`guestfs_cp\*(C'\fR, \f(CW\*(C`guestfs_cp_a\*(C'\fR and
\&\f(CW\*(C`guestfs_mv\*(C'\fR for general file copying and moving functions.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.13.25)
.SS "guestfs_copy_file_to_file_va"
.IX Subsection "guestfs_copy_file_to_file_va"
.Vb 5
\& int
\& guestfs_copy_file_to_file_va (guestfs_h *g,
\&                               const char *src,
\&                               const char *dest,
\&                               va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_copy_file_to_file\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_file_to_file_argv"
.IX Subsection "guestfs_copy_file_to_file_argv"
.Vb 5
\& int
\& guestfs_copy_file_to_file_argv (guestfs_h *g,
\&                                 const char *src,
\&                                 const char *dest,
\&                                 const struct guestfs_copy_file_to_file_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_copy_file_to_file\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_copy_size"
.IX Subsection "guestfs_copy_size"
.Vb 5
\& int
\& guestfs_copy_size (guestfs_h *g,
\&                    const char *src,
\&                    const char *dest,
\&                    int64_t size);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_copy_device_to_device\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command copies exactly \f(CW\*(C`size\*(C'\fR bytes from one source device or file
\&\f(CW\*(C`src\*(C'\fR to another destination device or file \f(CW\*(C`dest\*(C'\fR.
.PP
Note this will fail if the source is too short or if the destination is not
large enough.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.87)
.SS "guestfs_cp"
.IX Subsection "guestfs_cp"
.Vb 4
\& int
\& guestfs_cp (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
This copies a file from \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR where \f(CW\*(C`dest\*(C'\fR is either a
destination filename or destination directory.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.18)
.SS "guestfs_cp_a"
.IX Subsection "guestfs_cp_a"
.Vb 4
\& int
\& guestfs_cp_a (guestfs_h *g,
\&               const char *src,
\&               const char *dest);
.Ve
.PP
This copies a file or directory from \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR recursively using the
\&\f(CW\*(C`cp \-a\*(C'\fR command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.18)
.SS "guestfs_dd"
.IX Subsection "guestfs_dd"
.Vb 4
\& int
\& guestfs_dd (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_copy_device_to_device\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command copies from one source device or file \f(CW\*(C`src\*(C'\fR to another
destination device or file \f(CW\*(C`dest\*(C'\fR.  Normally you would use this to copy to
or from a device or partition, for example to duplicate a filesystem.
.PP
If the destination is a device, it must be as large or larger than the
source file or device, otherwise the copy will fail.  This command cannot do
partial copies (see \f(CW\*(C`guestfs_copy_device_to_device\*(C'\fR).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.80)
.SS "guestfs_df"
.IX Subsection "guestfs_df"
.Vb 2
\& char *
\& guestfs_df (guestfs_h *g);
.Ve
.PP
This command runs the \f(CW\*(C`df\*(C'\fR command to report disk space used.
.PP
This command is mostly useful for interactive sessions.  It is \fInot\fR
intended that you try to parse the output string.  Use \f(CW\*(C`guestfs_statvfs\*(C'\fR
from programs.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.54)
.SS "guestfs_df_h"
.IX Subsection "guestfs_df_h"
.Vb 2
\& char *
\& guestfs_df_h (guestfs_h *g);
.Ve
.PP
This command runs the \f(CW\*(C`df \-h\*(C'\fR command to report disk space used in
human-readable format.
.PP
This command is mostly useful for interactive sessions.  It is \fInot\fR
intended that you try to parse the output string.  Use \f(CW\*(C`guestfs_statvfs\*(C'\fR
from programs.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.54)
.SS "guestfs_dmesg"
.IX Subsection "guestfs_dmesg"
.Vb 2
\& char *
\& guestfs_dmesg (guestfs_h *g);
.Ve
.PP
This returns the kernel messages (\f(CW\*(C`dmesg\*(C'\fR output) from the guest kernel.
This is sometimes useful for extended debugging of problems.
.PP
Another way to get the same information is to enable verbose messages with
\&\f(CW\*(C`guestfs_set_verbose\*(C'\fR or by setting the environment variable
\&\f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR before running the program.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.18)
.SS "guestfs_download"
.IX Subsection "guestfs_download"
.Vb 4
\& int
\& guestfs_download (guestfs_h *g,
\&                   const char *remotefilename,
\&                   const char *filename);
.Ve
.PP
Download file \f(CW\*(C`remotefilename\*(C'\fR and save it as \f(CW\*(C`filename\*(C'\fR on the local
machine.
.PP
\&\f(CW\*(C`filename\*(C'\fR can also be a named pipe.
.PP
See also \f(CW\*(C`guestfs_upload\*(C'\fR, \f(CW\*(C`guestfs_cat\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.2)
.SS "guestfs_download_offset"
.IX Subsection "guestfs_download_offset"
.Vb 6
\& int
\& guestfs_download_offset (guestfs_h *g,
\&                          const char *remotefilename,
\&                          const char *filename,
\&                          int64_t offset,
\&                          int64_t size);
.Ve
.PP
Download file \f(CW\*(C`remotefilename\*(C'\fR and save it as \f(CW\*(C`filename\*(C'\fR on the local
machine.
.PP
\&\f(CW\*(C`remotefilename\*(C'\fR is read for \f(CW\*(C`size\*(C'\fR bytes starting at \f(CW\*(C`offset\*(C'\fR (this
region must be within the file or device).
.PP
Note that there is no limit on the amount of data that can be downloaded
with this call, unlike with \f(CW\*(C`guestfs_pread\*(C'\fR, and this call always reads the
full amount unless an error occurs.
.PP
See also \f(CW\*(C`guestfs_download\*(C'\fR, \f(CW\*(C`guestfs_pread\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.5.17)
.SS "guestfs_drop_caches"
.IX Subsection "guestfs_drop_caches"
.Vb 3
\& int
\& guestfs_drop_caches (guestfs_h *g,
\&                      int whattodrop);
.Ve
.PP
This instructs the guest kernel to drop its page cache, and/or dentries and
inode caches.  The parameter \f(CW\*(C`whattodrop\*(C'\fR tells the kernel what precisely
to drop, see http://linux\-mm.org/Drop_Caches <http://linux-mm.org/Drop_Caches>
.PP
Setting \f(CW\*(C`whattodrop\*(C'\fR to 3 should drop everything.
.PP
This automatically calls \fIsync\fR\|(2) before the operation, so that the
maximum guest memory is freed.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.18)
.SS "guestfs_du"
.IX Subsection "guestfs_du"
.Vb 3
\& int64_t
\& guestfs_du (guestfs_h *g,
\&             const char *path);
.Ve
.PP
This command runs the \f(CW\*(C`du \-s\*(C'\fR command to estimate file space usage for
\&\f(CW\*(C`path\*(C'\fR.
.PP
\&\f(CW\*(C`path\*(C'\fR can be a file or a directory.  If \f(CW\*(C`path\*(C'\fR is a directory then the
estimate includes the contents of the directory and all subdirectories
(recursively).
.PP
The result is the estimated size in \fIkilobytes\fR (ie. units of 1024 bytes).
.PP
On error this function returns \-1.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.54)
.SS "guestfs_e2fsck"
.IX Subsection "guestfs_e2fsck"
.Vb 4
\& int
\& guestfs_e2fsck (guestfs_h *g,
\&                 const char *device,
\&                 ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 2
\& GUESTFS_E2FSCK_CORRECT, int correct,
\& GUESTFS_E2FSCK_FORCEALL, int forceall,
.Ve
.PP
This runs the ext2/ext3 filesystem checker on \f(CW\*(C`device\*(C'\fR.  It can take the
following optional arguments:
.ie n .IP """correct""" 4
.el .IP "\f(CWcorrect\fR" 4
.IX Item "correct"
Automatically repair the file system. This option will cause e2fsck to
automatically fix any filesystem problems that can be safely fixed without
human intervention.
.Sp
This option may not be specified at the same time as the \f(CW\*(C`forceall\*(C'\fR option.
.ie n .IP """forceall""" 4
.el .IP "\f(CWforceall\fR" 4
.IX Item "forceall"
Assume an answer of 'yes' to all questions; allows e2fsck to be used
non-interactively.
.Sp
This option may not be specified at the same time as the \f(CW\*(C`correct\*(C'\fR option.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.15.17)
.SS "guestfs_e2fsck_va"
.IX Subsection "guestfs_e2fsck_va"
.Vb 4
\& int
\& guestfs_e2fsck_va (guestfs_h *g,
\&                    const char *device,
\&                    va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_e2fsck\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_e2fsck_argv"
.IX Subsection "guestfs_e2fsck_argv"
.Vb 4
\& int
\& guestfs_e2fsck_argv (guestfs_h *g,
\&                      const char *device,
\&                      const struct guestfs_e2fsck_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_e2fsck\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_e2fsck_f"
.IX Subsection "guestfs_e2fsck_f"
.Vb 3
\& int
\& guestfs_e2fsck_f (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This runs \f(CW\*(C`e2fsck \-p \-f device\*(C'\fR, ie. runs the ext2/ext3 filesystem checker
on \f(CW\*(C`device\*(C'\fR, noninteractively (\fI\-p\fR), even if the filesystem appears to be
clean (\fI\-f\fR).
.PP
This command is only needed because of \f(CW\*(C`guestfs_resize2fs\*(C'\fR (q.v.).
Normally you should use \f(CW\*(C`guestfs_fsck\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.29)
.SS "guestfs_echo_daemon"
.IX Subsection "guestfs_echo_daemon"
.Vb 3
\& char *
\& guestfs_echo_daemon (guestfs_h *g,
\&                      char *const *words);
.Ve
.PP
This command concatenates the list of \f(CW\*(C`words\*(C'\fR passed with single spaces
between them and returns the resulting string.
.PP
You can use this command to test the connection through to the daemon.
.PP
See also \f(CW\*(C`guestfs_ping_daemon\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.69)
.SS "guestfs_egrep"
.IX Subsection "guestfs_egrep"
.Vb 4
\& char **
\& guestfs_egrep (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`egrep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_egrepi"
.IX Subsection "guestfs_egrepi"
.Vb 4
\& char **
\& guestfs_egrepi (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`egrep \-i\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_equal"
.IX Subsection "guestfs_equal"
.Vb 4
\& int
\& guestfs_equal (guestfs_h *g,
\&                const char *file1,
\&                const char *file2);
.Ve
.PP
This compares the two files \f(CW\*(C`file1\*(C'\fR and \f(CW\*(C`file2\*(C'\fR and returns true if their
content is exactly equal, or false otherwise.
.PP
The external \fIcmp\fR\|(1) program is used for the comparison.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.18)
.SS "guestfs_exists"
.IX Subsection "guestfs_exists"
.Vb 3
\& int
\& guestfs_exists (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a file, directory (or anything)
with the given \f(CW\*(C`path\*(C'\fR name.
.PP
See also \f(CW\*(C`guestfs_is_file\*(C'\fR, \f(CW\*(C`guestfs_is_dir\*(C'\fR, \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_fallocate"
.IX Subsection "guestfs_fallocate"
.Vb 4
\& int
\& guestfs_fallocate (guestfs_h *g,
\&                    const char *path,
\&                    int len);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_fallocate64\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command preallocates a file (containing zero bytes) named \f(CW\*(C`path\*(C'\fR of
size \f(CW\*(C`len\*(C'\fR bytes.  If the file exists already, it is overwritten.
.PP
Do not confuse this with the guestfish-specific \f(CW\*(C`alloc\*(C'\fR command which
allocates a file in the host and attaches it as a device.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_fallocate64"
.IX Subsection "guestfs_fallocate64"
.Vb 4
\& int
\& guestfs_fallocate64 (guestfs_h *g,
\&                      const char *path,
\&                      int64_t len);
.Ve
.PP
This command preallocates a file (containing zero bytes) named \f(CW\*(C`path\*(C'\fR of
size \f(CW\*(C`len\*(C'\fR bytes.  If the file exists already, it is overwritten.
.PP
Note that this call allocates disk blocks for the file.  To create a sparse
file use \f(CW\*(C`guestfs_truncate_size\*(C'\fR instead.
.PP
The deprecated call \f(CW\*(C`guestfs_fallocate\*(C'\fR does the same, but owing to an
oversight it only allowed 30 bit lengths to be specified, effectively
limiting the maximum size of files created through that call to 1GB.
.PP
Do not confuse this with the guestfish-specific \f(CW\*(C`alloc\*(C'\fR and \f(CW\*(C`sparse\*(C'\fR
commands which create a file in the host and attach it as a device.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.17)
.SS "guestfs_fgrep"
.IX Subsection "guestfs_fgrep"
.Vb 4
\& char **
\& guestfs_fgrep (guestfs_h *g,
\&                const char *pattern,
\&                const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`fgrep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_fgrepi"
.IX Subsection "guestfs_fgrepi"
.Vb 4
\& char **
\& guestfs_fgrepi (guestfs_h *g,
\&                 const char *pattern,
\&                 const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`fgrep \-i\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_file"
.IX Subsection "guestfs_file"
.Vb 3
\& char *
\& guestfs_file (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This call uses the standard \fIfile\fR\|(1) command to determine the type or
contents of the file.
.PP
This call will also transparently look inside various types of compressed
file.
.PP
The exact command which runs is \f(CW\*(C`file \-zb path\*(C'\fR.  Note in particular that
the filename is not prepended to the output (the \fI\-b\fR option).
.PP
The output depends on the output of the underlying \fIfile\fR\|(1) command and it
can change in future in ways beyond our control.  In other words, the output
is not guaranteed by the \s-1ABI\s0.
.PP
See also: \fIfile\fR\|(1), \f(CW\*(C`guestfs_vfs_type\*(C'\fR, \f(CW\*(C`guestfs_lstat\*(C'\fR,
\&\f(CW\*(C`guestfs_is_file\*(C'\fR, \f(CW\*(C`guestfs_is_blockdev\*(C'\fR (etc), \f(CW\*(C`guestfs_is_zero\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 0.9.1)
.SS "guestfs_file_architecture"
.IX Subsection "guestfs_file_architecture"
.Vb 3
\& char *
\& guestfs_file_architecture (guestfs_h *g,
\&                            const char *filename);
.Ve
.PP
This detects the architecture of the binary \f(CW\*(C`filename\*(C'\fR, and returns it if
known.
.PP
Currently defined architectures are:
.ie n .IP """i386""" 4
.el .IP "``i386''" 4
.IX Item "i386"
This string is returned for all 32 bit i386, i486, i586, i686 binaries
irrespective of the precise processor requirements of the binary.
.ie n .IP """x86_64""" 4
.el .IP "``x86_64''" 4
.IX Item "x86_64"
64 bit x86\-64.
.ie n .IP """sparc""" 4
.el .IP "``sparc''" 4
.IX Item "sparc"
32 bit \s-1SPARC\s0.
.ie n .IP """sparc64""" 4
.el .IP "``sparc64''" 4
.IX Item "sparc64"
64 bit \s-1SPARC\s0 V9 and above.
.ie n .IP """ia64""" 4
.el .IP "``ia64''" 4
.IX Item "ia64"
Intel Itanium.
.ie n .IP """ppc""" 4
.el .IP "``ppc''" 4
.IX Item "ppc"
32 bit Power \s-1PC\s0.
.ie n .IP """ppc64""" 4
.el .IP "``ppc64''" 4
.IX Item "ppc64"
64 bit Power \s-1PC\s0.
.PP
Libguestfs may return other architecture strings in future.
.PP
The function works on at least the following types of files:
.IP "\(bu" 4
many types of Un*x and Linux binary
.IP "\(bu" 4
many types of Un*x and Linux shared library
.IP "\(bu" 4
Windows Win32 and Win64 binaries
.IP "\(bu" 4
Windows Win32 and Win64 DLLs
.Sp
Win32 binaries and DLLs return \f(CW\*(C`i386\*(C'\fR.
.Sp
Win64 binaries and DLLs return \f(CW\*(C`x86_64\*(C'\fR.
.IP "\(bu" 4
Linux kernel modules
.IP "\(bu" 4
Linux new-style initrd images
.IP "\(bu" 4
some non\-x86 Linux vmlinuz kernels
.PP
What it can't do currently:
.IP "\(bu" 4
static libraries (libfoo.a)
.IP "\(bu" 4
Linux old-style initrd as compressed ext2 filesystem (\s-1RHEL\s0 3)
.IP "\(bu" 4
x86 Linux vmlinuz kernels
.Sp
x86 vmlinuz images (bzImage format) consist of a mix of 16\-, 32\- and
compressed code, and are horribly hard to unpack.  If you want to find the
architecture of a kernel, use the architecture of the associated initrd or
kernel module(s) instead.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_filesize"
.IX Subsection "guestfs_filesize"
.Vb 3
\& int64_t
\& guestfs_filesize (guestfs_h *g,
\&                   const char *file);
.Ve
.PP
This command returns the size of \f(CW\*(C`file\*(C'\fR in bytes.
.PP
To get other stats about a file, use \f(CW\*(C`guestfs_stat\*(C'\fR, \f(CW\*(C`guestfs_lstat\*(C'\fR,
\&\f(CW\*(C`guestfs_is_dir\*(C'\fR, \f(CW\*(C`guestfs_is_file\*(C'\fR etc.  To get the size of block
devices, use \f(CW\*(C`guestfs_blockdev_getsize64\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.82)
.SS "guestfs_fill"
.IX Subsection "guestfs_fill"
.Vb 5
\& int
\& guestfs_fill (guestfs_h *g,
\&               int c,
\&               int len,
\&               const char *path);
.Ve
.PP
This command creates a new file called \f(CW\*(C`path\*(C'\fR.  The initial content of the
file is \f(CW\*(C`len\*(C'\fR octets of \f(CW\*(C`c\*(C'\fR, where \f(CW\*(C`c\*(C'\fR must be a number in the range
\&\f(CW\*(C`[0..255]\*(C'\fR.
.PP
To fill a file with zero bytes (sparsely), it is much more efficient to use
\&\f(CW\*(C`guestfs_truncate_size\*(C'\fR.  To create a file with a pattern of repeating
bytes use \f(CW\*(C`guestfs_fill_pattern\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.79)
.SS "guestfs_fill_pattern"
.IX Subsection "guestfs_fill_pattern"
.Vb 5
\& int
\& guestfs_fill_pattern (guestfs_h *g,
\&                       const char *pattern,
\&                       int len,
\&                       const char *path);
.Ve
.PP
This function is like \f(CW\*(C`guestfs_fill\*(C'\fR except that it creates a new file of
length \f(CW\*(C`len\*(C'\fR containing the repeating pattern of bytes in \f(CW\*(C`pattern\*(C'\fR.  The
pattern is truncated if necessary to ensure the length of the file is
exactly \f(CW\*(C`len\*(C'\fR bytes.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.3.12)
.SS "guestfs_find"
.IX Subsection "guestfs_find"
.Vb 3
\& char **
\& guestfs_find (guestfs_h *g,
\&               const char *directory);
.Ve
.PP
This command lists out all files and directories, recursively, starting at
\&\f(CW\*(C`directory\*(C'\fR.  It is essentially equivalent to running the shell command
\&\f(CW\*(C`find directory \-print\*(C'\fR but some post-processing happens on the output,
described below.
.PP
This returns a list of strings \fIwithout any prefix\fR.  Thus if the directory
structure was:
.PP
.Vb 3
\& /tmp/a
\& /tmp/b
\& /tmp/c/d
.Ve
.PP
then the returned list from \f(CW\*(C`guestfs_find\*(C'\fR \f(CW\*(C`/tmp\*(C'\fR would be 4 elements:
.PP
.Vb 4
\& a
\& b
\& c
\& c/d
.Ve
.PP
If \f(CW\*(C`directory\*(C'\fR is not a directory, then this command returns an error.
.PP
The returned list is sorted.
.PP
See also \f(CW\*(C`guestfs_find0\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.27)
.SS "guestfs_find0"
.IX Subsection "guestfs_find0"
.Vb 4
\& int
\& guestfs_find0 (guestfs_h *g,
\&                const char *directory,
\&                const char *files);
.Ve
.PP
This command lists out all files and directories, recursively, starting at
\&\f(CW\*(C`directory\*(C'\fR, placing the resulting list in the external file called
\&\f(CW\*(C`files\*(C'\fR.
.PP
This command works the same way as \f(CW\*(C`guestfs_find\*(C'\fR with the following
exceptions:
.IP "\(bu" 4
The resulting list is written to an external file.
.IP "\(bu" 4
Items (filenames) in the result are separated by \f(CW\*(C`\e0\*(C'\fR characters.  See
\&\fIfind\fR\|(1) option \fI\-print0\fR.
.IP "\(bu" 4
This command is not limited in the number of names that it can return.
.IP "\(bu" 4
The result list is not sorted.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.74)
.SS "guestfs_findfs_label"
.IX Subsection "guestfs_findfs_label"
.Vb 3
\& char *
\& guestfs_findfs_label (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
This command searches the filesystems and returns the one which has the
given label.  An error is returned if no such filesystem can be found.
.PP
To find the label of a filesystem, use \f(CW\*(C`guestfs_vfs_label\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_findfs_uuid"
.IX Subsection "guestfs_findfs_uuid"
.Vb 3
\& char *
\& guestfs_findfs_uuid (guestfs_h *g,
\&                      const char *uuid);
.Ve
.PP
This command searches the filesystems and returns the one which has the
given \s-1UUID\s0.  An error is returned if no such filesystem can be found.
.PP
To find the \s-1UUID\s0 of a filesystem, use \f(CW\*(C`guestfs_vfs_uuid\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_fsck"
.IX Subsection "guestfs_fsck"
.Vb 4
\& int
\& guestfs_fsck (guestfs_h *g,
\&               const char *fstype,
\&               const char *device);
.Ve
.PP
This runs the filesystem checker (fsck) on \f(CW\*(C`device\*(C'\fR which should have
filesystem type \f(CW\*(C`fstype\*(C'\fR.
.PP
The returned integer is the status.  See \fIfsck\fR\|(8) for the list of status
codes from \f(CW\*(C`fsck\*(C'\fR.
.PP
Notes:
.IP "\(bu" 4
Multiple status codes can be summed together.
.IP "\(bu" 4
A non-zero return code can mean \*(L"success\*(R", for example if errors have been
corrected on the filesystem.
.IP "\(bu" 4
Checking or repairing \s-1NTFS\s0 volumes is not supported (by linux-ntfs).
.PP
This command is entirely equivalent to running \f(CW\*(C`fsck \-a \-t fstype device\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.16)
.SS "guestfs_get_append"
.IX Subsection "guestfs_get_append"
.Vb 2
\& const char *
\& guestfs_get_append (guestfs_h *g);
.Ve
.PP
Return the additional kernel options which are added to the guest kernel
command line.
.PP
If \f(CW\*(C`NULL\*(C'\fR then no options are added.
.PP
This function returns a string which may be \s-1NULL\s0.  There is no way to return
an error from this function.  The string is owned by the guest handle and
must \fInot\fR be freed.
.PP
(Added in 1.0.26)
.SS "guestfs_get_attach_method"
.IX Subsection "guestfs_get_attach_method"
.Vb 2
\& char *
\& guestfs_get_attach_method (guestfs_h *g);
.Ve
.PP
Return the current attach method.  See \f(CW\*(C`guestfs_set_attach_method\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.9.8)
.SS "guestfs_get_autosync"
.IX Subsection "guestfs_get_autosync"
.Vb 2
\& int
\& guestfs_get_autosync (guestfs_h *g);
.Ve
.PP
Get the autosync flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_get_direct"
.IX Subsection "guestfs_get_direct"
.Vb 2
\& int
\& guestfs_get_direct (guestfs_h *g);
.Ve
.PP
Return the direct appliance mode flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.72)
.SS "guestfs_get_e2label"
.IX Subsection "guestfs_get_e2label"
.Vb 3
\& char *
\& guestfs_get_e2label (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_vfs_label\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This returns the ext2/3/4 filesystem label of the filesystem on \f(CW\*(C`device\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.15)
.SS "guestfs_get_e2uuid"
.IX Subsection "guestfs_get_e2uuid"
.Vb 3
\& char *
\& guestfs_get_e2uuid (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_vfs_uuid\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This returns the ext2/3/4 filesystem \s-1UUID\s0 of the filesystem on \f(CW\*(C`device\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.15)
.SS "guestfs_get_memsize"
.IX Subsection "guestfs_get_memsize"
.Vb 2
\& int
\& guestfs_get_memsize (guestfs_h *g);
.Ve
.PP
This gets the memory size in megabytes allocated to the qemu subprocess.
.PP
If \f(CW\*(C`guestfs_set_memsize\*(C'\fR was not called on this handle, and if
\&\f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR was not set, then this returns the compiled-in default
value for memsize.
.PP
For more information on the architecture of libguestfs, see \fIguestfs\fR\|(3).
.PP
On error this function returns \-1.
.PP
(Added in 1.0.55)
.SS "guestfs_get_network"
.IX Subsection "guestfs_get_network"
.Vb 2
\& int
\& guestfs_get_network (guestfs_h *g);
.Ve
.PP
This returns the enable network flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.4)
.SS "guestfs_get_path"
.IX Subsection "guestfs_get_path"
.Vb 2
\& const char *
\& guestfs_get_path (guestfs_h *g);
.Ve
.PP
Return the current search path.
.PP
This is always non-NULL.  If it wasn't set already, then this will return
the default path.
.PP
This function returns a string, or \s-1NULL\s0 on error.  The string is owned by
the guest handle and must \fInot\fR be freed.
.PP
(Added in 0.3)
.SS "guestfs_get_pgroup"
.IX Subsection "guestfs_get_pgroup"
.Vb 2
\& int
\& guestfs_get_pgroup (guestfs_h *g);
.Ve
.PP
This returns the process group flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.11.18)
.SS "guestfs_get_pid"
.IX Subsection "guestfs_get_pid"
.Vb 2
\& int
\& guestfs_get_pid (guestfs_h *g);
.Ve
.PP
Return the process \s-1ID\s0 of the qemu subprocess.  If there is no qemu
subprocess, then this will return an error.
.PP
This is an internal call used for debugging and testing.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.56)
.SS "guestfs_get_qemu"
.IX Subsection "guestfs_get_qemu"
.Vb 2
\& const char *
\& guestfs_get_qemu (guestfs_h *g);
.Ve
.PP
Return the current qemu binary.
.PP
This is always non-NULL.  If it wasn't set already, then this will return
the default qemu binary name.
.PP
This function returns a string, or \s-1NULL\s0 on error.  The string is owned by
the guest handle and must \fInot\fR be freed.
.PP
(Added in 1.0.6)
.SS "guestfs_get_recovery_proc"
.IX Subsection "guestfs_get_recovery_proc"
.Vb 2
\& int
\& guestfs_get_recovery_proc (guestfs_h *g);
.Ve
.PP
Return the recovery process enabled flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_get_selinux"
.IX Subsection "guestfs_get_selinux"
.Vb 2
\& int
\& guestfs_get_selinux (guestfs_h *g);
.Ve
.PP
This returns the current setting of the selinux flag which is passed to the
appliance at boot time.  See \f(CW\*(C`guestfs_set_selinux\*(C'\fR.
.PP
For more information on the architecture of libguestfs, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.67)
.SS "guestfs_get_smp"
.IX Subsection "guestfs_get_smp"
.Vb 2
\& int
\& guestfs_get_smp (guestfs_h *g);
.Ve
.PP
This returns the number of virtual CPUs assigned to the appliance.
.PP
On error this function returns \-1.
.PP
(Added in 1.13.15)
.SS "guestfs_get_state"
.IX Subsection "guestfs_get_state"
.Vb 2
\& int
\& guestfs_get_state (guestfs_h *g);
.Ve
.PP
This returns the current state as an opaque integer.  This is only useful
for printing debug and internal error messages.
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
On error this function returns \-1.
.PP
(Added in 1.0.2)
.SS "guestfs_get_trace"
.IX Subsection "guestfs_get_trace"
.Vb 2
\& int
\& guestfs_get_trace (guestfs_h *g);
.Ve
.PP
Return the command trace flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.69)
.SS "guestfs_get_umask"
.IX Subsection "guestfs_get_umask"
.Vb 2
\& int
\& guestfs_get_umask (guestfs_h *g);
.Ve
.PP
Return the current umask.  By default the umask is \f(CW022\fR unless it has been
set by calling \f(CW\*(C`guestfs_umask\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.3.4)
.SS "guestfs_get_verbose"
.IX Subsection "guestfs_get_verbose"
.Vb 2
\& int
\& guestfs_get_verbose (guestfs_h *g);
.Ve
.PP
This returns the verbose messages flag.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_getcon"
.IX Subsection "guestfs_getcon"
.Vb 2
\& char *
\& guestfs_getcon (guestfs_h *g);
.Ve
.PP
This gets the SELinux security context of the daemon.
.PP
See the documentation about \s-1SELINUX\s0 in \fIguestfs\fR\|(3), and \f(CW\*(C`guestfs_setcon\*(C'\fR
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.67)
.SS "guestfs_getxattr"
.IX Subsection "guestfs_getxattr"
.Vb 5
\& char *
\& guestfs_getxattr (guestfs_h *g,
\&                   const char *path,
\&                   const char *name,
\&                   size_t *size_r);
.Ve
.PP
Get a single extended attribute from file \f(CW\*(C`path\*(C'\fR named \f(CW\*(C`name\*(C'\fR.  This call
follows symlinks.  If you want to lookup an extended attribute for the
symlink itself, use \f(CW\*(C`guestfs_lgetxattr\*(C'\fR.
.PP
Normally it is better to get all extended attributes from a file in one go
by calling \f(CW\*(C`guestfs_getxattrs\*(C'\fR.  However some Linux filesystem
implementations are buggy and do not provide a way to list out attributes.
For these filesystems (notably ntfs\-3g)  you have to know the names of the
extended attributes you want in advance and call this function.
.PP
Extended attribute values are blobs of binary data.  If there is no extended
attribute named \f(CW\*(C`name\*(C'\fR, this returns an error.
.PP
See also: \f(CW\*(C`guestfs_getxattrs\*(C'\fR, \f(CW\*(C`guestfs_lgetxattr\*(C'\fR, \fIattr\fR\|(5).
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
(Added in 1.7.24)
.SS "guestfs_getxattrs"
.IX Subsection "guestfs_getxattrs"
.Vb 3
\& struct guestfs_xattr_list *
\& guestfs_getxattrs (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
This call lists the extended attributes of the file or directory \f(CW\*(C`path\*(C'\fR.
.PP
At the system call level, this is a combination of the \fIlistxattr\fR\|(2) and
\&\fIgetxattr\fR\|(2) calls.
.PP
See also: \f(CW\*(C`guestfs_lgetxattrs\*(C'\fR, \fIattr\fR\|(5).
.PP
This function returns a \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI after use\fR.
.PP
(Added in 1.0.59)
.SS "guestfs_glob_expand"
.IX Subsection "guestfs_glob_expand"
.Vb 3
\& char **
\& guestfs_glob_expand (guestfs_h *g,
\&                      const char *pattern);
.Ve
.PP
This command searches for all the pathnames matching \f(CW\*(C`pattern\*(C'\fR according to
the wildcard expansion rules used by the shell.
.PP
If no paths match, then this returns an empty list (note: not an error).
.PP
It is just a wrapper around the C \fIglob\fR\|(3) function with flags
\&\f(CW\*(C`GLOB_MARK|GLOB_BRACE\*(C'\fR.  See that manual page for more details.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.50)
.SS "guestfs_grep"
.IX Subsection "guestfs_grep"
.Vb 4
\& char **
\& guestfs_grep (guestfs_h *g,
\&               const char *regex,
\&               const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`grep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_grepi"
.IX Subsection "guestfs_grepi"
.Vb 4
\& char **
\& guestfs_grepi (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`grep \-i\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_grub_install"
.IX Subsection "guestfs_grub_install"
.Vb 4
\& int
\& guestfs_grub_install (guestfs_h *g,
\&                       const char *root,
\&                       const char *device);
.Ve
.PP
This command installs \s-1GRUB\s0 1 (the Grand Unified Bootloader) on \f(CW\*(C`device\*(C'\fR,
with the root directory being \f(CW\*(C`root\*(C'\fR.
.PP
Notes:
.IP "\(bu" 4
There is currently no way in the \s-1API\s0 to install grub2, which is used by most
modern Linux guests.  It is possible to run the grub2 command from the
guest, although see the caveats in \*(L"\s-1RUNNING\s0 \s-1COMMANDS\s0\*(R" in \fIguestfs\fR\|(3).
.IP "\(bu" 4
This uses \f(CW\*(C`grub\-install\*(C'\fR from the host.  Unfortunately grub is not always
compatible with itself, so this only works in rather narrow circumstances.
Careful testing with each guest version is advisable.
.IP "\(bu" 4
If grub-install reports the error \*(L"No suitable drive was found in the
generated device map.\*(R" it may be that you need to create a
\&\f(CW\*(C`/boot/grub/device.map\*(C'\fR file first that contains the mapping between grub
device names and Linux device names.  It is usually sufficient to create a
file containing:
.Sp
.Vb 1
\& (hd0) /dev/vda
.Ve
.Sp
replacing \f(CW\*(C`/dev/vda\*(C'\fR with the name of the installation device.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.17)
.SS "guestfs_head"
.IX Subsection "guestfs_head"
.Vb 3
\& char **
\& guestfs_head (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This command returns up to the first 10 lines of a file as a list of
strings.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.54)
.SS "guestfs_head_n"
.IX Subsection "guestfs_head_n"
.Vb 4
\& char **
\& guestfs_head_n (guestfs_h *g,
\&                 int nrlines,
\&                 const char *path);
.Ve
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is a positive number, this returns the first
\&\f(CW\*(C`nrlines\*(C'\fR lines of the file \f(CW\*(C`path\*(C'\fR.
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is a negative number, this returns lines from
the file \f(CW\*(C`path\*(C'\fR, excluding the last \f(CW\*(C`nrlines\*(C'\fR lines.
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is zero, this returns an empty list.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.54)
.SS "guestfs_hexdump"
.IX Subsection "guestfs_hexdump"
.Vb 3
\& char *
\& guestfs_hexdump (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This runs \f(CW\*(C`hexdump \-C\*(C'\fR on the given \f(CW\*(C`path\*(C'\fR.  The result is the
human-readable, canonical hex dump of the file.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.22)
.SS "guestfs_initrd_cat"
.IX Subsection "guestfs_initrd_cat"
.Vb 5
\& char *
\& guestfs_initrd_cat (guestfs_h *g,
\&                     const char *initrdpath,
\&                     const char *filename,
\&                     size_t *size_r);
.Ve
.PP
This command unpacks the file \f(CW\*(C`filename\*(C'\fR from the initrd file called
\&\f(CW\*(C`initrdpath\*(C'\fR.  The filename must be given \fIwithout\fR the initial \f(CW\*(C`/\*(C'\fR
character.
.PP
For example, in guestfish you could use the following command to examine the
boot script (usually called \f(CW\*(C`/init\*(C'\fR)  contained in a Linux initrd or
initramfs image:
.PP
.Vb 1
\& initrd\-cat /boot/initrd\-<version>.img init
.Ve
.PP
See also \f(CW\*(C`guestfs_initrd_list\*(C'\fR.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.84)
.SS "guestfs_initrd_list"
.IX Subsection "guestfs_initrd_list"
.Vb 3
\& char **
\& guestfs_initrd_list (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
This command lists out files contained in an initrd.
.PP
The files are listed without any initial \f(CW\*(C`/\*(C'\fR character.  The files are
listed in the order they appear (not necessarily alphabetical).  Directory
names are listed as separate items.
.PP
Old Linux kernels (2.4 and earlier) used a compressed ext2 filesystem as
initrd.  We \fIonly\fR support the newer initramfs format (compressed cpio
files).
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.54)
.SS "guestfs_inotify_add_watch"
.IX Subsection "guestfs_inotify_add_watch"
.Vb 4
\& int64_t
\& guestfs_inotify_add_watch (guestfs_h *g,
\&                            const char *path,
\&                            int mask);
.Ve
.PP
Watch \f(CW\*(C`path\*(C'\fR for the events listed in \f(CW\*(C`mask\*(C'\fR.
.PP
Note that if \f(CW\*(C`path\*(C'\fR is a directory then events within that directory are
watched, but this does \fInot\fR happen recursively (in subdirectories).
.PP
Note for non-C or non-Linux callers: the inotify events are defined by the
Linux kernel \s-1ABI\s0 and are listed in \f(CW\*(C`/usr/include/sys/inotify.h\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.66)
.SS "guestfs_inotify_close"
.IX Subsection "guestfs_inotify_close"
.Vb 2
\& int
\& guestfs_inotify_close (guestfs_h *g);
.Ve
.PP
This closes the inotify handle which was previously opened by inotify_init.
It removes all watches, throws away any pending events, and deallocates all
resources.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_inotify_files"
.IX Subsection "guestfs_inotify_files"
.Vb 2
\& char **
\& guestfs_inotify_files (guestfs_h *g);
.Ve
.PP
This function is a helpful wrapper around \f(CW\*(C`guestfs_inotify_read\*(C'\fR which just
returns a list of pathnames of objects that were touched.  The returned
pathnames are sorted and deduplicated.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.66)
.SS "guestfs_inotify_init"
.IX Subsection "guestfs_inotify_init"
.Vb 3
\& int
\& guestfs_inotify_init (guestfs_h *g,
\&                       int maxevents);
.Ve
.PP
This command creates a new inotify handle.  The inotify subsystem can be
used to notify events which happen to objects in the guest filesystem.
.PP
\&\f(CW\*(C`maxevents\*(C'\fR is the maximum number of events which will be queued up between
calls to \f(CW\*(C`guestfs_inotify_read\*(C'\fR or \f(CW\*(C`guestfs_inotify_files\*(C'\fR.  If this is
passed as \f(CW0\fR, then the kernel (or previously set)  default is used.  For
Linux 2.6.29 the default was 16384 events.  Beyond this limit, the kernel
throws away events, but records the fact that it threw them away by setting
a flag \f(CW\*(C`IN_Q_OVERFLOW\*(C'\fR in the returned structure list (see
\&\f(CW\*(C`guestfs_inotify_read\*(C'\fR).
.PP
Before any events are generated, you have to add some watches to the
internal watch list.  See: \f(CW\*(C`guestfs_inotify_add_watch\*(C'\fR,
\&\f(CW\*(C`guestfs_inotify_rm_watch\*(C'\fR and \f(CW\*(C`guestfs_inotify_watch_all\*(C'\fR.
.PP
Queued up events should be read periodically by calling
\&\f(CW\*(C`guestfs_inotify_read\*(C'\fR (or \f(CW\*(C`guestfs_inotify_files\*(C'\fR which is just a helpful
wrapper around \f(CW\*(C`guestfs_inotify_read\*(C'\fR).  If you don't read the events out
often enough then you risk the internal queue overflowing.
.PP
The handle should be closed after use by calling \f(CW\*(C`guestfs_inotify_close\*(C'\fR.
This also removes any watches automatically.
.PP
See also \fIinotify\fR\|(7) for an overview of the inotify interface as exposed
by the Linux kernel, which is roughly what we expose via libguestfs.  Note
that there is one global inotify handle per libguestfs instance.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_inotify_read"
.IX Subsection "guestfs_inotify_read"
.Vb 2
\& struct guestfs_inotify_event_list *
\& guestfs_inotify_read (guestfs_h *g);
.Ve
.PP
Return the complete queue of events that have happened since the previous
read call.
.PP
If no events have happened, this returns an empty list.
.PP
\&\fINote\fR: In order to make sure that all events have been read, you must call
this function repeatedly until it returns an empty list.  The reason is that
the call will read events up to the maximum appliance-to-host message size
and leave remaining events in the queue.
.PP
This function returns a \f(CW\*(C`struct guestfs_inotify_event_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call
\&\f(CI\*(C`guestfs_free_inotify_event_list\*(C'\fI after use\fR.
.PP
(Added in 1.0.66)
.SS "guestfs_inotify_rm_watch"
.IX Subsection "guestfs_inotify_rm_watch"
.Vb 3
\& int
\& guestfs_inotify_rm_watch (guestfs_h *g,
\&                           int wd);
.Ve
.PP
Remove a previously defined inotify watch.  See
\&\f(CW\*(C`guestfs_inotify_add_watch\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_inspect_get_arch"
.IX Subsection "guestfs_inspect_get_arch"
.Vb 3
\& char *
\& guestfs_inspect_get_arch (guestfs_h *g,
\&                           const char *root);
.Ve
.PP
This returns the architecture of the inspected operating system.  The
possible return values are listed under \f(CW\*(C`guestfs_file_architecture\*(C'\fR.
.PP
If the architecture could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR is
returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_distro"
.IX Subsection "guestfs_inspect_get_distro"
.Vb 3
\& char *
\& guestfs_inspect_get_distro (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
This returns the distro (distribution) of the inspected operating system.
.PP
Currently defined distros are:
.ie n .IP """archlinux""" 4
.el .IP "``archlinux''" 4
.IX Item "archlinux"
Arch Linux.
.ie n .IP """centos""" 4
.el .IP "``centos''" 4
.IX Item "centos"
CentOS.
.ie n .IP """debian""" 4
.el .IP "``debian''" 4
.IX Item "debian"
Debian.
.ie n .IP """fedora""" 4
.el .IP "``fedora''" 4
.IX Item "fedora"
Fedora.
.ie n .IP """gentoo""" 4
.el .IP "``gentoo''" 4
.IX Item "gentoo"
Gentoo.
.ie n .IP """linuxmint""" 4
.el .IP "``linuxmint''" 4
.IX Item "linuxmint"
Linux Mint.
.ie n .IP """mageia""" 4
.el .IP "``mageia''" 4
.IX Item "mageia"
Mageia.
.ie n .IP """mandriva""" 4
.el .IP "``mandriva''" 4
.IX Item "mandriva"
Mandriva.
.ie n .IP """meego""" 4
.el .IP "``meego''" 4
.IX Item "meego"
MeeGo.
.ie n .IP """opensuse""" 4
.el .IP "``opensuse''" 4
.IX Item "opensuse"
OpenSUSE.
.ie n .IP """pardus""" 4
.el .IP "``pardus''" 4
.IX Item "pardus"
Pardus.
.ie n .IP """redhat-based""" 4
.el .IP "``redhat-based''" 4
.IX Item "redhat-based"
Some Red Hat-derived distro.
.ie n .IP """rhel""" 4
.el .IP "``rhel''" 4
.IX Item "rhel"
Red Hat Enterprise Linux.
.ie n .IP """scientificlinux""" 4
.el .IP "``scientificlinux''" 4
.IX Item "scientificlinux"
Scientific Linux.
.ie n .IP """slackware""" 4
.el .IP "``slackware''" 4
.IX Item "slackware"
Slackware.
.ie n .IP """ttylinux""" 4
.el .IP "``ttylinux''" 4
.IX Item "ttylinux"
ttylinux.
.ie n .IP """ubuntu""" 4
.el .IP "``ubuntu''" 4
.IX Item "ubuntu"
Ubuntu.
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
The distro could not be determined.
.ie n .IP """windows""" 4
.el .IP "``windows''" 4
.IX Item "windows"
Windows does not have distributions.  This string is returned if the \s-1OS\s0 type
is Windows.
.PP
Future versions of libguestfs may return other strings here.  The caller
should be prepared to handle any string.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_drive_mappings"
.IX Subsection "guestfs_inspect_get_drive_mappings"
.Vb 3
\& char **
\& guestfs_inspect_get_drive_mappings (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
This call is useful for Windows which uses a primitive system of assigning
drive letters (like \*(L"C:\*(R") to partitions.  This inspection \s-1API\s0 examines the
Windows Registry to find out how disks/partitions are mapped to drive
letters, and returns a hash table as in the example below:
.PP
.Vb 3
\& C      =>     /dev/vda2
\& E      =>     /dev/vdb1
\& F      =>     /dev/vdc1
.Ve
.PP
Note that keys are drive letters.  For Windows, the key is case insensitive
and just contains the drive letter, without the customary colon separator
character.
.PP
In future we may support other operating systems that also used drive
letters, but the keys for those might not be case insensitive and might be
longer than 1 character.  For example in \s-1OS\-9\s0, hard drives were named \f(CW\*(C`h0\*(C'\fR,
\&\f(CW\*(C`h1\*(C'\fR etc.
.PP
For Windows guests, currently only hard drive mappings are returned.
Removable disks (eg. DVD-ROMs) are ignored.
.PP
For guests that do not use drive mappings, or if the drive mappings could
not be determined, this returns an empty hash table.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.  See also
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, \f(CW\*(C`guestfs_inspect_get_filesystems\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.9.17)
.SS "guestfs_inspect_get_filesystems"
.IX Subsection "guestfs_inspect_get_filesystems"
.Vb 3
\& char **
\& guestfs_inspect_get_filesystems (guestfs_h *g,
\&                                  const char *root);
.Ve
.PP
This returns a list of all the filesystems that we think are associated with
this operating system.  This includes the root filesystem, other ordinary
filesystems, and non-mounted devices like swap partitions.
.PP
In the case of a multi-boot virtual machine, it is possible for a filesystem
to be shared between operating systems.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.  See also
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_format"
.IX Subsection "guestfs_inspect_get_format"
.Vb 3
\& char *
\& guestfs_inspect_get_format (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
This returns the format of the inspected operating system.  You can use it
to detect install images, live CDs and similar.
.PP
Currently defined formats are:
.ie n .IP """installed""" 4
.el .IP "``installed''" 4
.IX Item "installed"
This is an installed operating system.
.ie n .IP """installer""" 4
.el .IP "``installer''" 4
.IX Item "installer"
The disk image being inspected is not an installed operating system, but a
\&\fIbootable\fR install disk, live \s-1CD\s0, or similar.
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
The format of this disk image is not known.
.PP
Future versions of libguestfs may return other strings here.  The caller
should be prepared to handle any string.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.9.4)
.SS "guestfs_inspect_get_hostname"
.IX Subsection "guestfs_inspect_get_hostname"
.Vb 3
\& char *
\& guestfs_inspect_get_hostname (guestfs_h *g,
\&                               const char *root);
.Ve
.PP
This function returns the hostname of the operating system as found by
inspection of the guest's configuration files.
.PP
If the hostname could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR is
returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.7.9)
.SS "guestfs_inspect_get_icon"
.IX Subsection "guestfs_inspect_get_icon"
.Vb 5
\& char *
\& guestfs_inspect_get_icon (guestfs_h *g,
\&                           const char *root,
\&                           size_t *size_r,
\&                           ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 2
\& GUESTFS_INSPECT_GET_ICON_FAVICON, int favicon,
\& GUESTFS_INSPECT_GET_ICON_HIGHQUALITY, int highquality,
.Ve
.PP
This function returns an icon corresponding to the inspected operating
system.  The icon is returned as a buffer containing a \s-1PNG\s0 image (re-encoded
to \s-1PNG\s0 if necessary).
.PP
If it was not possible to get an icon this function returns a zero-length
(non-NULL) buffer.  \fICallers must check for this case\fR.
.PP
Libguestfs will start by looking for a file called \f(CW\*(C`/etc/favicon.png\*(C'\fR or
\&\f(CW\*(C`C:\eetc\efavicon.png\*(C'\fR and if it has the correct format, the contents of this
file will be returned.  You can disable favicons by passing the optional
\&\f(CW\*(C`favicon\*(C'\fR boolean as false (default is true).
.PP
If finding the favicon fails, then we look in other places in the guest for
a suitable icon.
.PP
If the optional \f(CW\*(C`highquality\*(C'\fR boolean is true then only high quality icons
are returned, which means only icons of high resolution with an alpha
channel.  The default (false) is to return any icon we can, even if it is of
substandard quality.
.PP
Notes:
.IP "\(bu" 4
Unlike most other inspection \s-1API\s0 calls, the guest's disks must be mounted up
before you call this, since it needs to read information from the guest
filesystem during the call.
.IP "\(bu" 4
\&\fBSecurity:\fR The icon data comes from the untrusted guest, and should be
treated with caution.  \s-1PNG\s0 files have been known to contain exploits.
Ensure that libpng (or other relevant libraries) are fully up to date before
trying to process or display the icon.
.IP "\(bu" 4
The \s-1PNG\s0 image returned can be any size.  It might not be square.  Libguestfs
tries to return the largest, highest quality icon available.  The
application must scale the icon to the required size.
.IP "\(bu" 4
Extracting icons from Windows guests requires the external \f(CW\*(C`wrestool\*(C'\fR
program from the \f(CW\*(C`icoutils\*(C'\fR package, and several programs (\f(CW\*(C`bmptopnm\*(C'\fR,
\&\f(CW\*(C`pnmtopng\*(C'\fR, \f(CW\*(C`pamcut\*(C'\fR)  from the \f(CW\*(C`netpbm\*(C'\fR package.  These must be
installed separately.
.IP "\(bu" 4
Operating system icons are usually trademarks.  Seek legal advice before
using trademarks in applications.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
(Added in 1.11.12)
.SS "guestfs_inspect_get_icon_va"
.IX Subsection "guestfs_inspect_get_icon_va"
.Vb 5
\& char *
\& guestfs_inspect_get_icon_va (guestfs_h *g,
\&                              const char *root,
\&                              size_t *size_r,
\&                              va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_inspect_get_icon\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_inspect_get_icon_argv"
.IX Subsection "guestfs_inspect_get_icon_argv"
.Vb 5
\& char *
\& guestfs_inspect_get_icon_argv (guestfs_h *g,
\&                                const char *root,
\&                                size_t *size_r,
\&                                const struct guestfs_inspect_get_icon_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_inspect_get_icon\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_inspect_get_major_version"
.IX Subsection "guestfs_inspect_get_major_version"
.Vb 3
\& int
\& guestfs_inspect_get_major_version (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
This returns the major version number of the inspected operating system.
.PP
Windows uses a consistent versioning scheme which is \fInot\fR reflected in the
popular public names used by the operating system.  Notably the operating
system known as \*(L"Windows 7\*(R" is really version 6.1 (ie. major = 6, minor =
1).  You can find out the real versions corresponding to releases of Windows
by consulting Wikipedia or \s-1MSDN\s0.
.PP
If the version could not be determined, then \f(CW0\fR is returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
On error this function returns \-1.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_minor_version"
.IX Subsection "guestfs_inspect_get_minor_version"
.Vb 3
\& int
\& guestfs_inspect_get_minor_version (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
This returns the minor version number of the inspected operating system.
.PP
If the version could not be determined, then \f(CW0\fR is returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.  See also
\&\f(CW\*(C`guestfs_inspect_get_major_version\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_mountpoints"
.IX Subsection "guestfs_inspect_get_mountpoints"
.Vb 3
\& char **
\& guestfs_inspect_get_mountpoints (guestfs_h *g,
\&                                  const char *root);
.Ve
.PP
This returns a hash of where we think the filesystems associated with this
operating system should be mounted.  Callers should note that this is at
best an educated guess made by reading configuration files such as
\&\f(CW\*(C`/etc/fstab\*(C'\fR.  \fIIn particular note\fR that this may return filesystems which
are non-existent or not mountable and callers should be prepared to handle
or ignore failures if they try to mount them.
.PP
Each element in the returned hashtable has a key which is the path of the
mountpoint (eg. \f(CW\*(C`/boot\*(C'\fR) and a value which is the filesystem that would be
mounted there (eg. \f(CW\*(C`/dev/sda1\*(C'\fR).
.PP
Non-mounted devices such as swap devices are \fInot\fR returned in this list.
.PP
For operating systems like Windows which still use drive letters, this call
will only return an entry for the first drive \*(L"mounted on\*(R" \f(CW\*(C`/\*(C'\fR.  For
information about the mapping of drive letters to partitions, see
\&\f(CW\*(C`guestfs_inspect_get_drive_mappings\*(C'\fR.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.  See also
\&\f(CW\*(C`guestfs_inspect_get_filesystems\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_package_format"
.IX Subsection "guestfs_inspect_get_package_format"
.Vb 3
\& char *
\& guestfs_inspect_get_package_format (guestfs_h *g,
\&                                     const char *root);
.Ve
.PP
This function and \f(CW\*(C`guestfs_inspect_get_package_management\*(C'\fR return the
package format and package management tool used by the inspected operating
system.  For example for Fedora these functions would return \f(CW\*(C`rpm\*(C'\fR (package
format) and \f(CW\*(C`yum\*(C'\fR (package management).
.PP
This returns the string \f(CW\*(C`unknown\*(C'\fR if we could not determine the package
format \fIor\fR if the operating system does not have a real packaging system
(eg. Windows).
.PP
Possible strings include: \f(CW\*(C`rpm\*(C'\fR, \f(CW\*(C`deb\*(C'\fR, \f(CW\*(C`ebuild\*(C'\fR, \f(CW\*(C`pisi\*(C'\fR, \f(CW\*(C`pacman\*(C'\fR,
\&\f(CW\*(C`pkgsrc\*(C'\fR.  Future versions of libguestfs may return other strings.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.7.5)
.SS "guestfs_inspect_get_package_management"
.IX Subsection "guestfs_inspect_get_package_management"
.Vb 3
\& char *
\& guestfs_inspect_get_package_management (guestfs_h *g,
\&                                         const char *root);
.Ve
.PP
\&\f(CW\*(C`guestfs_inspect_get_package_format\*(C'\fR and this function return the package
format and package management tool used by the inspected operating system.
For example for Fedora these functions would return \f(CW\*(C`rpm\*(C'\fR (package format)
and \f(CW\*(C`yum\*(C'\fR (package management).
.PP
This returns the string \f(CW\*(C`unknown\*(C'\fR if we could not determine the package
management tool \fIor\fR if the operating system does not have a real packaging
system (eg. Windows).
.PP
Possible strings include: \f(CW\*(C`yum\*(C'\fR, \f(CW\*(C`up2date\*(C'\fR, \f(CW\*(C`apt\*(C'\fR (for all Debian
derivatives), \f(CW\*(C`portage\*(C'\fR, \f(CW\*(C`pisi\*(C'\fR, \f(CW\*(C`pacman\*(C'\fR, \f(CW\*(C`urpmi\*(C'\fR, \f(CW\*(C`zypper\*(C'\fR.  Future
versions of libguestfs may return other strings.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.7.5)
.SS "guestfs_inspect_get_product_name"
.IX Subsection "guestfs_inspect_get_product_name"
.Vb 3
\& char *
\& guestfs_inspect_get_product_name (guestfs_h *g,
\&                                   const char *root);
.Ve
.PP
This returns the product name of the inspected operating system.  The
product name is generally some freeform string which can be displayed to the
user, but should not be parsed by programs.
.PP
If the product name could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR is
returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_product_variant"
.IX Subsection "guestfs_inspect_get_product_variant"
.Vb 3
\& char *
\& guestfs_inspect_get_product_variant (guestfs_h *g,
\&                                      const char *root);
.Ve
.PP
This returns the product variant of the inspected operating system.
.PP
For Windows guests, this returns the contents of the Registry key
\&\f(CW\*(C`HKLM\eSoftware\eMicrosoft\eWindows NT\eCurrentVersion\*(C'\fR \f(CW\*(C`InstallationType\*(C'\fR
which is usually a string such as \f(CW\*(C`Client\*(C'\fR or \f(CW\*(C`Server\*(C'\fR (other values are
possible).  This can be used to distinguish consumer and enterprise versions
of Windows that have the same version number (for example, Windows 7 and
Windows 2008 Server are both version 6.1, but the former is \f(CW\*(C`Client\*(C'\fR and
the latter is \f(CW\*(C`Server\*(C'\fR).
.PP
For enterprise Linux guests, in future we intend this to return the product
variant such as \f(CW\*(C`Desktop\*(C'\fR, \f(CW\*(C`Server\*(C'\fR and so on.  But this is not
implemented at present.
.PP
If the product variant could not be determined, then the string \f(CW\*(C`unknown\*(C'\fR
is returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.  See also
\&\f(CW\*(C`guestfs_inspect_get_product_name\*(C'\fR, \f(CW\*(C`guestfs_inspect_get_major_version\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.9.13)
.SS "guestfs_inspect_get_roots"
.IX Subsection "guestfs_inspect_get_roots"
.Vb 2
\& char **
\& guestfs_inspect_get_roots (guestfs_h *g);
.Ve
.PP
This function is a convenient way to get the list of root devices, as
returned from a previous call to \f(CW\*(C`guestfs_inspect_os\*(C'\fR, but without redoing
the whole inspection process.
.PP
This returns an empty list if either no root devices were found or the
caller has not called \f(CW\*(C`guestfs_inspect_os\*(C'\fR.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.7.3)
.SS "guestfs_inspect_get_type"
.IX Subsection "guestfs_inspect_get_type"
.Vb 3
\& char *
\& guestfs_inspect_get_type (guestfs_h *g,
\&                           const char *root);
.Ve
.PP
This returns the type of the inspected operating system.  Currently defined
types are:
.ie n .IP """linux""" 4
.el .IP "``linux''" 4
.IX Item "linux"
Any Linux-based operating system.
.ie n .IP """windows""" 4
.el .IP "``windows''" 4
.IX Item "windows"
Any Microsoft Windows operating system.
.ie n .IP """freebsd""" 4
.el .IP "``freebsd''" 4
.IX Item "freebsd"
FreeBSD.
.ie n .IP """netbsd""" 4
.el .IP "``netbsd''" 4
.IX Item "netbsd"
NetBSD.
.ie n .IP """hurd""" 4
.el .IP "``hurd''" 4
.IX Item "hurd"
GNU/Hurd.
.ie n .IP """unknown""" 4
.el .IP "``unknown''" 4
.IX Item "unknown"
The operating system type could not be determined.
.PP
Future versions of libguestfs may return other strings here.  The caller
should be prepared to handle any string.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_inspect_get_windows_current_control_set"
.IX Subsection "guestfs_inspect_get_windows_current_control_set"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_current_control_set (guestfs_h *g,
\&                                                  const char *root);
.Ve
.PP
This returns the Windows CurrentControlSet of the inspected guest.  The
CurrentControlSet is a registry key name such as \f(CW\*(C`ControlSet001\*(C'\fR.
.PP
This call assumes that the guest is Windows and that the Registry could be
examined by inspection.  If this is not the case then an error is returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.9.17)
.SS "guestfs_inspect_get_windows_systemroot"
.IX Subsection "guestfs_inspect_get_windows_systemroot"
.Vb 3
\& char *
\& guestfs_inspect_get_windows_systemroot (guestfs_h *g,
\&                                         const char *root);
.Ve
.PP
This returns the Windows systemroot of the inspected guest.  The systemroot
is a directory path such as \f(CW\*(C`/WINDOWS\*(C'\fR.
.PP
This call assumes that the guest is Windows and that the systemroot could be
determined by inspection.  If this is not the case then an error is
returned.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.25)
.SS "guestfs_inspect_is_live"
.IX Subsection "guestfs_inspect_is_live"
.Vb 3
\& int
\& guestfs_inspect_is_live (guestfs_h *g,
\&                          const char *root);
.Ve
.PP
If \f(CW\*(C`guestfs_inspect_get_format\*(C'\fR returns \f(CW\*(C`installer\*(C'\fR (this is an install
disk), then this returns true if a live image was detected on the disk.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.9.4)
.SS "guestfs_inspect_is_multipart"
.IX Subsection "guestfs_inspect_is_multipart"
.Vb 3
\& int
\& guestfs_inspect_is_multipart (guestfs_h *g,
\&                               const char *root);
.Ve
.PP
If \f(CW\*(C`guestfs_inspect_get_format\*(C'\fR returns \f(CW\*(C`installer\*(C'\fR (this is an install
disk), then this returns true if the disk is part of a set.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.9.4)
.SS "guestfs_inspect_is_netinst"
.IX Subsection "guestfs_inspect_is_netinst"
.Vb 3
\& int
\& guestfs_inspect_is_netinst (guestfs_h *g,
\&                             const char *root);
.Ve
.PP
If \f(CW\*(C`guestfs_inspect_get_format\*(C'\fR returns \f(CW\*(C`installer\*(C'\fR (this is an install
disk), then this returns true if the disk is a network installer, ie. not a
self-contained install \s-1CD\s0 but one which is likely to require network access
to complete the install.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.9.4)
.SS "guestfs_inspect_list_applications"
.IX Subsection "guestfs_inspect_list_applications"
.Vb 3
\& struct guestfs_application_list *
\& guestfs_inspect_list_applications (guestfs_h *g,
\&                                    const char *root);
.Ve
.PP
Return the list of applications installed in the operating system.
.PP
\&\fINote:\fR This call works differently from other parts of the inspection
\&\s-1API\s0.  You have to call \f(CW\*(C`guestfs_inspect_os\*(C'\fR, then
\&\f(CW\*(C`guestfs_inspect_get_mountpoints\*(C'\fR, then mount up the disks, before calling
this.  Listing applications is a significantly more difficult operation
which requires access to the full filesystem.  Also note that unlike the
other \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR calls which are just returning data cached in
the libguestfs handle, this call actually reads parts of the mounted
filesystems during the call.
.PP
This returns an empty list if the inspection code was not able to determine
the list of applications.
.PP
The application structure contains the following fields:
.ie n .IP """app_name""" 4
.el .IP "\f(CWapp_name\fR" 4
.IX Item "app_name"
The name of the application.  For Red Hat-derived and Debian-derived Linux
guests, this is the package name.
.ie n .IP """app_display_name""" 4
.el .IP "\f(CWapp_display_name\fR" 4
.IX Item "app_display_name"
The display name of the application, sometimes localized to the install
language of the guest operating system.
.Sp
If unavailable this is returned as an empty string \f(CW""\fR.  Callers needing
to display something can use \f(CW\*(C`app_name\*(C'\fR instead.
.ie n .IP """app_epoch""" 4
.el .IP "\f(CWapp_epoch\fR" 4
.IX Item "app_epoch"
For package managers which use epochs, this contains the epoch of the
package (an integer).  If unavailable, this is returned as \f(CW0\fR.
.ie n .IP """app_version""" 4
.el .IP "\f(CWapp_version\fR" 4
.IX Item "app_version"
The version string of the application or package.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app_release""" 4
.el .IP "\f(CWapp_release\fR" 4
.IX Item "app_release"
The release string of the application or package, for package managers that
use this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_install_path""" 4
.el .IP "\f(CWapp_install_path\fR" 4
.IX Item "app_install_path"
The installation path of the application (on operating systems such as
Windows which use installation paths).  This path is in the format used by
the guest operating system, it is not a libguestfs path.
.Sp
If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_trans_path""" 4
.el .IP "\f(CWapp_trans_path\fR" 4
.IX Item "app_trans_path"
The install path translated into a libguestfs path.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app_publisher""" 4
.el .IP "\f(CWapp_publisher\fR" 4
.IX Item "app_publisher"
The name of the publisher of the application, for package managers that use
this.  If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_url""" 4
.el .IP "\f(CWapp_url\fR" 4
.IX Item "app_url"
The \s-1URL\s0 (eg. upstream \s-1URL\s0) of the application.  If unavailable this is
returned as an empty string \f(CW""\fR.
.ie n .IP """app_source_package""" 4
.el .IP "\f(CWapp_source_package\fR" 4
.IX Item "app_source_package"
For packaging systems which support this, the name of the source package.
If unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_summary""" 4
.el .IP "\f(CWapp_summary\fR" 4
.IX Item "app_summary"
A short (usually one line) description of the application or package.  If
unavailable this is returned as an empty string \f(CW""\fR.
.ie n .IP """app_description""" 4
.el .IP "\f(CWapp_description\fR" 4
.IX Item "app_description"
A longer description of the application or package.  If unavailable this is
returned as an empty string \f(CW""\fR.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
This function returns a \f(CW\*(C`struct guestfs_application_list *\*(C'\fR, or \s-1NULL\s0 if
there was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_application_list\*(C'\fI
after use\fR.
.PP
(Added in 1.7.8)
.SS "guestfs_inspect_os"
.IX Subsection "guestfs_inspect_os"
.Vb 2
\& char **
\& guestfs_inspect_os (guestfs_h *g);
.Ve
.PP
This function uses other libguestfs functions and certain heuristics to
inspect the disk(s) (usually disks belonging to a virtual machine), looking
for operating systems.
.PP
The list returned is empty if no operating systems were found.
.PP
If one operating system was found, then this returns a list with a single
element, which is the name of the root filesystem of this operating system.
It is also possible for this function to return a list containing more than
one element, indicating a dual-boot or multi-boot virtual machine, with each
element being the root filesystem of one of the operating systems.
.PP
You can pass the root string(s) returned to other \f(CW\*(C`guestfs_inspect_get_*\*(C'\fR
functions in order to query further information about each operating system,
such as the name and version.
.PP
This function uses other libguestfs features such as \f(CW\*(C`guestfs_mount_ro\*(C'\fR and
\&\f(CW\*(C`guestfs_umount_all\*(C'\fR in order to mount and unmount filesystems and look at
the contents.  This should be called with no disks currently mounted.  The
function may also use Augeas, so any existing Augeas handle will be closed.
.PP
This function cannot decrypt encrypted disks.  The caller must do that first
(supplying the necessary keys) if the disk is encrypted.
.PP
Please read \*(L"\s-1INSPECTION\s0\*(R" in \fIguestfs\fR\|(3) for more details.
.PP
See also \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.5.3)
.SS "guestfs_is_blockdev"
.IX Subsection "guestfs_is_blockdev"
.Vb 3
\& int
\& guestfs_is_blockdev (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a block device with the given
\&\f(CW\*(C`path\*(C'\fR name.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.10)
.SS "guestfs_is_busy"
.IX Subsection "guestfs_is_busy"
.Vb 2
\& int
\& guestfs_is_busy (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is busy processing a command (in the
\&\f(CW\*(C`BUSY\*(C'\fR state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.2)
.SS "guestfs_is_chardev"
.IX Subsection "guestfs_is_chardev"
.Vb 3
\& int
\& guestfs_is_chardev (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a character device with the
given \f(CW\*(C`path\*(C'\fR name.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.10)
.SS "guestfs_is_config"
.IX Subsection "guestfs_is_config"
.Vb 2
\& int
\& guestfs_is_config (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is being configured (in the \f(CW\*(C`CONFIG\*(C'\fR
state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.2)
.SS "guestfs_is_dir"
.IX Subsection "guestfs_is_dir"
.Vb 3
\& int
\& guestfs_is_dir (guestfs_h *g,
\&                 const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a directory with the given
\&\f(CW\*(C`path\*(C'\fR name.  Note that it returns false for other objects like files.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_is_fifo"
.IX Subsection "guestfs_is_fifo"
.Vb 3
\& int
\& guestfs_is_fifo (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a \s-1FIFO\s0 (named pipe)  with the
given \f(CW\*(C`path\*(C'\fR name.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.10)
.SS "guestfs_is_file"
.IX Subsection "guestfs_is_file"
.Vb 3
\& int
\& guestfs_is_file (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a regular file with the given
\&\f(CW\*(C`path\*(C'\fR name.  Note that it returns false for other objects like
directories.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_is_launching"
.IX Subsection "guestfs_is_launching"
.Vb 2
\& int
\& guestfs_is_launching (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is launching the subprocess (in the
\&\f(CW\*(C`LAUNCHING\*(C'\fR state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.2)
.SS "guestfs_is_lv"
.IX Subsection "guestfs_is_lv"
.Vb 3
\& int
\& guestfs_is_lv (guestfs_h *g,
\&                const char *device);
.Ve
.PP
This command tests whether \f(CW\*(C`device\*(C'\fR is a logical volume, and returns true
iff this is the case.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.3)
.SS "guestfs_is_ready"
.IX Subsection "guestfs_is_ready"
.Vb 2
\& int
\& guestfs_is_ready (guestfs_h *g);
.Ve
.PP
This returns true iff this handle is ready to accept commands (in the
\&\f(CW\*(C`READY\*(C'\fR state).
.PP
For more information on states, see \fIguestfs\fR\|(3).
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.0.2)
.SS "guestfs_is_socket"
.IX Subsection "guestfs_is_socket"
.Vb 3
\& int
\& guestfs_is_socket (guestfs_h *g,
\&                    const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a Unix domain socket with the
given \f(CW\*(C`path\*(C'\fR name.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.10)
.SS "guestfs_is_symlink"
.IX Subsection "guestfs_is_symlink"
.Vb 3
\& int
\& guestfs_is_symlink (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
This returns \f(CW\*(C`true\*(C'\fR if and only if there is a symbolic link with the given
\&\f(CW\*(C`path\*(C'\fR name.
.PP
See also \f(CW\*(C`guestfs_stat\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.5.10)
.SS "guestfs_is_zero"
.IX Subsection "guestfs_is_zero"
.Vb 3
\& int
\& guestfs_is_zero (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This returns true iff the file exists and the file is empty or it contains
all zero bytes.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.11.8)
.SS "guestfs_is_zero_device"
.IX Subsection "guestfs_is_zero_device"
.Vb 3
\& int
\& guestfs_is_zero_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
This returns true iff the device exists and contains all zero bytes.
.PP
Note that for large devices this can take a long time to run.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.11.8)
.SS "guestfs_kill_subprocess"
.IX Subsection "guestfs_kill_subprocess"
.Vb 2
\& int
\& guestfs_kill_subprocess (guestfs_h *g);
.Ve
.PP
This kills the qemu subprocess.  You should never need to call this.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_launch"
.IX Subsection "guestfs_launch"
.Vb 2
\& int
\& guestfs_launch (guestfs_h *g);
.Ve
.PP
Internally libguestfs is implemented by running a virtual machine using
\&\fIqemu\fR\|(1).
.PP
You should call this after configuring the handle (eg. adding drives) but
before performing any actions.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 0.3)
.SS "guestfs_lchown"
.IX Subsection "guestfs_lchown"
.Vb 5
\& int
\& guestfs_lchown (guestfs_h *g,
\&                 int owner,
\&                 int group,
\&                 const char *path);
.Ve
.PP
Change the file owner to \f(CW\*(C`owner\*(C'\fR and group to \f(CW\*(C`group\*(C'\fR.  This is like
\&\f(CW\*(C`guestfs_chown\*(C'\fR but if \f(CW\*(C`path\*(C'\fR is a symlink then the link itself is
changed, not the target.
.PP
Only numeric uid and gid are supported.  If you want to use names, you will
need to locate and parse the password file yourself (Augeas support makes
this relatively easy).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_lgetxattr"
.IX Subsection "guestfs_lgetxattr"
.Vb 5
\& char *
\& guestfs_lgetxattr (guestfs_h *g,
\&                    const char *path,
\&                    const char *name,
\&                    size_t *size_r);
.Ve
.PP
Get a single extended attribute from file \f(CW\*(C`path\*(C'\fR named \f(CW\*(C`name\*(C'\fR.  If \f(CW\*(C`path\*(C'\fR
is a symlink, then this call returns an extended attribute from the symlink.
.PP
Normally it is better to get all extended attributes from a file in one go
by calling \f(CW\*(C`guestfs_getxattrs\*(C'\fR.  However some Linux filesystem
implementations are buggy and do not provide a way to list out attributes.
For these filesystems (notably ntfs\-3g)  you have to know the names of the
extended attributes you want in advance and call this function.
.PP
Extended attribute values are blobs of binary data.  If there is no extended
attribute named \f(CW\*(C`name\*(C'\fR, this returns an error.
.PP
See also: \f(CW\*(C`guestfs_lgetxattrs\*(C'\fR, \f(CW\*(C`guestfs_getxattr\*(C'\fR, \fIattr\fR\|(5).
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
(Added in 1.7.24)
.SS "guestfs_lgetxattrs"
.IX Subsection "guestfs_lgetxattrs"
.Vb 3
\& struct guestfs_xattr_list *
\& guestfs_lgetxattrs (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_getxattrs\*(C'\fR, but if \f(CW\*(C`path\*(C'\fR is a symbolic link,
then it returns the extended attributes of the link itself.
.PP
This function returns a \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI after use\fR.
.PP
(Added in 1.0.59)
.SS "guestfs_list_9p"
.IX Subsection "guestfs_list_9p"
.Vb 2
\& char **
\& guestfs_list_9p (guestfs_h *g);
.Ve
.PP
List all 9p filesystems attached to the guest.  A list of mount tags is
returned.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.11.12)
.SS "guestfs_list_devices"
.IX Subsection "guestfs_list_devices"
.Vb 2
\& char **
\& guestfs_list_devices (guestfs_h *g);
.Ve
.PP
List all the block devices.
.PP
The full block device names are returned, eg. \f(CW\*(C`/dev/sda\*(C'\fR.
.PP
See also \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_list_dm_devices"
.IX Subsection "guestfs_list_dm_devices"
.Vb 2
\& char **
\& guestfs_list_dm_devices (guestfs_h *g);
.Ve
.PP
List all device mapper devices.
.PP
The returned list contains \f(CW\*(C`/dev/mapper/*\*(C'\fR devices, eg. ones created by a
previous call to \f(CW\*(C`guestfs_luks_open\*(C'\fR.
.PP
Device mapper devices which correspond to logical volumes are \fInot\fR
returned in this list.  Call \f(CW\*(C`guestfs_lvs\*(C'\fR if you want to list logical
volumes.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.11.15)
.SS "guestfs_list_filesystems"
.IX Subsection "guestfs_list_filesystems"
.Vb 2
\& char **
\& guestfs_list_filesystems (guestfs_h *g);
.Ve
.PP
This inspection command looks for filesystems on partitions, block devices
and logical volumes, returning a list of devices containing filesystems and
their type.
.PP
The return value is a hash, where the keys are the devices containing
filesystems, and the values are the filesystem types.  For example:
.PP
.Vb 4
\& "/dev/sda1" => "ntfs"
\& "/dev/sda2" => "ext2"
\& "/dev/vg_guest/lv_root" => "ext4"
\& "/dev/vg_guest/lv_swap" => "swap"
.Ve
.PP
The value can have the special value \*(L"unknown\*(R", meaning the content of the
device is undetermined or empty.  \*(L"swap\*(R" means a Linux swap partition.
.PP
This command runs other libguestfs commands, which might include
\&\f(CW\*(C`guestfs_mount\*(C'\fR and \f(CW\*(C`guestfs_umount\*(C'\fR, and therefore you should use this
soon after launch and only when nothing is mounted.
.PP
Not all of the filesystems returned will be mountable.  In particular, swap
partitions are returned in the list.  Also this command does not check that
each filesystem found is valid and mountable, and some filesystems might be
mountable but require special options.  Filesystems may not all belong to a
single logical operating system (use \f(CW\*(C`guestfs_inspect_os\*(C'\fR to look for
OSes).
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.5.15)
.SS "guestfs_list_md_devices"
.IX Subsection "guestfs_list_md_devices"
.Vb 2
\& char **
\& guestfs_list_md_devices (guestfs_h *g);
.Ve
.PP
List all Linux md devices.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.15.4)
.SS "guestfs_list_partitions"
.IX Subsection "guestfs_list_partitions"
.Vb 2
\& char **
\& guestfs_list_partitions (guestfs_h *g);
.Ve
.PP
List all the partitions detected on all block devices.
.PP
The full partition device names are returned, eg. \f(CW\*(C`/dev/sda1\*(C'\fR
.PP
This does not return logical volumes.  For that you will need to call
\&\f(CW\*(C`guestfs_lvs\*(C'\fR.
.PP
See also \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_ll"
.IX Subsection "guestfs_ll"
.Vb 3
\& char *
\& guestfs_ll (guestfs_h *g,
\&             const char *directory);
.Ve
.PP
List the files in \f(CW\*(C`directory\*(C'\fR (relative to the root directory, there is no
cwd) in the format of 'ls \-la'.
.PP
This command is mostly useful for interactive sessions.  It is \fInot\fR
intended that you try to parse the output string.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_ln"
.IX Subsection "guestfs_ln"
.Vb 4
\& int
\& guestfs_ln (guestfs_h *g,
\&             const char *target,
\&             const char *linkname);
.Ve
.PP
This command creates a hard link using the \f(CW\*(C`ln\*(C'\fR command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_ln_f"
.IX Subsection "guestfs_ln_f"
.Vb 4
\& int
\& guestfs_ln_f (guestfs_h *g,
\&               const char *target,
\&               const char *linkname);
.Ve
.PP
This command creates a hard link using the \f(CW\*(C`ln \-f\*(C'\fR command.  The \fI\-f\fR
option removes the link (\f(CW\*(C`linkname\*(C'\fR) if it exists already.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_ln_s"
.IX Subsection "guestfs_ln_s"
.Vb 4
\& int
\& guestfs_ln_s (guestfs_h *g,
\&               const char *target,
\&               const char *linkname);
.Ve
.PP
This command creates a symbolic link using the \f(CW\*(C`ln \-s\*(C'\fR command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_ln_sf"
.IX Subsection "guestfs_ln_sf"
.Vb 4
\& int
\& guestfs_ln_sf (guestfs_h *g,
\&                const char *target,
\&                const char *linkname);
.Ve
.PP
This command creates a symbolic link using the \f(CW\*(C`ln \-sf\*(C'\fR command, The \fI\-f\fR
option removes the link (\f(CW\*(C`linkname\*(C'\fR) if it exists already.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_lremovexattr"
.IX Subsection "guestfs_lremovexattr"
.Vb 4
\& int
\& guestfs_lremovexattr (guestfs_h *g,
\&                       const char *xattr,
\&                       const char *path);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_removexattr\*(C'\fR, but if \f(CW\*(C`path\*(C'\fR is a symbolic
link, then it removes an extended attribute of the link itself.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.59)
.SS "guestfs_ls"
.IX Subsection "guestfs_ls"
.Vb 3
\& char **
\& guestfs_ls (guestfs_h *g,
\&             const char *directory);
.Ve
.PP
List the files in \f(CW\*(C`directory\*(C'\fR (relative to the root directory, there is no
cwd).  The '.' and '..' entries are not returned, but hidden files are
shown.
.PP
This command is mostly useful for interactive sessions.  Programs should
probably use \f(CW\*(C`guestfs_readdir\*(C'\fR instead.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_lsetxattr"
.IX Subsection "guestfs_lsetxattr"
.Vb 6
\& int
\& guestfs_lsetxattr (guestfs_h *g,
\&                    const char *xattr,
\&                    const char *val,
\&                    int vallen,
\&                    const char *path);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_setxattr\*(C'\fR, but if \f(CW\*(C`path\*(C'\fR is a symbolic link,
then it sets an extended attribute of the link itself.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.59)
.SS "guestfs_lstat"
.IX Subsection "guestfs_lstat"
.Vb 3
\& struct guestfs_stat *
\& guestfs_lstat (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Returns file information for the given \f(CW\*(C`path\*(C'\fR.
.PP
This is the same as \f(CW\*(C`guestfs_stat\*(C'\fR except that if \f(CW\*(C`path\*(C'\fR is a symbolic
link, then the link is stat-ed, not the file it refers to.
.PP
This is the same as the \f(CWlstat(2)\fR system call.
.PP
This function returns a \f(CW\*(C`struct guestfs_stat *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_stat\*(C'\fI after use\fR.
.PP
(Added in 0.9.2)
.SS "guestfs_lstatlist"
.IX Subsection "guestfs_lstatlist"
.Vb 4
\& struct guestfs_stat_list *
\& guestfs_lstatlist (guestfs_h *g,
\&                    const char *path,
\&                    char *const *names);
.Ve
.PP
This call allows you to perform the \f(CW\*(C`guestfs_lstat\*(C'\fR operation on multiple
files, where all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list
of files from this directory.
.PP
On return you get a list of stat structs, with a one-to-one correspondence
to the \f(CW\*(C`names\*(C'\fR list.  If any name did not exist or could not be lstat'd,
then the \f(CW\*(C`ino\*(C'\fR field of that structure is set to \f(CW\*(C`\-1\*(C'\fR.
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also \f(CW\*(C`guestfs_lxattrlist\*(C'\fR
for a similarly efficient call for getting extended attributes.  Very long
directory listings might cause the protocol message size to be exceeded,
causing this call to fail.  The caller must split up such requests into
smaller groups of names.
.PP
This function returns a \f(CW\*(C`struct guestfs_stat_list *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_stat_list\*(C'\fI after use\fR.
.PP
(Added in 1.0.77)
.SS "guestfs_luks_add_key"
.IX Subsection "guestfs_luks_add_key"
.Vb 6
\& int
\& guestfs_luks_add_key (guestfs_h *g,
\&                       const char *device,
\&                       const char *key,
\&                       const char *newkey,
\&                       int keyslot);
.Ve
.PP
This command adds a new key on \s-1LUKS\s0 device \f(CW\*(C`device\*(C'\fR.  \f(CW\*(C`key\*(C'\fR is any
existing key, and is used to access the device.  \f(CW\*(C`newkey\*(C'\fR is the new key to
add.  \f(CW\*(C`keyslot\*(C'\fR is the key slot that will be replaced.
.PP
Note that if \f(CW\*(C`keyslot\*(C'\fR already contains a key, then this command will
fail.  You have to use \f(CW\*(C`guestfs_luks_kill_slot\*(C'\fR first to remove that key.
.PP
This function returns 0 on success or \-1 on error.
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0\*(R" for more
information.
.PP
(Added in 1.5.2)
.SS "guestfs_luks_close"
.IX Subsection "guestfs_luks_close"
.Vb 3
\& int
\& guestfs_luks_close (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
This closes a \s-1LUKS\s0 device that was created earlier by \f(CW\*(C`guestfs_luks_open\*(C'\fR
or \f(CW\*(C`guestfs_luks_open_ro\*(C'\fR.  The \f(CW\*(C`device\*(C'\fR parameter must be the name of the
\&\s-1LUKS\s0 mapping device (ie. \f(CW\*(C`/dev/mapper/mapname\*(C'\fR) and \fInot\fR the name of the
underlying block device.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.5.1)
.SS "guestfs_luks_format"
.IX Subsection "guestfs_luks_format"
.Vb 5
\& int
\& guestfs_luks_format (guestfs_h *g,
\&                      const char *device,
\&                      const char *key,
\&                      int keyslot);
.Ve
.PP
This command erases existing data on \f(CW\*(C`device\*(C'\fR and formats the device as a
\&\s-1LUKS\s0 encrypted device.  \f(CW\*(C`key\*(C'\fR is the initial key, which is added to key
slot \f(CW\*(C`slot\*(C'\fR.  (\s-1LUKS\s0 supports 8 key slots, numbered 0\-7).
.PP
This function returns 0 on success or \-1 on error.
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0\*(R" for more
information.
.PP
(Added in 1.5.2)
.SS "guestfs_luks_format_cipher"
.IX Subsection "guestfs_luks_format_cipher"
.Vb 6
\& int
\& guestfs_luks_format_cipher (guestfs_h *g,
\&                             const char *device,
\&                             const char *key,
\&                             int keyslot,
\&                             const char *cipher);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_luks_format\*(C'\fR but it also allows you to
set the \f(CW\*(C`cipher\*(C'\fR used.
.PP
This function returns 0 on success or \-1 on error.
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0\*(R" for more
information.
.PP
(Added in 1.5.2)
.SS "guestfs_luks_kill_slot"
.IX Subsection "guestfs_luks_kill_slot"
.Vb 5
\& int
\& guestfs_luks_kill_slot (guestfs_h *g,
\&                         const char *device,
\&                         const char *key,
\&                         int keyslot);
.Ve
.PP
This command deletes the key in key slot \f(CW\*(C`keyslot\*(C'\fR from the encrypted \s-1LUKS\s0
device \f(CW\*(C`device\*(C'\fR.  \f(CW\*(C`key\*(C'\fR must be one of the \fIother\fR keys.
.PP
This function returns 0 on success or \-1 on error.
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0\*(R" for more
information.
.PP
(Added in 1.5.2)
.SS "guestfs_luks_open"
.IX Subsection "guestfs_luks_open"
.Vb 5
\& int
\& guestfs_luks_open (guestfs_h *g,
\&                    const char *device,
\&                    const char *key,
\&                    const char *mapname);
.Ve
.PP
This command opens a block device which has been encrypted according to the
Linux Unified Key Setup (\s-1LUKS\s0) standard.
.PP
\&\f(CW\*(C`device\*(C'\fR is the encrypted block device or partition.
.PP
The caller must supply one of the keys associated with the \s-1LUKS\s0 block
device, in the \f(CW\*(C`key\*(C'\fR parameter.
.PP
This creates a new block device called \f(CW\*(C`/dev/mapper/mapname\*(C'\fR.  Reads and
writes to this block device are decrypted from and encrypted to the
underlying \f(CW\*(C`device\*(C'\fR respectively.
.PP
If this block device contains \s-1LVM\s0 volume groups, then calling
\&\f(CW\*(C`guestfs_vgscan\*(C'\fR followed by \f(CW\*(C`guestfs_vg_activate_all\*(C'\fR will make them
visible.
.PP
Use \f(CW\*(C`guestfs_list_dm_devices\*(C'\fR to list all device mapper devices.
.PP
This function returns 0 on success or \-1 on error.
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0\*(R" for more
information.
.PP
(Added in 1.5.1)
.SS "guestfs_luks_open_ro"
.IX Subsection "guestfs_luks_open_ro"
.Vb 5
\& int
\& guestfs_luks_open_ro (guestfs_h *g,
\&                       const char *device,
\&                       const char *key,
\&                       const char *mapname);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_luks_open\*(C'\fR except that a read-only mapping is
created.
.PP
This function returns 0 on success or \-1 on error.
.PP
This function takes a key or passphrase parameter which could contain
sensitive material.  Read the section \*(L"\s-1KEYS\s0 \s-1AND\s0 \s-1PASSPHRASES\s0\*(R" for more
information.
.PP
(Added in 1.5.1)
.SS "guestfs_lvcreate"
.IX Subsection "guestfs_lvcreate"
.Vb 5
\& int
\& guestfs_lvcreate (guestfs_h *g,
\&                   const char *logvol,
\&                   const char *volgroup,
\&                   int mbytes);
.Ve
.PP
This creates an \s-1LVM\s0 logical volume called \f(CW\*(C`logvol\*(C'\fR on the volume group
\&\f(CW\*(C`volgroup\*(C'\fR, with \f(CW\*(C`size\*(C'\fR megabytes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_lvm_canonical_lv_name"
.IX Subsection "guestfs_lvm_canonical_lv_name"
.Vb 3
\& char *
\& guestfs_lvm_canonical_lv_name (guestfs_h *g,
\&                                const char *lvname);
.Ve
.PP
This converts alternative naming schemes for LVs that you might find to the
canonical name.  For example, \f(CW\*(C`/dev/mapper/VG\-LV\*(C'\fR is converted to
\&\f(CW\*(C`/dev/VG/LV\*(C'\fR.
.PP
This command returns an error if the \f(CW\*(C`lvname\*(C'\fR parameter does not refer to a
logical volume.
.PP
See also \f(CW\*(C`guestfs_is_lv\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.24)
.SS "guestfs_lvm_clear_filter"
.IX Subsection "guestfs_lvm_clear_filter"
.Vb 2
\& int
\& guestfs_lvm_clear_filter (guestfs_h *g);
.Ve
.PP
This undoes the effect of \f(CW\*(C`guestfs_lvm_set_filter\*(C'\fR.  \s-1LVM\s0 will be able to
see every block device.
.PP
This command also clears the \s-1LVM\s0 cache and performs a volume group scan.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.5.1)
.SS "guestfs_lvm_remove_all"
.IX Subsection "guestfs_lvm_remove_all"
.Vb 2
\& int
\& guestfs_lvm_remove_all (guestfs_h *g);
.Ve
.PP
This command removes all \s-1LVM\s0 logical volumes, volume groups and physical
volumes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_lvm_set_filter"
.IX Subsection "guestfs_lvm_set_filter"
.Vb 3
\& int
\& guestfs_lvm_set_filter (guestfs_h *g,
\&                         char *const *devices);
.Ve
.PP
This sets the \s-1LVM\s0 device filter so that \s-1LVM\s0 will only be able to \*(L"see\*(R" the
block devices in the list \f(CW\*(C`devices\*(C'\fR, and will ignore all other attached
block devices.
.PP
Where disk image(s) contain duplicate PVs or VGs, this command is useful to
get \s-1LVM\s0 to ignore the duplicates, otherwise \s-1LVM\s0 can get confused.  Note also
there are two types of duplication possible: either cloned PVs/VGs which
have identical UUIDs; or VGs that are not cloned but just happen to have the
same name.  In normal operation you cannot create this situation, but you
can do it outside \s-1LVM\s0, eg.  by cloning disk images or by bit twiddling
inside the \s-1LVM\s0 metadata.
.PP
This command also clears the \s-1LVM\s0 cache and performs a volume group scan.
.PP
You can filter whole block devices or individual partitions.
.PP
You cannot use this if any \s-1VG\s0 is currently in use (eg.  contains a mounted
filesystem), even if you are not filtering out that \s-1VG\s0.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.5.1)
.SS "guestfs_lvremove"
.IX Subsection "guestfs_lvremove"
.Vb 3
\& int
\& guestfs_lvremove (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
Remove an \s-1LVM\s0 logical volume \f(CW\*(C`device\*(C'\fR, where \f(CW\*(C`device\*(C'\fR is the path to the
\&\s-1LV\s0, such as \f(CW\*(C`/dev/VG/LV\*(C'\fR.
.PP
You can also remove all LVs in a volume group by specifying the \s-1VG\s0 name,
\&\f(CW\*(C`/dev/VG\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.13)
.SS "guestfs_lvrename"
.IX Subsection "guestfs_lvrename"
.Vb 4
\& int
\& guestfs_lvrename (guestfs_h *g,
\&                   const char *logvol,
\&                   const char *newlogvol);
.Ve
.PP
Rename a logical volume \f(CW\*(C`logvol\*(C'\fR with the new name \f(CW\*(C`newlogvol\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.83)
.SS "guestfs_lvresize"
.IX Subsection "guestfs_lvresize"
.Vb 4
\& int
\& guestfs_lvresize (guestfs_h *g,
\&                   const char *device,
\&                   int mbytes);
.Ve
.PP
This resizes (expands or shrinks) an existing \s-1LVM\s0 logical volume to
\&\f(CW\*(C`mbytes\*(C'\fR.  When reducing, data in the reduced part is lost.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.27)
.SS "guestfs_lvresize_free"
.IX Subsection "guestfs_lvresize_free"
.Vb 4
\& int
\& guestfs_lvresize_free (guestfs_h *g,
\&                        const char *lv,
\&                        int percent);
.Ve
.PP
This expands an existing logical volume \f(CW\*(C`lv\*(C'\fR so that it fills \f(CW\*(C`pc\*(C'\fR% of the
remaining free space in the volume group.  Commonly you would call this with
pc = 100 which expands the logical volume as much as possible, using all
remaining free space in the volume group.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.3)
.SS "guestfs_lvs"
.IX Subsection "guestfs_lvs"
.Vb 2
\& char **
\& guestfs_lvs (guestfs_h *g);
.Ve
.PP
List all the logical volumes detected.  This is the equivalent of the
\&\fIlvs\fR\|(8) command.
.PP
This returns a list of the logical volume device names
(eg. \f(CW\*(C`/dev/VolGroup00/LogVol00\*(C'\fR).
.PP
See also \f(CW\*(C`guestfs_lvs_full\*(C'\fR, \f(CW\*(C`guestfs_list_filesystems\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_lvs_full"
.IX Subsection "guestfs_lvs_full"
.Vb 2
\& struct guestfs_lvm_lv_list *
\& guestfs_lvs_full (guestfs_h *g);
.Ve
.PP
List all the logical volumes detected.  This is the equivalent of the
\&\fIlvs\fR\|(8) command.  The \*(L"full\*(R" version includes all fields.
.PP
This function returns a \f(CW\*(C`struct guestfs_lvm_lv_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_lvm_lv_list\*(C'\fI after
use\fR.
.PP
(Added in 0.4)
.SS "guestfs_lvuuid"
.IX Subsection "guestfs_lvuuid"
.Vb 3
\& char *
\& guestfs_lvuuid (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
This command returns the \s-1UUID\s0 of the \s-1LVM\s0 \s-1LV\s0 \f(CW\*(C`device\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.87)
.SS "guestfs_lxattrlist"
.IX Subsection "guestfs_lxattrlist"
.Vb 4
\& struct guestfs_xattr_list *
\& guestfs_lxattrlist (guestfs_h *g,
\&                     const char *path,
\&                     char *const *names);
.Ve
.PP
This call allows you to get the extended attributes of multiple files, where
all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list of files from
this directory.
.PP
On return you get a flat list of xattr structs which must be interpreted
sequentially.  The first xattr struct always has a zero-length \f(CW\*(C`attrname\*(C'\fR.
\&\f(CW\*(C`attrval\*(C'\fR in this struct is zero-length to indicate there was an error
doing \f(CW\*(C`lgetxattr\*(C'\fR for this file, \fIor\fR is a C string which is a decimal
number (the number of following attributes for this file, which could be
\&\f(CW"0"\fR).  Then after the first xattr struct are the zero or more attributes
for the first named file.  This repeats for the second and subsequent files.
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  See also \f(CW\*(C`guestfs_lstatlist\*(C'\fR for
a similarly efficient call for getting standard stats.  Very long directory
listings might cause the protocol message size to be exceeded, causing this
call to fail.  The caller must split up such requests into smaller groups of
names.
.PP
This function returns a \f(CW\*(C`struct guestfs_xattr_list *\*(C'\fR, or \s-1NULL\s0 if there was
an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_xattr_list\*(C'\fI after use\fR.
.PP
(Added in 1.0.77)
.SS "guestfs_md_create"
.IX Subsection "guestfs_md_create"
.Vb 5
\& int
\& guestfs_md_create (guestfs_h *g,
\&                    const char *name,
\&                    char *const *devices,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 5
\& GUESTFS_MD_CREATE_MISSINGBITMAP, int64_t missingbitmap,
\& GUESTFS_MD_CREATE_NRDEVICES, int nrdevices,
\& GUESTFS_MD_CREATE_SPARE, int spare,
\& GUESTFS_MD_CREATE_CHUNK, int64_t chunk,
\& GUESTFS_MD_CREATE_LEVEL, const char *level,
.Ve
.PP
Create a Linux md (\s-1RAID\s0) device named \f(CW\*(C`name\*(C'\fR on the devices in the list
\&\f(CW\*(C`devices\*(C'\fR.
.PP
The optional parameters are:
.ie n .IP """missingbitmap""" 4
.el .IP "\f(CWmissingbitmap\fR" 4
.IX Item "missingbitmap"
A bitmap of missing devices.  If a bit is set it means that a missing device
is added to the array.  The least significant bit corresponds to the first
device in the array.
.Sp
As examples:
.Sp
If \f(CW\*(C`devices = ["/dev/sda"]\*(C'\fR and \f(CW\*(C`missingbitmap = 0x1\*(C'\fR then the resulting
array would be \f(CW\*(C`[<missing>, "/dev/sda"]\*(C'\fR.
.Sp
If \f(CW\*(C`devices = ["/dev/sda"]\*(C'\fR and \f(CW\*(C`missingbitmap = 0x2\*(C'\fR then the resulting
array would be \f(CW\*(C`["/dev/sda", <missing>]\*(C'\fR.
.Sp
This defaults to \f(CW0\fR (no missing devices).
.Sp
The length of \f(CW\*(C`devices\*(C'\fR + the number of bits set in \f(CW\*(C`missingbitmap\*(C'\fR must
equal \f(CW\*(C`nrdevices\*(C'\fR + \f(CW\*(C`spare\*(C'\fR.
.ie n .IP """nrdevices""" 4
.el .IP "\f(CWnrdevices\fR" 4
.IX Item "nrdevices"
The number of active \s-1RAID\s0 devices.
.Sp
If not set, this defaults to the length of \f(CW\*(C`devices\*(C'\fR plus the number of
bits set in \f(CW\*(C`missingbitmap\*(C'\fR.
.ie n .IP """spare""" 4
.el .IP "\f(CWspare\fR" 4
.IX Item "spare"
The number of spare devices.
.Sp
If not set, this defaults to \f(CW0\fR.
.ie n .IP """chunk""" 4
.el .IP "\f(CWchunk\fR" 4
.IX Item "chunk"
The chunk size in bytes.
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
The \s-1RAID\s0 level, which can be one of: \fIlinear\fR, \fIraid0\fR, \fI0\fR, \fIstripe\fR,
\&\fIraid1\fR, \fI1\fR, \fImirror\fR, \fIraid4\fR, \fI4\fR, \fIraid5\fR, \fI5\fR, \fIraid6\fR, \fI6\fR,
\&\fIraid10\fR, \fI10\fR.  Some of these are synonymous, and more levels may be
added in future.
.Sp
If not set, this defaults to \f(CW\*(C`raid1\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.15.6)
.SS "guestfs_md_create_va"
.IX Subsection "guestfs_md_create_va"
.Vb 5
\& int
\& guestfs_md_create_va (guestfs_h *g,
\&                       const char *name,
\&                       char *const *devices,
\&                       va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_md_create\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_md_create_argv"
.IX Subsection "guestfs_md_create_argv"
.Vb 5
\& int
\& guestfs_md_create_argv (guestfs_h *g,
\&                         const char *name,
\&                         char *const *devices,
\&                         const struct guestfs_md_create_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_md_create\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_md_detail"
.IX Subsection "guestfs_md_detail"
.Vb 3
\& char **
\& guestfs_md_detail (guestfs_h *g,
\&                    const char *md);
.Ve
.PP
This command exposes the output of 'mdadm \-DY <md>'. The following fields
are usually present in the returned hash. Other fields may also be present.
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
The raid level of the \s-1MD\s0 device.
.ie n .IP """devices""" 4
.el .IP "\f(CWdevices\fR" 4
.IX Item "devices"
The number of underlying devices in the \s-1MD\s0 device.
.ie n .IP """metadata""" 4
.el .IP "\f(CWmetadata\fR" 4
.IX Item "metadata"
The metadata version used.
.ie n .IP """uuid""" 4
.el .IP "\f(CWuuid\fR" 4
.IX Item "uuid"
The \s-1UUID\s0 of the \s-1MD\s0 device.
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The name of the \s-1MD\s0 device.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.15.6)
.SS "guestfs_md_stop"
.IX Subsection "guestfs_md_stop"
.Vb 3
\& int
\& guestfs_md_stop (guestfs_h *g,
\&                  const char *md);
.Ve
.PP
This command deactivates the \s-1MD\s0 array named \f(CW\*(C`md\*(C'\fR.  The device is stopped,
but it is not destroyed or zeroed.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.15.6)
.SS "guestfs_mkdir"
.IX Subsection "guestfs_mkdir"
.Vb 3
\& int
\& guestfs_mkdir (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Create a directory named \f(CW\*(C`path\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_mkdir_mode"
.IX Subsection "guestfs_mkdir_mode"
.Vb 4
\& int
\& guestfs_mkdir_mode (guestfs_h *g,
\&                     const char *path,
\&                     int mode);
.Ve
.PP
This command creates a directory, setting the initial permissions of the
directory to \f(CW\*(C`mode\*(C'\fR.
.PP
For common Linux filesystems, the actual mode which is set will be \f(CW\*(C`mode &
~umask & 01777\*(C'\fR.  Non-native-Linux filesystems may interpret the mode in
other ways.
.PP
See also \f(CW\*(C`guestfs_mkdir\*(C'\fR, \f(CW\*(C`guestfs_umask\*(C'\fR
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_mkdir_p"
.IX Subsection "guestfs_mkdir_p"
.Vb 3
\& int
\& guestfs_mkdir_p (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Create a directory named \f(CW\*(C`path\*(C'\fR, creating any parent directories as
necessary.  This is like the \f(CW\*(C`mkdir \-p\*(C'\fR shell command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_mkdtemp"
.IX Subsection "guestfs_mkdtemp"
.Vb 3
\& char *
\& guestfs_mkdtemp (guestfs_h *g,
\&                  const char *tmpl);
.Ve
.PP
This command creates a temporary directory.  The \f(CW\*(C`tmpl\*(C'\fR parameter should be
a full pathname for the temporary directory name with the final six
characters being \*(L"\s-1XXXXXX\s0\*(R".
.PP
For example: \*(L"/tmp/myprogXXXXXX\*(R" or \*(L"/Temp/myprogXXXXXX\*(R", the second one
being suitable for Windows filesystems.
.PP
The name of the temporary directory that was created is returned.
.PP
The temporary directory is created with mode 0700 and is owned by root.
.PP
The caller is responsible for deleting the temporary directory and its
contents after use.
.PP
See also: \fImkdtemp\fR\|(3)
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.54)
.SS "guestfs_mke2fs_J"
.IX Subsection "guestfs_mke2fs_J"
.Vb 6
\& int
\& guestfs_mke2fs_J (guestfs_h *g,
\&                   const char *fstype,
\&                   int blocksize,
\&                   const char *device,
\&                   const char *journal);
.Ve
.PP
This creates an ext2/3/4 filesystem on \f(CW\*(C`device\*(C'\fR with an external journal on
\&\f(CW\*(C`journal\*(C'\fR.  It is equivalent to the command:
.PP
.Vb 1
\& mke2fs \-t fstype \-b blocksize \-J device=<journal> <device>
.Ve
.PP
See also \f(CW\*(C`guestfs_mke2journal\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mke2fs_JL"
.IX Subsection "guestfs_mke2fs_JL"
.Vb 6
\& int
\& guestfs_mke2fs_JL (guestfs_h *g,
\&                    const char *fstype,
\&                    int blocksize,
\&                    const char *device,
\&                    const char *label);
.Ve
.PP
This creates an ext2/3/4 filesystem on \f(CW\*(C`device\*(C'\fR with an external journal on
the journal labeled \f(CW\*(C`label\*(C'\fR.
.PP
See also \f(CW\*(C`guestfs_mke2journal_L\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mke2fs_JU"
.IX Subsection "guestfs_mke2fs_JU"
.Vb 6
\& int
\& guestfs_mke2fs_JU (guestfs_h *g,
\&                    const char *fstype,
\&                    int blocksize,
\&                    const char *device,
\&                    const char *uuid);
.Ve
.PP
This creates an ext2/3/4 filesystem on \f(CW\*(C`device\*(C'\fR with an external journal on
the journal with \s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR.
.PP
See also \f(CW\*(C`guestfs_mke2journal_U\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mke2journal"
.IX Subsection "guestfs_mke2journal"
.Vb 4
\& int
\& guestfs_mke2journal (guestfs_h *g,
\&                      int blocksize,
\&                      const char *device);
.Ve
.PP
This creates an ext2 external journal on \f(CW\*(C`device\*(C'\fR.  It is equivalent to the
command:
.PP
.Vb 1
\& mke2fs \-O journal_dev \-b blocksize device
.Ve
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mke2journal_L"
.IX Subsection "guestfs_mke2journal_L"
.Vb 5
\& int
\& guestfs_mke2journal_L (guestfs_h *g,
\&                        int blocksize,
\&                        const char *label,
\&                        const char *device);
.Ve
.PP
This creates an ext2 external journal on \f(CW\*(C`device\*(C'\fR with label \f(CW\*(C`label\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mke2journal_U"
.IX Subsection "guestfs_mke2journal_U"
.Vb 5
\& int
\& guestfs_mke2journal_U (guestfs_h *g,
\&                        int blocksize,
\&                        const char *uuid,
\&                        const char *device);
.Ve
.PP
This creates an ext2 external journal on \f(CW\*(C`device\*(C'\fR with \s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mkfifo"
.IX Subsection "guestfs_mkfifo"
.Vb 4
\& int
\& guestfs_mkfifo (guestfs_h *g,
\&                 int mode,
\&                 const char *path);
.Ve
.PP
This call creates a \s-1FIFO\s0 (named pipe) called \f(CW\*(C`path\*(C'\fR with mode \f(CW\*(C`mode\*(C'\fR.  It
is just a convenient wrapper around \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
The mode actually set is affected by the umask.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mkfs"
.IX Subsection "guestfs_mkfs"
.Vb 4
\& int
\& guestfs_mkfs (guestfs_h *g,
\&               const char *fstype,
\&               const char *device);
.Ve
.PP
This creates a filesystem on \f(CW\*(C`device\*(C'\fR (usually a partition or \s-1LVM\s0 logical
volume).  The filesystem type is \f(CW\*(C`fstype\*(C'\fR, for example \f(CW\*(C`ext3\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_mkfs_b"
.IX Subsection "guestfs_mkfs_b"
.Vb 5
\& int
\& guestfs_mkfs_b (guestfs_h *g,
\&                 const char *fstype,
\&                 int blocksize,
\&                 const char *device);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_mkfs_opts\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This call is similar to \f(CW\*(C`guestfs_mkfs\*(C'\fR, but it allows you to control the
block size of the resulting filesystem.  Supported block sizes depend on the
filesystem type, but typically they are \f(CW1024\fR, \f(CW2048\fR or \f(CW4096\fR only.
.PP
For \s-1VFAT\s0 and \s-1NTFS\s0 the \f(CW\*(C`blocksize\*(C'\fR parameter is treated as the requested
cluster size.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mkfs_opts"
.IX Subsection "guestfs_mkfs_opts"
.Vb 5
\& int
\& guestfs_mkfs_opts (guestfs_h *g,
\&                    const char *fstype,
\&                    const char *device,
\&                    ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 4
\& GUESTFS_MKFS_OPTS_BLOCKSIZE, int blocksize,
\& GUESTFS_MKFS_OPTS_FEATURES, const char *features,
\& GUESTFS_MKFS_OPTS_INODE, int inode,
\& GUESTFS_MKFS_OPTS_SECTORSIZE, int sectorsize,
.Ve
.PP
This function creates a filesystem on \f(CW\*(C`device\*(C'\fR.  The filesystem type is
\&\f(CW\*(C`fstype\*(C'\fR, for example \f(CW\*(C`ext3\*(C'\fR.
.PP
The optional arguments are:
.ie n .IP """blocksize""" 4
.el .IP "\f(CWblocksize\fR" 4
.IX Item "blocksize"
The filesystem block size.  Supported block sizes depend on the filesystem
type, but typically they are \f(CW1024\fR, \f(CW2048\fR or \f(CW4096\fR for Linux ext2/3
filesystems.
.Sp
For \s-1VFAT\s0 and \s-1NTFS\s0 the \f(CW\*(C`blocksize\*(C'\fR parameter is treated as the requested
cluster size.
.Sp
For \s-1UFS\s0 block sizes, please see \fImkfs.ufs\fR\|(8).
.ie n .IP """features""" 4
.el .IP "\f(CWfeatures\fR" 4
.IX Item "features"
This passes the \fI\-O\fR parameter to the external mkfs program.
.Sp
For certain filesystem types, this allows extra filesystem features to be
selected.  See \fImke2fs\fR\|(8) and \fImkfs.ufs\fR\|(8) for more details.
.Sp
You cannot use this optional parameter with the \f(CW\*(C`gfs\*(C'\fR or \f(CW\*(C`gfs2\*(C'\fR filesystem
type.
.ie n .IP """inode""" 4
.el .IP "\f(CWinode\fR" 4
.IX Item "inode"
This passes the \fI\-I\fR parameter to the external \fImke2fs\fR\|(8) program which
sets the inode size (only for ext2/3/4 filesystems at present).
.ie n .IP """sectorsize""" 4
.el .IP "\f(CWsectorsize\fR" 4
.IX Item "sectorsize"
This passes the \fI\-S\fR parameter to external \fImkfs.ufs\fR\|(8) program, which
sets sector size for ufs filesystem.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.7.19)
.SS "guestfs_mkfs_opts_va"
.IX Subsection "guestfs_mkfs_opts_va"
.Vb 5
\& int
\& guestfs_mkfs_opts_va (guestfs_h *g,
\&                       const char *fstype,
\&                       const char *device,
\&                       va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_mkfs_opts\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_mkfs_opts_argv"
.IX Subsection "guestfs_mkfs_opts_argv"
.Vb 5
\& int
\& guestfs_mkfs_opts_argv (guestfs_h *g,
\&                         const char *fstype,
\&                         const char *device,
\&                         const struct guestfs_mkfs_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_mkfs_opts\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_mkmountpoint"
.IX Subsection "guestfs_mkmountpoint"
.Vb 3
\& int
\& guestfs_mkmountpoint (guestfs_h *g,
\&                       const char *exemptpath);
.Ve
.PP
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR and \f(CW\*(C`guestfs_rmmountpoint\*(C'\fR are specialized calls
that can be used to create extra mountpoints before mounting the first
filesystem.
.PP
These calls are \fIonly\fR necessary in some very limited circumstances, mainly
the case where you want to mount a mix of unrelated and/or read-only
filesystems together.
.PP
For example, live CDs often contain a \*(L"Russian doll\*(R" nest of filesystems, an
\&\s-1ISO\s0 outer layer, with a squashfs image inside, with an ext2/3 image inside
that.  You can unpack this as follows in guestfish:
.PP
.Vb 8
\& add\-ro Fedora\-11\-i686\-Live.iso
\& run
\& mkmountpoint /cd
\& mkmountpoint /sqsh
\& mkmountpoint /ext3fs
\& mount /dev/sda /cd
\& mount\-loop /cd/LiveOS/squashfs.img /sqsh
\& mount\-loop /sqsh/LiveOS/ext3fs.img /ext3fs
.Ve
.PP
The inner filesystem is now unpacked under the /ext3fs mountpoint.
.PP
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR is not compatible with \f(CW\*(C`guestfs_umount_all\*(C'\fR.  You
may get unexpected errors if you try to mix these calls.  It is safest to
manually unmount filesystems and remove mountpoints after use.
.PP
\&\f(CW\*(C`guestfs_umount_all\*(C'\fR unmounts filesystems by sorting the paths longest
first, so for this to work for manual mountpoints, you must ensure that the
innermost mountpoints have the longest pathnames, as in the example code
above.
.PP
For more details see <https://bugzilla.redhat.com/show_bug.cgi?id=599503>
.PP
Autosync [see \f(CW\*(C`guestfs_set_autosync\*(C'\fR, this is set by default on handles]
can cause \f(CW\*(C`guestfs_umount_all\*(C'\fR to be called when the handle is closed which
can also trigger these issues.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.62)
.SS "guestfs_mknod"
.IX Subsection "guestfs_mknod"
.Vb 6
\& int
\& guestfs_mknod (guestfs_h *g,
\&                int mode,
\&                int devmajor,
\&                int devminor,
\&                const char *path);
.Ve
.PP
This call creates block or character special devices, or named pipes
(FIFOs).
.PP
The \f(CW\*(C`mode\*(C'\fR parameter should be the mode, using the standard constants.
\&\f(CW\*(C`devmajor\*(C'\fR and \f(CW\*(C`devminor\*(C'\fR are the device major and minor numbers, only
used when creating block and character special devices.
.PP
Note that, just like \fImknod\fR\|(2), the mode must be bitwise \s-1OR\s0'd with
S_IFBLK, S_IFCHR, S_IFIFO or S_IFSOCK (otherwise this call just creates a
regular file).  These constants are available in the standard Linux header
files, or you can use \f(CW\*(C`guestfs_mknod_b\*(C'\fR, \f(CW\*(C`guestfs_mknod_c\*(C'\fR or
\&\f(CW\*(C`guestfs_mkfifo\*(C'\fR which are wrappers around this command which bitwise \s-1OR\s0 in
the appropriate constant for you.
.PP
The mode actually set is affected by the umask.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mknod_b"
.IX Subsection "guestfs_mknod_b"
.Vb 6
\& int
\& guestfs_mknod_b (guestfs_h *g,
\&                  int mode,
\&                  int devmajor,
\&                  int devminor,
\&                  const char *path);
.Ve
.PP
This call creates a block device node called \f(CW\*(C`path\*(C'\fR with mode \f(CW\*(C`mode\*(C'\fR and
device major/minor \f(CW\*(C`devmajor\*(C'\fR and \f(CW\*(C`devminor\*(C'\fR.  It is just a convenient
wrapper around \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
The mode actually set is affected by the umask.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mknod_c"
.IX Subsection "guestfs_mknod_c"
.Vb 6
\& int
\& guestfs_mknod_c (guestfs_h *g,
\&                  int mode,
\&                  int devmajor,
\&                  int devminor,
\&                  const char *path);
.Ve
.PP
This call creates a char device node called \f(CW\*(C`path\*(C'\fR with mode \f(CW\*(C`mode\*(C'\fR and
device major/minor \f(CW\*(C`devmajor\*(C'\fR and \f(CW\*(C`devminor\*(C'\fR.  It is just a convenient
wrapper around \f(CW\*(C`guestfs_mknod\*(C'\fR.
.PP
The mode actually set is affected by the umask.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mkswap"
.IX Subsection "guestfs_mkswap"
.Vb 3
\& int
\& guestfs_mkswap (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
Create a swap partition on \f(CW\*(C`device\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mkswap_L"
.IX Subsection "guestfs_mkswap_L"
.Vb 4
\& int
\& guestfs_mkswap_L (guestfs_h *g,
\&                   const char *label,
\&                   const char *device);
.Ve
.PP
Create a swap partition on \f(CW\*(C`device\*(C'\fR with label \f(CW\*(C`label\*(C'\fR.
.PP
Note that you cannot attach a swap label to a block device
(eg. \f(CW\*(C`/dev/sda\*(C'\fR), just to a partition.  This appears to be a limitation of
the kernel or swap tools.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mkswap_U"
.IX Subsection "guestfs_mkswap_U"
.Vb 4
\& int
\& guestfs_mkswap_U (guestfs_h *g,
\&                   const char *uuid,
\&                   const char *device);
.Ve
.PP
Create a swap partition on \f(CW\*(C`device\*(C'\fR with \s-1UUID\s0 \f(CW\*(C`uuid\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_mkswap_file"
.IX Subsection "guestfs_mkswap_file"
.Vb 3
\& int
\& guestfs_mkswap_file (guestfs_h *g,
\&                      const char *path);
.Ve
.PP
Create a swap file.
.PP
This command just writes a swap file signature to an existing file.  To
create the file itself, use something like \f(CW\*(C`guestfs_fallocate\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_modprobe"
.IX Subsection "guestfs_modprobe"
.Vb 3
\& int
\& guestfs_modprobe (guestfs_h *g,
\&                   const char *modulename);
.Ve
.PP
This loads a kernel module in the appliance.
.PP
The kernel module must have been whitelisted when libguestfs was built (see
\&\f(CW\*(C`appliance/kmod.whitelist.in\*(C'\fR in the source).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.68)
.SS "guestfs_mount"
.IX Subsection "guestfs_mount"
.Vb 4
\& int
\& guestfs_mount (guestfs_h *g,
\&                const char *device,
\&                const char *mountpoint);
.Ve
.PP
Mount a guest disk at a position in the filesystem.  Block devices are named
\&\f(CW\*(C`/dev/sda\*(C'\fR, \f(CW\*(C`/dev/sdb\*(C'\fR and so on, as they were added to the guest.  If
those block devices contain partitions, they will have the usual names
(eg. \f(CW\*(C`/dev/sda1\*(C'\fR).  Also \s-1LVM\s0 \f(CW\*(C`/dev/VG/LV\*(C'\fR\-style names can be used.
.PP
The rules are the same as for \fImount\fR\|(2): A filesystem must first be
mounted on \f(CW\*(C`/\*(C'\fR before others can be mounted.  Other filesystems can only be
mounted on directories which already exist.
.PP
The mounted filesystem is writable, if we have sufficient permissions on the
underlying device.
.PP
Before libguestfs 1.13.16, this call implicitly added the options \f(CW\*(C`sync\*(C'\fR
and \f(CW\*(C`noatime\*(C'\fR.  The \f(CW\*(C`sync\*(C'\fR option greatly slowed writes and caused many
problems for users.  If your program might need to work with older versions
of libguestfs, use \f(CW\*(C`guestfs_mount_options\*(C'\fR instead (using an empty string
for the first parameter if you don't want any options).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_mount_9p"
.IX Subsection "guestfs_mount_9p"
.Vb 5
\& int
\& guestfs_mount_9p (guestfs_h *g,
\&                   const char *mounttag,
\&                   const char *mountpoint,
\&                   ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 1
\& GUESTFS_MOUNT_9P_OPTIONS, const char *options,
.Ve
.PP
Mount the virtio\-9p filesystem with the tag \f(CW\*(C`mounttag\*(C'\fR on the directory
\&\f(CW\*(C`mountpoint\*(C'\fR.
.PP
If required, \f(CW\*(C`trans=virtio\*(C'\fR will be automatically added to the options.
Any other options required can be passed in the optional \f(CW\*(C`options\*(C'\fR
parameter.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.11.12)
.SS "guestfs_mount_9p_va"
.IX Subsection "guestfs_mount_9p_va"
.Vb 5
\& int
\& guestfs_mount_9p_va (guestfs_h *g,
\&                      const char *mounttag,
\&                      const char *mountpoint,
\&                      va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_mount_9p\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_mount_9p_argv"
.IX Subsection "guestfs_mount_9p_argv"
.Vb 5
\& int
\& guestfs_mount_9p_argv (guestfs_h *g,
\&                        const char *mounttag,
\&                        const char *mountpoint,
\&                        const struct guestfs_mount_9p_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_mount_9p\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_mount_loop"
.IX Subsection "guestfs_mount_loop"
.Vb 4
\& int
\& guestfs_mount_loop (guestfs_h *g,
\&                     const char *file,
\&                     const char *mountpoint);
.Ve
.PP
This command lets you mount \f(CW\*(C`file\*(C'\fR (a filesystem image in a file) on a
mount point.  It is entirely equivalent to the command \f(CW\*(C`mount \-o loop file
mountpoint\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.54)
.SS "guestfs_mount_options"
.IX Subsection "guestfs_mount_options"
.Vb 5
\& int
\& guestfs_mount_options (guestfs_h *g,
\&                        const char *options,
\&                        const char *device,
\&                        const char *mountpoint);
.Ve
.PP
This is the same as the \f(CW\*(C`guestfs_mount\*(C'\fR command, but it allows you to set
the mount options as for the \fImount\fR\|(8) \fI\-o\fR flag.
.PP
If the \f(CW\*(C`options\*(C'\fR parameter is an empty string, then no options are passed
(all options default to whatever the filesystem uses).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.10)
.SS "guestfs_mount_ro"
.IX Subsection "guestfs_mount_ro"
.Vb 4
\& int
\& guestfs_mount_ro (guestfs_h *g,
\&                   const char *device,
\&                   const char *mountpoint);
.Ve
.PP
This is the same as the \f(CW\*(C`guestfs_mount\*(C'\fR command, but it mounts the
filesystem with the read-only (\fI\-o ro\fR) flag.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.10)
.SS "guestfs_mount_vfs"
.IX Subsection "guestfs_mount_vfs"
.Vb 6
\& int
\& guestfs_mount_vfs (guestfs_h *g,
\&                    const char *options,
\&                    const char *vfstype,
\&                    const char *device,
\&                    const char *mountpoint);
.Ve
.PP
This is the same as the \f(CW\*(C`guestfs_mount\*(C'\fR command, but it allows you to set
both the mount options and the vfstype as for the \fImount\fR\|(8) \fI\-o\fR and
\&\fI\-t\fR flags.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.10)
.SS "guestfs_mountpoints"
.IX Subsection "guestfs_mountpoints"
.Vb 2
\& char **
\& guestfs_mountpoints (guestfs_h *g);
.Ve
.PP
This call is similar to \f(CW\*(C`guestfs_mounts\*(C'\fR.  That call returns a list of
devices.  This one returns a hash table (map) of device name to directory
where the device is mounted.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 1.0.62)
.SS "guestfs_mounts"
.IX Subsection "guestfs_mounts"
.Vb 2
\& char **
\& guestfs_mounts (guestfs_h *g);
.Ve
.PP
This returns the list of currently mounted filesystems.  It returns the list
of devices (eg. \f(CW\*(C`/dev/sda1\*(C'\fR, \f(CW\*(C`/dev/VG/LV\*(C'\fR).
.PP
Some internal mounts are not shown.
.PP
See also: \f(CW\*(C`guestfs_mountpoints\*(C'\fR
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.8)
.SS "guestfs_mv"
.IX Subsection "guestfs_mv"
.Vb 4
\& int
\& guestfs_mv (guestfs_h *g,
\&             const char *src,
\&             const char *dest);
.Ve
.PP
This moves a file from \f(CW\*(C`src\*(C'\fR to \f(CW\*(C`dest\*(C'\fR where \f(CW\*(C`dest\*(C'\fR is either a
destination filename or destination directory.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.18)
.SS "guestfs_ntfs_3g_probe"
.IX Subsection "guestfs_ntfs_3g_probe"
.Vb 4
\& int
\& guestfs_ntfs_3g_probe (guestfs_h *g,
\&                        int rw,
\&                        const char *device);
.Ve
.PP
This command runs the \fIntfs\-3g.probe\fR\|(8) command which probes an \s-1NTFS\s0
\&\f(CW\*(C`device\*(C'\fR for mountability.  (Not all \s-1NTFS\s0 volumes can be mounted
read-write, and some cannot be mounted at all).
.PP
\&\f(CW\*(C`rw\*(C'\fR is a boolean flag.  Set it to true if you want to test if the volume
can be mounted read-write.  Set it to false if you want to test if the
volume can be mounted read-only.
.PP
The return value is an integer which \f(CW0\fR if the operation would succeed, or
some non-zero value documented in the \fIntfs\-3g.probe\fR\|(8) manual page.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.43)
.SS "guestfs_ntfsresize"
.IX Subsection "guestfs_ntfsresize"
.Vb 3
\& int
\& guestfs_ntfsresize (guestfs_h *g,
\&                     const char *device);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_ntfsresize_opts\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command resizes an \s-1NTFS\s0 filesystem, expanding or shrinking it to the
size of the underlying device.
.PP
\&\fINote:\fR After the resize operation, the filesystem is marked as requiring a
consistency check (for safety).  You have to boot into Windows to perform
this check and clear this condition.  Furthermore, ntfsresize refuses to
resize filesystems which have been marked in this way.  So in effect it is
not possible to call ntfsresize multiple times on a single filesystem
without booting into Windows between each resize.
.PP
See also \fIntfsresize\fR\|(8).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_ntfsresize_opts"
.IX Subsection "guestfs_ntfsresize_opts"
.Vb 4
\& int
\& guestfs_ntfsresize_opts (guestfs_h *g,
\&                          const char *device,
\&                          ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 2
\& GUESTFS_NTFSRESIZE_OPTS_SIZE, int64_t size,
\& GUESTFS_NTFSRESIZE_OPTS_FORCE, int force,
.Ve
.PP
This command resizes an \s-1NTFS\s0 filesystem, expanding or shrinking it to the
size of the underlying device.
.PP
The optional parameters are:
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
The new size (in bytes) of the filesystem.  If omitted, the filesystem is
resized to fit the container (eg. partition).
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
If this option is true, then force the resize of the filesystem even if the
filesystem is marked as requiring a consistency check.
.Sp
After the resize operation, the filesystem is always marked as requiring a
consistency check (for safety).  You have to boot into Windows to perform
this check and clear this condition.  If you \fIdon't\fR set the \f(CW\*(C`force\*(C'\fR
option then it is not possible to call \f(CW\*(C`guestfs_ntfsresize_opts\*(C'\fR multiple
times on a single filesystem without booting into Windows between each
resize.
.PP
See also \fIntfsresize\fR\|(8).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.11.15)
.SS "guestfs_ntfsresize_opts_va"
.IX Subsection "guestfs_ntfsresize_opts_va"
.Vb 4
\& int
\& guestfs_ntfsresize_opts_va (guestfs_h *g,
\&                             const char *device,
\&                             va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_ntfsresize_opts\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_ntfsresize_opts_argv"
.IX Subsection "guestfs_ntfsresize_opts_argv"
.Vb 4
\& int
\& guestfs_ntfsresize_opts_argv (guestfs_h *g,
\&                               const char *device,
\&                               const struct guestfs_ntfsresize_opts_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_ntfsresize_opts\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_ntfsresize_size"
.IX Subsection "guestfs_ntfsresize_size"
.Vb 4
\& int
\& guestfs_ntfsresize_size (guestfs_h *g,
\&                          const char *device,
\&                          int64_t size);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the
\&\*(L"guestfs_ntfsresize_opts\*(R" call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command is the same as \f(CW\*(C`guestfs_ntfsresize\*(C'\fR except that it allows you
to specify the new size (in bytes) explicitly.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.14)
.SS "guestfs_part_add"
.IX Subsection "guestfs_part_add"
.Vb 6
\& int
\& guestfs_part_add (guestfs_h *g,
\&                   const char *device,
\&                   const char *prlogex,
\&                   int64_t startsect,
\&                   int64_t endsect);
.Ve
.PP
This command adds a partition to \f(CW\*(C`device\*(C'\fR.  If there is no partition table
on the device, call \f(CW\*(C`guestfs_part_init\*(C'\fR first.
.PP
The \f(CW\*(C`prlogex\*(C'\fR parameter is the type of partition.  Normally you should pass
\&\f(CW\*(C`p\*(C'\fR or \f(CW\*(C`primary\*(C'\fR here, but \s-1MBR\s0 partition tables also support \f(CW\*(C`l\*(C'\fR (or
\&\f(CW\*(C`logical\*(C'\fR) and \f(CW\*(C`e\*(C'\fR (or \f(CW\*(C`extended\*(C'\fR) partition types.
.PP
\&\f(CW\*(C`startsect\*(C'\fR and \f(CW\*(C`endsect\*(C'\fR are the start and end of the partition in
\&\fIsectors\fR.  \f(CW\*(C`endsect\*(C'\fR may be negative, which means it counts backwards
from the end of the disk (\f(CW\*(C`\-1\*(C'\fR is the last sector).
.PP
Creating a partition which covers the whole disk is not so easy.  Use
\&\f(CW\*(C`guestfs_part_disk\*(C'\fR to do that.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.78)
.SS "guestfs_part_del"
.IX Subsection "guestfs_part_del"
.Vb 4
\& int
\& guestfs_part_del (guestfs_h *g,
\&                   const char *device,
\&                   int partnum);
.Ve
.PP
This command deletes the partition numbered \f(CW\*(C`partnum\*(C'\fR on \f(CW\*(C`device\*(C'\fR.
.PP
Note that in the case of \s-1MBR\s0 partitioning, deleting an extended partition
also deletes any logical partitions it contains.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_part_disk"
.IX Subsection "guestfs_part_disk"
.Vb 4
\& int
\& guestfs_part_disk (guestfs_h *g,
\&                    const char *device,
\&                    const char *parttype);
.Ve
.PP
This command is simply a combination of \f(CW\*(C`guestfs_part_init\*(C'\fR followed by
\&\f(CW\*(C`guestfs_part_add\*(C'\fR to create a single primary partition covering the whole
disk.
.PP
\&\f(CW\*(C`parttype\*(C'\fR is the partition table type, usually \f(CW\*(C`mbr\*(C'\fR or \f(CW\*(C`gpt\*(C'\fR, but other
possible values are described in \f(CW\*(C`guestfs_part_init\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.78)
.SS "guestfs_part_get_bootable"
.IX Subsection "guestfs_part_get_bootable"
.Vb 4
\& int
\& guestfs_part_get_bootable (guestfs_h *g,
\&                            const char *device,
\&                            int partnum);
.Ve
.PP
This command returns true if the partition \f(CW\*(C`partnum\*(C'\fR on \f(CW\*(C`device\*(C'\fR has the
bootable flag set.
.PP
See also \f(CW\*(C`guestfs_part_set_bootable\*(C'\fR.
.PP
This function returns a C truth value on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_part_get_mbr_id"
.IX Subsection "guestfs_part_get_mbr_id"
.Vb 4
\& int
\& guestfs_part_get_mbr_id (guestfs_h *g,
\&                          const char *device,
\&                          int partnum);
.Ve
.PP
Returns the \s-1MBR\s0 type byte (also known as the \s-1ID\s0 byte) from the numbered
partition \f(CW\*(C`partnum\*(C'\fR.
.PP
Note that only \s-1MBR\s0 (old DOS-style) partitions have type bytes.  You will get
undefined results for other partition table types (see
\&\f(CW\*(C`guestfs_part_get_parttype\*(C'\fR).
.PP
On error this function returns \-1.
.PP
(Added in 1.3.2)
.SS "guestfs_part_get_parttype"
.IX Subsection "guestfs_part_get_parttype"
.Vb 3
\& char *
\& guestfs_part_get_parttype (guestfs_h *g,
\&                            const char *device);
.Ve
.PP
This command examines the partition table on \f(CW\*(C`device\*(C'\fR and returns the
partition table type (format) being used.
.PP
Common return values include: \f(CW\*(C`msdos\*(C'\fR (a DOS/Windows style \s-1MBR\s0 partition
table), \f(CW\*(C`gpt\*(C'\fR (a GPT/EFI\-style partition table).  Other values are
possible, although unusual.  See \f(CW\*(C`guestfs_part_init\*(C'\fR for a full list.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.78)
.SS "guestfs_part_init"
.IX Subsection "guestfs_part_init"
.Vb 4
\& int
\& guestfs_part_init (guestfs_h *g,
\&                    const char *device,
\&                    const char *parttype);
.Ve
.PP
This creates an empty partition table on \f(CW\*(C`device\*(C'\fR of one of the partition
types listed below.  Usually \f(CW\*(C`parttype\*(C'\fR should be either \f(CW\*(C`msdos\*(C'\fR or \f(CW\*(C`gpt\*(C'\fR
(for large disks).
.PP
Initially there are no partitions.  Following this, you should call
\&\f(CW\*(C`guestfs_part_add\*(C'\fR for each partition required.
.PP
Possible values for \f(CW\*(C`parttype\*(C'\fR are:
.IP "\fBefi\fR" 4
.IX Item "efi"
.PD 0
.IP "\fBgpt\fR" 4
.IX Item "gpt"
.PD
Intel \s-1EFI\s0 / \s-1GPT\s0 partition table.
.Sp
This is recommended for >= 2 \s-1TB\s0 partitions that will be accessed from Linux
and Intel-based Mac \s-1OS\s0 X.  It also has limited backwards compatibility with
the \f(CW\*(C`mbr\*(C'\fR format.
.IP "\fBmbr\fR" 4
.IX Item "mbr"
.PD 0
.IP "\fBmsdos\fR" 4
.IX Item "msdos"
.PD
The standard \s-1PC\s0 \*(L"Master Boot Record\*(R" (\s-1MBR\s0) format used by MS-DOS and
Windows.  This partition type will \fBonly\fR work for device sizes up to 2
\&\s-1TB\s0.  For large disks we recommend using \f(CW\*(C`gpt\*(C'\fR.
.PP
Other partition table types that may work but are not supported include:
.IP "\fBaix\fR" 4
.IX Item "aix"
\&\s-1AIX\s0 disk labels.
.IP "\fBamiga\fR" 4
.IX Item "amiga"
.PD 0
.IP "\fBrdb\fR" 4
.IX Item "rdb"
.PD
Amiga \*(L"Rigid Disk Block\*(R" format.
.IP "\fBbsd\fR" 4
.IX Item "bsd"
\&\s-1BSD\s0 disk labels.
.IP "\fBdasd\fR" 4
.IX Item "dasd"
\&\s-1DASD\s0, used on \s-1IBM\s0 mainframes.
.IP "\fBdvh\fR" 4
.IX Item "dvh"
\&\s-1MIPS/SGI\s0 volumes.
.IP "\fBmac\fR" 4
.IX Item "mac"
Old Mac partition format.  Modern Macs use \f(CW\*(C`gpt\*(C'\fR.
.IP "\fBpc98\fR" 4
.IX Item "pc98"
\&\s-1NEC\s0 \s-1PC\-98\s0 format, common in Japan apparently.
.IP "\fBsun\fR" 4
.IX Item "sun"
Sun disk labels.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.78)
.SS "guestfs_part_list"
.IX Subsection "guestfs_part_list"
.Vb 3
\& struct guestfs_partition_list *
\& guestfs_part_list (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This command parses the partition table on \f(CW\*(C`device\*(C'\fR and returns the list of
partitions found.
.PP
The fields in the returned structure are:
.IP "\fBpart_num\fR" 4
.IX Item "part_num"
Partition number, counting from 1.
.IP "\fBpart_start\fR" 4
.IX Item "part_start"
Start of the partition \fIin bytes\fR.  To get sectors you have to divide by
the device's sector size, see \f(CW\*(C`guestfs_blockdev_getss\*(C'\fR.
.IP "\fBpart_end\fR" 4
.IX Item "part_end"
End of the partition in bytes.
.IP "\fBpart_size\fR" 4
.IX Item "part_size"
Size of the partition in bytes.
.PP
This function returns a \f(CW\*(C`struct guestfs_partition_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_partition_list\*(C'\fI after
use\fR.
.PP
(Added in 1.0.78)
.SS "guestfs_part_set_bootable"
.IX Subsection "guestfs_part_set_bootable"
.Vb 5
\& int
\& guestfs_part_set_bootable (guestfs_h *g,
\&                            const char *device,
\&                            int partnum,
\&                            int bootable);
.Ve
.PP
This sets the bootable flag on partition numbered \f(CW\*(C`partnum\*(C'\fR on device
\&\f(CW\*(C`device\*(C'\fR.  Note that partitions are numbered from 1.
.PP
The bootable flag is used by some operating systems (notably Windows) to
determine which partition to boot from.  It is by no means universally
recognized.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.78)
.SS "guestfs_part_set_mbr_id"
.IX Subsection "guestfs_part_set_mbr_id"
.Vb 5
\& int
\& guestfs_part_set_mbr_id (guestfs_h *g,
\&                          const char *device,
\&                          int partnum,
\&                          int idbyte);
.Ve
.PP
Sets the \s-1MBR\s0 type byte (also known as the \s-1ID\s0 byte) of the numbered partition
\&\f(CW\*(C`partnum\*(C'\fR to \f(CW\*(C`idbyte\*(C'\fR.  Note that the type bytes quoted in most
documentation are in fact hexadecimal numbers, but usually documented
without any leading \*(L"0x\*(R" which might be confusing.
.PP
Note that only \s-1MBR\s0 (old DOS-style) partitions have type bytes.  You will get
undefined results for other partition table types (see
\&\f(CW\*(C`guestfs_part_get_parttype\*(C'\fR).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_part_set_name"
.IX Subsection "guestfs_part_set_name"
.Vb 5
\& int
\& guestfs_part_set_name (guestfs_h *g,
\&                        const char *device,
\&                        int partnum,
\&                        const char *name);
.Ve
.PP
This sets the partition name on partition numbered \f(CW\*(C`partnum\*(C'\fR on device
\&\f(CW\*(C`device\*(C'\fR.  Note that partitions are numbered from 1.
.PP
The partition name can only be set on certain types of partition table.
This works on \f(CW\*(C`gpt\*(C'\fR but not on \f(CW\*(C`mbr\*(C'\fR partitions.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.78)
.SS "guestfs_part_to_dev"
.IX Subsection "guestfs_part_to_dev"
.Vb 3
\& char *
\& guestfs_part_to_dev (guestfs_h *g,
\&                      const char *partition);
.Ve
.PP
This function takes a partition name (eg. \*(L"/dev/sdb1\*(R") and removes the
partition number, returning the device name (eg. \*(L"/dev/sdb\*(R").
.PP
The named partition must exist, for example as a string returned from
\&\f(CW\*(C`guestfs_list_partitions\*(C'\fR.
.PP
See also \f(CW\*(C`guestfs_part_to_partnum\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.5.15)
.SS "guestfs_part_to_partnum"
.IX Subsection "guestfs_part_to_partnum"
.Vb 3
\& int
\& guestfs_part_to_partnum (guestfs_h *g,
\&                          const char *partition);
.Ve
.PP
This function takes a partition name (eg. \*(L"/dev/sdb1\*(R") and returns the
partition number (eg. \f(CW1\fR).
.PP
The named partition must exist, for example as a string returned from
\&\f(CW\*(C`guestfs_list_partitions\*(C'\fR.
.PP
See also \f(CW\*(C`guestfs_part_to_dev\*(C'\fR.
.PP
On error this function returns \-1.
.PP
(Added in 1.13.25)
.SS "guestfs_ping_daemon"
.IX Subsection "guestfs_ping_daemon"
.Vb 2
\& int
\& guestfs_ping_daemon (guestfs_h *g);
.Ve
.PP
This is a test probe into the guestfs daemon running inside the qemu
subprocess.  Calling this function checks that the daemon responds to the
ping message, without affecting the daemon or attached block device(s) in
any other way.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.18)
.SS "guestfs_pread"
.IX Subsection "guestfs_pread"
.Vb 6
\& char *
\& guestfs_pread (guestfs_h *g,
\&                const char *path,
\&                int count,
\&                int64_t offset,
\&                size_t *size_r);
.Ve
.PP
This command lets you read part of a file.  It reads \f(CW\*(C`count\*(C'\fR bytes of the
file, starting at \f(CW\*(C`offset\*(C'\fR, from file \f(CW\*(C`path\*(C'\fR.
.PP
This may read fewer bytes than requested.  For further details see the
\&\fIpread\fR\|(2) system call.
.PP
See also \f(CW\*(C`guestfs_pwrite\*(C'\fR, \f(CW\*(C`guestfs_pread_device\*(C'\fR.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.77)
.SS "guestfs_pread_device"
.IX Subsection "guestfs_pread_device"
.Vb 6
\& char *
\& guestfs_pread_device (guestfs_h *g,
\&                       const char *device,
\&                       int count,
\&                       int64_t offset,
\&                       size_t *size_r);
.Ve
.PP
This command lets you read part of a file.  It reads \f(CW\*(C`count\*(C'\fR bytes of
\&\f(CW\*(C`device\*(C'\fR, starting at \f(CW\*(C`offset\*(C'\fR.
.PP
This may read fewer bytes than requested.  For further details see the
\&\fIpread\fR\|(2) system call.
.PP
See also \f(CW\*(C`guestfs_pread\*(C'\fR.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.5.21)
.SS "guestfs_pvcreate"
.IX Subsection "guestfs_pvcreate"
.Vb 3
\& int
\& guestfs_pvcreate (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This creates an \s-1LVM\s0 physical volume on the named \f(CW\*(C`device\*(C'\fR, where \f(CW\*(C`device\*(C'\fR
should usually be a partition name such as \f(CW\*(C`/dev/sda1\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_pvremove"
.IX Subsection "guestfs_pvremove"
.Vb 3
\& int
\& guestfs_pvremove (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This wipes a physical volume \f(CW\*(C`device\*(C'\fR so that \s-1LVM\s0 will no longer recognise
it.
.PP
The implementation uses the \f(CW\*(C`pvremove\*(C'\fR command which refuses to wipe
physical volumes that contain any volume groups, so you have to remove those
first.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.13)
.SS "guestfs_pvresize"
.IX Subsection "guestfs_pvresize"
.Vb 3
\& int
\& guestfs_pvresize (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This resizes (expands or shrinks) an existing \s-1LVM\s0 physical volume to match
the new size of the underlying device.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.26)
.SS "guestfs_pvresize_size"
.IX Subsection "guestfs_pvresize_size"
.Vb 4
\& int
\& guestfs_pvresize_size (guestfs_h *g,
\&                        const char *device,
\&                        int64_t size);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_pvresize\*(C'\fR except that it allows you to
specify the new size (in bytes) explicitly.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.14)
.SS "guestfs_pvs"
.IX Subsection "guestfs_pvs"
.Vb 2
\& char **
\& guestfs_pvs (guestfs_h *g);
.Ve
.PP
List all the physical volumes detected.  This is the equivalent of the
\&\fIpvs\fR\|(8) command.
.PP
This returns a list of just the device names that contain PVs
(eg. \f(CW\*(C`/dev/sda2\*(C'\fR).
.PP
See also \f(CW\*(C`guestfs_pvs_full\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_pvs_full"
.IX Subsection "guestfs_pvs_full"
.Vb 2
\& struct guestfs_lvm_pv_list *
\& guestfs_pvs_full (guestfs_h *g);
.Ve
.PP
List all the physical volumes detected.  This is the equivalent of the
\&\fIpvs\fR\|(8) command.  The \*(L"full\*(R" version includes all fields.
.PP
This function returns a \f(CW\*(C`struct guestfs_lvm_pv_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_lvm_pv_list\*(C'\fI after
use\fR.
.PP
(Added in 0.4)
.SS "guestfs_pvuuid"
.IX Subsection "guestfs_pvuuid"
.Vb 3
\& char *
\& guestfs_pvuuid (guestfs_h *g,
\&                 const char *device);
.Ve
.PP
This command returns the \s-1UUID\s0 of the \s-1LVM\s0 \s-1PV\s0 \f(CW\*(C`device\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.87)
.SS "guestfs_pwrite"
.IX Subsection "guestfs_pwrite"
.Vb 6
\& int
\& guestfs_pwrite (guestfs_h *g,
\&                 const char *path,
\&                 const char *content,
\&                 size_t content_size,
\&                 int64_t offset);
.Ve
.PP
This command writes to part of a file.  It writes the data buffer \f(CW\*(C`content\*(C'\fR
to the file \f(CW\*(C`path\*(C'\fR starting at offset \f(CW\*(C`offset\*(C'\fR.
.PP
This command implements the \fIpwrite\fR\|(2) system call, and like that system
call it may not write the full data requested.  The return value is the
number of bytes that were actually written to the file.  This could even be
0, although short writes are unlikely for regular files in ordinary
circumstances.
.PP
See also \f(CW\*(C`guestfs_pread\*(C'\fR, \f(CW\*(C`guestfs_pwrite_device\*(C'\fR.
.PP
On error this function returns \-1.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.3.14)
.SS "guestfs_pwrite_device"
.IX Subsection "guestfs_pwrite_device"
.Vb 6
\& int
\& guestfs_pwrite_device (guestfs_h *g,
\&                        const char *device,
\&                        const char *content,
\&                        size_t content_size,
\&                        int64_t offset);
.Ve
.PP
This command writes to part of a device.  It writes the data buffer
\&\f(CW\*(C`content\*(C'\fR to \f(CW\*(C`device\*(C'\fR starting at offset \f(CW\*(C`offset\*(C'\fR.
.PP
This command implements the \fIpwrite\fR\|(2) system call, and like that system
call it may not write the full data requested (although short writes to disk
devices and partitions are probably impossible with standard Linux kernels).
.PP
See also \f(CW\*(C`guestfs_pwrite\*(C'\fR.
.PP
On error this function returns \-1.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.5.20)
.SS "guestfs_read_file"
.IX Subsection "guestfs_read_file"
.Vb 4
\& char *
\& guestfs_read_file (guestfs_h *g,
\&                    const char *path,
\&                    size_t *size_r);
.Ve
.PP
This calls returns the contents of the file \f(CW\*(C`path\*(C'\fR as a buffer.
.PP
Unlike \f(CW\*(C`guestfs_cat\*(C'\fR, this function can correctly handle files that contain
embedded \s-1ASCII\s0 \s-1NUL\s0 characters.  However unlike \f(CW\*(C`guestfs_download\*(C'\fR, this
function is limited in the total size of file that can be handled.
.PP
This function returns a buffer, or \s-1NULL\s0 on error.  The size of the returned
buffer is written to \f(CW*size_r\fR.  \fIThe caller must free the returned buffer
after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.63)
.SS "guestfs_read_lines"
.IX Subsection "guestfs_read_lines"
.Vb 3
\& char **
\& guestfs_read_lines (guestfs_h *g,
\&                     const char *path);
.Ve
.PP
Return the contents of the file named \f(CW\*(C`path\*(C'\fR.
.PP
The file contents are returned as a list of lines.  Trailing \f(CW\*(C`LF\*(C'\fR and
\&\f(CW\*(C`CRLF\*(C'\fR character sequences are \fInot\fR returned.
.PP
Note that this function cannot correctly handle binary files (specifically,
files containing \f(CW\*(C`\e0\*(C'\fR character which is treated as end of line).  For
those you need to use the \f(CW\*(C`guestfs_read_file\*(C'\fR function which has a more
complex interface.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.7)
.SS "guestfs_readdir"
.IX Subsection "guestfs_readdir"
.Vb 3
\& struct guestfs_dirent_list *
\& guestfs_readdir (guestfs_h *g,
\&                  const char *dir);
.Ve
.PP
This returns the list of directory entries in directory \f(CW\*(C`dir\*(C'\fR.
.PP
All entries in the directory are returned, including \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR.  The
entries are \fInot\fR sorted, but returned in the same order as the underlying
filesystem.
.PP
Also this call returns basic file type information about each file.  The
\&\f(CW\*(C`ftyp\*(C'\fR field will contain one of the following characters:
.IP "'b'" 4
.IX Item "'b'"
Block special
.IP "'c'" 4
.IX Item "'c'"
Char special
.IP "'d'" 4
.IX Item "'d'"
Directory
.IP "'f'" 4
.IX Item "'f'"
\&\s-1FIFO\s0 (named pipe)
.IP "'l'" 4
.IX Item "'l'"
Symbolic link
.IP "'r'" 4
.IX Item "'r'"
Regular file
.IP "'s'" 4
.IX Item "'s'"
Socket
.IP "'u'" 4
.IX Item "'u'"
Unknown file type
.IP "'?'" 4
The \fIreaddir\fR\|(3) call returned a \f(CW\*(C`d_type\*(C'\fR field with an unexpected value
.PP
This function is primarily intended for use by programs.  To get a simple
list of names, use \f(CW\*(C`guestfs_ls\*(C'\fR.  To get a printable directory for human
consumption, use \f(CW\*(C`guestfs_ll\*(C'\fR.
.PP
This function returns a \f(CW\*(C`struct guestfs_dirent_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_dirent_list\*(C'\fI after
use\fR.
.PP
(Added in 1.0.55)
.SS "guestfs_readlink"
.IX Subsection "guestfs_readlink"
.Vb 3
\& char *
\& guestfs_readlink (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
This command reads the target of a symbolic link.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.66)
.SS "guestfs_readlinklist"
.IX Subsection "guestfs_readlinklist"
.Vb 4
\& char **
\& guestfs_readlinklist (guestfs_h *g,
\&                       const char *path,
\&                       char *const *names);
.Ve
.PP
This call allows you to do a \f(CW\*(C`readlink\*(C'\fR operation on multiple files, where
all files are in the directory \f(CW\*(C`path\*(C'\fR.  \f(CW\*(C`names\*(C'\fR is the list of files from
this directory.
.PP
On return you get a list of strings, with a one-to-one correspondence to the
\&\f(CW\*(C`names\*(C'\fR list.  Each string is the value of the symbolic link.
.PP
If the \f(CWreadlink(2)\fR operation fails on any name, then the corresponding
result string is the empty string \f(CW""\fR.  However the whole operation is
completed even if there were \f(CWreadlink(2)\fR errors, and so you can call this
function with names where you don't know if they are symbolic links already
(albeit slightly less efficient).
.PP
This call is intended for programs that want to efficiently list a directory
contents without making many round-trips.  Very long directory listings
might cause the protocol message size to be exceeded, causing this call to
fail.  The caller must split up such requests into smaller groups of names.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.77)
.SS "guestfs_realpath"
.IX Subsection "guestfs_realpath"
.Vb 3
\& char *
\& guestfs_realpath (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
Return the canonicalized absolute pathname of \f(CW\*(C`path\*(C'\fR.  The returned path
has no \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`..\*(C'\fR or symbolic link path elements.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.66)
.SS "guestfs_removexattr"
.IX Subsection "guestfs_removexattr"
.Vb 4
\& int
\& guestfs_removexattr (guestfs_h *g,
\&                      const char *xattr,
\&                      const char *path);
.Ve
.PP
This call removes the extended attribute named \f(CW\*(C`xattr\*(C'\fR of the file \f(CW\*(C`path\*(C'\fR.
.PP
See also: \f(CW\*(C`guestfs_lremovexattr\*(C'\fR, \fIattr\fR\|(5).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.59)
.SS "guestfs_resize2fs"
.IX Subsection "guestfs_resize2fs"
.Vb 3
\& int
\& guestfs_resize2fs (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This resizes an ext2, ext3 or ext4 filesystem to match the size of the
underlying device.
.PP
\&\fINote:\fR It is sometimes required that you run \f(CW\*(C`guestfs_e2fsck_f\*(C'\fR on the
\&\f(CW\*(C`device\*(C'\fR before calling this command.  For unknown reasons \f(CW\*(C`resize2fs\*(C'\fR
sometimes gives an error about this and sometimes not.  In any case, it is
always safe to call \f(CW\*(C`guestfs_e2fsck_f\*(C'\fR before calling this function.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.27)
.SS "guestfs_resize2fs_M"
.IX Subsection "guestfs_resize2fs_M"
.Vb 3
\& int
\& guestfs_resize2fs_M (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_resize2fs\*(C'\fR, but the filesystem is
resized to its minimum size.  This works like the \fI\-M\fR option to the
\&\f(CW\*(C`resize2fs\*(C'\fR command.
.PP
To get the resulting size of the filesystem you should call
\&\f(CW\*(C`guestfs_tune2fs_l\*(C'\fR and read the \f(CW\*(C`Block size\*(C'\fR and \f(CW\*(C`Block count\*(C'\fR values.
These two numbers, multiplied together, give the resulting size of the
minimal filesystem in bytes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.9.4)
.SS "guestfs_resize2fs_size"
.IX Subsection "guestfs_resize2fs_size"
.Vb 4
\& int
\& guestfs_resize2fs_size (guestfs_h *g,
\&                         const char *device,
\&                         int64_t size);
.Ve
.PP
This command is the same as \f(CW\*(C`guestfs_resize2fs\*(C'\fR except that it allows you
to specify the new size (in bytes) explicitly.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.14)
.SS "guestfs_rm"
.IX Subsection "guestfs_rm"
.Vb 3
\& int
\& guestfs_rm (guestfs_h *g,
\&             const char *path);
.Ve
.PP
Remove the single file \f(CW\*(C`path\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_rm_rf"
.IX Subsection "guestfs_rm_rf"
.Vb 3
\& int
\& guestfs_rm_rf (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Remove the file or directory \f(CW\*(C`path\*(C'\fR, recursively removing the contents if
its a directory.  This is like the \f(CW\*(C`rm \-rf\*(C'\fR shell command.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_rmdir"
.IX Subsection "guestfs_rmdir"
.Vb 3
\& int
\& guestfs_rmdir (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Remove the single directory \f(CW\*(C`path\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_rmmountpoint"
.IX Subsection "guestfs_rmmountpoint"
.Vb 3
\& int
\& guestfs_rmmountpoint (guestfs_h *g,
\&                       const char *exemptpath);
.Ve
.PP
This calls removes a mountpoint that was previously created with
\&\f(CW\*(C`guestfs_mkmountpoint\*(C'\fR.  See \f(CW\*(C`guestfs_mkmountpoint\*(C'\fR for full details.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.62)
.SS "guestfs_scrub_device"
.IX Subsection "guestfs_scrub_device"
.Vb 3
\& int
\& guestfs_scrub_device (guestfs_h *g,
\&                       const char *device);
.Ve
.PP
This command writes patterns over \f(CW\*(C`device\*(C'\fR to make data retrieval more
difficult.
.PP
It is an interface to the \fIscrub\fR\|(1) program.  See that manual page for
more details.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.52)
.SS "guestfs_scrub_file"
.IX Subsection "guestfs_scrub_file"
.Vb 3
\& int
\& guestfs_scrub_file (guestfs_h *g,
\&                     const char *file);
.Ve
.PP
This command writes patterns over a file to make data retrieval more
difficult.
.PP
The file is \fIremoved\fR after scrubbing.
.PP
It is an interface to the \fIscrub\fR\|(1) program.  See that manual page for
more details.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.52)
.SS "guestfs_scrub_freespace"
.IX Subsection "guestfs_scrub_freespace"
.Vb 3
\& int
\& guestfs_scrub_freespace (guestfs_h *g,
\&                          const char *dir);
.Ve
.PP
This command creates the directory \f(CW\*(C`dir\*(C'\fR and then fills it with files until
the filesystem is full, and scrubs the files as for \f(CW\*(C`guestfs_scrub_file\*(C'\fR,
and deletes them.  The intention is to scrub any free space on the partition
containing \f(CW\*(C`dir\*(C'\fR.
.PP
It is an interface to the \fIscrub\fR\|(1) program.  See that manual page for
more details.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.52)
.SS "guestfs_set_append"
.IX Subsection "guestfs_set_append"
.Vb 3
\& int
\& guestfs_set_append (guestfs_h *g,
\&                     const char *append);
.Ve
.PP
This function is used to add additional options to the guest kernel command
line.
.PP
The default is \f(CW\*(C`NULL\*(C'\fR unless overridden by setting \f(CW\*(C`LIBGUESTFS_APPEND\*(C'\fR
environment variable.
.PP
Setting \f(CW\*(C`append\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR means \fIno\fR additional options are passed
(libguestfs always adds a few of its own).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.26)
.SS "guestfs_set_attach_method"
.IX Subsection "guestfs_set_attach_method"
.Vb 3
\& int
\& guestfs_set_attach_method (guestfs_h *g,
\&                            const char *attachmethod);
.Ve
.PP
Set the method that libguestfs uses to connect to the back end guestfsd
daemon.  Possible methods are:
.ie n .IP """appliance""" 4
.el .IP "\f(CWappliance\fR" 4
.IX Item "appliance"
Launch an appliance and connect to it.  This is the ordinary method and the
default.
.ie n .IP """unix:\f(CIpath\f(CW""" 4
.el .IP "\f(CWunix:\f(CIpath\f(CW\fR" 4
.IX Item "unix:path"
Connect to the Unix domain socket \fIpath\fR.
.Sp
This method lets you connect to an existing daemon or (using virtio-serial)
to a live guest.  For more information, see \*(L"\s-1ATTACHING\s0 \s-1TO\s0
\&\s-1RUNNING\s0 \s-1DAEMONS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.9.8)
.SS "guestfs_set_autosync"
.IX Subsection "guestfs_set_autosync"
.Vb 3
\& int
\& guestfs_set_autosync (guestfs_h *g,
\&                       int autosync);
.Ve
.PP
If \f(CW\*(C`autosync\*(C'\fR is true, this enables autosync.  Libguestfs will make a best
effort attempt to make filesystems consistent and synchronized when the
handle is closed (also if the program exits without closing handles).
.PP
This is enabled by default (since libguestfs 1.5.24, previously it was
disabled by default).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_set_direct"
.IX Subsection "guestfs_set_direct"
.Vb 3
\& int
\& guestfs_set_direct (guestfs_h *g,
\&                     int direct);
.Ve
.PP
If the direct appliance mode flag is enabled, then stdin and stdout are
passed directly through to the appliance once it is launched.
.PP
One consequence of this is that log messages aren't caught by the library
and handled by \f(CW\*(C`guestfs_set_log_message_callback\*(C'\fR, but go straight to
stdout.
.PP
You probably don't want to use this unless you know what you are doing.
.PP
The default is disabled.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.72)
.SS "guestfs_set_e2label"
.IX Subsection "guestfs_set_e2label"
.Vb 4
\& int
\& guestfs_set_e2label (guestfs_h *g,
\&                      const char *device,
\&                      const char *label);
.Ve
.PP
This sets the ext2/3/4 filesystem label of the filesystem on \f(CW\*(C`device\*(C'\fR to
\&\f(CW\*(C`label\*(C'\fR.  Filesystem labels are limited to 16 characters.
.PP
You can use either \f(CW\*(C`guestfs_tune2fs_l\*(C'\fR or \f(CW\*(C`guestfs_get_e2label\*(C'\fR to return
the existing label on a filesystem.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.15)
.SS "guestfs_set_e2uuid"
.IX Subsection "guestfs_set_e2uuid"
.Vb 4
\& int
\& guestfs_set_e2uuid (guestfs_h *g,
\&                     const char *device,
\&                     const char *uuid);
.Ve
.PP
This sets the ext2/3/4 filesystem \s-1UUID\s0 of the filesystem on \f(CW\*(C`device\*(C'\fR to
\&\f(CW\*(C`uuid\*(C'\fR.  The format of the \s-1UUID\s0 and alternatives such as \f(CW\*(C`clear\*(C'\fR,
\&\f(CW\*(C`random\*(C'\fR and \f(CW\*(C`time\*(C'\fR are described in the \fItune2fs\fR\|(8) manpage.
.PP
You can use either \f(CW\*(C`guestfs_tune2fs_l\*(C'\fR or \f(CW\*(C`guestfs_get_e2uuid\*(C'\fR to return
the existing \s-1UUID\s0 of a filesystem.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.15)
.SS "guestfs_set_memsize"
.IX Subsection "guestfs_set_memsize"
.Vb 3
\& int
\& guestfs_set_memsize (guestfs_h *g,
\&                      int memsize);
.Ve
.PP
This sets the memory size in megabytes allocated to the qemu subprocess.
This only has any effect if called before \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
You can also change this by setting the environment variable
\&\f(CW\*(C`LIBGUESTFS_MEMSIZE\*(C'\fR before the handle is created.
.PP
For more information on the architecture of libguestfs, see \fIguestfs\fR\|(3).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_set_network"
.IX Subsection "guestfs_set_network"
.Vb 3
\& int
\& guestfs_set_network (guestfs_h *g,
\&                      int network);
.Ve
.PP
If \f(CW\*(C`network\*(C'\fR is true, then the network is enabled in the libguestfs
appliance.  The default is false.
.PP
This affects whether commands are able to access the network (see
\&\*(L"\s-1RUNNING\s0 \s-1COMMANDS\s0\*(R" in \fIguestfs\fR\|(3)).
.PP
You must call this before calling \f(CW\*(C`guestfs_launch\*(C'\fR, otherwise it has no
effect.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.5.4)
.SS "guestfs_set_path"
.IX Subsection "guestfs_set_path"
.Vb 3
\& int
\& guestfs_set_path (guestfs_h *g,
\&                   const char *searchpath);
.Ve
.PP
Set the path that libguestfs searches for kernel and initrd.img.
.PP
The default is \f(CW\*(C`$libdir/guestfs\*(C'\fR unless overridden by setting
\&\f(CW\*(C`LIBGUESTFS_PATH\*(C'\fR environment variable.
.PP
Setting \f(CW\*(C`path\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR restores the default path.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_set_pgroup"
.IX Subsection "guestfs_set_pgroup"
.Vb 3
\& int
\& guestfs_set_pgroup (guestfs_h *g,
\&                     int pgroup);
.Ve
.PP
If \f(CW\*(C`pgroup\*(C'\fR is true, child processes are placed into their own process
group.
.PP
The practical upshot of this is that signals like \f(CW\*(C`SIGINT\*(C'\fR (from users
pressing \f(CW\*(C`^C\*(C'\fR) won't be received by the child process.
.PP
The default for this flag is false, because usually you want \f(CW\*(C`^C\*(C'\fR to kill
the subprocess.  Guestfish sets this flag to true when used interactively,
so that \f(CW\*(C`^C\*(C'\fR can cancel long-running commands gracefully (see
\&\f(CW\*(C`guestfs_user_cancel\*(C'\fR).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.11.18)
.SS "guestfs_set_qemu"
.IX Subsection "guestfs_set_qemu"
.Vb 3
\& int
\& guestfs_set_qemu (guestfs_h *g,
\&                   const char *qemu);
.Ve
.PP
Set the qemu binary that we will use.
.PP
The default is chosen when the library was compiled by the configure script.
.PP
You can also override this by setting the \f(CW\*(C`LIBGUESTFS_QEMU\*(C'\fR environment
variable.
.PP
Setting \f(CW\*(C`qemu\*(C'\fR to \f(CW\*(C`NULL\*(C'\fR restores the default qemu binary.
.PP
Note that you should call this function as early as possible after creating
the handle.  This is because some pre-launch operations depend on testing
qemu features (by running \f(CW\*(C`qemu \-help\*(C'\fR).  If the qemu binary changes, we
don't retest features, and so you might see inconsistent results.  Using the
environment variable \f(CW\*(C`LIBGUESTFS_QEMU\*(C'\fR is safest of all since that picks
the qemu binary at the same time as the handle is created.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.6)
.SS "guestfs_set_recovery_proc"
.IX Subsection "guestfs_set_recovery_proc"
.Vb 3
\& int
\& guestfs_set_recovery_proc (guestfs_h *g,
\&                            int recoveryproc);
.Ve
.PP
If this is called with the parameter \f(CW\*(C`false\*(C'\fR then \f(CW\*(C`guestfs_launch\*(C'\fR does
not create a recovery process.  The purpose of the recovery process is to
stop runaway qemu processes in the case where the main program aborts
abruptly.
.PP
This only has any effect if called before \f(CW\*(C`guestfs_launch\*(C'\fR, and the default
is true.
.PP
About the only time when you would want to disable this is if the main
process will fork itself into the background (\*(L"daemonize\*(R" itself).  In this
case the recovery process thinks that the main program has disappeared and
so kills qemu, which is not very helpful.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_set_selinux"
.IX Subsection "guestfs_set_selinux"
.Vb 3
\& int
\& guestfs_set_selinux (guestfs_h *g,
\&                      int selinux);
.Ve
.PP
This sets the selinux flag that is passed to the appliance at boot time.
The default is \f(CW\*(C`selinux=0\*(C'\fR (disabled).
.PP
Note that if SELinux is enabled, it is always in Permissive mode
(\f(CW\*(C`enforcing=0\*(C'\fR).
.PP
For more information on the architecture of libguestfs, see \fIguestfs\fR\|(3).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.67)
.SS "guestfs_set_smp"
.IX Subsection "guestfs_set_smp"
.Vb 3
\& int
\& guestfs_set_smp (guestfs_h *g,
\&                  int smp);
.Ve
.PP
Change the number of virtual CPUs assigned to the appliance.  The default is
\&\f(CW1\fR.  Increasing this may improve performance, though often it has no
effect.
.PP
This function must be called before \f(CW\*(C`guestfs_launch\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.13.15)
.SS "guestfs_set_trace"
.IX Subsection "guestfs_set_trace"
.Vb 3
\& int
\& guestfs_set_trace (guestfs_h *g,
\&                    int trace);
.Ve
.PP
If the command trace flag is set to 1, then libguestfs calls, parameters and
return values are traced.
.PP
If you want to trace C \s-1API\s0 calls into libguestfs (and other libraries) then
possibly a better way is to use the external \fIltrace\fR\|(1) command.
.PP
Command traces are disabled unless the environment variable
\&\f(CW\*(C`LIBGUESTFS_TRACE\*(C'\fR is defined and set to \f(CW1\fR.
.PP
Trace messages are normally sent to \f(CW\*(C`stderr\*(C'\fR, unless you register a
callback to send them somewhere else (see \f(CW\*(C`guestfs_set_event_callback\*(C'\fR).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.69)
.SS "guestfs_set_verbose"
.IX Subsection "guestfs_set_verbose"
.Vb 3
\& int
\& guestfs_set_verbose (guestfs_h *g,
\&                      int verbose);
.Ve
.PP
If \f(CW\*(C`verbose\*(C'\fR is true, this turns on verbose messages.
.PP
Verbose messages are disabled unless the environment variable
\&\f(CW\*(C`LIBGUESTFS_DEBUG\*(C'\fR is defined and set to \f(CW1\fR.
.PP
Verbose messages are normally sent to \f(CW\*(C`stderr\*(C'\fR, unless you register a
callback to send them somewhere else (see \f(CW\*(C`guestfs_set_event_callback\*(C'\fR).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_setcon"
.IX Subsection "guestfs_setcon"
.Vb 3
\& int
\& guestfs_setcon (guestfs_h *g,
\&                 const char *context);
.Ve
.PP
This sets the SELinux security context of the daemon to the string
\&\f(CW\*(C`context\*(C'\fR.
.PP
See the documentation about \s-1SELINUX\s0 in \fIguestfs\fR\|(3).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.67)
.SS "guestfs_setxattr"
.IX Subsection "guestfs_setxattr"
.Vb 6
\& int
\& guestfs_setxattr (guestfs_h *g,
\&                   const char *xattr,
\&                   const char *val,
\&                   int vallen,
\&                   const char *path);
.Ve
.PP
This call sets the extended attribute named \f(CW\*(C`xattr\*(C'\fR of the file \f(CW\*(C`path\*(C'\fR to
the value \f(CW\*(C`val\*(C'\fR (of length \f(CW\*(C`vallen\*(C'\fR).  The value is arbitrary 8 bit data.
.PP
See also: \f(CW\*(C`guestfs_lsetxattr\*(C'\fR, \fIattr\fR\|(5).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.59)
.SS "guestfs_sfdisk"
.IX Subsection "guestfs_sfdisk"
.Vb 7
\& int
\& guestfs_sfdisk (guestfs_h *g,
\&                 const char *device,
\&                 int cyls,
\&                 int heads,
\&                 int sectors,
\&                 char *const *lines);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_part_add\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is a direct interface to the \fIsfdisk\fR\|(8) program for creating
partitions on block devices.
.PP
\&\f(CW\*(C`device\*(C'\fR should be a block device, for example \f(CW\*(C`/dev/sda\*(C'\fR.
.PP
\&\f(CW\*(C`cyls\*(C'\fR, \f(CW\*(C`heads\*(C'\fR and \f(CW\*(C`sectors\*(C'\fR are the number of cylinders, heads and
sectors on the device, which are passed directly to sfdisk as the \fI\-C\fR,
\&\fI\-H\fR and \fI\-S\fR parameters.  If you pass \f(CW0\fR for any of these, then the
corresponding parameter is omitted.  Usually for 'large' disks, you can just
pass \f(CW0\fR for these, but for small (floppy-sized) disks, sfdisk (or rather,
the kernel) cannot work out the right geometry and you will need to tell it.
.PP
\&\f(CW\*(C`lines\*(C'\fR is a list of lines that we feed to \f(CW\*(C`sfdisk\*(C'\fR.  For more information
refer to the \fIsfdisk\fR\|(8) manpage.
.PP
To create a single partition occupying the whole disk, you would pass
\&\f(CW\*(C`lines\*(C'\fR as a single element list, when the single element being the string
\&\f(CW\*(C`,\*(C'\fR (comma).
.PP
See also: \f(CW\*(C`guestfs_sfdisk_l\*(C'\fR, \f(CW\*(C`guestfs_sfdisk_N\*(C'\fR, \f(CW\*(C`guestfs_part_init\*(C'\fR
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_sfdiskM"
.IX Subsection "guestfs_sfdiskM"
.Vb 4
\& int
\& guestfs_sfdiskM (guestfs_h *g,
\&                  const char *device,
\&                  char *const *lines);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_part_add\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This is a simplified interface to the \f(CW\*(C`guestfs_sfdisk\*(C'\fR command, where
partition sizes are specified in megabytes only (rounded to the nearest
cylinder) and you don't need to specify the cyls, heads and sectors
parameters which were rarely if ever used anyway.
.PP
See also: \f(CW\*(C`guestfs_sfdisk\*(C'\fR, the \fIsfdisk\fR\|(8) manpage and
\&\f(CW\*(C`guestfs_part_disk\*(C'\fR
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.55)
.SS "guestfs_sfdisk_N"
.IX Subsection "guestfs_sfdisk_N"
.Vb 8
\& int
\& guestfs_sfdisk_N (guestfs_h *g,
\&                   const char *device,
\&                   int partnum,
\&                   int cyls,
\&                   int heads,
\&                   int sectors,
\&                   const char *line);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_part_add\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This runs \fIsfdisk\fR\|(8) option to modify just the single partition \f(CW\*(C`n\*(C'\fR
(note: \f(CW\*(C`n\*(C'\fR counts from 1).
.PP
For other parameters, see \f(CW\*(C`guestfs_sfdisk\*(C'\fR.  You should usually pass \f(CW0\fR
for the cyls/heads/sectors parameters.
.PP
See also: \f(CW\*(C`guestfs_part_add\*(C'\fR
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.26)
.SS "guestfs_sfdisk_disk_geometry"
.IX Subsection "guestfs_sfdisk_disk_geometry"
.Vb 3
\& char *
\& guestfs_sfdisk_disk_geometry (guestfs_h *g,
\&                               const char *device);
.Ve
.PP
This displays the disk geometry of \f(CW\*(C`device\*(C'\fR read from the partition table.
Especially in the case where the underlying block device has been resized,
this can be different from the kernel's idea of the geometry (see
\&\f(CW\*(C`guestfs_sfdisk_kernel_geometry\*(C'\fR).
.PP
The result is in human-readable format, and not designed to be parsed.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.26)
.SS "guestfs_sfdisk_kernel_geometry"
.IX Subsection "guestfs_sfdisk_kernel_geometry"
.Vb 3
\& char *
\& guestfs_sfdisk_kernel_geometry (guestfs_h *g,
\&                                 const char *device);
.Ve
.PP
This displays the kernel's idea of the geometry of \f(CW\*(C`device\*(C'\fR.
.PP
The result is in human-readable format, and not designed to be parsed.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.26)
.SS "guestfs_sfdisk_l"
.IX Subsection "guestfs_sfdisk_l"
.Vb 3
\& char *
\& guestfs_sfdisk_l (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_part_list\*(R"
call instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This displays the partition table on \f(CW\*(C`device\*(C'\fR, in the human-readable output
of the \fIsfdisk\fR\|(8) command.  It is not intended to be parsed.
.PP
See also: \f(CW\*(C`guestfs_part_list\*(C'\fR
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.26)
.SS "guestfs_sh"
.IX Subsection "guestfs_sh"
.Vb 3
\& char *
\& guestfs_sh (guestfs_h *g,
\&             const char *command);
.Ve
.PP
This call runs a command from the guest filesystem via the guest's
\&\f(CW\*(C`/bin/sh\*(C'\fR.
.PP
This is like \f(CW\*(C`guestfs_command\*(C'\fR, but passes the command to:
.PP
.Vb 1
\& /bin/sh \-c "command"
.Ve
.PP
Depending on the guest's shell, this usually results in wildcards being
expanded, shell expressions being interpolated and so on.
.PP
All the provisos about \f(CW\*(C`guestfs_command\*(C'\fR apply to this call.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.50)
.SS "guestfs_sh_lines"
.IX Subsection "guestfs_sh_lines"
.Vb 3
\& char **
\& guestfs_sh_lines (guestfs_h *g,
\&                   const char *command);
.Ve
.PP
This is the same as \f(CW\*(C`guestfs_sh\*(C'\fR, but splits the result into a list of
lines.
.PP
See also: \f(CW\*(C`guestfs_command_lines\*(C'\fR
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.50)
.SS "guestfs_sleep"
.IX Subsection "guestfs_sleep"
.Vb 3
\& int
\& guestfs_sleep (guestfs_h *g,
\&                int secs);
.Ve
.PP
Sleep for \f(CW\*(C`secs\*(C'\fR seconds.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.41)
.SS "guestfs_stat"
.IX Subsection "guestfs_stat"
.Vb 3
\& struct guestfs_stat *
\& guestfs_stat (guestfs_h *g,
\&               const char *path);
.Ve
.PP
Returns file information for the given \f(CW\*(C`path\*(C'\fR.
.PP
This is the same as the \f(CWstat(2)\fR system call.
.PP
This function returns a \f(CW\*(C`struct guestfs_stat *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_stat\*(C'\fI after use\fR.
.PP
(Added in 0.9.2)
.SS "guestfs_statvfs"
.IX Subsection "guestfs_statvfs"
.Vb 3
\& struct guestfs_statvfs *
\& guestfs_statvfs (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
Returns file system statistics for any mounted file system.  \f(CW\*(C`path\*(C'\fR should
be a file or directory in the mounted file system (typically it is the mount
point itself, but it doesn't need to be).
.PP
This is the same as the \f(CWstatvfs(2)\fR system call.
.PP
This function returns a \f(CW\*(C`struct guestfs_statvfs *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_statvfs\*(C'\fI after use\fR.
.PP
(Added in 0.9.2)
.SS "guestfs_strings"
.IX Subsection "guestfs_strings"
.Vb 3
\& char **
\& guestfs_strings (guestfs_h *g,
\&                  const char *path);
.Ve
.PP
This runs the \fIstrings\fR\|(1) command on a file and returns the list of
printable strings found.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.22)
.SS "guestfs_strings_e"
.IX Subsection "guestfs_strings_e"
.Vb 4
\& char **
\& guestfs_strings_e (guestfs_h *g,
\&                    const char *encoding,
\&                    const char *path);
.Ve
.PP
This is like the \f(CW\*(C`guestfs_strings\*(C'\fR command, but allows you to specify the
encoding of strings that are looked for in the source file \f(CW\*(C`path\*(C'\fR.
.PP
Allowed encodings are:
.IP "s" 4
.IX Item "s"
Single 7\-bit\-byte characters like \s-1ASCII\s0 and the ASCII-compatible parts of
\&\s-1ISO\-8859\-X\s0 (this is what \f(CW\*(C`guestfs_strings\*(C'\fR uses).
.IP "S" 4
.IX Item "S"
Single 8\-bit\-byte characters.
.IP "b" 4
.IX Item "b"
16\-bit big endian strings such as those encoded in \s-1UTF\-16BE\s0 or \s-1UCS\-2BE\s0.
.IP "l (lower case letter L)" 4
.IX Item "l (lower case letter L)"
16\-bit little endian such as \s-1UTF\-16LE\s0 and \s-1UCS\-2LE\s0.  This is useful for
examining binaries in Windows guests.
.IP "B" 4
.IX Item "B"
32\-bit big endian such as \s-1UCS\-4BE\s0.
.IP "L" 4
.IX Item "L"
32\-bit little endian such as \s-1UCS\-4LE\s0.
.PP
The returned strings are transcoded to \s-1UTF\-8\s0.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.22)
.SS "guestfs_swapoff_device"
.IX Subsection "guestfs_swapoff_device"
.Vb 3
\& int
\& guestfs_swapoff_device (guestfs_h *g,
\&                         const char *device);
.Ve
.PP
This command disables the libguestfs appliance swap device or partition
named \f(CW\*(C`device\*(C'\fR.  See \f(CW\*(C`guestfs_swapon_device\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapoff_file"
.IX Subsection "guestfs_swapoff_file"
.Vb 3
\& int
\& guestfs_swapoff_file (guestfs_h *g,
\&                       const char *file);
.Ve
.PP
This command disables the libguestfs appliance swap on file.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapoff_label"
.IX Subsection "guestfs_swapoff_label"
.Vb 3
\& int
\& guestfs_swapoff_label (guestfs_h *g,
\&                        const char *label);
.Ve
.PP
This command disables the libguestfs appliance swap on labeled swap
partition.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapoff_uuid"
.IX Subsection "guestfs_swapoff_uuid"
.Vb 3
\& int
\& guestfs_swapoff_uuid (guestfs_h *g,
\&                       const char *uuid);
.Ve
.PP
This command disables the libguestfs appliance swap partition with the given
\&\s-1UUID\s0.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapon_device"
.IX Subsection "guestfs_swapon_device"
.Vb 3
\& int
\& guestfs_swapon_device (guestfs_h *g,
\&                        const char *device);
.Ve
.PP
This command enables the libguestfs appliance to use the swap device or
partition named \f(CW\*(C`device\*(C'\fR.  The increased memory is made available for all
commands, for example those run using \f(CW\*(C`guestfs_command\*(C'\fR or \f(CW\*(C`guestfs_sh\*(C'\fR.
.PP
Note that you should not swap to existing guest swap partitions unless you
know what you are doing.  They may contain hibernation information, or other
information that the guest doesn't want you to trash.  You also risk leaking
information about the host to the guest this way.  Instead, attach a new
host device to the guest and swap on that.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapon_file"
.IX Subsection "guestfs_swapon_file"
.Vb 3
\& int
\& guestfs_swapon_file (guestfs_h *g,
\&                      const char *file);
.Ve
.PP
This command enables swap to a file.  See \f(CW\*(C`guestfs_swapon_device\*(C'\fR for other
notes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapon_label"
.IX Subsection "guestfs_swapon_label"
.Vb 3
\& int
\& guestfs_swapon_label (guestfs_h *g,
\&                       const char *label);
.Ve
.PP
This command enables swap to a labeled swap partition.  See
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR for other notes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_swapon_uuid"
.IX Subsection "guestfs_swapon_uuid"
.Vb 3
\& int
\& guestfs_swapon_uuid (guestfs_h *g,
\&                      const char *uuid);
.Ve
.PP
This command enables swap to a swap partition with the given \s-1UUID\s0.  See
\&\f(CW\*(C`guestfs_swapon_device\*(C'\fR for other notes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.66)
.SS "guestfs_sync"
.IX Subsection "guestfs_sync"
.Vb 2
\& int
\& guestfs_sync (guestfs_h *g);
.Ve
.PP
This syncs the disk, so that any writes are flushed through to the
underlying disk image.
.PP
You should always call this if you have modified a disk image, before
closing the handle.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_tail"
.IX Subsection "guestfs_tail"
.Vb 3
\& char **
\& guestfs_tail (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This command returns up to the last 10 lines of a file as a list of strings.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.54)
.SS "guestfs_tail_n"
.IX Subsection "guestfs_tail_n"
.Vb 4
\& char **
\& guestfs_tail_n (guestfs_h *g,
\&                 int nrlines,
\&                 const char *path);
.Ve
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is a positive number, this returns the last
\&\f(CW\*(C`nrlines\*(C'\fR lines of the file \f(CW\*(C`path\*(C'\fR.
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is a negative number, this returns lines from
the file \f(CW\*(C`path\*(C'\fR, starting with the \f(CW\*(C`\-nrlines\*(C'\fRth line.
.PP
If the parameter \f(CW\*(C`nrlines\*(C'\fR is zero, this returns an empty list.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.54)
.SS "guestfs_tar_in"
.IX Subsection "guestfs_tar_in"
.Vb 4
\& int
\& guestfs_tar_in (guestfs_h *g,
\&                 const char *tarfile,
\&                 const char *directory);
.Ve
.PP
This command uploads and unpacks local file \f(CW\*(C`tarfile\*(C'\fR (an \fIuncompressed\fR
tar file) into \f(CW\*(C`directory\*(C'\fR.
.PP
To upload a compressed tarball, use \f(CW\*(C`guestfs_tgz_in\*(C'\fR or \f(CW\*(C`guestfs_txz_in\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.3)
.SS "guestfs_tar_out"
.IX Subsection "guestfs_tar_out"
.Vb 4
\& int
\& guestfs_tar_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarfile);
.Ve
.PP
This command packs the contents of \f(CW\*(C`directory\*(C'\fR and downloads it to local
file \f(CW\*(C`tarfile\*(C'\fR.
.PP
To download a compressed tarball, use \f(CW\*(C`guestfs_tgz_out\*(C'\fR or
\&\f(CW\*(C`guestfs_txz_out\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.3)
.SS "guestfs_tgz_in"
.IX Subsection "guestfs_tgz_in"
.Vb 4
\& int
\& guestfs_tgz_in (guestfs_h *g,
\&                 const char *tarball,
\&                 const char *directory);
.Ve
.PP
This command uploads and unpacks local file \f(CW\*(C`tarball\*(C'\fR (a \fIgzip compressed\fR
tar file) into \f(CW\*(C`directory\*(C'\fR.
.PP
To upload an uncompressed tarball, use \f(CW\*(C`guestfs_tar_in\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.3)
.SS "guestfs_tgz_out"
.IX Subsection "guestfs_tgz_out"
.Vb 4
\& int
\& guestfs_tgz_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarball);
.Ve
.PP
This command packs the contents of \f(CW\*(C`directory\*(C'\fR and downloads it to local
file \f(CW\*(C`tarball\*(C'\fR.
.PP
To download an uncompressed tarball, use \f(CW\*(C`guestfs_tar_out\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.3)
.SS "guestfs_touch"
.IX Subsection "guestfs_touch"
.Vb 3
\& int
\& guestfs_touch (guestfs_h *g,
\&                const char *path);
.Ve
.PP
Touch acts like the \fItouch\fR\|(1) command.  It can be used to update the
timestamps on a file, or, if the file does not exist, to create a new
zero-length file.
.PP
This command only works on regular files, and will fail on other file types
such as directories, symbolic links, block special etc.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_truncate"
.IX Subsection "guestfs_truncate"
.Vb 3
\& int
\& guestfs_truncate (guestfs_h *g,
\&                   const char *path);
.Ve
.PP
This command truncates \f(CW\*(C`path\*(C'\fR to a zero-length file.  The file must exist
already.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_truncate_size"
.IX Subsection "guestfs_truncate_size"
.Vb 4
\& int
\& guestfs_truncate_size (guestfs_h *g,
\&                        const char *path,
\&                        int64_t size);
.Ve
.PP
This command truncates \f(CW\*(C`path\*(C'\fR to size \f(CW\*(C`size\*(C'\fR bytes.  The file must exist
already.
.PP
If the current file size is less than \f(CW\*(C`size\*(C'\fR then the file is extended to
the required size with zero bytes.  This creates a sparse file (ie. disk
blocks are not allocated for the file until you write to it).  To create a
non-sparse file of zeroes, use \f(CW\*(C`guestfs_fallocate64\*(C'\fR instead.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_tune2fs"
.IX Subsection "guestfs_tune2fs"
.Vb 4
\& int
\& guestfs_tune2fs (guestfs_h *g,
\&                  const char *device,
\&                  ...);
.Ve
.PP
You may supply a list of optional arguments to this call.  Use zero or more
of the following pairs of parameters, and terminate the list with \f(CW\*(C`\-1\*(C'\fR on
its own.  See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.PP
.Vb 10
\& GUESTFS_TUNE2FS_FORCE, int force,
\& GUESTFS_TUNE2FS_MAXMOUNTCOUNT, int maxmountcount,
\& GUESTFS_TUNE2FS_MOUNTCOUNT, int mountcount,
\& GUESTFS_TUNE2FS_ERRORBEHAVIOR, const char *errorbehavior,
\& GUESTFS_TUNE2FS_GROUP, int64_t group,
\& GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS, int intervalbetweenchecks,
\& GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE, int reservedblockspercentage,
\& GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY, const char *lastmounteddirectory,
\& GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT, int64_t reservedblockscount,
\& GUESTFS_TUNE2FS_USER, int64_t user,
.Ve
.PP
This call allows you to adjust various filesystem parameters of an
ext2/ext3/ext4 filesystem called \f(CW\*(C`device\*(C'\fR.
.PP
The optional parameters are:
.ie n .IP """force""" 4
.el .IP "\f(CWforce\fR" 4
.IX Item "force"
Force tune2fs to complete the operation even in the face of errors.  This is
the same as the tune2fs \f(CW\*(C`\-f\*(C'\fR option.
.ie n .IP """maxmountcount""" 4
.el .IP "\f(CWmaxmountcount\fR" 4
.IX Item "maxmountcount"
Set the number of mounts after which the filesystem is checked by
\&\fIe2fsck\fR\|(8).  If this is \f(CW0\fR then the number of mounts is disregarded.
This is the same as the tune2fs \f(CW\*(C`\-c\*(C'\fR option.
.ie n .IP """mountcount""" 4
.el .IP "\f(CWmountcount\fR" 4
.IX Item "mountcount"
Set the number of times the filesystem has been mounted.  This is the same
as the tune2fs \f(CW\*(C`\-C\*(C'\fR option.
.ie n .IP """errorbehavior""" 4
.el .IP "\f(CWerrorbehavior\fR" 4
.IX Item "errorbehavior"
Change the behavior of the kernel code when errors are detected.  Possible
values currently are: \f(CW\*(C`continue\*(C'\fR, \f(CW\*(C`remount\-ro\*(C'\fR, \f(CW\*(C`panic\*(C'\fR.  In practice
these options don't really make any difference, particularly for write
errors.
.Sp
This is the same as the tune2fs \f(CW\*(C`\-e\*(C'\fR option.
.ie n .IP """group""" 4
.el .IP "\f(CWgroup\fR" 4
.IX Item "group"
Set the group which can use reserved filesystem blocks.  This is the same as
the tune2fs \f(CW\*(C`\-g\*(C'\fR option except that it can only be specified as a number.
.ie n .IP """intervalbetweenchecks""" 4
.el .IP "\f(CWintervalbetweenchecks\fR" 4
.IX Item "intervalbetweenchecks"
Adjust the maximal time between two filesystem checks (in seconds).  If the
option is passed as \f(CW0\fR then time-dependent checking is disabled.
.Sp
This is the same as the tune2fs \f(CW\*(C`\-i\*(C'\fR option.
.ie n .IP """reservedblockspercentage""" 4
.el .IP "\f(CWreservedblockspercentage\fR" 4
.IX Item "reservedblockspercentage"
Set the percentage of the filesystem which may only be allocated by
privileged processes.  This is the same as the tune2fs \f(CW\*(C`\-m\*(C'\fR option.
.ie n .IP """lastmounteddirectory""" 4
.el .IP "\f(CWlastmounteddirectory\fR" 4
.IX Item "lastmounteddirectory"
Set the last mounted directory.  This is the same as the tune2fs \f(CW\*(C`\-M\*(C'\fR
option.
.ie n .IP """reservedblockscount"" Set the number of reserved filesystem blocks.  This is the same as the tune2fs ""\-r"" option." 4
.el .IP "\f(CWreservedblockscount\fR Set the number of reserved filesystem blocks.  This is the same as the tune2fs \f(CW\-r\fR option." 4
.IX Item "reservedblockscount Set the number of reserved filesystem blocks.  This is the same as the tune2fs -r option."
.PD 0
.ie n .IP """user""" 4
.el .IP "\f(CWuser\fR" 4
.IX Item "user"
.PD
Set the user who can use the reserved filesystem blocks.  This is the same
as the tune2fs \f(CW\*(C`\-u\*(C'\fR option except that it can only be specified as a
number.
.PP
To get the current values of filesystem parameters, see
\&\f(CW\*(C`guestfs_tune2fs_l\*(C'\fR.  For precise details of how tune2fs works, see the
\&\fItune2fs\fR\|(8) man page.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.15.4)
.SS "guestfs_tune2fs_va"
.IX Subsection "guestfs_tune2fs_va"
.Vb 4
\& int
\& guestfs_tune2fs_va (guestfs_h *g,
\&                     const char *device,
\&                     va_list args);
.Ve
.PP
This is the \*(L"va_list variant\*(R" of \*(L"guestfs_tune2fs\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_tune2fs_argv"
.IX Subsection "guestfs_tune2fs_argv"
.Vb 4
\& int
\& guestfs_tune2fs_argv (guestfs_h *g,
\&                       const char *device,
\&                       const struct guestfs_tune2fs_argv *optargs);
.Ve
.PP
This is the \*(L"argv variant\*(R" of \*(L"guestfs_tune2fs\*(R".
.PP
See \*(L"\s-1CALLS\s0 \s-1WITH\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R".
.SS "guestfs_tune2fs_l"
.IX Subsection "guestfs_tune2fs_l"
.Vb 3
\& char **
\& guestfs_tune2fs_l (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This returns the contents of the ext2, ext3 or ext4 filesystem superblock on
\&\f(CW\*(C`device\*(C'\fR.
.PP
It is the same as running \f(CW\*(C`tune2fs \-l device\*(C'\fR.  See \fItune2fs\fR\|(8) manpage
for more details.  The list of fields returned isn't clearly defined, and
depends on both the version of \f(CW\*(C`tune2fs\*(C'\fR that libguestfs was built against,
and the filesystem itself.
.PP
This function returns a NULL-terminated array of strings, or \s-1NULL\s0 if there
was an error.  The array of strings will always have length \f(CW\*(C`2n+1\*(C'\fR, where
\&\f(CW\*(C`n\*(C'\fR keys and values alternate, followed by the trailing \s-1NULL\s0 entry.  \fIThe
caller must free the strings and the array after use\fR.
.PP
(Added in 0.9.2)
.SS "guestfs_txz_in"
.IX Subsection "guestfs_txz_in"
.Vb 4
\& int
\& guestfs_txz_in (guestfs_h *g,
\&                 const char *tarball,
\&                 const char *directory);
.Ve
.PP
This command uploads and unpacks local file \f(CW\*(C`tarball\*(C'\fR (an \fIxz compressed\fR
tar file) into \f(CW\*(C`directory\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_txz_out"
.IX Subsection "guestfs_txz_out"
.Vb 4
\& int
\& guestfs_txz_out (guestfs_h *g,
\&                  const char *directory,
\&                  const char *tarball);
.Ve
.PP
This command packs the contents of \f(CW\*(C`directory\*(C'\fR and downloads it to local
file \f(CW\*(C`tarball\*(C'\fR (as an xz compressed tar archive).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_umask"
.IX Subsection "guestfs_umask"
.Vb 3
\& int
\& guestfs_umask (guestfs_h *g,
\&                int mask);
.Ve
.PP
This function sets the mask used for creating new files and device nodes to
\&\f(CW\*(C`mask & 0777\*(C'\fR.
.PP
Typical umask values would be \f(CW022\fR which creates new files with
permissions like \*(L"\-rw\-r\*(--r\-\-\*(R" or \*(L"\-rwxr\-xr\-x\*(R", and \f(CW002\fR which creates new
files with permissions like \*(L"\-rw\-rw\-r\-\-\*(R" or \*(L"\-rwxrwxr\-x\*(R".
.PP
The default umask is \f(CW022\fR.  This is important because it means that
directories and device nodes will be created with \f(CW0644\fR or \f(CW0755\fR mode
even if you specify \f(CW0777\fR.
.PP
See also \f(CW\*(C`guestfs_get_umask\*(C'\fR, \fIumask\fR\|(2), \f(CW\*(C`guestfs_mknod\*(C'\fR,
\&\f(CW\*(C`guestfs_mkdir\*(C'\fR.
.PP
This call returns the previous umask.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.55)
.SS "guestfs_umount"
.IX Subsection "guestfs_umount"
.Vb 3
\& int
\& guestfs_umount (guestfs_h *g,
\&                 const char *pathordevice);
.Ve
.PP
This unmounts the given filesystem.  The filesystem may be specified either
by its mountpoint (path) or the device which contains the filesystem.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_umount_all"
.IX Subsection "guestfs_umount_all"
.Vb 2
\& int
\& guestfs_umount_all (guestfs_h *g);
.Ve
.PP
This unmounts all mounted filesystems.
.PP
Some internal mounts are not unmounted by this call.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_upload"
.IX Subsection "guestfs_upload"
.Vb 4
\& int
\& guestfs_upload (guestfs_h *g,
\&                 const char *filename,
\&                 const char *remotefilename);
.Ve
.PP
Upload local file \f(CW\*(C`filename\*(C'\fR to \f(CW\*(C`remotefilename\*(C'\fR on the filesystem.
.PP
\&\f(CW\*(C`filename\*(C'\fR can also be a named pipe.
.PP
See also \f(CW\*(C`guestfs_download\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.2)
.SS "guestfs_upload_offset"
.IX Subsection "guestfs_upload_offset"
.Vb 5
\& int
\& guestfs_upload_offset (guestfs_h *g,
\&                        const char *filename,
\&                        const char *remotefilename,
\&                        int64_t offset);
.Ve
.PP
Upload local file \f(CW\*(C`filename\*(C'\fR to \f(CW\*(C`remotefilename\*(C'\fR on the filesystem.
.PP
\&\f(CW\*(C`remotefilename\*(C'\fR is overwritten starting at the byte \f(CW\*(C`offset\*(C'\fR specified.
The intention is to overwrite parts of existing files or devices, although
if a non-existant file is specified then it is created with a \*(L"hole\*(R" before
\&\f(CW\*(C`offset\*(C'\fR.  The size of the data written is implicit in the size of the
source \f(CW\*(C`filename\*(C'\fR.
.PP
Note that there is no limit on the amount of data that can be uploaded with
this call, unlike with \f(CW\*(C`guestfs_pwrite\*(C'\fR, and this call always writes the
full amount unless an error occurs.
.PP
See also \f(CW\*(C`guestfs_upload\*(C'\fR, \f(CW\*(C`guestfs_pwrite\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.5.17)
.SS "guestfs_utimens"
.IX Subsection "guestfs_utimens"
.Vb 7
\& int
\& guestfs_utimens (guestfs_h *g,
\&                  const char *path,
\&                  int64_t atsecs,
\&                  int64_t atnsecs,
\&                  int64_t mtsecs,
\&                  int64_t mtnsecs);
.Ve
.PP
This command sets the timestamps of a file with nanosecond precision.
.PP
\&\f(CW\*(C`atsecs, atnsecs\*(C'\fR are the last access time (atime) in secs and nanoseconds
from the epoch.
.PP
\&\f(CW\*(C`mtsecs, mtnsecs\*(C'\fR are the last modification time (mtime) in secs and
nanoseconds from the epoch.
.PP
If the \f(CW*nsecs\fR field contains the special value \f(CW\*(C`\-1\*(C'\fR then the
corresponding timestamp is set to the current time.  (The \f(CW*secs\fR field is
ignored in this case).
.PP
If the \f(CW*nsecs\fR field contains the special value \f(CW\*(C`\-2\*(C'\fR then the
corresponding timestamp is left unchanged.  (The \f(CW*secs\fR field is ignored
in this case).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.77)
.SS "guestfs_version"
.IX Subsection "guestfs_version"
.Vb 2
\& struct guestfs_version *
\& guestfs_version (guestfs_h *g);
.Ve
.PP
Return the libguestfs version number that the program is linked against.
.PP
Note that because of dynamic linking this is not necessarily the version of
libguestfs that you compiled against.  You can compile the program, and then
at runtime dynamically link against a completely different \f(CW\*(C`libguestfs.so\*(C'\fR
library.
.PP
This call was added in version \f(CW1.0.58\fR.  In previous versions of
libguestfs there was no way to get the version number.  From C code you can
use dynamic linker functions to find out if this symbol exists (if it
doesn't, then it's an earlier version).
.PP
The call returns a structure with four elements.  The first three (\f(CW\*(C`major\*(C'\fR,
\&\f(CW\*(C`minor\*(C'\fR and \f(CW\*(C`release\*(C'\fR) are numbers and correspond to the usual version
triplet.  The fourth element (\f(CW\*(C`extra\*(C'\fR) is a string and is normally empty,
but may be used for distro-specific information.
.PP
To construct the original version string: \f(CW\*(C`$major.$minor.$release$extra\*(C'\fR
.PP
See also: \*(L"\s-1LIBGUESTFS\s0 \s-1VERSION\s0 \s-1NUMBERS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
\&\fINote:\fR Don't use this call to test for availability of features.  In
enterprise distributions we backport features from later versions into
earlier versions, making this an unreliable way to test for features.  Use
\&\f(CW\*(C`guestfs_available\*(C'\fR instead.
.PP
This function returns a \f(CW\*(C`struct guestfs_version *\*(C'\fR, or \s-1NULL\s0 if there was an
error.  \fIThe caller must call \f(CI\*(C`guestfs_free_version\*(C'\fI after use\fR.
.PP
(Added in 1.0.58)
.SS "guestfs_vfs_label"
.IX Subsection "guestfs_vfs_label"
.Vb 3
\& char *
\& guestfs_vfs_label (guestfs_h *g,
\&                    const char *device);
.Ve
.PP
This returns the filesystem label of the filesystem on \f(CW\*(C`device\*(C'\fR.
.PP
If the filesystem is unlabeled, this returns the empty string.
.PP
To find a filesystem from the label, use \f(CW\*(C`guestfs_findfs_label\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.3.18)
.SS "guestfs_vfs_type"
.IX Subsection "guestfs_vfs_type"
.Vb 3
\& char *
\& guestfs_vfs_type (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This command gets the filesystem type corresponding to the filesystem on
\&\f(CW\*(C`device\*(C'\fR.
.PP
For most filesystems, the result is the name of the Linux \s-1VFS\s0 module which
would be used to mount this filesystem if you mounted it without specifying
the filesystem type.  For example a string such as \f(CW\*(C`ext3\*(C'\fR or \f(CW\*(C`ntfs\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.75)
.SS "guestfs_vfs_uuid"
.IX Subsection "guestfs_vfs_uuid"
.Vb 3
\& char *
\& guestfs_vfs_uuid (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This returns the filesystem \s-1UUID\s0 of the filesystem on \f(CW\*(C`device\*(C'\fR.
.PP
If the filesystem does not have a \s-1UUID\s0, this returns the empty string.
.PP
To find a filesystem from the \s-1UUID\s0, use \f(CW\*(C`guestfs_findfs_uuid\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.3.18)
.SS "guestfs_vg_activate"
.IX Subsection "guestfs_vg_activate"
.Vb 4
\& int
\& guestfs_vg_activate (guestfs_h *g,
\&                      int activate,
\&                      char *const *volgroups);
.Ve
.PP
This command activates or (if \f(CW\*(C`activate\*(C'\fR is false) deactivates all logical
volumes in the listed volume groups \f(CW\*(C`volgroups\*(C'\fR.
.PP
This command is the same as running \f(CW\*(C`vgchange \-a y|n volgroups...\*(C'\fR
.PP
Note that if \f(CW\*(C`volgroups\*(C'\fR is an empty list then \fBall\fR volume groups are
activated or deactivated.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.26)
.SS "guestfs_vg_activate_all"
.IX Subsection "guestfs_vg_activate_all"
.Vb 3
\& int
\& guestfs_vg_activate_all (guestfs_h *g,
\&                          int activate);
.Ve
.PP
This command activates or (if \f(CW\*(C`activate\*(C'\fR is false) deactivates all logical
volumes in all volume groups.
.PP
This command is the same as running \f(CW\*(C`vgchange \-a y|n\*(C'\fR
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.26)
.SS "guestfs_vgcreate"
.IX Subsection "guestfs_vgcreate"
.Vb 4
\& int
\& guestfs_vgcreate (guestfs_h *g,
\&                   const char *volgroup,
\&                   char *const *physvols);
.Ve
.PP
This creates an \s-1LVM\s0 volume group called \f(CW\*(C`volgroup\*(C'\fR from the non-empty list
of physical volumes \f(CW\*(C`physvols\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.8)
.SS "guestfs_vglvuuids"
.IX Subsection "guestfs_vglvuuids"
.Vb 3
\& char **
\& guestfs_vglvuuids (guestfs_h *g,
\&                    const char *vgname);
.Ve
.PP
Given a \s-1VG\s0 called \f(CW\*(C`vgname\*(C'\fR, this returns the UUIDs of all the logical
volumes created in this volume group.
.PP
You can use this along with \f(CW\*(C`guestfs_lvs\*(C'\fR and \f(CW\*(C`guestfs_lvuuid\*(C'\fR calls to
associate logical volumes and volume groups.
.PP
See also \f(CW\*(C`guestfs_vgpvuuids\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.87)
.SS "guestfs_vgpvuuids"
.IX Subsection "guestfs_vgpvuuids"
.Vb 3
\& char **
\& guestfs_vgpvuuids (guestfs_h *g,
\&                    const char *vgname);
.Ve
.PP
Given a \s-1VG\s0 called \f(CW\*(C`vgname\*(C'\fR, this returns the UUIDs of all the physical
volumes that this volume group resides on.
.PP
You can use this along with \f(CW\*(C`guestfs_pvs\*(C'\fR and \f(CW\*(C`guestfs_pvuuid\*(C'\fR calls to
associate physical volumes and volume groups.
.PP
See also \f(CW\*(C`guestfs_vglvuuids\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 1.0.87)
.SS "guestfs_vgremove"
.IX Subsection "guestfs_vgremove"
.Vb 3
\& int
\& guestfs_vgremove (guestfs_h *g,
\&                   const char *vgname);
.Ve
.PP
Remove an \s-1LVM\s0 volume group \f(CW\*(C`vgname\*(C'\fR, (for example \f(CW\*(C`VG\*(C'\fR).
.PP
This also forcibly removes all logical volumes in the volume group (if any).
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.13)
.SS "guestfs_vgrename"
.IX Subsection "guestfs_vgrename"
.Vb 4
\& int
\& guestfs_vgrename (guestfs_h *g,
\&                   const char *volgroup,
\&                   const char *newvolgroup);
.Ve
.PP
Rename a volume group \f(CW\*(C`volgroup\*(C'\fR with the new name \f(CW\*(C`newvolgroup\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.83)
.SS "guestfs_vgs"
.IX Subsection "guestfs_vgs"
.Vb 2
\& char **
\& guestfs_vgs (guestfs_h *g);
.Ve
.PP
List all the volumes groups detected.  This is the equivalent of the
\&\fIvgs\fR\|(8) command.
.PP
This returns a list of just the volume group names that were detected
(eg. \f(CW\*(C`VolGroup00\*(C'\fR).
.PP
See also \f(CW\*(C`guestfs_vgs_full\*(C'\fR.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
(Added in 0.4)
.SS "guestfs_vgs_full"
.IX Subsection "guestfs_vgs_full"
.Vb 2
\& struct guestfs_lvm_vg_list *
\& guestfs_vgs_full (guestfs_h *g);
.Ve
.PP
List all the volumes groups detected.  This is the equivalent of the
\&\fIvgs\fR\|(8) command.  The \*(L"full\*(R" version includes all fields.
.PP
This function returns a \f(CW\*(C`struct guestfs_lvm_vg_list *\*(C'\fR, or \s-1NULL\s0 if there
was an error.  \fIThe caller must call \f(CI\*(C`guestfs_free_lvm_vg_list\*(C'\fI after
use\fR.
.PP
(Added in 0.4)
.SS "guestfs_vgscan"
.IX Subsection "guestfs_vgscan"
.Vb 2
\& int
\& guestfs_vgscan (guestfs_h *g);
.Ve
.PP
This rescans all block devices and rebuilds the list of \s-1LVM\s0 physical
volumes, volume groups and logical volumes.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.3.2)
.SS "guestfs_vguuid"
.IX Subsection "guestfs_vguuid"
.Vb 3
\& char *
\& guestfs_vguuid (guestfs_h *g,
\&                 const char *vgname);
.Ve
.PP
This command returns the \s-1UUID\s0 of the \s-1LVM\s0 \s-1VG\s0 named \f(CW\*(C`vgname\*(C'\fR.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.87)
.SS "guestfs_wait_ready"
.IX Subsection "guestfs_wait_ready"
.Vb 2
\& int
\& guestfs_wait_ready (guestfs_h *g);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_launch\*(R" call
instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This function is a no op.
.PP
In versions of the \s-1API\s0 < 1.0.71 you had to call this function just after
calling \f(CW\*(C`guestfs_launch\*(C'\fR to wait for the launch to complete.  However this
is no longer necessary because \f(CW\*(C`guestfs_launch\*(C'\fR now does the waiting.
.PP
If you see any calls to this function in code then you can just remove them,
unless you want to retain compatibility with older versions of the \s-1API\s0.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 0.3)
.SS "guestfs_wc_c"
.IX Subsection "guestfs_wc_c"
.Vb 3
\& int
\& guestfs_wc_c (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This command counts the characters in a file, using the \f(CW\*(C`wc \-c\*(C'\fR external
command.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.54)
.SS "guestfs_wc_l"
.IX Subsection "guestfs_wc_l"
.Vb 3
\& int
\& guestfs_wc_l (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This command counts the lines in a file, using the \f(CW\*(C`wc \-l\*(C'\fR external
command.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.54)
.SS "guestfs_wc_w"
.IX Subsection "guestfs_wc_w"
.Vb 3
\& int
\& guestfs_wc_w (guestfs_h *g,
\&               const char *path);
.Ve
.PP
This command counts the words in a file, using the \f(CW\*(C`wc \-w\*(C'\fR external
command.
.PP
On error this function returns \-1.
.PP
(Added in 1.0.54)
.SS "guestfs_write"
.IX Subsection "guestfs_write"
.Vb 5
\& int
\& guestfs_write (guestfs_h *g,
\&                const char *path,
\&                const char *content,
\&                size_t content_size);
.Ve
.PP
This call creates a file called \f(CW\*(C`path\*(C'\fR.  The content of the file is the
string \f(CW\*(C`content\*(C'\fR (which can contain any 8 bit data).
.PP
See also \f(CW\*(C`guestfs_write_append\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.3.14)
.SS "guestfs_write_append"
.IX Subsection "guestfs_write_append"
.Vb 5
\& int
\& guestfs_write_append (guestfs_h *g,
\&                       const char *path,
\&                       const char *content,
\&                       size_t content_size);
.Ve
.PP
This call appends \f(CW\*(C`content\*(C'\fR to the end of file \f(CW\*(C`path\*(C'\fR.  If \f(CW\*(C`path\*(C'\fR does
not exist, then a new file is created.
.PP
See also \f(CW\*(C`guestfs_write\*(C'\fR.
.PP
This function returns 0 on success or \-1 on error.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.11.18)
.SS "guestfs_write_file"
.IX Subsection "guestfs_write_file"
.Vb 5
\& int
\& guestfs_write_file (guestfs_h *g,
\&                     const char *path,
\&                     const char *content,
\&                     int size);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_write\*(R" call
instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This call creates a file called \f(CW\*(C`path\*(C'\fR.  The contents of the file is the
string \f(CW\*(C`content\*(C'\fR (which can contain any 8 bit data), with length \f(CW\*(C`size\*(C'\fR.
.PP
As a special case, if \f(CW\*(C`size\*(C'\fR is \f(CW0\fR then the length is calculated using
\&\f(CW\*(C`strlen\*(C'\fR (so in this case the content cannot contain embedded \s-1ASCII\s0 NULs).
.PP
\&\fI\s-1NB\s0.\fR Owing to a bug, writing content containing \s-1ASCII\s0 \s-1NUL\s0 characters does
\&\fInot\fR work, even if the length is specified.
.PP
This function returns 0 on success or \-1 on error.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 0.8)
.SS "guestfs_zegrep"
.IX Subsection "guestfs_zegrep"
.Vb 4
\& char **
\& guestfs_zegrep (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`zegrep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_zegrepi"
.IX Subsection "guestfs_zegrepi"
.Vb 4
\& char **
\& guestfs_zegrepi (guestfs_h *g,
\&                  const char *regex,
\&                  const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`zegrep \-i\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_zero"
.IX Subsection "guestfs_zero"
.Vb 3
\& int
\& guestfs_zero (guestfs_h *g,
\&               const char *device);
.Ve
.PP
This command writes zeroes over the first few blocks of \f(CW\*(C`device\*(C'\fR.
.PP
How many blocks are zeroed isn't specified (but it's \fInot\fR enough to
securely wipe the device).  It should be sufficient to remove any partition
tables, filesystem superblocks and so on.
.PP
If blocks are already zero, then this command avoids writing zeroes.  This
prevents the underlying device from becoming non-sparse or growing
unnecessarily.
.PP
See also: \f(CW\*(C`guestfs_zero_device\*(C'\fR, \f(CW\*(C`guestfs_scrub_device\*(C'\fR,
\&\f(CW\*(C`guestfs_is_zero_device\*(C'\fR
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.16)
.SS "guestfs_zero_device"
.IX Subsection "guestfs_zero_device"
.Vb 3
\& int
\& guestfs_zero_device (guestfs_h *g,
\&                      const char *device);
.Ve
.PP
This command writes zeroes over the entire \f(CW\*(C`device\*(C'\fR.  Compare with
\&\f(CW\*(C`guestfs_zero\*(C'\fR which just zeroes the first few blocks of a device.
.PP
If blocks are already zero, then this command avoids writing zeroes.  This
prevents the underlying device from becoming non-sparse or growing
unnecessarily.
.PP
This function returns 0 on success or \-1 on error.
.PP
This long-running command can generate progress notification messages so
that the caller can display a progress bar or indicator.  To receive these
messages, the caller must register a progress event callback.  See
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.3.1)
.SS "guestfs_zerofree"
.IX Subsection "guestfs_zerofree"
.Vb 3
\& int
\& guestfs_zerofree (guestfs_h *g,
\&                   const char *device);
.Ve
.PP
This runs the \fIzerofree\fR program on \f(CW\*(C`device\*(C'\fR.  This program claims to zero
unused inodes and disk blocks on an ext2/3 filesystem, thus making it
possible to compress the filesystem more effectively.
.PP
You should \fBnot\fR run this program if the filesystem is mounted.
.PP
It is possible that using this program can damage the filesystem or data on
the filesystem.
.PP
This function returns 0 on success or \-1 on error.
.PP
(Added in 1.0.26)
.SS "guestfs_zfgrep"
.IX Subsection "guestfs_zfgrep"
.Vb 4
\& char **
\& guestfs_zfgrep (guestfs_h *g,
\&                 const char *pattern,
\&                 const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`zfgrep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_zfgrepi"
.IX Subsection "guestfs_zfgrepi"
.Vb 4
\& char **
\& guestfs_zfgrepi (guestfs_h *g,
\&                  const char *pattern,
\&                  const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`zfgrep \-i\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_zfile"
.IX Subsection "guestfs_zfile"
.Vb 4
\& char *
\& guestfs_zfile (guestfs_h *g,
\&                const char *meth,
\&                const char *path);
.Ve
.PP
\&\fIThis function is deprecated.\fR In new code, use the \*(L"guestfs_file\*(R" call
instead.
.PP
Deprecated functions will not be removed from the \s-1API\s0, but the fact that
they are deprecated indicates that there are problems with correct use of
these functions.
.PP
This command runs \f(CW\*(C`file\*(C'\fR after first decompressing \f(CW\*(C`path\*(C'\fR using \f(CW\*(C`method\*(C'\fR.
.PP
\&\f(CW\*(C`method\*(C'\fR must be one of \f(CW\*(C`gzip\*(C'\fR, \f(CW\*(C`compress\*(C'\fR or \f(CW\*(C`bzip2\*(C'\fR.
.PP
Since 1.0.63, use \f(CW\*(C`guestfs_file\*(C'\fR instead which can now process compressed
files.
.PP
This function returns a string, or \s-1NULL\s0 on error.  \fIThe caller must free
the returned string after use\fR.
.PP
(Added in 1.0.59)
.SS "guestfs_zgrep"
.IX Subsection "guestfs_zgrep"
.Vb 4
\& char **
\& guestfs_zgrep (guestfs_h *g,
\&                const char *regex,
\&                const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`zgrep\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SS "guestfs_zgrepi"
.IX Subsection "guestfs_zgrepi"
.Vb 4
\& char **
\& guestfs_zgrepi (guestfs_h *g,
\&                 const char *regex,
\&                 const char *path);
.Ve
.PP
This calls the external \f(CW\*(C`zgrep \-i\*(C'\fR program and returns the matching lines.
.PP
This function returns a NULL-terminated array of strings (like
\&\fIenviron\fR\|(3)), or \s-1NULL\s0 if there was an error.  \fIThe caller must free the
strings and the array after use\fR.
.PP
Because of the message protocol, there is a transfer limit of somewhere
between 2MB and 4MB.  See \*(L"\s-1PROTOCOL\s0 \s-1LIMITS\s0\*(R" in \fIguestfs\fR\|(3).
.PP
(Added in 1.0.66)
.SH "STRUCTURES"
.IX Header "STRUCTURES"
.SS "guestfs_int_bool"
.IX Subsection "guestfs_int_bool"
.Vb 4
\& struct guestfs_int_bool {
\&   int32_t i;
\&   int32_t b;
\& };
\& 
\& struct guestfs_int_bool_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_int_bool *val; /* Elements. */
\& };
\& 
\& void guestfs_free_int_bool (struct guestfs_free_int_bool *);
\& void guestfs_free_int_bool_list (struct guestfs_free_int_bool_list *);
.Ve
.SS "guestfs_lvm_pv"
.IX Subsection "guestfs_lvm_pv"
.Vb 10
\& struct guestfs_lvm_pv {
\&   char *pv_name;
\&   /* The next field is NOT nul\-terminated, be careful when printing it: */
\&   char pv_uuid[32];
\&   char *pv_fmt;
\&   uint64_t pv_size;
\&   uint64_t dev_size;
\&   uint64_t pv_free;
\&   uint64_t pv_used;
\&   char *pv_attr;
\&   int64_t pv_pe_count;
\&   int64_t pv_pe_alloc_count;
\&   char *pv_tags;
\&   uint64_t pe_start;
\&   int64_t pv_mda_count;
\&   uint64_t pv_mda_free;
\& };
\& 
\& struct guestfs_lvm_pv_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_lvm_pv *val; /* Elements. */
\& };
\& 
\& void guestfs_free_lvm_pv (struct guestfs_free_lvm_pv *);
\& void guestfs_free_lvm_pv_list (struct guestfs_free_lvm_pv_list *);
.Ve
.SS "guestfs_lvm_vg"
.IX Subsection "guestfs_lvm_vg"
.Vb 10
\& struct guestfs_lvm_vg {
\&   char *vg_name;
\&   /* The next field is NOT nul\-terminated, be careful when printing it: */
\&   char vg_uuid[32];
\&   char *vg_fmt;
\&   char *vg_attr;
\&   uint64_t vg_size;
\&   uint64_t vg_free;
\&   char *vg_sysid;
\&   uint64_t vg_extent_size;
\&   int64_t vg_extent_count;
\&   int64_t vg_free_count;
\&   int64_t max_lv;
\&   int64_t max_pv;
\&   int64_t pv_count;
\&   int64_t lv_count;
\&   int64_t snap_count;
\&   int64_t vg_seqno;
\&   char *vg_tags;
\&   int64_t vg_mda_count;
\&   uint64_t vg_mda_free;
\& };
\& 
\& struct guestfs_lvm_vg_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_lvm_vg *val; /* Elements. */
\& };
\& 
\& void guestfs_free_lvm_vg (struct guestfs_free_lvm_vg *);
\& void guestfs_free_lvm_vg_list (struct guestfs_free_lvm_vg_list *);
.Ve
.SS "guestfs_lvm_lv"
.IX Subsection "guestfs_lvm_lv"
.Vb 10
\& struct guestfs_lvm_lv {
\&   char *lv_name;
\&   /* The next field is NOT nul\-terminated, be careful when printing it: */
\&   char lv_uuid[32];
\&   char *lv_attr;
\&   int64_t lv_major;
\&   int64_t lv_minor;
\&   int64_t lv_kernel_major;
\&   int64_t lv_kernel_minor;
\&   uint64_t lv_size;
\&   int64_t seg_count;
\&   char *origin;
\&   /* The next field is [0..100] or \-1 meaning \*(Aqnot present\*(Aq: */
\&   float snap_percent;
\&   /* The next field is [0..100] or \-1 meaning \*(Aqnot present\*(Aq: */
\&   float copy_percent;
\&   char *move_pv;
\&   char *lv_tags;
\&   char *mirror_log;
\&   char *modules;
\& };
\& 
\& struct guestfs_lvm_lv_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_lvm_lv *val; /* Elements. */
\& };
\& 
\& void guestfs_free_lvm_lv (struct guestfs_free_lvm_lv *);
\& void guestfs_free_lvm_lv_list (struct guestfs_free_lvm_lv_list *);
.Ve
.SS "guestfs_stat"
.IX Subsection "guestfs_stat"
.Vb 10
\& struct guestfs_stat {
\&   int64_t dev;
\&   int64_t ino;
\&   int64_t mode;
\&   int64_t nlink;
\&   int64_t uid;
\&   int64_t gid;
\&   int64_t rdev;
\&   int64_t size;
\&   int64_t blksize;
\&   int64_t blocks;
\&   int64_t atime;
\&   int64_t mtime;
\&   int64_t ctime;
\& };
\& 
\& struct guestfs_stat_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_stat *val; /* Elements. */
\& };
\& 
\& void guestfs_free_stat (struct guestfs_free_stat *);
\& void guestfs_free_stat_list (struct guestfs_free_stat_list *);
.Ve
.SS "guestfs_statvfs"
.IX Subsection "guestfs_statvfs"
.Vb 10
\& struct guestfs_statvfs {
\&   int64_t bsize;
\&   int64_t frsize;
\&   int64_t blocks;
\&   int64_t bfree;
\&   int64_t bavail;
\&   int64_t files;
\&   int64_t ffree;
\&   int64_t favail;
\&   int64_t fsid;
\&   int64_t flag;
\&   int64_t namemax;
\& };
\& 
\& struct guestfs_statvfs_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_statvfs *val; /* Elements. */
\& };
\& 
\& void guestfs_free_statvfs (struct guestfs_free_statvfs *);
\& void guestfs_free_statvfs_list (struct guestfs_free_statvfs_list *);
.Ve
.SS "guestfs_dirent"
.IX Subsection "guestfs_dirent"
.Vb 5
\& struct guestfs_dirent {
\&   int64_t ino;
\&   char ftyp;
\&   char *name;
\& };
\& 
\& struct guestfs_dirent_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_dirent *val; /* Elements. */
\& };
\& 
\& void guestfs_free_dirent (struct guestfs_free_dirent *);
\& void guestfs_free_dirent_list (struct guestfs_free_dirent_list *);
.Ve
.SS "guestfs_version"
.IX Subsection "guestfs_version"
.Vb 6
\& struct guestfs_version {
\&   int64_t major;
\&   int64_t minor;
\&   int64_t release;
\&   char *extra;
\& };
\& 
\& struct guestfs_version_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_version *val; /* Elements. */
\& };
\& 
\& void guestfs_free_version (struct guestfs_free_version *);
\& void guestfs_free_version_list (struct guestfs_free_version_list *);
.Ve
.SS "guestfs_xattr"
.IX Subsection "guestfs_xattr"
.Vb 6
\& struct guestfs_xattr {
\&   char *attrname;
\&   /* The next two fields describe a byte array. */
\&   uint32_t attrval_len;
\&   char *attrval;
\& };
\& 
\& struct guestfs_xattr_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_xattr *val; /* Elements. */
\& };
\& 
\& void guestfs_free_xattr (struct guestfs_free_xattr *);
\& void guestfs_free_xattr_list (struct guestfs_free_xattr_list *);
.Ve
.SS "guestfs_inotify_event"
.IX Subsection "guestfs_inotify_event"
.Vb 6
\& struct guestfs_inotify_event {
\&   int64_t in_wd;
\&   uint32_t in_mask;
\&   uint32_t in_cookie;
\&   char *in_name;
\& };
\& 
\& struct guestfs_inotify_event_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_inotify_event *val; /* Elements. */
\& };
\& 
\& void guestfs_free_inotify_event (struct guestfs_free_inotify_event *);
\& void guestfs_free_inotify_event_list (struct guestfs_free_inotify_event_list *);
.Ve
.SS "guestfs_partition"
.IX Subsection "guestfs_partition"
.Vb 6
\& struct guestfs_partition {
\&   int32_t part_num;
\&   uint64_t part_start;
\&   uint64_t part_end;
\&   uint64_t part_size;
\& };
\& 
\& struct guestfs_partition_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_partition *val; /* Elements. */
\& };
\& 
\& void guestfs_free_partition (struct guestfs_free_partition *);
\& void guestfs_free_partition_list (struct guestfs_free_partition_list *);
.Ve
.SS "guestfs_application"
.IX Subsection "guestfs_application"
.Vb 10
\& struct guestfs_application {
\&   char *app_name;
\&   char *app_display_name;
\&   int32_t app_epoch;
\&   char *app_version;
\&   char *app_release;
\&   char *app_install_path;
\&   char *app_trans_path;
\&   char *app_publisher;
\&   char *app_url;
\&   char *app_source_package;
\&   char *app_summary;
\&   char *app_description;
\& };
\& 
\& struct guestfs_application_list {
\&   uint32_t len; /* Number of elements in list. */
\&   struct guestfs_application *val; /* Elements. */
\& };
\& 
\& void guestfs_free_application (struct guestfs_free_application *);
\& void guestfs_free_application_list (struct guestfs_free_application_list *);
.Ve
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
.SS "\s-1GROUPS\s0 \s-1OF\s0 \s-1FUNCTIONALITY\s0 \s-1IN\s0 \s-1THE\s0 \s-1APPLIANCE\s0"
.IX Subsection "GROUPS OF FUNCTIONALITY IN THE APPLIANCE"
Using \*(L"guestfs_available\*(R" you can test availability of the following
groups of functions.  This test queries the appliance to see if the
appliance you are currently using supports the functionality.
.IP "\fBaugeas\fR" 4
.IX Item "augeas"
The following functions: \*(L"guestfs_aug_clear\*(R" \*(L"guestfs_aug_close\*(R"
\&\*(L"guestfs_aug_defnode\*(R" \*(L"guestfs_aug_defvar\*(R" \*(L"guestfs_aug_get\*(R"
\&\*(L"guestfs_aug_init\*(R" \*(L"guestfs_aug_insert\*(R" \*(L"guestfs_aug_load\*(R"
\&\*(L"guestfs_aug_ls\*(R" \*(L"guestfs_aug_match\*(R" \*(L"guestfs_aug_mv\*(R"
\&\*(L"guestfs_aug_rm\*(R" \*(L"guestfs_aug_save\*(R" \*(L"guestfs_aug_set\*(R"
.IP "\fBbtrfs\fR" 4
.IX Item "btrfs"
The following functions: \*(L"guestfs_btrfs_filesystem_resize\*(R"
.IP "\fBgrub\fR" 4
.IX Item "grub"
The following functions: \*(L"guestfs_grub_install\*(R"
.IP "\fBinotify\fR" 4
.IX Item "inotify"
The following functions: \*(L"guestfs_inotify_add_watch\*(R"
\&\*(L"guestfs_inotify_close\*(R" \*(L"guestfs_inotify_files\*(R" \*(L"guestfs_inotify_init\*(R"
\&\*(L"guestfs_inotify_read\*(R" \*(L"guestfs_inotify_rm_watch\*(R"
.IP "\fBlinuxfsuuid\fR" 4
.IX Item "linuxfsuuid"
The following functions: \*(L"guestfs_mke2fs_JU\*(R" \*(L"guestfs_mke2journal_U\*(R"
\&\*(L"guestfs_mkswap_U\*(R" \*(L"guestfs_swapoff_uuid\*(R" \*(L"guestfs_swapon_uuid\*(R"
.IP "\fBlinuxmodules\fR" 4
.IX Item "linuxmodules"
The following functions: \*(L"guestfs_modprobe\*(R"
.IP "\fBlinuxxattrs\fR" 4
.IX Item "linuxxattrs"
The following functions: \*(L"guestfs_getxattr\*(R" \*(L"guestfs_getxattrs\*(R"
\&\*(L"guestfs_lgetxattr\*(R" \*(L"guestfs_lgetxattrs\*(R" \*(L"guestfs_lremovexattr\*(R"
\&\*(L"guestfs_lsetxattr\*(R" \*(L"guestfs_lxattrlist\*(R" \*(L"guestfs_removexattr\*(R"
\&\*(L"guestfs_setxattr\*(R"
.IP "\fBluks\fR" 4
.IX Item "luks"
The following functions: \*(L"guestfs_luks_add_key\*(R" \*(L"guestfs_luks_close\*(R"
\&\*(L"guestfs_luks_format\*(R" \*(L"guestfs_luks_format_cipher\*(R"
\&\*(L"guestfs_luks_kill_slot\*(R" \*(L"guestfs_luks_open\*(R" \*(L"guestfs_luks_open_ro\*(R"
.IP "\fBlvm2\fR" 4
.IX Item "lvm2"
The following functions: \*(L"guestfs_is_lv\*(R" \*(L"guestfs_lvcreate\*(R"
\&\*(L"guestfs_lvm_remove_all\*(R" \*(L"guestfs_lvm_set_filter\*(R" \*(L"guestfs_lvremove\*(R"
\&\*(L"guestfs_lvresize\*(R" \*(L"guestfs_lvresize_free\*(R" \*(L"guestfs_lvs\*(R"
\&\*(L"guestfs_lvs_full\*(R" \*(L"guestfs_pvcreate\*(R" \*(L"guestfs_pvremove\*(R"
\&\*(L"guestfs_pvresize\*(R" \*(L"guestfs_pvresize_size\*(R" \*(L"guestfs_pvs\*(R"
\&\*(L"guestfs_pvs_full\*(R" \*(L"guestfs_vg_activate\*(R" \*(L"guestfs_vg_activate_all\*(R"
\&\*(L"guestfs_vgcreate\*(R" \*(L"guestfs_vgremove\*(R" \*(L"guestfs_vgs\*(R"
\&\*(L"guestfs_vgs_full\*(R"
.IP "\fBmdadm\fR" 4
.IX Item "mdadm"
The following functions: \*(L"guestfs_md_create\*(R" \*(L"guestfs_md_detail\*(R"
\&\*(L"guestfs_md_stop\*(R"
.IP "\fBmknod\fR" 4
.IX Item "mknod"
The following functions: \*(L"guestfs_mkfifo\*(R" \*(L"guestfs_mknod\*(R"
\&\*(L"guestfs_mknod_b\*(R" \*(L"guestfs_mknod_c\*(R"
.IP "\fBntfs3g\fR" 4
.IX Item "ntfs3g"
The following functions: \*(L"guestfs_ntfs_3g_probe\*(R"
.IP "\fBntfsprogs\fR" 4
.IX Item "ntfsprogs"
The following functions: \*(L"guestfs_ntfsresize\*(R" \*(L"guestfs_ntfsresize_opts\*(R"
\&\*(L"guestfs_ntfsresize_size\*(R"
.IP "\fBrealpath\fR" 4
.IX Item "realpath"
The following functions: \*(L"guestfs_realpath\*(R"
.IP "\fBscrub\fR" 4
.IX Item "scrub"
The following functions: \*(L"guestfs_scrub_device\*(R" \*(L"guestfs_scrub_file\*(R"
\&\*(L"guestfs_scrub_freespace\*(R"
.IP "\fBselinux\fR" 4
.IX Item "selinux"
The following functions: \*(L"guestfs_getcon\*(R" \*(L"guestfs_setcon\*(R"
.IP "\fBxz\fR" 4
.IX Item "xz"
The following functions: \*(L"guestfs_txz_in\*(R" \*(L"guestfs_txz_out\*(R"
.IP "\fBzerofree\fR" 4
.IX Item "zerofree"
The following functions: \*(L"guestfs_zerofree\*(R"
.SS "\s-1GUESTFISH\s0 supported \s-1COMMAND\s0"
.IX Subsection "GUESTFISH supported COMMAND"
In \fIguestfish\fR\|(3) there is a handy interactive command \f(CW\*(C`supported\*(C'\fR which
prints out the available groups and whether they are supported by this build
of libguestfs.  Note however that you have to do \f(CW\*(C`run\*(C'\fR first.
.SS "\s-1SINGLE\s0 \s-1CALLS\s0 \s-1AT\s0 \s-1COMPILE\s0 \s-1TIME\s0"
.IX Subsection "SINGLE CALLS AT COMPILE TIME"
Since version 1.5.8, \f(CW\*(C`<guestfs.h>\*(C'\fR defines symbols for each C \s-1API\s0
function, such as:
.PP
.Vb 1
\& #define LIBGUESTFS_HAVE_DD 1
.Ve
.PP
if \*(L"guestfs_dd\*(R" is available.
.PP
Before version 1.5.8, if you needed to test whether a single libguestfs
function is available at compile time, we recommended using build tools such
as autoconf or cmake.  For example in autotools you could use:
.PP
.Vb 2
\& AC_CHECK_LIB([guestfs],[guestfs_create])
\& AC_CHECK_FUNCS([guestfs_dd])
.Ve
.PP
which would result in \f(CW\*(C`HAVE_GUESTFS_DD\*(C'\fR being either defined or not defined
in your program.
.SS "\s-1SINGLE\s0 \s-1CALLS\s0 \s-1AT\s0 \s-1RUN\s0 \s-1TIME\s0"
.IX Subsection "SINGLE CALLS AT RUN TIME"
Testing at compile time doesn't guarantee that a function really exists in
the library.  The reason is that you might be dynamically linked against a
previous \fIlibguestfs.so\fR (dynamic library)  which doesn't have the call.
This situation unfortunately results in a segmentation fault, which is a
shortcoming of the C dynamic linking system itself.
.PP
You can use \fIdlopen\fR\|(3) to test if a function is available at run time, as
in this example program (note that you still need the compile time check as
well):
.PP
.Vb 5
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <unistd.h>
\& #include <dlfcn.h>
\& #include <guestfs.h>
\& 
\& main ()
\& {
\& #ifdef LIBGUESTFS_HAVE_DD
\&   void *dl;
\&   int has_function;
\& 
\&   /* Test if the function guestfs_dd is really available. */
\&   dl = dlopen (NULL, RTLD_LAZY);
\&   if (!dl) {
\&     fprintf (stderr, "dlopen: %s\en", dlerror ());
\&     exit (EXIT_FAILURE);
\&   }
\&   has_function = dlsym (dl, "guestfs_dd") != NULL;
\&   dlclose (dl);
\& 
\&   if (!has_function)
\&     printf ("this libguestfs.so does NOT have guestfs_dd function\en");
\&   else {
\&     printf ("this libguestfs.so has guestfs_dd function\en");
\&     /* Now it\*(Aqs safe to call
\&     guestfs_dd (g, "foo", "bar");
\&     */
\&   }
\& #else
\&   printf ("guestfs_dd function was not found at compile time\en");
\& #endif
\&  }
.Ve
.PP
You may think the above is an awful lot of hassle, and it is.  There are
other ways outside of the C linking system to ensure that this kind of
incompatibility never arises, such as using package versioning:
.PP
.Vb 1
\& Requires: libguestfs >= 1.0.80
.Ve
.SH "CALLS WITH OPTIONAL ARGUMENTS"
.IX Header "CALLS WITH OPTIONAL ARGUMENTS"
A recent feature of the \s-1API\s0 is the introduction of calls which take optional
arguments.  In C these are declared 3 ways.  The main way is as a call which
takes variable arguments (ie. \f(CW\*(C`...\*(C'\fR), as in this example:
.PP
.Vb 1
\& int guestfs_add_drive_opts (guestfs_h *g, const char *filename, ...);
.Ve
.PP
Call this with a list of optional arguments, terminated by \f(CW\*(C`\-1\*(C'\fR.  So to
call with no optional arguments specified:
.PP
.Vb 1
\& guestfs_add_drive_opts (g, filename, \-1);
.Ve
.PP
With a single optional argument:
.PP
.Vb 3
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
\&                         \-1);
.Ve
.PP
With two:
.PP
.Vb 4
\& guestfs_add_drive_opts (g, filename,
\&                         GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2",
\&                         GUESTFS_ADD_DRIVE_OPTS_READONLY, 1,
\&                         \-1);
.Ve
.PP
and so forth.  Don't forget the terminating \f(CW\*(C`\-1\*(C'\fR otherwise Bad Things will
happen!
.SS "\s-1USING\s0 va_list \s-1FOR\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0"
.IX Subsection "USING va_list FOR OPTIONAL ARGUMENTS"
The second variant has the same name with the suffix \f(CW\*(C`_va\*(C'\fR, which works the
same way but takes a \f(CW\*(C`va_list\*(C'\fR.  See the C manual for details.  For the
example function, this is declared:
.PP
.Vb 2
\& int guestfs_add_drive_opts_va (guestfs_h *g, const char *filename,
\&                                va_list args);
.Ve
.SS "\s-1CONSTRUCTING\s0 \s-1OPTIONAL\s0 \s-1ARGUMENTS\s0"
.IX Subsection "CONSTRUCTING OPTIONAL ARGUMENTS"
The third variant is useful where you need to construct these calls.  You
pass in a structure where you fill in the optional fields.  The structure
has a bitmask as the first element which you must set to indicate which
fields you have filled in.  For our example function the structure and call
are declared:
.PP
.Vb 8
\& struct guestfs_add_drive_opts_argv {
\&   uint64_t bitmask;
\&   int readonly;
\&   const char *format;
\&   /* ... */
\& };
\& int guestfs_add_drive_opts_argv (guestfs_h *g, const char *filename,
\&              const struct guestfs_add_drive_opts_argv *optargs);
.Ve
.PP
You could call it like this:
.PP
.Vb 6
\& struct guestfs_add_drive_opts_argv optargs = {
\&   .bitmask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK |
\&              GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK,
\&   .readonly = 1,
\&   .format = "qcow2"
\& };
\& 
\& guestfs_add_drive_opts_argv (g, filename, &optargs);
.Ve
.PP
Notes:
.IP "\(bu" 4
The \f(CW\*(C`_BITMASK\*(C'\fR suffix on each option name when specifying the bitmask.
.IP "\(bu" 4
You do not need to fill in all fields of the structure.
.IP "\(bu" 4
There must be a one-to-one correspondence between fields of the structure
that are filled in, and bits set in the bitmask.
.SS "\s-1OPTIONAL\s0 \s-1ARGUMENTS\s0 \s-1IN\s0 \s-1OTHER\s0 \s-1LANGUAGES\s0"
.IX Subsection "OPTIONAL ARGUMENTS IN OTHER LANGUAGES"
In other languages, optional arguments are expressed in the way that is
natural for that language.  We refer you to the language-specific
documentation for more details on that.
.PP
For guestfish, see \*(L"\s-1OPTIONAL\s0 \s-1ARGUMENTS\s0\*(R" in \fIguestfish\fR\|(1).
.SS "\s-1SETTING\s0 \s-1CALLBACKS\s0 \s-1TO\s0 \s-1HANDLE\s0 \s-1EVENTS\s0"
.IX Subsection "SETTING CALLBACKS TO HANDLE EVENTS"
\&\fBNote:\fR This section documents the generic event mechanism introduced in
libguestfs 1.10, which you should use in new code if possible.  The old
functions \f(CW\*(C`guestfs_set_log_message_callback\*(C'\fR,
\&\f(CW\*(C`guestfs_set_subprocess_quit_callback\*(C'\fR,
\&\f(CW\*(C`guestfs_set_launch_done_callback\*(C'\fR, \f(CW\*(C`guestfs_set_close_callback\*(C'\fR and
\&\f(CW\*(C`guestfs_set_progress_callback\*(C'\fR are no longer documented in this manual
page.  Because of the \s-1ABI\s0 guarantee, the old functions continue to work.
.PP
Handles generate events when certain things happen, such as log messages
being generated, progress messages during long-running operations, or the
handle being closed.  The \s-1API\s0 calls described below let you register a
callback to be called when events happen.  You can register multiple
callbacks (for the same, different or overlapping sets of events), and
individually remove callbacks.  If callbacks are not removed, then they
remain in force until the handle is closed.
.PP
In the current implementation, events are only generated synchronously: that
means that events (and hence callbacks) can only happen while you are in the
middle of making another libguestfs call.  The callback is called in the
same thread.
.PP
Events may contain a payload, usually nothing (void), an array of 64 bit
unsigned integers, or a message buffer.  Payloads are discussed later on.
.PP
\fI\s-1CLASSES\s0 \s-1OF\s0 \s-1EVENTS\s0\fR
.IX Subsection "CLASSES OF EVENTS"
.IP "\s-1GUESTFS_EVENT_CLOSE\s0 (payload type: void)" 4
.IX Item "GUESTFS_EVENT_CLOSE (payload type: void)"
The callback function will be called while the handle is being closed
(synchronously from \*(L"guestfs_close\*(R").
.Sp
Note that libguestfs installs an \fIatexit\fR\|(3) handler to try to clean up
handles that are open when the program exits.  This means that this callback
might be called indirectly from \fIexit\fR\|(3), which can cause unexpected
problems in higher-level languages (eg. if your \s-1HLL\s0 interpreter has already
been cleaned up by the time this is called, and if your callback then jumps
into some \s-1HLL\s0 function).
.Sp
If no callback is registered: the handle is closed without any callback
being invoked.
.IP "\s-1GUESTFS_EVENT_SUBPROCESS_QUIT\s0 (payload type: void)" 4
.IX Item "GUESTFS_EVENT_SUBPROCESS_QUIT (payload type: void)"
The callback function will be called when the child process quits, either
asynchronously or if killed by \*(L"guestfs_kill_subprocess\*(R".  (This
corresponds to a transition from any state to the \s-1CONFIG\s0 state).
.Sp
If no callback is registered: the event is ignored.
.IP "\s-1GUESTFS_EVENT_LAUNCH_DONE\s0 (payload type: void)" 4
.IX Item "GUESTFS_EVENT_LAUNCH_DONE (payload type: void)"
The callback function will be called when the child process becomes ready
first time after it has been launched.  (This corresponds to a transition
from \s-1LAUNCHING\s0 to the \s-1READY\s0 state).
.Sp
If no callback is registered: the event is ignored.
.IP "\s-1GUESTFS_EVENT_PROGRESS\s0 (payload type: array of 4 x uint64_t)" 4
.IX Item "GUESTFS_EVENT_PROGRESS (payload type: array of 4 x uint64_t)"
Some long-running operations can generate progress messages.  If this
callback is registered, then it will be called each time a progress message
is generated (usually two seconds after the operation started, and three
times per second thereafter until it completes, although the frequency may
change in future versions).
.Sp
The callback receives in the payload four unsigned 64 bit numbers which are
(in order): \f(CW\*(C`proc_nr\*(C'\fR, \f(CW\*(C`serial\*(C'\fR, \f(CW\*(C`position\*(C'\fR, \f(CW\*(C`total\*(C'\fR.
.Sp
The units of \f(CW\*(C`total\*(C'\fR are not defined, although for some operations \f(CW\*(C`total\*(C'\fR
may relate in some way to the amount of data to be transferred (eg. in bytes
or megabytes), and \f(CW\*(C`position\*(C'\fR may be the portion which has been
transferred.
.Sp
The only defined and stable parts of the \s-1API\s0 are:
.RS 4
.IP "\(bu" 4
The callback can display to the user some type of progress bar or indicator
which shows the ratio of \f(CW\*(C`position\*(C'\fR:\f(CW\*(C`total\*(C'\fR.
.IP "\(bu" 4
0 <= \f(CW\*(C`position\*(C'\fR <= \f(CW\*(C`total\*(C'\fR
.IP "\(bu" 4
If any progress notification is sent during a call, then a final progress
notification is always sent when \f(CW\*(C`position\*(C'\fR = \f(CW\*(C`total\*(C'\fR (\fIunless\fR the call
fails with an error).
.Sp
This is to simplify caller code, so callers can easily set the progress
indicator to \*(L"100%\*(R" at the end of the operation, without requiring special
code to detect this case.
.IP "\(bu" 4
For some calls we are unable to estimate the progress of the call, but we
can still generate progress messages to indicate activity.  This is known as
\&\*(L"pulse mode\*(R", and is directly supported by certain progress bar
implementations (eg. GtkProgressBar).
.Sp
For these calls, zero or more progress messages are generated with
\&\f(CW\*(C`position = 0\*(C'\fR and \f(CW\*(C`total = 1\*(C'\fR, followed by a final message with
\&\f(CW\*(C`position = total = 1\*(C'\fR.
.Sp
As noted above, if the call fails with an error then the final message may
not be generated.
.RE
.RS 4
.Sp
The callback also receives the procedure number (\f(CW\*(C`proc_nr\*(C'\fR) and serial
number (\f(CW\*(C`serial\*(C'\fR) of the call.  These are only useful for debugging
protocol issues, and the callback can normally ignore them.  The callback
may want to print these numbers in error messages or debugging messages.
.Sp
If no callback is registered: progress messages are discarded.
.RE
.IP "\s-1GUESTFS_EVENT_APPLIANCE\s0 (payload type: message buffer)" 4
.IX Item "GUESTFS_EVENT_APPLIANCE (payload type: message buffer)"
The callback function is called whenever a log message is generated by qemu,
the appliance kernel, guestfsd (daemon), or utility programs.
.Sp
If the verbose flag (\*(L"guestfs_set_verbose\*(R") is set before launch
(\*(L"guestfs_launch\*(R") then additional debug messages are generated.
.Sp
If no callback is registered: the messages are discarded unless the verbose
flag is set in which case they are sent to stderr.  You can override the
printing of verbose messages to stderr by setting up a callback.
.IP "\s-1GUESTFS_EVENT_LIBRARY\s0 (payload type: message buffer)" 4
.IX Item "GUESTFS_EVENT_LIBRARY (payload type: message buffer)"
The callback function is called whenever a log message is generated by the
library part of libguestfs.
.Sp
If the verbose flag (\*(L"guestfs_set_verbose\*(R") is set then additional debug
messages are generated.
.Sp
If no callback is registered: the messages are discarded unless the verbose
flag is set in which case they are sent to stderr.  You can override the
printing of verbose messages to stderr by setting up a callback.
.IP "\s-1GUESTFS_EVENT_TRACE\s0 (payload type: message buffer)" 4
.IX Item "GUESTFS_EVENT_TRACE (payload type: message buffer)"
The callback function is called whenever a trace message is generated.  This
only applies if the trace flag (\*(L"guestfs_set_trace\*(R") is set.
.Sp
If no callback is registered: the messages are sent to stderr.  You can
override the printing of trace messages to stderr by setting up a callback.
.IP "\s-1GUESTFS_EVENT_ENTER\s0 (payload type: function name)" 4
.IX Item "GUESTFS_EVENT_ENTER (payload type: function name)"
The callback function is called whenever a libguestfs function is entered.
.Sp
The payload is a string which contains the name of the function that we are
entering (not including \f(CW\*(C`guestfs_\*(C'\fR prefix).
.Sp
Note that libguestfs functions can call themselves, so you may see many
events from a single call.  A few libguestfs functions do not generate this
event.
.Sp
If no callback is registered: the event is ignored.
.PP
\fIguestfs_set_event_callback\fR
.IX Subsection "guestfs_set_event_callback"
.PP
.Vb 5
\& int guestfs_set_event_callback (guestfs_h *g,
\&                                 guestfs_event_callback cb,
\&                                 uint64_t event_bitmask,
\&                                 int flags,
\&                                 void *opaque);
.Ve
.PP
This function registers a callback (\f(CW\*(C`cb\*(C'\fR) for all event classes in the
\&\f(CW\*(C`event_bitmask\*(C'\fR.
.PP
For example, to register for all log message events, you could call this
function with the bitmask \f(CW\*(C`GUESTFS_EVENT_APPLIANCE|GUESTFS_EVENT_LIBRARY\*(C'\fR.
To register a single callback for all possible classes of events, use
\&\f(CW\*(C`GUESTFS_EVENT_ALL\*(C'\fR.
.PP
\&\f(CW\*(C`flags\*(C'\fR should always be passed as 0.
.PP
\&\f(CW\*(C`opaque\*(C'\fR is an opaque pointer which is passed to the callback.  You can use
it for any purpose.
.PP
The return value is the event handle (an integer) which you can use to
delete the callback (see below).
.PP
If there is an error, this function returns \f(CW\*(C`\-1\*(C'\fR, and sets the error in the
handle in the usual way (see \*(L"guestfs_last_error\*(R" etc.)
.PP
Callbacks remain in effect until they are deleted, or until the handle is
closed.
.PP
In the case where multiple callbacks are registered for a particular event
class, all of the callbacks are called.  The order in which multiple
callbacks are called is not defined.
.PP
\fIguestfs_delete_event_callback\fR
.IX Subsection "guestfs_delete_event_callback"
.PP
.Vb 1
\& void guestfs_delete_event_callback (guestfs_h *g, int event_handle);
.Ve
.PP
Delete a callback that was previously registered.  \f(CW\*(C`event_handle\*(C'\fR should be
the integer that was returned by a previous call to
\&\f(CW\*(C`guestfs_set_event_callback\*(C'\fR on the same handle.
.PP
\fIguestfs_event_callback\fR
.IX Subsection "guestfs_event_callback"
.PP
.Vb 8
\& typedef void (*guestfs_event_callback) (
\&                  guestfs_h *g,
\&                  void *opaque,
\&                  uint64_t event,
\&                  int event_handle,
\&                  int flags,
\&                  const char *buf, size_t buf_len,
\&                  const uint64_t *array, size_t array_len);
.Ve
.PP
This is the type of the event callback function that you have to provide.
.PP
The basic parameters are: the handle (\f(CW\*(C`g\*(C'\fR), the opaque user pointer
(\f(CW\*(C`opaque\*(C'\fR), the event class (eg. \f(CW\*(C`GUESTFS_EVENT_PROGRESS\*(C'\fR), the event
handle, and \f(CW\*(C`flags\*(C'\fR which in the current \s-1API\s0 you should ignore.
.PP
The remaining parameters contain the event payload (if any).  Each event may
contain a payload, which usually relates to the event class, but for future
proofing your code should be written to handle any payload for any event
class.
.PP
\&\f(CW\*(C`buf\*(C'\fR and \f(CW\*(C`buf_len\*(C'\fR contain a message buffer (if \f(CW\*(C`buf_len == 0\*(C'\fR, then
there is no message buffer).  Note that this message buffer can contain
arbitrary 8 bit data, including \s-1NUL\s0 bytes.
.PP
\&\f(CW\*(C`array\*(C'\fR and \f(CW\*(C`array_len\*(C'\fR is an array of 64 bit unsigned integers.  At the
moment this is only used for progress messages.
.PP
\fI\s-1EXAMPLE:\s0 \s-1CAPTURING\s0 \s-1LOG\s0 \s-1MESSAGES\s0\fR
.IX Subsection "EXAMPLE: CAPTURING LOG MESSAGES"
.PP
One motivation for the generic event \s-1API\s0 was to allow \s-1GUI\s0 programs to
capture debug and other messages.  In libguestfs ≤ 1.8 these were sent
unconditionally to \f(CW\*(C`stderr\*(C'\fR.
.PP
Events associated with log messages are: \f(CW\*(C`GUESTFS_EVENT_LIBRARY\*(C'\fR,
\&\f(CW\*(C`GUESTFS_EVENT_APPLIANCE\*(C'\fR and \f(CW\*(C`GUESTFS_EVENT_TRACE\*(C'\fR.  (Note that error
messages are not events; you must capture error messages separately).
.PP
Programs have to set up a callback to capture the classes of events of
interest:
.PP
.Vb 9
\& int eh =
\&   guestfs_set_event_callback
\&     (g, message_callback,
\&      GUESTFS_EVENT_LIBRARY|GUESTFS_EVENT_APPLIANCE|
\&      GUESTFS_EVENT_TRACE,
\&      0, NULL) == \-1)
\& if (eh == \-1) {
\&   // handle error in the usual way
\& }
.Ve
.PP
The callback can then direct messages to the appropriate place.  In this
example, messages are directed to syslog:
.PP
.Vb 10
\& static void
\& message_callback (
\&         guestfs_h *g,
\&         void *opaque,
\&         uint64_t event,
\&         int event_handle,
\&         int flags,
\&         const char *buf, size_t buf_len,
\&         const uint64_t *array, size_t array_len)
\& {
\&   const int priority = LOG_USER|LOG_INFO;
\&   if (buf_len > 0)
\&     syslog (priority, "event 0x%lx: %s", event, buf);
\& }
.Ve
.SH "CANCELLING LONG TRANSFERS"
.IX Header "CANCELLING LONG TRANSFERS"
Some operations can be cancelled by the caller while they are in progress.
Currently only operations that involve uploading or downloading data can be
cancelled (technically: operations that have \f(CW\*(C`FileIn\*(C'\fR or \f(CW\*(C`FileOut\*(C'\fR
parameters in the generator).
.SS "guestfs_user_cancel"
.IX Subsection "guestfs_user_cancel"
.Vb 1
\& void guestfs_user_cancel (guestfs_h *g);
.Ve
.PP
\&\f(CW\*(C`guestfs_user_cancel\*(C'\fR cancels the current upload or download operation.
.PP
Unlike most other libguestfs calls, this function is signal safe and thread
safe.  You can call it from a signal handler or from another thread, without
needing to do any locking.
.PP
The transfer that was in progress (if there is one) will stop shortly
afterwards, and will return an error.  The errno (see
\&\*(L"guestfs_last_errno\*(R") is set to \f(CW\*(C`EINTR\*(C'\fR, so you can test for this to find
out if the operation was cancelled or failed because of another error.
.PP
No cleanup is performed: for example, if a file was being uploaded then
after cancellation there may be a partially uploaded file.  It is the
caller's responsibility to clean up if necessary.
.PP
There are two common places that you might call \f(CW\*(C`guestfs_user_cancel\*(C'\fR.
.PP
In an interactive text-based program, you might call it from a \f(CW\*(C`SIGINT\*(C'\fR
signal handler so that pressing \f(CW\*(C`^C\*(C'\fR cancels the current operation.  (You
also need to call \*(L"guestfs_set_pgroup\*(R" so that child processes don't
receive the \f(CW\*(C`^C\*(C'\fR signal).
.PP
In a graphical program, when the main thread is displaying a progress bar
with a cancel button, wire up the cancel button to call this function.
.SH "PRIVATE DATA AREA"
.IX Header "PRIVATE DATA AREA"
You can attach named pieces of private data to the libguestfs handle, fetch
them by name, and walk over them, for the lifetime of the handle.  This is
called the private data area and is only available from the C \s-1API\s0.
.PP
To attach a named piece of data, use the following call:
.PP
.Vb 1
\& void guestfs_set_private (guestfs_h *g, const char *key, void *data);
.Ve
.PP
\&\f(CW\*(C`key\*(C'\fR is the name to associate with this data, and \f(CW\*(C`data\*(C'\fR is an arbitrary
pointer (which can be \f(CW\*(C`NULL\*(C'\fR).  Any previous item with the same key is
overwritten.
.PP
You can use any \f(CW\*(C`key\*(C'\fR you want, but your key should \fInot\fR start with an
underscore character.  Keys beginning with an underscore character are
reserved for internal libguestfs purposes (eg. for implementing language
bindings).  It is recommended that you prefix the key with some unique
string to avoid collisions with other users.
.PP
To retrieve the pointer, use:
.PP
.Vb 1
\& void *guestfs_get_private (guestfs_h *g, const char *key);
.Ve
.PP
This function returns \f(CW\*(C`NULL\*(C'\fR if either no data is found associated with
\&\f(CW\*(C`key\*(C'\fR, or if the user previously set the \f(CW\*(C`key\*(C'\fR's \f(CW\*(C`data\*(C'\fR pointer to
\&\f(CW\*(C`NULL\*(C'\fR.
.PP
Libguestfs does not try to look at or interpret the \f(CW\*(C`data\*(C'\fR pointer in any
way.  As far as libguestfs is concerned, it need not be a valid pointer at
all.  In particular, libguestfs does \fInot\fR try to free the data when the
handle is closed.  If the data must be freed, then the caller must either
free it before calling \*(L"guestfs_close\*(R" or must set up a close callback to
do it (see \*(L"\s-1GUESTFS_EVENT_CLOSE\s0\*(R").
.PP
To walk over all entries, use these two functions:
.PP
.Vb 1
\& void *guestfs_first_private (guestfs_h *g, const char **key_rtn);
\&
\& void *guestfs_next_private (guestfs_h *g, const char **key_rtn);
.Ve
.PP
\&\f(CW\*(C`guestfs_first_private\*(C'\fR returns the first key, pointer pair (\*(L"first\*(R" does
not have any particular meaning \*(-- keys are not returned in any defined
order).  A pointer to the key is returned in \f(CW*key_rtn\fR and the
corresponding data pointer is returned from the function.  \f(CW\*(C`NULL\*(C'\fR is
returned if there are no keys stored in the handle.
.PP
\&\f(CW\*(C`guestfs_next_private\*(C'\fR returns the next key, pointer pair.  The return
value of this function is also \f(CW\*(C`NULL\*(C'\fR is there are no further entries to
return.
.PP
Notes about walking over entries:
.IP "\(bu" 4
You must not call \f(CW\*(C`guestfs_set_private\*(C'\fR while walking over the entries.
.IP "\(bu" 4
The handle maintains an internal iterator which is reset when you call
\&\f(CW\*(C`guestfs_first_private\*(C'\fR.  This internal iterator is invalidated when you
call \f(CW\*(C`guestfs_set_private\*(C'\fR.
.IP "\(bu" 4
If you have set the data pointer associated with a key to \f(CW\*(C`NULL\*(C'\fR, ie:
.Sp
.Vb 1
\& guestfs_set_private (g, key, NULL);
.Ve
.Sp
then that \f(CW\*(C`key\*(C'\fR is not returned when walking.
.IP "\(bu" 4
\&\f(CW*key_rtn\fR is only valid until the next call to \f(CW\*(C`guestfs_first_private\*(C'\fR,
\&\f(CW\*(C`guestfs_next_private\*(C'\fR or \f(CW\*(C`guestfs_set_private\*(C'\fR.
.PP
The following example code shows how to print all keys and data pointers
that are associated with the handle \f(CW\*(C`g\*(C'\fR:
.PP
.Vb 7
\& const char *key;
\& void *data = guestfs_first_private (g, &key);
\& while (data != NULL)
\&   {
\&     printf ("key = %s, data = %p\en", key, data);
\&     data = guestfs_next_private (g, &key);
\&   }
.Ve
.PP
More commonly you are only interested in keys that begin with an
application-specific prefix \f(CW\*(C`foo_\*(C'\fR.  Modify the loop like so:
.PP
.Vb 8
\& const char *key;
\& void *data = guestfs_first_private (g, &key);
\& while (data != NULL)
\&   {
\&     if (strncmp (key, "foo_", strlen ("foo_")) == 0)
\&       printf ("key = %s, data = %p\en", key, data);
\&     data = guestfs_next_private (g, &key);
\&   }
.Ve
.PP
If you need to modify keys while walking, then you have to jump back to the
beginning of the loop.  For example, to delete all keys prefixed with
\&\f(CW\*(C`foo_\*(C'\fR:
.PP
.Vb 10
\&  const char *key;
\&  void *data;
\& again:
\&  data = guestfs_first_private (g, &key);
\&  while (data != NULL)
\&    {
\&      if (strncmp (key, "foo_", strlen ("foo_")) == 0)
\&        {
\&          guestfs_set_private (g, key, NULL);
\&          /* note that \*(Aqkey\*(Aq pointer is now invalid, and so is
\&             the internal iterator */
\&          goto again;
\&        }
\&      data = guestfs_next_private (g, &key);
\&    }
.Ve
.PP
Note that the above loop is guaranteed to terminate because the keys are
being deleted, but other manipulations of keys within the loop might not
terminate unless you also maintain an indication of which keys have been
visited.
.SH "SYSTEMTAP"
.IX Header "SYSTEMTAP"
The libguestfs C library can be probed using systemtap or DTrace.  This is
true of any library, not just libguestfs.  However libguestfs also contains
static markers to help in probing internal operations.
.PP
You can list all the static markers by doing:
.PP
.Vb 2
\& stap \-l \*(Aqprocess("/usr/lib*/libguestfs.so.0")
\&              .provider("guestfs").mark("*")\*(Aq
.Ve
.PP
\&\fBNote:\fR These static markers are \fInot\fR part of the stable \s-1API\s0 and may
change in future versions.
.SS "\s-1SYSTEMTAP\s0 \s-1SCRIPT\s0 \s-1EXAMPLE\s0"
.IX Subsection "SYSTEMTAP SCRIPT EXAMPLE"
This script contains examples of displaying both the static markers and some
ordinary C entry points:
.PP
.Vb 1
\& global last;
\& 
\& function display_time () {
\&       now = gettimeofday_us ();
\&       delta = 0;
\&       if (last > 0)
\&             delta = now \- last;
\&       last = now;
\& 
\&       printf ("%d (+%d):", now, delta);
\& }
\& 
\& probe begin {
\&       last = 0;
\&       printf ("ready\en");
\& }
\& 
\& /* Display all calls to static markers. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .provider("guestfs").mark("*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", $$name, $$parms);
\& }
\& 
\& /* Display all calls to guestfs_mkfs* functions. */
\& probe process("/usr/lib*/libguestfs.so.0")
\&           .function("guestfs_mkfs*") ? {
\&       display_time();
\&       printf ("\et%s %s\en", probefunc(), $$parms);
\& }
.Ve
.PP
The script above can be saved to \f(CW\*(C`test.stap\*(C'\fR and run using the \fIstap\fR\|(1)
program.  Note that you either have to be root, or you have to add yourself
to several special stap groups.  Consult the systemtap documentation for
more information.
.PP
.Vb 2
\& # stap /tmp/test.stap
\& ready
.Ve
.PP
In another terminal, run a guestfish command such as this:
.PP
.Vb 1
\& guestfish \-N fs
.Ve
.PP
In the first terminal, stap trace output similar to this is shown:
.PP
.Vb 6
\& 1318248056692655 (+0): launch_start
\& 1318248056692850 (+195):       launch_build_appliance_start
\& 1318248056818285 (+125435):    launch_build_appliance_end
\& 1318248056838059 (+19774):     launch_run_qemu
\& 1318248061071167 (+4233108):   launch_end
\& 1318248061280324 (+209157):    guestfs_mkfs g=0x1024ab0 fstype=0x46116f device=0x1024e60
.Ve
.SH "ARCHITECTURE"
.IX Header "ARCHITECTURE"
Internally, libguestfs is implemented by running an appliance (a special
type of small virtual machine) using \fIqemu\fR\|(1).  Qemu runs as a child
process of the main program.
.PP
.Vb 10
\&  _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& /                   \e
\& | main program      |
\& |                   |
\& |                   |           child process / appliance
\& |                   |           _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\& |                   |          / qemu                     \e
\& +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+   RPC    |      +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+ |
\& | libguestfs     <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> guestfsd        | |
\& |                   |          |      +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+ |
\& \e_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/          |      | Linux kernel    | |
\&                                |      +\-\-^\-\-\-\-\-\-\-\-\-\-\-\-\-\-+ |
\&                                \e_\|_\|_\|_\|_\|_\|_\|_\|_|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/
\&                                          |
\&                                   _\|_\|_\|_\|_\|_\|_v_\|_\|_\|_\|_\|_
\&                                  /              \e
\&                                  | Device or    |
\&                                  | disk image   |
\&                                  \e_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/
.Ve
.PP
The library, linked to the main program, creates the child process and hence
the appliance in the \*(L"guestfs_launch\*(R" function.
.PP
Inside the appliance is a Linux kernel and a complete stack of userspace
tools (such as \s-1LVM\s0 and ext2 programs) and a small controlling daemon called
\&\*(L"guestfsd\*(R".  The library talks to \*(L"guestfsd\*(R" using remote procedure
calls (\s-1RPC\s0).  There is a mostly one-to-one correspondence between libguestfs
\&\s-1API\s0 calls and \s-1RPC\s0 calls to the daemon.  Lastly the disk image(s) are
attached to the qemu process which translates device access by the
appliance's Linux kernel into accesses to the image.
.PP
A common misunderstanding is that the appliance \*(L"is\*(R" the virtual machine.
Although the disk image you are attached to might also be used by some
virtual machine, libguestfs doesn't know or care about this.  (But you will
care if both libguestfs's qemu process and your virtual machine are trying
to update the disk image at the same time, since these usually results in
massive disk corruption).
.SH "STATE MACHINE"
.IX Header "STATE MACHINE"
libguestfs uses a state machine to model the child process:
.PP
.Vb 10
\&                         |
\&                    guestfs_create
\&                         |
\&                         |
\&                     _\|_\|_\|_V_\|_\|_\|_\|_
\&                    /          \e
\&                    |  CONFIG  |
\&                    \e_\|_\|_\|_\|_\|_\|_\|_\|_\|_/
\&                     ^ ^   ^  \e
\&                    /  |    \e  \e guestfs_launch
\&                   /   |    _\e_\|_V_\|_\|_\|_\|_\|_
\&                  /    |   /           \e
\&                 /     |   | LAUNCHING |
\&                /      |   \e_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_/
\&               /       |       /
\&              /        |  guestfs_launch
\&             /         |     /
\&    _\|_\|_\|_\|_\|_  /        _\|_|_\|_\|_\|_V
\&   /      \e \-\-\-\-\-\-> /        \e
\&   | BUSY |         | READY  |
\&   \e_\|_\|_\|_\|_\|_/ <\-\-\-\-\-\- \e_\|_\|_\|_\|_\|_\|_\|_/
.Ve
.PP
The normal transitions are (1) \s-1CONFIG\s0 (when the handle is created, but there
is no child process), (2) \s-1LAUNCHING\s0 (when the child process is booting up),
(3) alternating between \s-1READY\s0 and \s-1BUSY\s0 as commands are issued to, and
carried out by, the child process.
.PP
The guest may be killed by \*(L"guestfs_kill_subprocess\*(R", or may die
asynchronously at any time (eg. due to some internal error), and that causes
the state to transition back to \s-1CONFIG\s0.
.PP
Configuration commands for qemu such as \*(L"guestfs_add_drive\*(R" can only be
issued when in the \s-1CONFIG\s0 state.
.PP
The \s-1API\s0 offers one call that goes from \s-1CONFIG\s0 through \s-1LAUNCHING\s0 to \s-1READY\s0.
\&\*(L"guestfs_launch\*(R" blocks until the child process is \s-1READY\s0 to accept
commands (or until some failure or timeout).  \*(L"guestfs_launch\*(R" internally
moves the state from \s-1CONFIG\s0 to \s-1LAUNCHING\s0 while it is running.
.PP
\&\s-1API\s0 actions such as \*(L"guestfs_mount\*(R" can only be issued when in the \s-1READY\s0
state.  These \s-1API\s0 calls block waiting for the command to be carried out
(ie. the state to transition to \s-1BUSY\s0 and then back to \s-1READY\s0).  There are no
non-blocking versions, and no way to issue more than one command per handle
at the same time.
.PP
Finally, the child process sends asynchronous messages back to the main
program, such as kernel log messages.  You can register a callback to
receive these messages.
.SH "INTERNALS"
.IX Header "INTERNALS"
.SS "\s-1APPLIANCE\s0 \s-1BOOT\s0 \s-1PROCESS\s0"
.IX Subsection "APPLIANCE BOOT PROCESS"
This process has evolved and continues to evolve.  The description here
corresponds only to the current version of libguestfs and is provided for
information only.
.PP
In order to follow the stages involved below, enable libguestfs debugging
(set the environment variable \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR).
.IP "Create the appliance" 4
.IX Item "Create the appliance"
\&\f(CW\*(C`febootstrap\-supermin\-helper\*(C'\fR is invoked to create the kernel, a small
initrd and the appliance.
.Sp
The appliance is cached in \f(CW\*(C`/var/tmp/.guestfs\-<UID>\*(C'\fR (or in another
directory if \f(CW\*(C`TMPDIR\*(C'\fR is set).
.Sp
For a complete description of how the appliance is created and cached, read
the \fIfebootstrap\fR\|(8) and \fIfebootstrap\-supermin\-helper\fR\|(8) man pages.
.IP "Start qemu and boot the kernel" 4
.IX Item "Start qemu and boot the kernel"
qemu is invoked to boot the kernel.
.IP "Run the initrd" 4
.IX Item "Run the initrd"
\&\f(CW\*(C`febootstrap\-supermin\-helper\*(C'\fR builds a small initrd.  The initrd is not the
appliance.  The purpose of the initrd is to load enough kernel modules in
order that the appliance itself can be mounted and started.
.Sp
The initrd is a cpio archive called
\&\f(CW\*(C`/var/tmp/.guestfs\-<UID>/initrd\*(C'\fR.
.Sp
When the initrd has started you will see messages showing that kernel
modules are being loaded, similar to this:
.Sp
.Vb 4
\& febootstrap: ext2 mini initrd starting up
\& febootstrap: mounting /sys
\& febootstrap: internal insmod libcrc32c.ko
\& febootstrap: internal insmod crc32c\-intel.ko
.Ve
.IP "Find and mount the appliance device" 4
.IX Item "Find and mount the appliance device"
The appliance is a sparse file containing an ext2 filesystem which contains
a familiar (although reduced in size) Linux operating system.  It would
normally be called \f(CW\*(C`/var/tmp/.guestfs\-<UID>/root\*(C'\fR.
.Sp
The regular disks being inspected by libguestfs are the first devices
exposed by qemu (eg. as \f(CW\*(C`/dev/vda\*(C'\fR).
.Sp
The last disk added to qemu is the appliance itself (eg. \f(CW\*(C`/dev/vdb\*(C'\fR if
there was only one regular disk).
.Sp
Thus the final job of the initrd is to locate the appliance disk, mount it,
and switch root into the appliance, and run \f(CW\*(C`/init\*(C'\fR from the appliance.
.Sp
If this works successfully you will see messages such as:
.Sp
.Vb 5
\& febootstrap: picked /sys/block/vdb/dev as root device
\& febootstrap: creating /dev/root as block special 252:16
\& febootstrap: mounting new root on /root
\& febootstrap: chroot
\& Starting /init script ...
.Ve
.Sp
Note that \f(CW\*(C`Starting /init script ...\*(C'\fR indicates that the appliance's init
script is now running.
.IP "Initialize the appliance" 4
.IX Item "Initialize the appliance"
The appliance itself now initializes itself.  This involves starting certain
processes like \f(CW\*(C`udev\*(C'\fR, possibly printing some debug information, and
finally running the daemon (\f(CW\*(C`guestfsd\*(C'\fR).
.IP "The daemon" 4
.IX Item "The daemon"
Finally the daemon (\f(CW\*(C`guestfsd\*(C'\fR) runs inside the appliance.  If it runs you
should see:
.Sp
.Vb 1
\& verbose daemon enabled
.Ve
.Sp
The daemon expects to see a named virtio-serial port exposed by qemu and
connected on the other end to the library.
.Sp
The daemon connects to this port (and hence to the library) and sends a four
byte message \f(CW\*(C`GUESTFS_LAUNCH_FLAG\*(C'\fR, which initiates the communication
protocol (see below).
.SS "\s-1COMMUNICATION\s0 \s-1PROTOCOL\s0"
.IX Subsection "COMMUNICATION PROTOCOL"
Don't rely on using this protocol directly.  This section documents how it
currently works, but it may change at any time.
.PP
The protocol used to talk between the library and the daemon running inside
the qemu virtual machine is a simple \s-1RPC\s0 mechanism built on top of \s-1XDR\s0 (\s-1RFC\s0
1014, \s-1RFC\s0 1832, \s-1RFC\s0 4506).
.PP
The detailed format of structures is in \f(CW\*(C`src/guestfs_protocol.x\*(C'\fR (note:
this file is automatically generated).
.PP
There are two broad cases, ordinary functions that don't have any \f(CW\*(C`FileIn\*(C'\fR
and \f(CW\*(C`FileOut\*(C'\fR parameters, which are handled with very simple request/reply
messages.  Then there are functions that have any \f(CW\*(C`FileIn\*(C'\fR or \f(CW\*(C`FileOut\*(C'\fR
parameters, which use the same request and reply messages, but they may also
be followed by files sent using a chunked encoding.
.PP
\fI\s-1ORDINARY\s0 \s-1FUNCTIONS\s0 (\s-1NO\s0 \s-1FILEIN/FILEOUT\s0 \s-1PARAMS\s0)\fR
.IX Subsection "ORDINARY FUNCTIONS (NO FILEIN/FILEOUT PARAMS)"
.PP
For ordinary functions, the request message is:
.PP
.Vb 4
\& total length (header + arguments,
\&      but not including the length word itself)
\& struct guestfs_message_header (encoded as XDR)
\& struct guestfs_<foo>_args (encoded as XDR)
.Ve
.PP
The total length field allows the daemon to allocate a fixed size buffer
into which it slurps the rest of the message.  As a result, the total length
is limited to \f(CW\*(C`GUESTFS_MESSAGE_MAX\*(C'\fR bytes (currently 4MB), which means the
effective size of any request is limited to somewhere under this size.
.PP
Note also that many functions don't take any arguments, in which case the
\&\f(CW\*(C`guestfs_\f(CIfoo\f(CW_args\*(C'\fR is completely omitted.
.PP
The header contains the procedure number (\f(CW\*(C`guestfs_proc\*(C'\fR) which is how the
receiver knows what type of args structure to expect, or none at all.
.PP
For functions that take optional arguments, the optional arguments are
encoded in the \f(CW\*(C`guestfs_\f(CIfoo\f(CW_args\*(C'\fR structure in the same way as ordinary
arguments.  A bitmask in the header indicates which optional arguments are
meaningful.  The bitmask is also checked to see if it contains bits set
which the daemon does not know about (eg. if more optional arguments were
added in a later version of the library), and this causes the call to be
rejected.
.PP
The reply message for ordinary functions is:
.PP
.Vb 4
\& total length (header + ret,
\&      but not including the length word itself)
\& struct guestfs_message_header (encoded as XDR)
\& struct guestfs_<foo>_ret (encoded as XDR)
.Ve
.PP
As above the \f(CW\*(C`guestfs_\f(CIfoo\f(CW_ret\*(C'\fR structure may be completely omitted for
functions that return no formal return values.
.PP
As above the total length of the reply is limited to \f(CW\*(C`GUESTFS_MESSAGE_MAX\*(C'\fR.
.PP
In the case of an error, a flag is set in the header, and the reply message
is slightly changed:
.PP
.Vb 4
\& total length (header + error,
\&      but not including the length word itself)
\& struct guestfs_message_header (encoded as XDR)
\& struct guestfs_message_error (encoded as XDR)
.Ve
.PP
The \f(CW\*(C`guestfs_message_error\*(C'\fR structure contains the error message as a
string.
.PP
\fI\s-1FUNCTIONS\s0 \s-1THAT\s0 \s-1HAVE\s0 \s-1FILEIN\s0 \s-1PARAMETERS\s0\fR
.IX Subsection "FUNCTIONS THAT HAVE FILEIN PARAMETERS"
.PP
A \f(CW\*(C`FileIn\*(C'\fR parameter indicates that we transfer a file \fIinto\fR the guest.
The normal request message is sent (see above).  However this is followed by
a sequence of file chunks.
.PP
.Vb 7
\& total length (header + arguments,
\&      but not including the length word itself,
\&      and not including the chunks)
\& struct guestfs_message_header (encoded as XDR)
\& struct guestfs_<foo>_args (encoded as XDR)
\& sequence of chunks for FileIn param #0
\& sequence of chunks for FileIn param #1 etc.
.Ve
.PP
The \*(L"sequence of chunks\*(R" is:
.PP
.Vb 7
\& length of chunk (not including length word itself)
\& struct guestfs_chunk (encoded as XDR)
\& length of chunk
\& struct guestfs_chunk (encoded as XDR)
\&   ...
\& length of chunk
\& struct guestfs_chunk (with data.data_len == 0)
.Ve
.PP
The final chunk has the \f(CW\*(C`data_len\*(C'\fR field set to zero.  Additionally a flag
is set in the final chunk to indicate either successful completion or early
cancellation.
.PP
At time of writing there are no functions that have more than one FileIn
parameter.  However this is (theoretically) supported, by sending the
sequence of chunks for each FileIn parameter one after another (from left to
right).
.PP
Both the library (sender) \fIand\fR the daemon (receiver) may cancel the
transfer.  The library does this by sending a chunk with a special flag set
to indicate cancellation.  When the daemon sees this, it cancels the whole
\&\s-1RPC\s0, does \fInot\fR send any reply, and goes back to reading the next request.
.PP
The daemon may also cancel.  It does this by writing a special word
\&\f(CW\*(C`GUESTFS_CANCEL_FLAG\*(C'\fR to the socket.  The library listens for this during
the transfer, and if it gets it, it will cancel the transfer (it sends a
cancel chunk).  The special word is chosen so that even if cancellation
happens right at the end of the transfer (after the library has finished
writing and has started listening for the reply), the \*(L"spurious\*(R" cancel flag
will not be confused with the reply message.
.PP
This protocol allows the transfer of arbitrary sized files (no 32 bit
limit), and also files where the size is not known in advance (eg. from
pipes or sockets).  However the chunks are rather small
(\f(CW\*(C`GUESTFS_MAX_CHUNK_SIZE\*(C'\fR), so that neither the library nor the daemon need
to keep much in memory.
.PP
\fI\s-1FUNCTIONS\s0 \s-1THAT\s0 \s-1HAVE\s0 \s-1FILEOUT\s0 \s-1PARAMETERS\s0\fR
.IX Subsection "FUNCTIONS THAT HAVE FILEOUT PARAMETERS"
.PP
The protocol for FileOut parameters is exactly the same as for FileIn
parameters, but with the roles of daemon and library reversed.
.PP
.Vb 7
\& total length (header + ret,
\&      but not including the length word itself,
\&      and not including the chunks)
\& struct guestfs_message_header (encoded as XDR)
\& struct guestfs_<foo>_ret (encoded as XDR)
\& sequence of chunks for FileOut param #0
\& sequence of chunks for FileOut param #1 etc.
.Ve
.PP
\fI\s-1INITIAL\s0 \s-1MESSAGE\s0\fR
.IX Subsection "INITIAL MESSAGE"
.PP
When the daemon launches it sends an initial word (\f(CW\*(C`GUESTFS_LAUNCH_FLAG\*(C'\fR)
which indicates that the guest and daemon is alive.  This is what
\&\*(L"guestfs_launch\*(R" waits for.
.PP
\fI\s-1PROGRESS\s0 \s-1NOTIFICATION\s0 \s-1MESSAGES\s0\fR
.IX Subsection "PROGRESS NOTIFICATION MESSAGES"
.PP
The daemon may send progress notification messages at any time.  These are
distinguished by the normal length word being replaced by
\&\f(CW\*(C`GUESTFS_PROGRESS_FLAG\*(C'\fR, followed by a fixed size progress message.
.PP
The library turns them into progress callbacks (see
\&\*(L"\s-1GUESTFS_EVENT_PROGRESS\s0\*(R") if there is a callback registered, or discards
them if not.
.PP
The daemon self-limits the frequency of progress messages it sends (see
\&\f(CW\*(C`daemon/proto.c:notify_progress\*(C'\fR).  Not all calls generate progress
messages.
.SH "LIBGUESTFS VERSION NUMBERS"
.IX Header "LIBGUESTFS VERSION NUMBERS"
Since April 2010, libguestfs has started to make separate development and
stable releases, along with corresponding branches in our git repository.
These separate releases can be identified by version number:
.PP
.Vb 10
\&                 even numbers for stable: 1.2.x, 1.4.x, ...
\&       .\-\-\-\-\-\-\-\- odd numbers for development: 1.3.x, 1.5.x, ...
\&       |
\&       v
\& 1  .  3  .  5
\& ^           ^
\& |           |
\& |           \`\-\-\-\-\-\-\-\- sub\-version
\& |
\& \`\-\-\-\-\-\- always \*(Aq1\*(Aq because we don\*(Aqt change the ABI
.Ve
.PP
Thus \*(L"1.3.5\*(R" is the 5th update to the development branch \*(L"1.3\*(R".
.PP
As time passes we cherry pick fixes from the development branch and backport
those into the stable branch, the effect being that the stable branch should
get more stable and less buggy over time.  So the stable releases are ideal
for people who don't need new features but would just like the software to
work.
.PP
Our criteria for backporting changes are:
.IP "\(bu" 4
Documentation changes which don't affect any code are backported unless the
documentation refers to a future feature which is not in stable.
.IP "\(bu" 4
Bug fixes which are not controversial, fix obvious problems, and have been
well tested are backported.
.IP "\(bu" 4
Simple rearrangements of code which shouldn't affect how it works get
backported.  This is so that the code in the two branches doesn't get too
far out of step, allowing us to backport future fixes more easily.
.IP "\(bu" 4
We \fIdon't\fR backport new features, new APIs, new tools etc, except in one
exceptional case: the new feature is required in order to implement an
important bug fix.
.PP
A new stable branch starts when we think the new features in development are
substantial and compelling enough over the current stable branch to warrant
it.  When that happens we create new stable and development versions 1.N.0
and 1.(N+1).0 [N is even].  The new dot-oh release won't necessarily be so
stable at this point, but by backporting fixes from development, that branch
will stabilize over time.
.SH "EXTENDING LIBGUESTFS"
.IX Header "EXTENDING LIBGUESTFS"
.SS "\s-1ADDING\s0 A \s-1NEW\s0 \s-1API\s0 \s-1ACTION\s0"
.IX Subsection "ADDING A NEW API ACTION"
Large amounts of boilerplate code in libguestfs (\s-1RPC\s0, bindings,
documentation) are generated, and this makes it easy to extend the
libguestfs \s-1API\s0.
.PP
To add a new \s-1API\s0 action there are two changes:
.IP "1." 4
You need to add a description of the call (name, parameters, return type,
tests, documentation) to \f(CW\*(C`generator/generator_actions.ml\*(C'\fR.
.Sp
There are two sorts of \s-1API\s0 action, depending on whether the call goes
through to the daemon in the appliance, or is serviced entirely by the
library (see \*(L"\s-1ARCHITECTURE\s0\*(R" above).  \*(L"guestfs_sync\*(R" is an example of the
former, since the sync is done in the appliance.  \*(L"guestfs_set_trace\*(R" is
an example of the latter, since a trace flag is maintained in the handle and
all tracing is done on the library side.
.Sp
Most new actions are of the first type, and get added to the
\&\f(CW\*(C`daemon_functions\*(C'\fR list.  Each function has a unique procedure number used
in the \s-1RPC\s0 protocol which is assigned to that action when we publish
libguestfs and cannot be reused.  Take the latest procedure number and
increment it.
.Sp
For library-only actions of the second type, add to the
\&\f(CW\*(C`non_daemon_functions\*(C'\fR list.  Since these functions are serviced by the
library and do not travel over the \s-1RPC\s0 mechanism to the daemon, these
functions do not need a procedure number, and so the procedure number is set
to \f(CW\*(C`\-1\*(C'\fR.
.IP "2." 4
Implement the action (in C):
.Sp
For daemon actions, implement the function \f(CW\*(C`do_<name>\*(C'\fR in the
\&\f(CW\*(C`daemon/\*(C'\fR directory.
.Sp
For library actions, implement the function \f(CW\*(C`guestfs_\|_<name>\*(C'\fR
(note: double underscore) in the \f(CW\*(C`src/\*(C'\fR directory.
.Sp
In either case, use another function as an example of what to do.
.PP
After making these changes, use \f(CW\*(C`make\*(C'\fR to compile.
.PP
Note that you don't need to implement the \s-1RPC\s0, language bindings, manual
pages or anything else.  It's all automatically generated from the OCaml
description.
.SS "\s-1ADDING\s0 \s-1TESTS\s0 \s-1FOR\s0 \s-1AN\s0 \s-1API\s0 \s-1ACTION\s0"
.IX Subsection "ADDING TESTS FOR AN API ACTION"
You can supply zero or as many tests as you want per \s-1API\s0 call.  The tests
can either be added as part of the \s-1API\s0 description
(\f(CW\*(C`generator/generator_actions.ml\*(C'\fR), or in some rarer cases you may want to
drop a script into \f(CW\*(C`tests/*/\*(C'\fR.  Note that adding a script to \f(CW\*(C`tests/*/\*(C'\fR is
slower, so if possible use the first method.
.PP
The following describes the test environment used when you add an \s-1API\s0 test
in \f(CW\*(C`generator_actions.ml\*(C'\fR.
.PP
The test environment has 4 block devices:
.ie n .IP """/dev/sda"" 500MB" 4
.el .IP "\f(CW/dev/sda\fR 500MB" 4
.IX Item "/dev/sda 500MB"
General block device for testing.
.ie n .IP """/dev/sdb"" 50MB" 4
.el .IP "\f(CW/dev/sdb\fR 50MB" 4
.IX Item "/dev/sdb 50MB"
\&\f(CW\*(C`/dev/sdb1\*(C'\fR is an ext2 filesystem used for testing filesystem write
operations.
.ie n .IP """/dev/sdc"" 10MB" 4
.el .IP "\f(CW/dev/sdc\fR 10MB" 4
.IX Item "/dev/sdc 10MB"
Used in a few tests where two block devices are needed.
.ie n .IP """/dev/sdd""" 4
.el .IP "\f(CW/dev/sdd\fR" 4
.IX Item "/dev/sdd"
\&\s-1ISO\s0 with fixed content (see \f(CW\*(C`images/test.iso\*(C'\fR).
.PP
To be able to run the tests in a reasonable amount of time, the libguestfs
appliance and block devices are reused between tests.  So don't try testing
\&\*(L"guestfs_kill_subprocess\*(R" :\-x
.PP
Each test starts with an initial scenario, selected using one of the
\&\f(CW\*(C`Init*\*(C'\fR expressions, described in \f(CW\*(C`generator/generator_types.ml\*(C'\fR.  These
initialize the disks mentioned above in a particular way as documented in
\&\f(CW\*(C`generator_types.ml\*(C'\fR.  You should not assume anything about the previous
contents of other disks that are not initialized.
.PP
You can add a prerequisite clause to any individual test.  This is a
run-time check, which, if it fails, causes the test to be skipped.  Useful
if testing a command which might not work on all variations of libguestfs
builds.  A test that has prerequisite of \f(CW\*(C`Always\*(C'\fR means to run
unconditionally.
.PP
In addition, packagers can skip individual tests by setting environment
variables before running \f(CW\*(C`make check\*(C'\fR.
.PP
.Vb 1
\& SKIP_TEST_<CMD>_<NUM>=1
.Ve
.PP
eg: \f(CW\*(C`SKIP_TEST_COMMAND_3=1\*(C'\fR skips test #3 of \*(L"guestfs_command\*(R".
.PP
or:
.PP
.Vb 1
\& SKIP_TEST_<CMD>=1
.Ve
.PP
eg: \f(CW\*(C`SKIP_TEST_ZEROFREE=1\*(C'\fR skips all \*(L"guestfs_zerofree\*(R" tests.
.PP
Packagers can run only certain tests by setting for example:
.PP
.Vb 1
\& TEST_ONLY="vfs_type zerofree"
.Ve
.PP
See \f(CW\*(C`tests/c\-api/tests.c\*(C'\fR for more details of how these environment
variables work.
.SS "\s-1DEBUGGING\s0 \s-1NEW\s0 \s-1API\s0 \s-1ACTIONS\s0"
.IX Subsection "DEBUGGING NEW API ACTIONS"
Test new actions work before submitting them.
.PP
You can use guestfish to try out new commands.
.PP
Debugging the daemon is a problem because it runs inside a minimal
environment.  However you can fprintf messages in the daemon to stderr, and
they will show up if you use \f(CW\*(C`guestfish \-v\*(C'\fR.
.SS "\s-1FORMATTING\s0 \s-1CODE\s0 \s-1AND\s0 \s-1OTHER\s0 \s-1CONVENTIONS\s0"
.IX Subsection "FORMATTING CODE AND OTHER CONVENTIONS"
Our C source code generally adheres to some basic code-formatting
conventions.  The existing code base is not totally consistent on this
front, but we do prefer that contributed code be formatted similarly.  In
short, use spaces-not-TABs for indentation, use 2 spaces for each
indentation level, and other than that, follow the K&R style.
.PP
If you use Emacs, add the following to one of one of your start-up files
(e.g., ~/.emacs), to help ensure that you get indentation right:
.PP
.Vb 9
\& ;;; In libguestfs, indent with spaces everywhere (not TABs).
\& ;;; Exceptions: Makefile and ChangeLog modes.
\& (add\-hook \*(Aqfind\-file\-hook
\&     \*(Aq(lambda () (if (and buffer\-file\-name
\&                          (string\-match "/libguestfs\e\e>"
\&                              (buffer\-file\-name))
\&                          (not (string\-equal mode\-name "Change Log"))
\&                          (not (string\-equal mode\-name "Makefile")))
\&                     (setq indent\-tabs\-mode nil))))
\& 
\& ;;; When editing C sources in libguestfs, use this style.
\& (defun libguestfs\-c\-mode ()
\&   "C mode with adjusted defaults for use with libguestfs."
\&   (interactive)
\&   (c\-set\-style "K&R")
\&   (setq c\-indent\-level 2)
\&   (setq c\-basic\-offset 2))
\& (add\-hook \*(Aqc\-mode\-hook
\&           \*(Aq(lambda () (if (string\-match "/libguestfs\e\e>"
\&                               (buffer\-file\-name))
\&                           (libguestfs\-c\-mode))))
.Ve
.PP
Enable warnings when compiling (and fix any problems this finds):
.PP
.Vb 1
\& ./configure \-\-enable\-gcc\-warnings
.Ve
.PP
Useful targets are:
.PP
.Vb 2
\& make syntax\-check  # checks the syntax of the C code
\& make check         # runs the test suite
.Ve
.SS "\s-1DAEMON\s0 \s-1CUSTOM\s0 \s-1PRINTF\s0 \s-1FORMATTERS\s0"
.IX Subsection "DAEMON CUSTOM PRINTF FORMATTERS"
In the daemon code we have created custom printf formatters \f(CW%Q\fR and \f(CW%R\fR,
which are used to do shell quoting.
.ie n .IP "%Q" 4
.el .IP "\f(CW%Q\fR" 4
.IX Item "%Q"
Simple shell quoted string.  Any spaces or other shell characters are
escaped for you.
.ie n .IP "%R" 4
.el .IP "\f(CW%R\fR" 4
.IX Item "%R"
Same as \f(CW%Q\fR except the string is treated as a path which is prefixed by
the sysroot.
.PP
For example:
.PP
.Vb 1
\& asprintf (&cmd, "cat %R", path);
.Ve
.PP
would produce \f(CW\*(C`cat /sysroot/some\e path\e with\e spaces\*(C'\fR
.PP
\&\fINote:\fR Do \fInot\fR use these when you are passing parameters to the
\&\f(CW\*(C`command{,r,v,rv}()\*(C'\fR functions.  These parameters do \s-1NOT\s0 need to be quoted
because they are not passed via the shell (instead, straight to exec).  You
probably want to use the \f(CW\*(C`sysroot_path()\*(C'\fR function however.
.SS "\s-1SUBMITTING\s0 \s-1YOUR\s0 \s-1NEW\s0 \s-1API\s0 \s-1ACTIONS\s0"
.IX Subsection "SUBMITTING YOUR NEW API ACTIONS"
Submit patches to the mailing list:
<http://www.redhat.com/mailman/listinfo/libguestfs> and \s-1CC\s0 to
rjones@redhat.com.
.SS "\s-1INTERNATIONALIZATION\s0 (I18N) \s-1SUPPORT\s0"
.IX Subsection "INTERNATIONALIZATION (I18N) SUPPORT"
We support i18n (gettext anyhow) in the library.
.PP
However many messages come from the daemon, and we don't translate those at
the moment.  One reason is that the appliance generally has all locale files
removed from it, because they take up a lot of space.  So we'd have to readd
some of those, as well as copying our \s-1PO\s0 files into the appliance.
.PP
Debugging messages are never translated, since they are intended for the
programmers.
.SS "\s-1SOURCE\s0 \s-1CODE\s0 \s-1SUBDIRECTORIES\s0"
.IX Subsection "SOURCE CODE SUBDIRECTORIES"
.ie n .IP """align""" 4
.el .IP "\f(CWalign\fR" 4
.IX Item "align"
\&\fIvirt\-alignment\-scan\fR\|(1) command and documentation.
.ie n .IP """appliance""" 4
.el .IP "\f(CWappliance\fR" 4
.IX Item "appliance"
The libguestfs appliance, build scripts and so on.
.ie n .IP """cat""" 4
.el .IP "\f(CWcat\fR" 4
.IX Item "cat"
The \fIvirt\-cat\fR\|(1), \fIvirt\-filesystems\fR\|(1) and \fIvirt\-ls\fR\|(1) commands and
documentation.
.ie n .IP """clone""" 4
.el .IP "\f(CWclone\fR" 4
.IX Item "clone"
Tools for cloning virtual machines.  Currently contains \fIvirt\-sysprep\fR\|(1)
command and documentation.
.ie n .IP """contrib""" 4
.el .IP "\f(CWcontrib\fR" 4
.IX Item "contrib"
Outside contributions, experimental parts.
.ie n .IP """daemon""" 4
.el .IP "\f(CWdaemon\fR" 4
.IX Item "daemon"
The daemon that runs inside the libguestfs appliance and carries out
actions.
.ie n .IP """df""" 4
.el .IP "\f(CWdf\fR" 4
.IX Item "df"
\&\fIvirt\-df\fR\|(1) command and documentation.
.ie n .IP """edit""" 4
.el .IP "\f(CWedit\fR" 4
.IX Item "edit"
\&\fIvirt\-edit\fR\|(1) command and documentation.
.ie n .IP """examples""" 4
.el .IP "\f(CWexamples\fR" 4
.IX Item "examples"
C \s-1API\s0 example code.
.ie n .IP """fish""" 4
.el .IP "\f(CWfish\fR" 4
.IX Item "fish"
\&\fIguestfish\fR\|(1), the command-line shell, and various shell scripts built on
top such as \fIvirt\-copy\-in\fR\|(1), \fIvirt\-copy\-out\fR\|(1), \fIvirt\-tar\-in\fR\|(1),
\&\fIvirt\-tar\-out\fR\|(1).
.ie n .IP """format""" 4
.el .IP "\f(CWformat\fR" 4
.IX Item "format"
\&\fIvirt\-format\fR\|(1) command and documentation.
.ie n .IP """fuse""" 4
.el .IP "\f(CWfuse\fR" 4
.IX Item "fuse"
\&\fIguestmount\fR\|(1), \s-1FUSE\s0 (userspace filesystem) built on top of libguestfs.
.ie n .IP """generator""" 4
.el .IP "\f(CWgenerator\fR" 4
.IX Item "generator"
The crucially important generator, used to automatically generate large
amounts of boilerplate C code for things like \s-1RPC\s0 and bindings.
.ie n .IP """inspector""" 4
.el .IP "\f(CWinspector\fR" 4
.IX Item "inspector"
\&\fIvirt\-inspector\fR\|(1), the virtual machine image inspector.
.ie n .IP """logo""" 4
.el .IP "\f(CWlogo\fR" 4
.IX Item "logo"
Logo used on the website.  The fish is called Arthur by the way.
.ie n .IP """m4""" 4
.el .IP "\f(CWm4\fR" 4
.IX Item "m4"
M4 macros used by autoconf.
.ie n .IP """po""" 4
.el .IP "\f(CWpo\fR" 4
.IX Item "po"
Translations of simple gettext strings.
.ie n .IP """po\-docs""" 4
.el .IP "\f(CWpo\-docs\fR" 4
.IX Item "po-docs"
The build infrastructure and \s-1PO\s0 files for translations of manpages and \s-1POD\s0
files.  Eventually this will be combined with the \f(CW\*(C`po\*(C'\fR directory, but that
is rather complicated.
.ie n .IP """rescue""" 4
.el .IP "\f(CWrescue\fR" 4
.IX Item "rescue"
\&\fIvirt\-rescue\fR\|(1) command and documentation.
.ie n .IP """resize""" 4
.el .IP "\f(CWresize\fR" 4
.IX Item "resize"
\&\fIvirt\-resize\fR\|(1) command and documentation.
.ie n .IP """sparsify""" 4
.el .IP "\f(CWsparsify\fR" 4
.IX Item "sparsify"
\&\fIvirt\-sparsify\fR\|(1) command and documentation.
.ie n .IP """src""" 4
.el .IP "\f(CWsrc\fR" 4
.IX Item "src"
Source code to the C library.
.ie n .IP """test\-tool""" 4
.el .IP "\f(CWtest\-tool\fR" 4
.IX Item "test-tool"
Test tool for end users to test if their qemu/kernel combination will work
with libguestfs.
.ie n .IP """tests""" 4
.el .IP "\f(CWtests\fR" 4
.IX Item "tests"
Tests.
.ie n .IP """tools""" 4
.el .IP "\f(CWtools\fR" 4
.IX Item "tools"
Command line tools written in Perl (\fIvirt\-win\-reg\fR\|(1) and many others).
.ie n .IP """csharp""" 4
.el .IP "\f(CWcsharp\fR" 4
.IX Item "csharp"
.PD 0
.ie n .IP """erlang""" 4
.el .IP "\f(CWerlang\fR" 4
.IX Item "erlang"
.ie n .IP """gobject""" 4
.el .IP "\f(CWgobject\fR" 4
.IX Item "gobject"
.ie n .IP """haskell""" 4
.el .IP "\f(CWhaskell\fR" 4
.IX Item "haskell"
.ie n .IP """java""" 4
.el .IP "\f(CWjava\fR" 4
.IX Item "java"
.ie n .IP """ocaml""" 4
.el .IP "\f(CWocaml\fR" 4
.IX Item "ocaml"
.ie n .IP """php""" 4
.el .IP "\f(CWphp\fR" 4
.IX Item "php"
.ie n .IP """perl""" 4
.el .IP "\f(CWperl\fR" 4
.IX Item "perl"
.ie n .IP """python""" 4
.el .IP "\f(CWpython\fR" 4
.IX Item "python"
.ie n .IP """ruby""" 4
.el .IP "\f(CWruby\fR" 4
.IX Item "ruby"
.PD
Language bindings.
.SS "\s-1MAKING\s0 A \s-1STABLE\s0 \s-1RELEASE\s0"
.IX Subsection "MAKING A STABLE RELEASE"
When we make a stable release, there are several steps documented here.  See
\&\*(L"\s-1LIBGUESTFS\s0 \s-1VERSION\s0 \s-1NUMBERS\s0\*(R" for general information about the stable
branch policy.
.IP "\(bu" 4
Check \f(CW\*(C`make && make check\*(C'\fR works on at least Fedora, Debian and Ubuntu.
.IP "\(bu" 4
Finalize RELEASE-NOTES.
.IP "\(bu" 4
Update \s-1ROADMAP\s0.
.IP "\(bu" 4
Run \f(CW\*(C`src/api\-support/update\-from\-tarballs.sh\*(C'\fR.
.IP "\(bu" 4
Push and pull from Transifex.
.Sp
Run:
.Sp
.Vb 1
\& tx push \-s
.Ve
.Sp
to push the latest \s-1POT\s0 files to Transifex.  Then run:
.Sp
.Vb 1
\& ./tx\-pull.sh
.Ve
.Sp
which is a wrapper to pull the latest translated \f(CW\*(C`*.po\*(C'\fR files.
.IP "\(bu" 4
Create new stable and development directories under
<http://libguestfs.org/download>.
.IP "\(bu" 4
Create the branch in git:
.Sp
.Vb 4
\& git tag \-a 1.XX.0 \-m "Version 1.XX.0 (stable)"
\& git tag \-a 1.YY.0 \-m "Version 1.YY.0 (development)"
\& git branch stable\-1.XX
\& git push origin tag 1.XX.0 1.YY.0 stable\-1.XX
.Ve
.SH "LIMITS"
.IX Header "LIMITS"
.SS "\s-1PROTOCOL\s0 \s-1LIMITS\s0"
.IX Subsection "PROTOCOL LIMITS"
Internally libguestfs uses a message-based protocol to pass \s-1API\s0 calls and
their responses to and from a small \*(L"appliance\*(R" (see \*(L"\s-1INTERNALS\s0\*(R" for
plenty more detail about this).  The maximum message size used by the
protocol is slightly less than 4 \s-1MB\s0.  For some \s-1API\s0 calls you may need to be
aware of this limit.  The \s-1API\s0 calls which may be affected are individually
documented, with a link back to this section of the documentation.
.PP
A simple call such as \*(L"guestfs_cat\*(R" returns its result (the file data) in
a simple string.  Because this string is at some point internally encoded as
a message, the maximum size that it can return is slightly under 4 \s-1MB\s0.  If
the requested file is larger than this then you will get an error.
.PP
In order to transfer large files into and out of the guest filesystem, you
need to use particular calls that support this.  The sections \*(L"\s-1UPLOADING\s0\*(R"
and \*(L"\s-1DOWNLOADING\s0\*(R" document how to do this.
.PP
You might also consider mounting the disk image using our \s-1FUSE\s0 filesystem
support (\fIguestmount\fR\|(1)).
.SS "\s-1MAXIMUM\s0 \s-1NUMBER\s0 \s-1OF\s0 \s-1DISKS\s0"
.IX Subsection "MAXIMUM NUMBER OF DISKS"
When using virtio disks (the default) the current limit is \fB25\fR disks.
.PP
Virtio itself consumes 1 virtual \s-1PCI\s0 slot per disk, and \s-1PCI\s0 is limited to 31
slots.  However febootstrap only understands disks with names \f(CW\*(C`/dev/vda\*(C'\fR
through \f(CW\*(C`/dev/vdz\*(C'\fR (26 letters) and it reserves one disk for its own
purposes.
.PP
We are working to substantially raise this limit in future versions but it
requires complex changes to qemu.
.PP
In future versions of libguestfs it should also be possible to \*(L"hot plug\*(R"
disks (add and remove disks after calling \*(L"guestfs_launch\*(R").  This also
requires changes to qemu.
.SS "\s-1MAXIMUM\s0 \s-1NUMBER\s0 \s-1OF\s0 \s-1PARTITIONS\s0 \s-1PER\s0 \s-1DISK\s0"
.IX Subsection "MAXIMUM NUMBER OF PARTITIONS PER DISK"
Virtio limits the maximum number of partitions per disk to \fB15\fR.
.PP
This is because it reserves 4 bits for the minor device number (thus
\&\f(CW\*(C`/dev/vda\*(C'\fR, and \f(CW\*(C`/dev/vda1\*(C'\fR through \f(CW\*(C`/dev/vda15\*(C'\fR).
.PP
If you attach a disk with more than 15 partitions, the extra partitions are
ignored by libguestfs.
.SS "\s-1MAXIMUM\s0 \s-1SIZE\s0 \s-1OF\s0 A \s-1DISK\s0"
.IX Subsection "MAXIMUM SIZE OF A DISK"
Probably the limit is between 2**63\-1 and 2**64\-1 bytes.
.PP
We have tested block devices up to 1 exabyte (2**60 or
1,152,921,504,606,846,976 bytes) using sparse files backed by an \s-1XFS\s0 host
filesystem.
.PP
Although libguestfs probably does not impose any limit, the underlying host
storage will.  If you store disk images on a host ext4 filesystem, then the
maximum size will be limited by the maximum ext4 file size (currently 16
\&\s-1TB\s0).  If you store disk images as host logical volumes then you are limited
by the maximum size of an \s-1LV\s0.
.PP
For the hugest disk image files, we recommend using \s-1XFS\s0 on the host for
storage.
.SS "\s-1MAXIMUM\s0 \s-1SIZE\s0 \s-1OF\s0 A \s-1PARTITION\s0"
.IX Subsection "MAXIMUM SIZE OF A PARTITION"
The \s-1MBR\s0 (ie. classic MS-DOS) partitioning scheme uses 32 bit sector
numbers.  Assuming a 512 byte sector size, this means that \s-1MBR\s0 cannot
address a partition located beyond 2 \s-1TB\s0 on the disk.
.PP
It is recommended that you use \s-1GPT\s0 partitions on disks which are larger than
this size.  \s-1GPT\s0 uses 64 bit sector numbers and so can address partitions
which are theoretically larger than the largest disk we could support.
.SS "\s-1MAXIMUM\s0 \s-1SIZE\s0 \s-1OF\s0 A \s-1FILESYSTEM\s0, \s-1FILES\s0, \s-1DIRECTORIES\s0"
.IX Subsection "MAXIMUM SIZE OF A FILESYSTEM, FILES, DIRECTORIES"
This depends on the filesystem type.  libguestfs itself does not impose any
known limit.  Consult Wikipedia or the filesystem documentation to find out
what these limits are.
.SS "\s-1MAXIMUM\s0 \s-1UPLOAD\s0 \s-1AND\s0 \s-1DOWNLOAD\s0"
.IX Subsection "MAXIMUM UPLOAD AND DOWNLOAD"
The \s-1API\s0 functions \*(L"guestfs_upload\*(R", \*(L"guestfs_download\*(R",
\&\*(L"guestfs_tar_in\*(R", \*(L"guestfs_tar_out\*(R" and the like allow unlimited sized
uploads and downloads.
.SS "\s-1INSPECTION\s0 \s-1LIMITS\s0"
.IX Subsection "INSPECTION LIMITS"
The inspection code has several arbitrary limits on things like the size of
Windows Registry hive it will read, and the length of product name.  These
are intended to stop a malicious guest from consuming arbitrary amounts of
memory and disk space on the host, and should not be reached in practice.
See the source code for more information.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.IP "\s-1FEBOOTSTRAP_KERNEL\s0" 4
.IX Item "FEBOOTSTRAP_KERNEL"
.PD 0
.IP "\s-1FEBOOTSTRAP_MODULES\s0" 4
.IX Item "FEBOOTSTRAP_MODULES"
.PD
These two environment variables allow the kernel that libguestfs uses in the
appliance to be selected.  If \f(CW$FEBOOTSTRAP_KERNEL\fR is not set, then the
most recent host kernel is chosen.  For more information about kernel
selection, see \fIfebootstrap\-supermin\-helper\fR\|(8).  This feature is only
available in febootstrap ≥ 3.8.
.IP "\s-1LIBGUESTFS_APPEND\s0" 4
.IX Item "LIBGUESTFS_APPEND"
Pass additional options to the guest kernel.
.IP "\s-1LIBGUESTFS_DEBUG\s0" 4
.IX Item "LIBGUESTFS_DEBUG"
Set \f(CW\*(C`LIBGUESTFS_DEBUG=1\*(C'\fR to enable verbose messages.  This has the same
effect as calling \f(CW\*(C`guestfs_set_verbose (g, 1)\*(C'\fR.
.IP "\s-1LIBGUESTFS_MEMSIZE\s0" 4
.IX Item "LIBGUESTFS_MEMSIZE"
Set the memory allocated to the qemu process, in megabytes.  For example:
.Sp
.Vb 1
\& LIBGUESTFS_MEMSIZE=700
.Ve
.IP "\s-1LIBGUESTFS_PATH\s0" 4
.IX Item "LIBGUESTFS_PATH"
Set the path that libguestfs uses to search for a supermin appliance.  See
the discussion of paths in section \*(L"\s-1PATH\s0\*(R" above.
.IP "\s-1LIBGUESTFS_QEMU\s0" 4
.IX Item "LIBGUESTFS_QEMU"
Set the default qemu binary that libguestfs uses.  If not set, then the qemu
which was found at compile time by the configure script is used.
.Sp
See also \*(L"\s-1QEMU\s0 \s-1WRAPPERS\s0\*(R" above.
.IP "\s-1LIBGUESTFS_TRACE\s0" 4
.IX Item "LIBGUESTFS_TRACE"
Set \f(CW\*(C`LIBGUESTFS_TRACE=1\*(C'\fR to enable command traces.  This has the same
effect as calling \f(CW\*(C`guestfs_set_trace (g, 1)\*(C'\fR.
.IP "\s-1TMPDIR\s0" 4
.IX Item "TMPDIR"
Location of temporary directory, defaults to \f(CW\*(C`/tmp\*(C'\fR except for the cached
supermin appliance which defaults to \f(CW\*(C`/var/tmp\*(C'\fR.
.Sp
If libguestfs was compiled to use the supermin appliance then the real
appliance is cached in this directory, shared between all handles belonging
to the same \s-1EUID\s0.  You can use \f(CW$TMPDIR\fR to configure another directory to
use in case \f(CW\*(C`/var/tmp\*(C'\fR is not large enough.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIguestfs\-examples\fR\|(3), \fIguestfs\-erlang\fR\|(3), \fIguestfs\-java\fR\|(3),
\&\fIguestfs\-ocaml\fR\|(3), \fIguestfs\-perl\fR\|(3), \fIguestfs\-python\fR\|(3),
\&\fIguestfs\-ruby\fR\|(3), \fIguestfish\fR\|(1), \fIguestmount\fR\|(1),
\&\fIvirt\-alignment\-scan\fR\|(1), \fIvirt\-cat\fR\|(1), \fIvirt\-copy\-in\fR\|(1),
\&\fIvirt\-copy\-out\fR\|(1), \fIvirt\-df\fR\|(1), \fIvirt\-edit\fR\|(1), \fIvirt\-filesystems\fR\|(1),
\&\fIvirt\-format\fR\|(1), \fIvirt\-inspector\fR\|(1), \fIvirt\-list\-filesystems\fR\|(1),
\&\fIvirt\-list\-partitions\fR\|(1), \fIvirt\-ls\fR\|(1), \fIvirt\-make\-fs\fR\|(1),
\&\fIvirt\-rescue\fR\|(1), \fIvirt\-resize\fR\|(1), \fIvirt\-sparsify\fR\|(1),
\&\fIvirt\-sysprep\fR\|(1), \fIvirt\-tar\fR\|(1), \fIvirt\-tar\-in\fR\|(1), \fIvirt\-tar\-out\fR\|(1),
\&\fIvirt\-win\-reg\fR\|(1), \fIguestfs\-testing\fR\|(1), \fIqemu\fR\|(1), \fIfebootstrap\fR\|(1),
\&\fIfebootstrap\-supermin\-helper\fR\|(8), \fIhivex\fR\|(3), \fIstap\fR\|(1),
<http://libguestfs.org/>.
.PP
Tools with a similar purpose: \fIfdisk\fR\|(8), \fIparted\fR\|(8), \fIkpartx\fR\|(8),
\&\fIlvm\fR\|(8), \fIdisktype\fR\|(1).
.SH "BUGS"
.IX Header "BUGS"
To get a list of bugs against libguestfs use this link:
.PP
<https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools>
.PP
To report a new bug against libguestfs use this link:
.PP
<https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools>
.PP
When reporting a bug, please check:
.IP "\(bu" 4
That the bug hasn't been reported already.
.IP "\(bu" 4
That you are testing a recent version.
.IP "\(bu" 4
Describe the bug accurately, and give a way to reproduce it.
.IP "\(bu" 4
Run libguestfs-test-tool and paste the \fBcomplete, unedited\fR output into the
bug report.
.SH "AUTHORS"
.IX Header "AUTHORS"
Richard W.M. Jones (\f(CW\*(C`rjones at redhat dot com\*(C'\fR)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2009\-2012 Red Hat Inc.  <http://libguestfs.org/>
.PP
This library is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 Lesser General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.
.PP
This library is distributed in the hope that it will be useful, but \s-1WITHOUT\s0
\&\s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0 Lesser General Public License
for more details.
.PP
You should have received a copy of the \s-1GNU\s0 Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 51 Franklin Street, Fifth Floor, Boston, \s-1MA\s0 02110\-1301 \s-1USA\s0
