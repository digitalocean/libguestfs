# libnuma
{
   libnuma_numa_node_size64_cond
   Memcheck:Cond
   fun:*
   fun:numa_node_size64
   fun:numa_init
}
{
   libnuma_numa_node_size64_cond_2
   Memcheck:Cond
   fun:numa_node_size64
   fun:numa_init
}
{
   libnuma_numa_node_size64_cond_3
   Memcheck:Cond
   fun:*
   fun:numa_node_size64
   obj:/usr/lib64/libnuma.so.1
}
{
   libnuma_numa_node_size64_cond_4
   Memcheck:Cond
   fun:numa_node_size64
   obj:/usr/lib64/libnuma.so.1
}
{
   libnuma_numa_node_size64_value8
   Memcheck:Value8
   fun:numa_node_size64
   fun:numa_init
}
{
   libnuma_numa_node_size64_value8_2
   Memcheck:Value8
   fun:numa_node_size64
   obj:/usr/lib64/libnuma.so.1
}

# libnl
{
   libnl_add_routing_table_name_leak
   Memcheck:Leak
   fun:malloc
   fun:strdup
   fun:add_routing_table_name
}
{
   libnl_add_routing_table_name_leak_2
   Memcheck:Leak
   fun:calloc
   fun:add_routing_table_name
}
{
   libnl_add_proto_name_leak
   Memcheck:Leak
   fun:malloc
   fun:strdup
   fun:add_proto_name
}
{
   libnl_add_proto_name_leak_2
   Memcheck:Leak
   fun:calloc
   fun:add_proto_name
}
{
   libnl1_malloc_leak
   Memcheck:Leak
   fun:malloc
   fun:strdup
   obj:/usr/lib/libnl.so.1.1
}
{
   libnl1_malloc_leak_2
   Memcheck:Leak
   fun:malloc
   fun:strdup
   obj:/lib64/libnl.so.1.1
}
{
   libnl1_malloc_leak_3
   Memcheck:Leak
   fun:malloc
   fun:strdup
   obj:/usr/lib64/libnl.so.1.1
}
{
   libnl1_calloc_leak
   Memcheck:Leak
   fun:calloc
   obj:/usr/lib/libnl.so.1.1
}
{
   libnl1_calloc_leak_2
   Memcheck:Leak
   fun:calloc
   obj:/lib64/libnl.so.1.1
}
{
   libnl1_calloc_leak_3
   Memcheck:Leak
   fun:calloc
   obj:/usr/lib64/libnl.so.1.1
}

# OCaml, by design, doesn't bother to free the major heap before
# calling exit.  Ignore that leak.
{
   ocaml_heap_leak
   Memcheck:Leak
   ...
   fun:caml_alloc_for_heap
}
# On the other hand, these seem to be a real bugs in OCaml:
{
   ocaml_heap_leak_2
   Memcheck:Leak
   fun:malloc
   fun:caml_thread_new_descriptor
   fun:caml_thread_new
}
{
   ocaml_heap_leak_3
   Memcheck:Leak
   fun:malloc
   fun:caml_thread_new_descriptor
   fun:caml_thread_initialize
}
{
   ocaml_heap_leak_4
   Memcheck:Leak
   ...
   fun:pthread_create*
   ...
   fun:caml_thread_new
}
{
   ocaml_heap_leak_5
   Memcheck:Leak
   fun:malloc
   fun:caml_stat_alloc
   fun:caml_threadstatus_new
}
{
   ocaml_heap_leak_6
   Memcheck:Leak
   fun:malloc
   fun:caml_stat_alloc
   fun:caml_search_in_path
}
{
   ocaml_heap_leak_7
   Memcheck:Leak
   fun:malloc
   ...
   fun:caml_build_primitive_table
}

# glibc
{
   glibc_cond
   Memcheck:Cond
   fun:index
   fun:expand_dynamic_string_token
}

# libvirt calls gnutls_global_init but doesn't call the
# corresponding gnutls_global_deinit function because of
# thread-safety issues (in GnuTLS).
{
   libvirt_leak_1
   Memcheck:Leak
   ...
   fun:gnutls_global_init
   fun:virInitialize
}

# RHBZ#847429
{
   libvirt_leak_2
   Memcheck:Leak
   ...
   fun:tryLoadOne
   fun:VBoxCGlueInit
   fun:vboxRegister
   fun:virInitialize
   fun:init_libguestfs
}

# FUSE leaks the per-thread context (although the code looks
# like it attempts to clean it up).  In older fuse, it uses
# malloc.  In newer fuse it uses calloc.
{
   fuse_leak_1
   Memcheck:Leak
   fun:malloc
   fun:fuse_get_context_internal
}

{
   fuse_leak_2
   Memcheck:Leak
   fun:calloc
   fun:fuse_get_context_internal
}

# ld-*.so
{
   ld_leak
   Memcheck:Leak
   ...
   fun:_dl_init
}
