=head1 NAME

virt-v2v - Convert a guest to use KVM

=head1 SYNOPSIS

 virt-v2v [-i mode] [other -i* options]
          [-o mode] [other -o* options]
          [guest|filename]

 virt-v2v --in-place
          [-i mode] [other -i* options]
          [guest|filename]

=head1 DESCRIPTION

Virt-v2v converts a single guest from a foreign hypervisor to run on
KVM.  It can read Linux and Windows guests running on VMware, Xen,
Hyper-V and some other hypervisors, and convert them to KVM managed by
libvirt, OpenStack, oVirt, Red Hat Virtualisation (RHV) or several
other targets.  It can modify the guest to make it bootable on KVM and
install virtio drivers so it will run quickly.

There is also a companion front-end called L<virt-p2v(1)> which comes
as an ISO, CD or PXE image that can be booted on physical machines to
virtualize those machines (physical to virtual, or p2v).

=head2 Input and Output

You normally run virt-v2v with several I<-i*> options controlling the
input mode and also several I<-o*> options controlling the output
mode.  In this sense, "input" refers to the source foreign hypervisor
such as VMware, and "output" refers to the target KVM-based management
system such as oVirt or OpenStack.

The input and output sides of virt-v2v are separate and unrelated.
Virt-v2v can read from any input and write to any output.  Therefore
these sides of virt-v2v are documented separately in this manual.

Virt-v2v normally copies from the input to the output, called "copying
mode".  In this case the source guest is always left unchanged.
In-place conversion (I<--in-place>) only uses the I<-i*> options and
modifies the source guest in-place.  (See L</In-place conversion>
below.)

=head2 Other virt-v2v topics

L<virt-v2v-support(1)> — Supported hypervisors, virtualization
management systems, guests.

L<virt-v2v-input-vmware(1)> — Input from VMware.

L<virt-v2v-input-xen(1)> — Input from Xen.

L<virt-v2v-output-local(1)> — Output to local files or local libvirt.

L<virt-v2v-output-rhv(1)> — Output to oVirt or RHV.

L<virt-v2v-output-openstack(1)> — Output to OpenStack.

L<virt-v2v-copy-to-local(1)> — Deprecated tool to handle Xen guests
using host block device storage.

=head1 EXAMPLES

=head2 Convert from VMware vCenter server to local libvirt

You have a VMware vCenter server called C<vcenter.example.com>, a
datacenter called C<Datacenter>, and an ESXi hypervisor called
C<esxi>.  You want to convert a guest called C<vmware_guest> to run
locally under libvirt.

 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest

In this case you will most likely have to run virt-v2v as C<root>,
since it needs to talk to the system libvirt daemon and copy the guest
disks to F</var/lib/libvirt/images>.

For more information see L<virt-v2v-input-vmware(1)>.

=head2 Convert from VMware to RHV/oVirt

This is the same as the previous example, except you want to send the
guest to a RHV Data Domain using the RHV REST API.  Guest network
interface(s) are connected to the target network called C<ovirtmgmt>.

 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi vmware_guest \
   -o rhv-upload -oc https://ovirt-engine.example.com/ovirt-engine/api \
   -os ovirt-data -op /tmp/ovirt-admin-password -of raw \
   -oo rhv-cafile=/tmp/ca.pem -oo rhv-direct \
   --bridge ovirtmgmt

In this case the host running virt-v2v acts as a B<conversion server>.

For more information see L<virt-v2v-output-rhv(1)>.

=head2 Convert from ESXi hypervisor over SSH to local libvirt

You have an ESXi hypervisor called C<esxi.example.com> with SSH access
enabled.  You want to convert from VMFS storage on that server to
a local file.

 virt-v2v \
   -i vmx -it ssh \
   "ssh://root@esxi.example.com/vmfs/volumes/datastore1/guest/guest.vmx" \
   -o local -os /var/tmp

The guest must not be running.  Virt-v2v would I<not> need to be run
as root in this case.

For more information about converting from VMX files see
L<virt-v2v-input-vmware(1)>.

=head2 Convert disk image to OpenStack

Given a disk image from another hypervisor that you want to convert to
run on OpenStack (only KVM-based OpenStack is supported), you can run
virt-v2v inside an OpenStack VM (called C<v2v-vm> below), and do:

 virt-v2v -i disk disk.img -o openstack -oo server-id=v2v-vm

See L<virt-v2v-output-openstack(1)>.

=head2 Convert disk image to disk image

Given a disk image from another hypervisor that you want to convert to
run on KVM, you have two options.  The simplest way is to try:

 virt-v2v -i disk disk.img -o local -os /var/tmp

where virt-v2v guesses everything about the input F<disk.img> and (in
this case) writes the converted result to F</var/tmp>.

A more complex method is to write some
L<libvirt XML|http://libvirt.org/formatdomain.html> describing the
input guest (if you can get the source hypervisor to provide you with
libvirt XML, then so much the better).  You can then do:

 virt-v2v -i libvirtxml guest-domain.xml -o local -os /var/tmp

Since F<guest-domain.xml> contains the path(s) to the guest disk
image(s) you do not need to specify the name of the disk image on the
command line.

To convert a local disk image and immediately boot it in local
qemu, do:

 virt-v2v -i disk disk.img -o qemu -os /var/tmp --qemu-boot

=head1 OPTIONS

=over 4

=item B<--help>

Display help.

=item B<-b> ...

=item B<--bridge> ...

See I<--network> below.

=item B<--colors>

=item B<--colours>

Use ANSI colour sequences to colourize messages.  This is the default
when the output is a tty.  If the output of the program is redirected
to a file, ANSI colour sequences are disabled unless you use this
option.

=item B<--compressed>

Write a compressed output file.  This is only allowed if the output
format is qcow2 (see I<-of> below), and is equivalent to the I<-c>
option of L<qemu-img(1)>.

=item B<--debug-overlays>

Save the overlay file(s) created during conversion.  This option is
only used for debugging virt-v2v and may be removed in a future
version.

=item B<--echo-keys>

When prompting for keys and passphrases, virt-v2v normally turns
echoing off so you cannot see what you are typing.  If you are not
worried about Tempest attacks and there is no one else in the room you
can specify this flag to see what you are typing.

Note this options only applies to keys and passphrases for encrypted
devices and partitions, not for passwords used to connect to remote
servers.

=item B<-i> B<disk>

Set the input method to I<disk>.

In this mode you can read a virtual machine disk image with no
metadata.  virt-v2v tries to guess the best default metadata.  This is
usually adequate but you can get finer control (eg. of memory and
vCPUs) by using I<-i libvirtxml> instead.  Only guests that use a single
disk can be imported this way.

=item B<-i> B<libvirt>

Set the input method to I<libvirt>.  This is the default.

In this mode you have to specify a libvirt guest name or UUID on the
command line.  You may also specify a libvirt connection URI (see
I<-ic>).

=item B<-i> B<libvirtxml>

Set the input method to I<libvirtxml>.

In this mode you have to pass a libvirt XML file on the command line.
This file is read in order to get metadata about the source guest
(such as its name, amount of memory), and also to locate the input
disks.  See L</Minimal XML for -i libvirtxml option> below.

=item B<-i> B<local>

This is the same as I<-i disk>.

=item B<-i> B<ova>

Set the input method to I<ova>.

In this mode you can read a VMware ova file.  Virt-v2v will read the
ova manifest file and check the vmdk volumes for validity (checksums)
as well as analyzing the ovf file, and then convert the guest.  See
L<virt-v2v-input-vmware(1)>.

=item B<-i> B<vmx>

Set the input method to I<vmx>.

In this mode you can read a VMware vmx file directly or over SSH.
This is useful when VMware VMs are stored on an NFS server which you
can mount directly, or where you have access by SSH to an ESXi
hypervisor.  See L<virt-v2v-input-vmware(1)>.

=item B<-ic> libvirtURI

Specify a libvirt connection URI to use when reading the guest.  This
is only used when S<I<-i libvirt>>.

Only local libvirt connections, VMware vCenter connections, or RHEL 5
Xen remote connections can be used.  Other remote libvirt connections
will not work in general.

See also L<virt-v2v-input-vmware(1)>,
L<virt-v2v-input-xen(1)>.

=item B<-if> format

For I<-i disk> only, this specifies the format of the input disk
image.  For other input methods you should specify the input
format in the metadata.

=item B<--in-place>

Do not create an output virtual machine in the target hypervisor.
Instead, adjust the guest OS in the source VM to run in the input
hypervisor.

This mode is meant for integration with other toolsets, which take the
responsibility of converting the VM configuration, providing for
rollback in case of errors, transforming the storage, etc.

See L</In-place conversion> below.

Conflicts with all I<-o *> options.

=item B<-io> OPTION=VALUE

Set input option(s) related to the current input mode or transport.
To display short help on what options are available you can use:

 virt-v2v -it vddk -io "?"

=item B<-io vddk-libdir=>LIBDIR

Set the VDDK library directory.  This directory should I<contain>
subdirectories called F<include>, F<lib64> etc., but do not include
F<lib64> actually in the parameter.

In most cases this parameter is required when using the I<-it vddk>
(VDDK) transport.  See L<virt-v2v-input-vmware(1)> for details.

=item B<-io vddk-thumbprint=>xx:xx:xx:...

Set the thumbprint of the remote VMware server.

This parameter is required when using the I<-it vddk> (VDDK) transport.
See L<virt-v2v-input-vmware(1)> for details.

=item B<-io vddk-config=>FILENAME

=item B<-io vddk-cookie=>COOKIE

=item B<-io vddk-nfchostport=>PORT

=item B<-io vddk-port=>PORT

=item B<-io vddk-snapshot=>SNAPSHOT-MOREF

=item B<-io vddk-transports=>MODE:MODE:...

When using VDDK mode, these options are passed unmodified to the
L<nbdkit(1)> VDDK plugin.  Please refer to L<nbdkit-vddk-plugin(1)>.
Do not use these options unless you know what you are doing.  These
are all optional.

=item B<-ip> filename

Supply a file containing a password to be used when connecting to the
target hypervisor.  If this is omitted then the input hypervisor may
ask for the password interactively.  Note the file should contain the
whole password, B<without any trailing newline>, and for security the
file should have mode C<0600> so that others cannot read it.

=item B<-it> B<ssh>

When using I<-i vmx>, this enables the ssh transport.
See L<virt-v2v-input-vmware(1)>.

=item B<-it> B<vddk>

Use VMware VDDK as a transport to copy the input disks.  See
L<virt-v2v-input-vmware(1)>.  If you use this parameter then you
may need to use other I<-io vddk*> options to specify how to connect
through VDDK.

=item B<--key> SELECTOR

Specify a key for LUKS, to automatically open a LUKS device when using
the inspection.  C<SELECTOR> can be in one of the following formats:

=over 4

=item B<--key> C<DEVICE>:key:KEY_STRING

Use the specified C<KEY_STRING> as passphrase.

=item B<--key> C<DEVICE>:file:FILENAME

Read the passphrase from F<FILENAME>.

=back

=item B<--keys-from-stdin>

Read key or passphrase parameters from stdin.  The default is
to try to read passphrases from the user by opening F</dev/tty>.

Note this options only applies to keys and passphrases for encrypted
devices and partitions, not for passwords used to connect to remote
servers.

=item B<--mac> aa:bb:cc:dd:ee:ffB<:network:>out

=item B<--mac> aa:bb:cc:dd:ee:ffB<:bridge:>out

Map source NIC MAC address to a network or bridge.

See L</Networks and bridges> below.

=item B<--machine-readable>

=item B<--machine-readable>=format

This option is used to make the output more machine friendly
when being parsed by other programs.  See
L</Machine readable output> below.

=item B<-n> in:out

=item B<-n> out

=item B<--network> in:out

=item B<--network> out

=item B<-b> in:out

=item B<-b> out

=item B<--bridge> in:out

=item B<--bridge> out

Map network (or bridge) called C<in> to network (or bridge) called
C<out>.  If no C<in:> prefix is given, all other networks (or bridges)
are mapped to C<out>.

See L</Networks and bridges> below.

=item B<--no-copy>

Don’t copy the disks.  Instead, conversion is performed (and thrown
away), and metadata is written, but no disks are created.  See
also discussion of S<I<-o null>> below.

This is useful in two cases: Either you want to test if conversion is
likely to succeed, without the long copying process.  Or you are only
interested in looking at the metadata.

This option is not compatible with I<-o libvirt> since it would create
a faulty guest (one with no disks).

This option is not compatible with I<-o glance> for technical reasons.

=item B<-o> B<disk>

This is the same as I<-o local>.

=item B<-o> B<glance>

This is a legacy option.  You should probably use I<-o openstack>
instead.

Set the output method to OpenStack Glance.  In this mode the converted
guest is uploaded to Glance.  See L<virt-v2v-output-openstack(1)>.

=item B<-o> B<libvirt>

Set the output method to I<libvirt>.  This is the default.

In this mode, the converted guest is created as a libvirt guest.  You
may also specify a libvirt connection URI (see I<-oc>).

See L<virt-v2v-output-local(1)>.

=item B<-o> B<local>

Set the output method to I<local>.

In this mode, the converted guest is written to a local directory
specified by I<-os /dir> (the directory must exist).  The converted
guest’s disks are written as:

 /dir/name-sda
 /dir/name-sdb
 [etc]

and a libvirt XML file is created containing guest metadata:

 /dir/name.xml

where C<name> is the guest name.

=item B<-o> B<null>

Set the output method to I<null>.

The guest is converted and copied (unless you also specify
I<--no-copy>), but the results are thrown away and no metadata is
written.

=item B<-o> B<openstack>

Set the output method to OpenStack.  See L<virt-v2v-output-openstack(1)>.

=item B<-o> B<ovirt>

This is the same as I<-o rhv>.

=item B<-o> B<ovirt-upload>

This is the same as I<-o rhv-upload>.

=item B<-o> B<qemu>

Set the output method to I<qemu>.

This is similar to I<-o local>, except that a shell script is written
which you can use to boot the guest in qemu.  The converted disks and
shell script are written to the directory specified by I<-os>.

When using this output mode, you can also specify the I<--qemu-boot>
option which boots the guest under qemu immediately.

=item B<-o> B<rhev>

This is the same as I<-o rhv>.

=item B<-o> B<rhv>

Set the output method to I<rhv>.

The converted guest is written to a RHV Export Storage Domain.  The
I<-os> parameter must also be used to specify the location of the
Export Storage Domain.  Note this does not actually import the guest
into RHV.  You have to do that manually later using the UI.

See L<virt-v2v-output-rhv(1)>.

=item B<-o> B<rhv-upload>

Set the output method to I<rhv-upload>.

The converted guest is written directly to a RHV Data Domain.
This is a faster method than I<-o rhv>, but requires oVirt
or RHV E<ge> 4.2.

See L<virt-v2v-output-rhv(1)>.

=item B<-o> B<vdsm>

Set the output method to I<vdsm>.

This mode is similar to I<-o rhv>, but the full path to the
data domain must be given:
F</rhv/data-center/E<lt>data-center-uuidE<gt>/E<lt>data-domain-uuidE<gt>>.
This mode is only used when virt-v2v runs under VDSM control.

=item B<-oa> B<sparse>

=item B<-oa> B<preallocated>

Set the output file allocation mode.  The default is C<sparse>.

=item B<-oc> URI

Specify a connection URI to use when writing the converted guest.

For S<I<-o libvirt>> this is the libvirt URI.  Only local libvirt
connections can be used.  Remote libvirt connections will not work.
See L<virt-v2v-output-local(1)> for further information.

=item B<-of> format

When converting the guest, convert the disks to the given format.

If not specified, then the input format is used.

=item B<-on> name

Rename the guest when converting it.  If this option is not used then
the output name is the same as the input name.

=item B<-oo> OPTION=VALUE

Set output option(s) related to the current output mode.
To display short help on what options are available you can use:

 virt-v2v -o rhv-upload -oo "?"

=item B<-oo guest-id=>C<ID>

For I<-o openstack> (L<virt-v2v-output-openstack(1)>) only, set a guest ID
which is saved on each Cinder volume in the C<virt_v2v_guest_id>
volume property.

=item B<-oo verify-server-certificate>

=item B<-oo verify-server-certificate=>C<true|false>

For I<-o openstack> (L<virt-v2v-output-openstack(1)>) only, this can
be used to disable SSL certification validation when connecting to
OpenStack by specifying I<-oo verify-server-certificate=false>.

=item B<-oo os->*B<=>*

For I<-o openstack> (L<virt-v2v-output-openstack(1)>) only, set optional
OpenStack authentication.  For example I<-oo os-username=>NAME is
equivalent to C<openstack --os-username=NAME>.

=item B<-oo rhv-cafile=>F<ca.pem>

For I<-o rhv-upload> (L<virt-v2v-output-rhv(1)>) only, the F<ca.pem> file
(Certificate Authority), copied from F</etc/pki/ovirt-engine/ca.pem>
on the oVirt engine.

=item B<-oo rhv-cluster=>C<CLUSTERNAME>

For I<-o rhv-upload> (L<virt-v2v-output-rhv(1)>) only, set the RHV Cluster
Name.  If not given it uses C<Default>.

=item B<-oo rhv-direct>

For I<-o rhv-upload> (L<virt-v2v-output-rhv(1)>) only, if this option is given
then virt-v2v will attempt to directly upload the disk to the oVirt
node, otherwise it will proxy the upload through the oVirt engine.
Direct upload requires that you have network access to the oVirt
nodes.  Non-direct upload is slightly slower but should work in all
situations.

=item B<-oo rhv-verifypeer>

For I<-o rhv-upload> (L<virt-v2v-output-rhv(1)>) only, verify the oVirt/RHV
server’s identity by checking the server‘s certificate against the
Certificate Authority.

=item B<-oo server-id=>C<NAME|UUID>

For I<-o openstack> (L<virt-v2v-output-openstack(1)>) only, set the name
of the conversion appliance where virt-v2v is running.

=item B<-oo vdsm-compat=0.10>

=item B<-oo vdsm-compat=1.1>

If I<-o vdsm> and the output format is qcow2, then we add the qcow2
I<compat=0.10> option to the output file for compatibility with RHEL 6
(see L<https://bugzilla.redhat.com/1145582>).

If I<-oo vdsm-compat=1.1> is used then modern qcow2 (I<compat=1.1>)
files are generated instead.

Currently I<-oo vdsm-compat=0.10> is the default, but this will change
to I<-oo vdsm-compat=1.1> in a future version of virt-v2v (when we can
assume that everyone is using a modern version of qemu).

B<Note this option only affects I<-o vdsm> output>.  All other output
modes (including I<-o rhv>) generate modern qcow2 I<compat=1.1>
files, always.

If this option is available, then C<vdsm-compat-option> will appear in
the I<--machine-readable> output.

=item B<-oo vdsm-image-uuid=>UUID

=item B<-oo vdsm-vol-uuid=>UUID

=item B<-oo vdsm-vm-uuid=>UUID

=item B<-oo vdsm-ovf-output=>DIR

Normally the RHV output mode chooses random UUIDs for the target
guest.  However VDSM needs to control the UUIDs and passes these
parameters when virt-v2v runs under VDSM control.  The parameters
control:

=over 4

=item *

the image directory of each guest disk (I<-oo vdsm-image-uuid>) (this
option is passed once for each guest disk)

=item *

UUIDs for each guest disk (I<-oo vdsm-vol-uuid>) (this option
is passed once for each guest disk)

=item *

the OVF file name (I<-oo vdsm-vm-uuid>).

=item *

the OVF output directory (default current directory) (I<-oo vdsm-ovf-output>).

=back

The format of UUIDs is: C<12345678-1234-1234-1234-123456789abc> (each
hex digit can be C<0-9> or C<a-f>), conforming to S<OSF DCE 1.1>.

These options can only be used with I<-o vdsm>.

=item B<-oo vdsm-ovf-flavour=>flavour

This option controls the format of the OVF generated at the end of conversion.
Currently there are two possible flavours:

=over 4

=item rhvexp

The OVF format used in RHV export storage domain.

=item ovirt

The OVF format understood by oVirt REST API.

=back

For backward compatibility the default is I<rhvexp>, but this may change in
the future.

=item B<-op> file

Supply a file containing a password to be used when connecting to the
target hypervisor.  Note the file should contain the whole password,
B<without any trailing newline>, and for security the file should have
mode C<0600> so that others cannot read it.

=item B<-os> storage

The location of the storage for the converted guest.

For I<-o libvirt>, this is a libvirt directory pool
(see S<C<virsh pool-list>>) or pool UUID.

For I<-o local> and I<-o qemu>, this is a directory name.  The
directory must exist.

For I<-o rhv-upload>, this is the name of the destination Storage
Domain.

For I<-o openstack>, this is the optional Cinder volume type.

For I<-o rhv>, this can be an NFS path of the Export Storage Domain
of the form C<E<lt>hostE<gt>:E<lt>pathE<gt>>, eg:

 rhv-storage.example.com:/rhv/export

The NFS export must be mountable and writable by the user and host
running virt-v2v, since the virt-v2v program has to actually mount it
when it runs.  So you probably have to run virt-v2v as C<root>.

B<Or:> You can mount the Export Storage Domain yourself, and point
I<-os> to the mountpoint.  Note that virt-v2v will still need to write
to this remote directory, so virt-v2v will still need to run as
C<root>.

You will get an error if virt-v2v is unable to mount/write to the
Export Storage Domain.

=item B<--print-estimate>

Print the estimated size of the data which will be copied from the
source disk(s) and stop.  One number (the size in bytes) is printed
per disk, and a total:

 $ virt-v2v --print-estimate
 ...
 disk 1: 100000
 disk 2: 200000
 total: 300000

With the I<--machine-readable> option you get JSON output which can be
directed into a file or elsewhere:

 $ virt-v2v --print-estimate --machine-readable=file:estimates
 ...
 $ cat estimates
 {
  "disks": [ 100000, 200000 ],
  "total": 300000
 }

When using this option you must specify an output mode.  This is
because virt-v2v has to perform the conversion in order to print the
estimate, and the conversion depends on the output mode.  Using
I<-o null> should be safe for most purposes.

When this option is used along with I<--machine-readable> you can
direct the output to an alternate file.

=item B<--print-source>

Print information about the source guest and stop.  This option is
useful when you are setting up network and bridge maps.
See L</Networks and bridges>.

=item B<--qemu-boot>

When using I<-o qemu> only, this boots the guest immediately after
virt-v2v finishes.

=item B<-q>

=item B<--quiet>

This disables progress bars and other unnecessary output.

=item B<--root ask>

=item B<--root single>

=item B<--root first>

=item B<--root> /dev/sdX

=item B<--root> /dev/VG/LV

Choose the root filesystem to be converted.

In the case where the virtual machine is dual-boot or multi-boot, or
where the VM has other filesystems that look like operating systems,
this option can be used to select the root filesystem (a.k.a. C<C:>
drive or F</>) of the operating system that is to be converted.  The
Windows Recovery Console, certain attached DVD drives, and bugs in
libguestfs inspection heuristics, can make a guest look like a
multi-boot operating system.

The default in virt-v2v E<le> 0.7.1 was S<I<--root single>>, which
causes virt-v2v to die if a multi-boot operating system is found.

Since virt-v2v E<ge> 0.7.2 the default is now S<I<--root ask>>: If the
VM is found to be multi-boot, then virt-v2v will stop and list the
possible root filesystems and ask the user which to use.  This
requires that virt-v2v is run interactively.

S<I<--root first>> means to choose the first root device in the case
of a multi-boot operating system.  Since this is a heuristic, it may
sometimes choose the wrong one.

You can also name a specific root device, eg. S<I<--root /dev/sda2>>
would mean to use the second partition on the first hard drive.  If
the named root device does not exist or was not detected as a root
device, then virt-v2v will fail.

Note that there is a bug in grub which prevents it from successfully
booting a multiboot system if virtio is enabled.  Grub is only able to
boot an operating system from the first virtio disk.  Specifically,
F</boot> must be on the first virtio disk, and it cannot chainload an
OS which is not in the first virtio disk.

=item B<-v>

=item B<--verbose>

Enable verbose messages for debugging.

=item B<-V>

=item B<--version>

Display version number and exit.

=item B<-x>

Enable tracing of libguestfs API calls.

=back

=head1 NOTES

=head2 Xen paravirtualized guests

Older versions of virt-v2v could turn a Xen paravirtualized (PV) guest
into a KVM guest by installing a new kernel.  This version of virt-v2v
does I<not> attempt to install any new kernels.  Instead it will give
you an error if there are I<only> Xen PV kernels available.

Therefore before conversion you should check that a regular kernel is
installed.  For some older Linux distributions, this means installing
a kernel from the table below:

 RHEL 3         (Does not apply, as there was no Xen PV kernel)
 
 RHEL 4         i686 with > 10GB of RAM: install 'kernel-hugemem'
                i686 SMP: install 'kernel-smp'
                other i686: install 'kernel'
                x86-64 SMP with > 8 CPUs: install 'kernel-largesmp'
                x86-64 SMP: install 'kernel-smp'
                other x86-64: install 'kernel'
 
 RHEL 5         i686: install 'kernel-PAE'
                x86-64: install 'kernel'
 
 SLES 10        i586 with > 10GB of RAM: install 'kernel-bigsmp'
                i586 SMP: install 'kernel-smp'
                other i586: install 'kernel-default'
                x86-64 SMP: install 'kernel-smp'
                other x86-64: install 'kernel-default'
 
 SLES 11+       i586: install 'kernel-pae'
                x86-64: install 'kernel-default'

 Windows        (Does not apply, as there is no Xen PV Windows kernel)

=head2 Enabling virtio

"Virtio" is the name for a set of drivers which make disk (block
device), network and other guest operations work much faster on KVM.

Older versions of virt-v2v could install these drivers for certain
Linux guests.  This version of virt-v2v does I<not> attempt to install
new Linux kernels or drivers, but will warn you if they are not
installed already.

In order to enable virtio, and hence improve performance of the guest
after conversion, you should ensure that the B<minimum> versions of
packages are installed I<before> conversion, by consulting the table
below.

 RHEL 3         No virtio drivers are available
 
 RHEL 4         kernel >= 2.5.9-89.EL
                lvm2 >= 2.02.42-5.el4
                device-mapper >= 1.02.28-2.el4
                selinux-policy-targeted >= 1.17.30-2.152.el4
                policycoreutils >= 1.18.1-4.13
 
 RHEL 5         kernel >= 2.6.18-128.el5
                lvm2 >= 2.02.40-6.el5
                selinux-policy-targeted >= 2.4.6-203.el5
 
 RHEL 6+        All versions support virtio
 
 Fedora         All versions support virtio
 
 SLES 11+       All versions support virtio
 
 SLES 10        kernel >= 2.6.16.60-0.85.1
 
 OpenSUSE 11+   All versions support virtio
 
 OpenSUSE 10    kernel >= 2.6.25.5-1.1

 Debian 6+      All versions support virtio

 Ubuntu 10.04+  All versions support virtio

 Windows        Drivers are installed from the ISO or directory pointed
                to by "VIRTIO_WIN" environment variable if present

=head2 RHEL 4: SELinux relabel appears to hang forever

In RHEL E<le> 4.7 there was a bug which causes SELinux relabelling
to appear to hang forever at:

 *** Warning -- SELinux relabel is required. ***
 *** Disabling security enforcement.         ***
 *** Relabeling could take a very long time, ***
 *** depending on file system size.          ***

In reality it is waiting for you to press a key (but there is no
visual indication of this).  You can either hit the C<[Return]> key,
at which point the guest will finish relabelling and reboot, or you
can install policycoreutils E<ge> 1.18.1-4.13 before starting the v2v
conversion.  See also
L<https://bugzilla.redhat.com/show_bug.cgi?id=244636>

=head2 Debian and Ubuntu

=head3 "warning: could not determine a way to update the configuration of Grub2"

Currently, virt-v2v has no way to set the default kernel in Debian
and Ubuntu guests using GRUB 2 as bootloader.  This means that
virt-v2v will not change the default kernel used for booting, even
in case it is not the best kernel available on the guest.
A recommended procedure is, before using virt-v2v, to check that the
boot kernel is the best kernel available in the guest (for example
by making sure the guest is up-to-date).

=head3 "vsyscall attempted with vsyscall=none"

When run on a recent Debian host virt-v2v may fail to convert guests
which were created before 2013.  In the debugging output you will see
a crash message similar to:

 vsyscall attempted with vsyscall=none ip:...
 segfault at ...

This is caused because Debian removed support for running old binaries
which used the legacy vsyscall page to call into the kernel.

You can work around this problem by running this command before
running virt-v2v:

 export LIBGUESTFS_APPEND="vsyscall=emulate"

For more information, see L<https://bugzilla.redhat.com/1592061>

=head2 Windows

=head3 Windows E<ge> 8 Fast Startup is incompatible with virt-v2v

Guests which use the Windows E<ge> 8 "Fast Startup" feature (or guests
which are hibernated) cannot be converted with virt-v2v.  You will see
an error:

 virt-v2v: error: unable to mount the disk image for writing. This has
 probably happened because Windows Hibernation or Fast Restart is being
 used in this guest. You have to disable this (in the guest) in order
 to use virt-v2v.

As the message says, you need to boot the guest and disable the "Fast
Startup" feature (Control Panel → Power Options → Choose what the
power buttons do → Change settings that are currently unavailable →
Turn on fast startup), and shut down the guest, and then you will be
able to convert it.

For more information, see:
L<guestfs(3)/WINDOWS HIBERNATION AND WINDOWS 8 FAST STARTUP>.

=head3 Boot failure: 0x0000007B

This boot failure is caused by Windows being unable to find or load
the right disk driver (eg. F<viostor.sys>).  If you experience this
error, here are some things to check:

=over 4

=item *

First ensure that the guest boots on the source hypervisor before
conversion.

=item *

Check you have the Windows virtio drivers available in
F</usr/share/virtio-win>, and that virt-v2v did not print any warning
about not being able to install virtio drivers.

On S<Red Hat Enterprise Linux 7>, you will need to install the signed
drivers available in the C<virtio-win> package.  If you do not have
access to the signed drivers, then you will probably need to disable
driver signing in the boot menus.

=item *

Check that you are presenting a virtio-blk interface (B<not>
virtio-scsi and B<not> ide) to the guest.  On the qemu/KVM command
line you should see something similar to this:

 ... -drive file=windows-sda,if=virtio ...

In libvirt XML, you should see:

 <target dev='vda' bus='virtio'/>

=item *

Check that Windows Group Policy does not prevent the driver from being
installed or used.  Try deleting Windows Group Policy before
conversion.

=item *

Check there is no anti-virus or other software which implements Group
Policy-like prohibitions on installing or using new drivers.

=item *

Enable boot debugging and check the F<viostor.sys> driver is being
loaded.

=back

=head3 OpenStack and Windows reactivation

OpenStack does not offer stable device / PCI addresses to guests.
Every time it creates or starts a guest, it regenerates the libvirt
XML for that guest from scratch.  The libvirt XML will have no
E<lt>addressE<gt> fields.  Libvirt will then assign addresses to
devices, in a predictable manner.  Addresses may change if any of the
following are true:

=over 4

=item *

A new disk or network device has been added or removed from the guest.

=item *

The version of OpenStack or (possibly) libvirt has changed.

=back

Because Windows does not like "hardware" changes of this kind, it may
trigger Windows reactivation.

This can also prevent booting with a 7B error [see previous section]
if the guest has group policy containing
C<Device Installation Restrictions>.

=head3 Support for SHA-2 certificates in Windows 7 and Windows Server 2008 R2

Later versions of the Windows virtio drivers are signed using SHA-2
certificates (instead of SHA-1).  The original shipping Windows 7 and
Windows Server 2008 R2 did not understand SHA-2 certificates and so
the Windows virtio drivers will not install properly.

To fix this you must apply SHA-2 Code Signing Support from:
L<https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2015/3033929>
before converting the guest.

For further information see:
L<https://bugzilla.redhat.com/show_bug.cgi?id=1624878>

=head2 Networks and bridges

Guests are usually connected to one or more networks, and when
converted to the target hypervisor you usually want to reconnect those
networks at the destination.  The options I<--network>, I<--bridge>
and I<--mac> allow you to do that.

If you are unsure of what networks and bridges are in use on the
source hypervisor, then you can examine the source metadata (libvirt
XML, vCenter information, etc.).  Or you can run virt-v2v with the
I<--print-source> option which causes virt-v2v to print out the
information it has about the guest on the source and then exit.

In the I<--print-source> output you will see a section showing the
guest’s Network Interface Cards (NICs):

 $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Network "default" mac: 52:54:00:d0:cf:0e

Bridges are special classes of network devices which are attached to a
named external network on the source hypervisor, for example:

 $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Bridge "br0"

To map a specific source bridge to a target network, for example
C<br0> on the source to C<ovirtmgmt> on the target, use:

 virt-v2v [...] --bridge br0:ovirtmgmt

To map every bridge to a target network, use:

 virt-v2v [...] --bridge ovirtmgmt

=head3 Fine-grained mapping of guest NICs

The I<--mac> option gives you more control over the mapping, letting
you map single NICs to either networks or bridges on the target.  For
example a source guest with two NICs could map them individually to
two networks called C<mgmt> and C<clientdata> like this:

 $ virt-v2v [...] \
    --mac 52:54:00:d0:cf:0e:network:mgmt \
    --mac 52:54:00:d0:cf:0f:network:clientdata

Note that virt-v2v does not have the ability to change a guest’s MAC
address.  The MAC address is part of the guest metadata and must
remain the same on source and target hypervisors.  Most guests will
use the MAC address to set up persistent associations between NICs and
internal names (like C<eth0>), with firewall settings, or even for
other purposes like software licensing.

=head2 Resource requirements

=head3 Network

The most important resource for virt-v2v appears to be network
bandwidth.  Virt-v2v should be able to copy guest data at gigabit
ethernet speeds or greater.

Ensure that the network connections between servers (conversion
server, NFS server, vCenter, Xen) are as fast and as low latency as
possible.

=head3 Disk space

Virt-v2v places potentially large temporary files in C<$TMPDIR> (which
is F</var/tmp> if you don't set it).  Using tmpfs is a bad idea.

For each guest disk, an overlay is stored temporarily.  This stores
the changes made during conversion, and is used as a cache.  The
overlays are not particularly large - tens or low hundreds of
megabytes per disk is typical.  In addition to the overlay(s), input
and output methods may use disk space, as outlined in the table below.

=over 4

=item I<-i ova>

This temporarily places a full copy of the uncompressed source disks
in C<$TMPDIR>.

=item I<-o glance>

This temporarily places a full copy of the output disks in C<$TMPDIR>.

=item I<-o local>

=item I<-o qemu>

You must ensure there is sufficient space in the output directory for
the converted guest.

=back

See also L</Minimum free space check in the host> below.

=head3 VMware vCenter resources

Copying from VMware vCenter is currently quite slow, but we believe
this to be an issue with VMware.  Ensuring the VMware ESXi hypervisor
and vCenter are running on fast hardware with plenty of memory should
alleviate this.

=head3 Compute power and RAM

Virt-v2v is not especially compute or RAM intensive.  If you are
running many parallel conversions, then you may consider allocating
one CPU core and 2 GB of RAM per running instance.

Virt-v2v can be run in a virtual machine.

=head3 Trimming

Virt-v2v attempts to optimize the speed of conversion by ignoring
guest filesystem data which is not used.  This would include unused
filesystem blocks, blocks containing zeroes, and deleted files.

To do this, virt-v2v issues a non-destructive L<fstrim(8)> operation.
As this happens to an overlay placed over the guest data, it does
B<not> affect the source in any way.

If this fstrim operation fails, you will see a warning, but virt-v2v
will continue anyway.  It may run more slowly (in some cases much more
slowly), because it is copying the unused parts of the disk.

Unfortunately support for fstrim is not universal, and it also depends
on specific details of the filesystem, partition alignment, and
backing storage.  As an example, NTFS filesystems cannot be fstrimmed
if they occupy a partition which is not aligned to the underlying
storage.  That was the default on Windows before Vista.  As another
example, VFAT filesystems (used by UEFI guests) cannot be trimmed at
all.

fstrim support in the Linux kernel is improving gradually, so over
time some of these restrictions will be lifted and virt-v2v will work
faster.

=head2 Post-conversion tasks

=head3 Guest network configuration

Virt-v2v cannot currently reconfigure a guest’s network configuration.
If the converted guest is not connected to the same subnet as the
source, its network configuration may have to be updated.  See also
L<virt-customize(1)>.

=head3 Converting a Windows guest

When converting a Windows guests, the conversion process is split into
two stages:

=over

=item 1

Offline conversion.

=item 2

First boot.

=back

The guest will be bootable after the offline conversion stage, but
will not yet have all necessary drivers installed to work correctly.
These will be installed automatically the first time the guest boots.

B<N.B.> Take care not to interrupt the automatic driver installation
process when logging in to the guest for the first time, as this may
prevent the guest from subsequently booting correctly.

=head2 Free space for conversion

=head3 Free space in the guest

Virt-v2v checks there is sufficient free space in the guest filesystem
to perform the conversion.  Currently it checks:

=over 4

=item Linux root filesystem or Windows C<C:> drive

Minimum free space: 20 MB

=item Linux F</boot>

Minimum free space: 50 MB

This is because we need to build a new initramfs for some Enterprise
Linux conversions.

=item Any other mountable filesystem

Minimum free space: 10 MB

=back

=head3 Minimum free space check in the host

You must have sufficient free space in the host directory used to
store temporary overlays (except in I<--in-place> mode).  To find out
which directory this is, use:

 $ df -h "`guestfish get-cachedir`"
 Filesystem        Size  Used Avail Use% Mounted on
 /dev/mapper/root   50G   40G  6.8G  86% /

and look under the C<Avail> column.  Virt-v2v will refuse to do the
conversion at all unless at least 1GB is available there.

See also L</Resource requirements> above.

=head2 Running virt-v2v as root or non-root

Nothing in virt-v2v inherently needs root access, and it will run just
fine as a non-root user.  However, certain external features may
require either root or a special user:

=over 4

=item Mounting the Export Storage Domain

When using I<-o rhv -os server:/esd> virt-v2v has to have sufficient
privileges to NFS mount the Export Storage Domain from C<server>.

You can avoid needing root here by mounting it yourself before running
virt-v2v, and passing I<-os /mountpoint> instead, but first of all
read the next S<section ...>

=item Writing to the Export Storage Domain as 36:36

RHV-M cannot read files and directories from the Export Storage
Domain unless they have UID:GID 36:36.  You will see VM import
problems if the UID:GID is not correct.

When you run virt-v2v I<-o rhv> as root, virt-v2v attempts to create
files and directories with the correct ownership.  If you run virt-v2v
as non-root, it will probably still work, but you will need to
manually change ownership after virt-v2v has finished.

=item Writing to libvirt

When using I<-o libvirt>, you may need to run virt-v2v as root so that
it can write to the libvirt system instance (ie. C<qemu:///system>)
and to the default location for disk images (usually
F</var/lib/libvirt/images>).

You can avoid this by setting up libvirt connection authentication,
see L<http://libvirt.org/auth.html>.  Alternatively, use
I<-oc qemu:///session>, which will write to your per-user libvirt
instance.

=item Writing to Openstack

Because of how Cinder volumes are presented as F</dev> block devices,
using I<-o openstack> normally requires that virt-v2v is run as root.

=item Writing to Glance

This does I<not> need root (in fact it probably won’t work), but may
require either a special user and/or for you to source a script that
sets authentication environment variables.  Consult the Glance
documentation.

=back

=head2 Minimal XML for -i libvirtxml option

When using the I<-i libvirtxml> option, you have to supply some
libvirt XML.  Writing this from scratch is hard, so the template below
is helpful.

B<Note this should only be used for testing and/or where you know what
you're doing!>  If you have libvirt metadata for the guest, always use
that instead.

 <domain type='kvm'>
   <name> NAME </name>
   <memory>1048576</memory>
   <vcpu>2</vcpu>
   <os>
     <type>hvm</type>
     <boot dev='hd'/>
   </os>
   <features>
     <acpi/>
     <apic/>
     <pae/>
   </features>
   <devices>
     <disk type='file' device='disk'>
       <driver name='qemu' type='raw'/>
       <source file='/path/to/disk/image'/>
       <target dev='hda' bus='ide'/>
     </disk>
     <interface type='network'>
       <mac address='52:54:00:01:02:03'/>
       <source network='default'/>
       <model type='rtl8139'/>
     </interface>
   </devices>
 </domain>

=head2 In-place conversion

It is also possible to use virt-v2v in scenarios where a foreign VM
has already been imported into a KVM-based hypervisor, but still needs
adjustments in the guest to make it run in the new virtual hardware.

In that case it is assumed that a third-party tool has created the
target VM in the supported KVM-based hypervisor based on the source VM
configuration and contents, but using virtual devices more appropriate
for KVM (e.g. virtio storage and network, etc.).

Then, to make the guest OS boot and run in the changed environment,
one can use:

 virt-v2v -ic qemu:///system converted_vm --in-place

Virt-v2v will analyze the configuration of C<converted_vm> in the
C<qemu:///system> libvirt instance, and apply various fixups to the
guest OS configuration to make it match the VM configuration.  This
may include installing virtio drivers, configuring the bootloader, the
mountpoints, the network interfaces, and so on.

Should an error occur during the operation, virt-v2v exits with an
error code leaving the VM in an undefined state.

=head2 Machine readable output

The I<--machine-readable> option can be used to make the output more
machine friendly, which is useful when calling virt-v2v from
other programs, GUIs etc.

There are two ways to use this option.

Firstly use the option on its own to query the capabilities of the
virt-v2v binary.  Typical output looks like this:

 $ virt-v2v --machine-readable
 virt-v2v
 libguestfs-rewrite
 colours-option
 vdsm-compat-option
 input:disk
 [...]
 output:local
 [...]
 convert:linux
 convert:windows

A list of features is printed, one per line, and the program exits
with status 0.

The C<input:> and C<output:> features refer to I<-i> and I<-o> (input
and output mode) options supported by this binary.  The C<convert:>
features refer to guest types that this binary knows how to convert.

Secondly use the option in conjunction with other options to make the
regular program output more machine friendly.

At the moment this means:

=over 4

=item 1.

Progress bar messages can be parsed from stdout by looking for this
regular expression:

 ^[0-9]+/[0-9]+$

=item 2.

The calling program should treat messages sent to stdout (except for
progress bar messages) as status messages.  They can be logged and/or
displayed to the user.

=item 3.

The calling program should treat messages sent to stderr as error
messages.  In addition, virt-v2v exits with a non-zero status
code if there was a fatal error.

=back

Virt-v2v E<le> 0.9.1 did not support the I<--machine-readable>
option at all.  The option was added when virt-v2v was rewritten in 2014.

It is possible to specify a format string for controlling the output;
see L<guestfs(3)/ADVANCED MACHINE READABLE OUTPUT>.

=head1 FILES

=over 4

=item F</usr/share/virtio-win>

(Optional)

If this directory is present, then virtio drivers for Windows guests
will be found from this directory and installed in the guest during
conversion.

=back

=head1 ENVIRONMENT VARIABLES

=over 4

=item C<TMPDIR>

Location of the temporary directory used for the potentially large
temporary overlay file.

See the L</Disk space> section above.

=item C<VIRT_TOOLS_DATA_DIR>

This can point to the directory containing data files used for Windows
conversion.

Normally you do not need to set this.  If not set, a compiled-in
default will be used (something like F</usr/share/virt-tools>).

This directory may contain the following files:

=over 4

=item F<rhsrvany.exe>

(Required when doing conversions of Windows guests)

This is the RHSrvAny Windows binary, used to install a "firstboot"
script in the guest during conversion of Windows guests.

See also: C<https://github.com/rwmjones/rhsrvany>

=item F<pvvxsvc.exe>

This is a Windows binary shipped with SUSE VMDP, used to install a "firstboot"
script in Windows guests.  It is required if you intend to use the
I<--firstboot> or I<--firstboot-command> options with Windows guests.

=item F<rhev-apt.exe>

(Optional)

The RHV Application Provisioning Tool (RHEV APT).  If this file is
present, then RHEV APT will be installed in the Windows guest during
conversion.  This tool is a guest agent which ensures that the virtio
drivers remain up to date when the guest is running on Red Hat
Virtualization (RHV).

This file comes from Red Hat Virtualization (RHV), and is not
distributed with virt-v2v.

=back

=item C<VIRTIO_WIN>

This is where virtio drivers for Windows are searched for.

If unset, then we look for drivers in whichever of these paths
is found first:

=over 4

=item F</usr/share/virtio-win/virtio-win.iso>

The ISO containing virtio drivers for Windows.

=item F</usr/share/virtio-win>

The exploded tree of virtio drivers for Windows.  This is
usually incomplete, hence the ISO is preferred.

=back

(F<> if unset).  It can be a directory I<or>
point to F<virtio-win.iso> (CD ROM image containing drivers).

See L</Enabling virtio>.

=back

For other environment variables, see L<guestfs(3)/ENVIRONMENT VARIABLES>.

=head1 OTHER TOOLS

=over 4

=item L<virt-v2v-copy-to-local(1)>

There are some special cases where virt-v2v cannot directly access the
remote hypervisor.  In that case you have to use
L<virt-v2v-copy-to-local(1)> to make a local copy of the guest first,
followed by running C<virt-v2v -i libvirtxml> to perform the
conversion.

=item L<engine-image-uploader(8)>

Variously called C<engine-image-uploader>, C<ovirt-image-uploader> or
C<rhevm-image-uploader>, this tool allows you to copy a guest from one
oVirt or RHV Export Storage Domain to another.  It only permits
importing a guest that was previously exported from another oVirt/RHV
instance.

=item L<import-to-ovirt.pl|http://git.annexia.org/?p=import-to-ovirt.git>

This script can be used to import guests that already run on KVM to
oVirt or RHV.  For more information, see this blog posting by the
author of virt-v2v:

L<https://rwmj.wordpress.com/2015/09/18/importing-kvm-guests-to-ovirt-or-rhev/#content>

=back

=head1 SEE ALSO

L<virt-p2v(1)>,
L<virt-customize(1)>,
L<virt-df(1)>,
L<virt-filesystems(1)>,
L<virt-sparsify(1)>,
L<virt-sysprep(1)>,
L<guestfs(3)>,
L<guestfish(1)>,
L<qemu-img(1)>,
L<virt-v2v-copy-to-local(1)>,
L<virt-v2v-test-harness(1)>,
L<engine-image-uploader(8)>,
L<import-to-ovirt.pl|http://git.annexia.org/?p=import-to-ovirt.git>,
L<nbdkit(1)>,
L<nbdkit-vddk-plugin(1)>,
L<http://libguestfs.org/>.

=head1 AUTHORS

Matthew Booth

Cédric Bosdonnat

Tomáš Golembiovský

Shahar Havivi

Roman Kagan

Mike Latimer

Nir Soffer

Richard W.M. Jones

Pino Toscano

Tingting Zheng

=head1 COPYRIGHT

Copyright (C) 2009-2019 Red Hat Inc.
