=head1 NAME

virt-v2v - Convert a guest to use KVM

=head1 SYNOPSIS

 virt-v2v -ic esx://esx.example.com/ esx_guest

 virt-v2v -ic esx://esx.example.com/ \
   -o rhev -os rhev.nfs:/export_domain --network rhevm esx_guest

 virt-v2v -i libvirtxml -o local -os /tmp guest-domain.xml

 virt-v2v -i disk -o local -os /tmp disk.img

=head1 DESCRIPTION

Virt-v2v converts guests from a foreign hypervisor to run on KVM,
managed by libvirt or Red Hat Enterprise Virtualisation (RHEV) version
2.2 or later. It can currently convert Red Hat Enterprise Linux and
Windows guests running on Xen and VMware ESX.

There is also a companion front-end called L<virt-p2v(1)> which comes
as an ISO or CD image that can be booted on physical machines.

This manual page documents the rewritten virt-v2v included in
libguestfs E<ge> 1.28.

=head1 INPUT AND OUTPUT MODES

                         ┌────────────┐
 -i disk ───────────┐    │            │   ┌───────> -o local
                    │    │ virt-v2v   │   │
                    └──> │ conversion │ ──┘
 -i libvirt ───────────> │ server     │ ────────> -o libvirt
  (default)         ┌──> │            │ ──┐        (default)
                    │    │            │   │
 -i libvirtxml ─────┘    │            │   └────────> -o rhev
                         └────────────┘

Virt-v2v has a number of possible input and output modes, selected
using the I<-i> and I<-o> options.  Only one input and output mode can
be selected for each run of virt-v2v.

I<-i libvirt> is used for reading from any libvirt source.  Since
libvirt can connect to many different hypervisors, it is used for
reading guests from VMware ESX, RHEL 5 Xen and more.  The I<-ic>
option selects the precise libvirt source.

I<-i disk> is used for reading from local disk images (mainly for
testing).

I<-i libvirtxml> is used to read from libvirt XML files.  This is the
method used by L<virt-p2v(1)> behind the scenes.

I<-o libvirt> is used for writing to any libvirt target.  Libvirt can
connect to local or remote KVM hypervisors.  The I<-oc> option selects
the precise libvirt target.

I<-o local> is used to write to a local disk image (mainly for testing).

I<-o rhev> is used to write to a RHEV-M / oVirt target.

=head1 EXAMPLES

=head2 Convert from VMware ESX server to local libvirt

You have a VMware ESX server called C<esx.example.com>.  You want to
convert a guest called C<esx_guest> to run locally under libvirt.

 virt-v2v -ic esx://example.com esx_guest

In this case you will most likely have to run virt-v2v as C<root>,
since it needs to talk to the system libvirt daemon and copy the guest
disks to C</var/lib/libvirt/images>.

=head2 Convert from ESX to RHEV-M/oVirt

This is the same as the previous example, except you want to send the
guest to a RHEV-M Export Storage Domain which is located remotely
(over NFS) at C<rhev.nfs:/export_domain>.  If you are unclear about
the location of the Export Storage Domain you should check the
settings on your RHEV-M management console.  Guest network
interface(s) are connected to the target network called C<rhevm>.

 virt-v2v -ic esx://esx.example.com/ \
   -o rhev -os rhev.nfs:/export_domain --network rhevm esx_guest

In this case the host running virt-v2v acts as a B<conversion server>.

Note that after conversion, the guest will appear in the RHEV-M Export
Storage Domain, from where you will need to import it using the RHEV-M
user interface.

=head2 Convert disk image to disk image

Given a disk image from another hypervisor that you want to convert to
run on KVM, you have two options.  The simplest way is to try:

 virt-v2v -i disk -o local -os /tmp disk.img

where virt-v2v guesses everything about the input C<disk.img> and (in
this case) writes the converted result to C</tmp>.

A more complex method is to write some
L<libvirt XML|http://libvirt.org/formatdomain.html> describing the
input guest (if you can get the source hypervisor to provide you with
libvirt XML, then so much the better).  You can then do:

 virt-v2v -i libvirtxml -o local -os /tmp guest-domain.xml

Since C<guest-domain.xml> contains the path(s) to the guest disk
image(s) you do not need to specify the name of the disk image on the
command line.

=head1 OPTIONS

=over 4

=item B<--help>

Display help.

=item B<--bridge> ...

See I<--network> below.

=item B<--debug-gc>

Debug garbage collection and memory allocation.  This is only useful
when debugging memory problems in virt-v2v or the OCaml libguestfs
bindings.

=item B<-i disk>

Set the input method to I<disk>.

In this mode you can read a virtual machine disk image with no
metadata.  virt-v2v tries to guess the best default metadata.  This is
usually adequate but you can get finer control (eg. of memory and
vCPUs) by using I<-i libvirtxml> instead.  Only guests that use a single
disk can be imported this way.

=item B<-i libvirt>

Set the input method to I<libvirt>.  This is the default.

In this mode you have to specify a libvirt guest name on the command
line.  You may also specify a libvirt connection URI (see I<-ic>).

=item B<-i libvirtxml>

Set the input method to I<libvirtxml>.

In this mode you have to pass a libvirt XML file on the command line.
This file is read in order to get metadata about the source guest
(such as its name, amount of memory), and also to locate the input
disks.

=item B<-i local>

This is the same as I<-i disk>.

=item B<-ic> libvirtURI

Specify a libvirt connection URI to use when reading the guest.  This
is only used when S<I<-i libvirt>>.

Only local libvirt connections and ESX connections can be used.
Remote libvirt connections will not work in general.

=item B<-if> format

For I<-i disk> only, this specifies the format of the input disk
image.  For other input methods you should specify the input
format in the metadata.

=item B<--machine-readable>

This option is used to make the output more machine friendly
when being parsed by other programs.  See
L</MACHINE READABLE OUTPUT> below.

=item B<--network> in:out

=item B<--network> out

=item B<--bridge> in:out

=item B<--bridge> out

Map network (or bridge) called C<in> to network (or bridge) called
C<out>.  If no C<in:> prefix is given, all other networks (or bridges)
are mapped to C<out>.

See L</NETWORKS AND BRIDGES> below.

=item B<--no-copy>

Don't copy the disks.  Instead, conversion is performed (and thrown
away), and metadata is written, but no disks are created.

This is useful in two cases: Either you want to test if conversion is
likely to succeed, without the long copying process.  Or you are only
interested in looking at the metadata.

This option is not compatible with I<-o libvirt> since it would create
a faulty guest (one with no disks).

=item B<-o libvirt>

Set the output method to I<libvirt>.  This is the default.

In this mode, the converted guest is created as a libvirt guest.  You
may also specify a libvirt connection URI (see I<-oc>).

See L</OUTPUT TO LIBVIRT> below.

=item B<-o local>

Set the output method to I<local>.

In this mode, the converted guest is written to a local directory
specified by I<-os /dir> (the directory must exist).  The converted
guest's disks are written as:

 /dir/disk-sda
 /dir/disk-sdb
 [etc]

and a libvirt XML file is created containing guest metadata
(C</dir/name.xml>, where C<name> is the guest name).

=item B<-o ovirt>

This is the same as I<-o rhev>.

=item B<-o rhev>

Set the output method to I<rhev>.

The converted guest is written to a RHEV Export Storage Domain.  The
I<-os> parameter must also be used to specify the location of the
Export Storage Domain.  Note this does not actually import the guest
into RHEV.  You have to do that manually later using the UI.

=item B<-oa sparse>

=item B<-oa preallocated>

Set the output file allocation mode.  The default is C<sparse>.

=item B<-oc> libvirtURI

Specify a libvirt connection to use when writing the converted guest.
This is only used when S<I<-o libvirt>>.  See L</OUTPUT TO LIBVIRT> below.

Only local libvirt connections can be used.  Remote libvirt
connections will not work.

=item B<-of> format

When converting the guest, convert the disks to the given format.

If not specified, then the input format is used.

=item B<-on> name

Rename the guest when converting it.  If this option is not used then
the output name is the same as the input name.

=item B<-os> storage

The location of the storage for the converted guest.

For I<-o libvirt>, this is a libvirt directory pool
(see S<C<virsh pool-list>>).

For I<-o local>, this is a directory name.  The directory must exist.

For I<-o rhev>, this can be an NFS path of the Export Storage Domain
of the form C<E<lt>hostE<gt>:E<lt>pathE<gt>>, eg:

 rhev-storage.example.com:/rhev/export

The NFS export must be mountable and writable by the user and host
running virt-v2v, since the virt-v2v program has to actually mount it
when it runs.  So you probably have to run virt-v2v as C<root>.

B<Or:> You can mount the Export Storage Domain yourself, and point
I<-os> to the mountpoint.  Note that virt-v2v will still need to write
to this remote directory, so virt-v2v will still need to run as
C<root>.

You will get an error if virt-v2v is unable to mount/write to the
Export Storage Domain.

=item B<--print-source>

Print information about the source guest and stop.  This option is
useful when you are setting up network and bridge maps.
See L</NETWORKS AND BRIDGES>.

=item B<-q>

=item B<--quiet>

This disables progress bars and other unnecessary output.

=item B<--rhev-image-uuid> UUID

=item B<--rhev-vol-uuid> UUID

=item B<--rhev-vm-uuid> UUID

Normally the RHEV output mode chooses a random UUID for each of:

=over 4

=item *

the image directory (I<--rhev-image-uuid>)

=item *

once for each guest disk (I<--rhev-vol-uuid>)

=item *

the VM and OVF file (I<--rhev-vm-uuid>).

=back

However you can force specific UUIDs instead by using these options.

You can use I<--rhev-image-uuid> and I<--rhev-vm-uuid> on the command
line at most once.

If the guest has more than one virtual disk, then you should use
I<--rhev-vol-uuid> multiple times to change the UUID of each guest
disk.

The format of UUIDs is: C<12345678-1234-1234-1234-123456789abc> (each
hex digit can be C<0-9> or C<a-f>), conforming to S<OSF DCE 1.1>.

These options can only be used with I<-o rhev>.

=item B<--root ask>

=item B<--root single>

=item B<--root first>

=item B<--root> /dev/sdX

=item B<--root> /dev/VG/LV

Choose the root filesystem to be converted.

In the case where the virtual machine is dual-boot or multi-boot, or
where the VM has other filesystems that look like operating systems,
this option can be used to select the root filesystem (a.k.a. C<C:>
drive or C</>) of the operating system that is to be converted.  The
Windows Recovery Console, certain attached DVD drives, and bugs in
libguestfs inspection heuristics, can make a guest look like a
multi-boot operating system.

The default in virt-v2v E<le> 0.7.1 was S<I<--root single>>, which
causes virt-v2v to die if a multi-boot operating system is found.

Since virt-v2v E<ge> 0.7.2 the default is now S<I<--root ask>>: If the
VM is found to be multi-boot, then virt-v2v will stop and list the
possible root filesystems and ask the user which to use.  This
requires that virt-v2v is run interactively.

S<I<--root first>> means to choose the first root device in the case
of a multi-boot operating system.  Since this is a heuristic, it may
sometimes choose the wrong one.

You can also name a specific root device, eg. S<I<--root /dev/sda2>>
would mean to use the second partition on the first hard drive.  If
the named root device does not exist or was not detected as a root
device, then virt-v2v will fail.

Note that there is a bug in grub which prevents it from successfully
booting a multiboot system if VirtIO is enabled.  Grub is only able to
boot an operating system from the first VirtIO disk.  Specifically,
C</boot> must be on the first VirtIO disk, and it cannot chainload an
OS which is not in the first VirtIO disk.

=item B<-v>

=item B<--verbose>

Enable verbose messages for debugging.

=item B<-V>

=item B<--version>

Display version number and exit.

=item B<--vmtype desktop>

=item B<--vmtype server>

For the RHEV target only, specify the type of guest.  You can set this
to C<desktop> or C<server>.  If the option is not given, then a
suitable default is chosen based on the detected guest operating
system.

=item B<-x>

Enable tracing of libguestfs API calls.

=back

=head1 XEN PARAVIRTUALIZED GUESTS

Older versions of virt-v2v could turn a Xen paravirtualized (PV) guest
into a KVM guest by installing a new kernel.  This version of virt-v2v
does I<not> attempt to install any new kernels.  Instead it will give
you an error if there are I<only> Xen PV kernels available.

Therefore before conversion you should check that a regular kernel is
installed.  For some older Linux distributions, this means installing
a kernel from the table below:

 RHEL 3         (Does not apply, as there was no Xen PV kernel)
 
 RHEL 4         i686 with > 10GB of RAM: install 'kernel-hugemem'
                i686 SMP: install 'kernel-smp'
                other i686: install 'kernel'
                x86-64 SMP with > 8 CPUs: install 'kernel-largesmp'
                x86-64 SMP: install 'kernel-smp'
                other x86-64: install 'kernel'
 
 RHEL 5         i686: install 'kernel-PAE'
                x86-64: install 'kernel'
 
 SLES 10        i586 with > 10GB of RAM: install 'kernel-bigsmp'
                i586 SMP: install 'kernel-smp'
                other i586: install 'kernel-default'
                x86-64 SMP: install 'kernel-smp'
                other x86-64: install 'kernel-default'
 
 SLES 11+       i586: install 'kernel-pae'
                x86-64: install 'kernel-default'

 Windows        (Does not apply, as there is no Xen PV Windows kernel)

=head1 ENABLING VIRTIO

"Virtio" is the name for a set of drivers which make disk (block
device), network and other guest operations work much faster on KVM.

Older versions of virt-v2v could install these drivers for certain
Linux guests.  This version of virt-v2v does I<not> attempt to install
new Linux kernels or drivers, but will warn you if they are not
installed already.

In order to enable virtio, and hence improve performance of the guest
after conversion, you should ensure that the B<minimum> versions of
packages are installed I<before> conversion, by consulting the table
below.

 RHEL 3         No virtio drivers are available
 
 RHEL 4         kernel >= 2.5.9-89.EL
 
 RHEL 5         kernel >= 2.6.18-128.el5
                lvm2 >= 2.02.40-6.el5
                selinux-policy-targeted >= 2.4.6-203.el5
 
 RHEL 6+        All versions support virtio
 
 Fedora         All versions support virtio
 
 SLES 11+       All versions support virtio
 
 SLES 10        kernel >= 2.6.16.60-0.85.1
 
 OpenSUSE 11+   All versions support virtio
 
 OpenSUSE 10    kernel >= 2.6.25.5-1.1

 Windows        Drivers are installed from /usr/share/virtio-win
                if present

=head1 NETWORKS AND BRIDGES

Guests are usually connected to one or more networks, and when
converted to the target hypervisor you usually want to reconnect those
networks at the destination.  The options I<--network> and I<--bridge>
allow you to do that.

If you are unsure of what networks and bridges are in use on the
source hypervisor, then you can examine the source metadata (libvirt
XML, vCenter information, etc.).  Or you can run virt-v2v with the
I<--print-source> option which causes virt-v2v to print out the
information it has about the guest on the source and then exit.

In the I<--print-source> output you will see a section showing the
guest's Network Interface Cards (NICs):

 $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Network "default" mac: 52:54:00:d0:cf:0e

This is typical of a libvirt guest: It has a single network interface
connected to a network called C<default>.

To map a specific network to a target network, for example C<default>
on the source to C<rhevm> on the target, use:

 virt-v2v [...] --network default:rhevm

To map every network to a target network, use:

 virt-v2v [...] --network rhevm

Bridges are handled in the same way, but you have to use the
I<--bridge> option instead.  For example:

 $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Bridge "br0"
 
 $ virt-v2v [...] --bridge br0:targetbr

=head1 OUTPUT TO LIBVIRT

The I<-o libvirt> option lets you upload the converted guest to
a libvirt-managed host.  There are several limitations:

=over 4

=item *

You can only use a local libvirt connection [see below for how to
workaround this].

=item *

The I<-os pool> option must specify a directory pool, not anything
more exotic such as iSCSI [but see below].

=item *

You can only upload to a KVM hypervisor.

=back

B<To output to a remote libvirt instance and/or a non-directory storage pool>
you have to use the following workaround:

=over 4

=item 1.

Use virt-v2v in I<-o local> mode to convert the guest disks and
metadata into a local temporary directory:

 virt-v2v [...] -o local -os /tmp

This creates two (or more) files in C</tmp> called:

 /tmp/NAME.xml     # the libvirt XML (metadata)
 /tmp/NAME-sda     # the guest's first disk

(for C<NAME> substitute the guest's name).

=item 2.

Upload the converted disk(s) into the storage pool called C<POOL>:

 size=$(stat -c%s /tmp/NAME-sda)
 virsh vol-create-as POOL NAME-sda $size --format raw
 virsh vol-upload --pool POOL NAME-sda /tmp/NAME-sda

=item 3.

Edit C</tmp/NAME.xml> to change C</tmp/NAME-sda> to the pool name.
In other words, locate the following bit of XML:

 <disk type='file' device='disk'>
   <driver name='qemu' type='raw' cache='none' />
   <source file='/tmp/NAME-sda' />
   <target dev='hda' bus='ide' />
 </disk>

and change two things: The C<type='file'> attribute must be changed to
C<type='volume'>, and the C<E<lt>sourceE<gt>> element must be changed
to include C<pool> and C<volume> attributes:

 <disk type='volume' device='disk'>
   ...
   <source pool='POOL' volume='NAME-sda' />
   ...
 </disk>

=item 4.

Define the final guest in libvirt:

 virsh define /tmp/NAME.xml

=back

=head1 MACHINE READABLE OUTPUT

The I<--machine-readable> option can be used to make the output more
machine friendly, which is useful when calling virt-v2v from
other programs, GUIs etc.

There are two ways to use this option.

Firstly use the option on its own to query the capabilities of the
virt-v2v binary.  Typical output looks like this:

 $ virt-v2v --machine-readable
 virt-v2v
 libguestfs-rewrite

A list of features is printed, one per line, and the program exits
with status 0.

Secondly use the option in conjunction with other options to make the
regular program output more machine friendly.

At the moment this means:

=over 4

=item 1.

Progress bar messages can be parsed from stdout by looking for this
regular expression:

 ^[0-9]+/[0-9]+$

=item 2.

The calling program should treat messages sent to stdout (except for
progress bar messages) as status messages.  They can be logged and/or
displayed to the user.

=item 3.

The calling program should treat messages sent to stderr as error
messages.  In addition, virt-v2v exits with a non-zero status
code if there was a fatal error.

=back

Virt-v2v E<le> 0.9.1 did not support the I<--machine-readable>
option at all.  The option was added when virt-v2v was rewritten in 2014.

=head1 FILES

=over 4

=item C</usr/share/virtio-win>

(Optional)

If this directory is present, then virtio drivers for Windows guests
will be found from this directory and installed in the guest during
conversion.

=back

=head1 ENVIRONMENT VARIABLES

=over 4

=item C<TMPDIR>

Location of the temporary directory used for the potentially large
temporary overlay file.

You should ensure there is enough free space in the worst case for a
full copy of the source disk (I<virtual> size), or else set C<$TMPDIR>
to point to another directory that has enough space.

This defaults to C</tmp>.

Note that if C<$TMPDIR> is a tmpfs (eg. if C</tmp> is on tmpfs, or if
you use C<TMPDIR=/dev/shm>), tmpfs defaults to a maximum size of
I<half> of physical RAM.  If virt-v2v exceeds this, it will hang.
The solution is either to use a real disk, or to increase the maximum
size of the tmpfs mountpoint, eg:

 mount -o remount,size=10G /tmp

=item C<VIRT_TOOLS_DATA_DIR>

This can point to the directory containing data files used for Windows
conversion.

Normally you do not need to set this.  If not set, a compiled-in
default will be used (something like C</usr/share/virt-tools>).

This directory may contain the following files:

=over 4

=item C<rhsrvany.exe>

(Required when doing conversions of Windows guests)

This is the RHSrvAny Windows binary, used to install a "firstboot"
script in the guest during conversion of Windows guests.

See also: C<https://github.com/rwmjones/rhsrvany>

=item C<rhev-apt.exe>

(Optional)

The RHEV Application Provisioning Tool (RHEV APT).  If this file is
present, then RHEV APT will be installed in the Windows guest during
conversion.  This tool is a guest agent which ensures that the virtio
drivers remain up to date when the guest is running on Red Hat
Enterprise Virtualization (RHEV).

This file comes from Red Hat Enterprise Virtualization (RHEV), and is
not distributed with virt-v2v.

=back

=back

For other environment variables, see L<guestfs(3)/ENVIRONMENT VARIABLES>.

=head1 SEE ALSO

L<virt-p2v(1)>,
L<virt-customize(1)>,
L<virt-df(1)>,
L<virt-filesystems(1)>,
L<virt-sparsify(1)>,
L<virt-sysprep(1)>,
L<guestfs(3)>,
L<guestfish(1)>,
L<qemu-img(1)>,
L<http://libguestfs.org/>.

=head1 AUTHORS

Richard W.M. Jones L<http://people.redhat.com/~rjones/>

Matthew Booth

Mike Latimer

=head1 COPYRIGHT

Copyright (C) 2009-2014 Red Hat Inc.
