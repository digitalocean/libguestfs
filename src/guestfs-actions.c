/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <stdio.h>
#include <stdlib.h>

#include "guestfs.h"
#include "guestfs_protocol.h"

#define error guestfs_error
#define perrorf guestfs_perrorf
#define safe_malloc guestfs_safe_malloc
#define safe_realloc guestfs_safe_realloc
#define safe_strdup guestfs_safe_strdup
#define safe_memdup guestfs_safe_memdup

/* Check the return message from a call for validity. */
static int
check_reply_header (guestfs_h *g,
                    const struct guestfs_message_header *hdr,
                    int proc_nr, int serial)
{
  if (hdr->prog != GUESTFS_PROGRAM) {
    error (g, "wrong program (%d/%d)", hdr->prog, GUESTFS_PROGRAM);
    return -1;
  }
  if (hdr->vers != GUESTFS_PROTOCOL_VERSION) {
    error (g, "wrong protocol version (%d/%d)",
	   hdr->vers, GUESTFS_PROTOCOL_VERSION);
    return -1;
  }
  if (hdr->direction != GUESTFS_DIRECTION_REPLY) {
    error (g, "unexpected message direction (%d/%d)",
	   hdr->direction, GUESTFS_DIRECTION_REPLY);
    return -1;
  }
  if (hdr->proc != proc_nr) {
    error (g, "unexpected procedure number (%d/%d)", hdr->proc, proc_nr);
    return -1;
  }
  if (hdr->serial != serial) {
    error (g, "unexpected serial (%d/%d)", hdr->serial, serial);
    return -1;
  }

  return 0;
}

/* Check we are in the right state to run a high-level action. */
static int
check_state (guestfs_h *g, const char *caller)
{
  if (!guestfs_is_ready (g)) {
    if (guestfs_is_config (g))
      error (g, "%s: call launch() before using this function",
        caller);
    else if (guestfs_is_launching (g))
      error (g, "%s: call wait_ready() before using this function",
        caller);
    else
      error (g, "%s called from the wrong state, %d != READY",
        caller, guestfs_get_state (g));
    return -1;
  }
  return 0;
}

struct mount_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_ctx *ctx = (struct mount_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_args args;
  struct mount_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT,
        (xdrproc_t) xdr_guestfs_mount_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct sync_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sync_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sync_ctx *ctx = (struct sync_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sync");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sync");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sync");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sync (guestfs_h *g)
{
  struct sync_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sync") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_SYNC, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sync_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sync");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SYNC, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct touch_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void touch_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct touch_ctx *ctx = (struct touch_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_touch");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_touch");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_touch");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_touch (guestfs_h *g,
		const char *path)
{
  struct guestfs_touch_args args;
  struct touch_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_touch") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TOUCH,
        (xdrproc_t) xdr_guestfs_touch_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, touch_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_touch");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TOUCH, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct cat_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_cat_ret ret;
};

static void cat_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct cat_ctx *ctx = (struct cat_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_cat");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_cat");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_cat");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_cat_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_cat");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_cat (guestfs_h *g,
		const char *path)
{
  struct guestfs_cat_args args;
  struct cat_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_cat") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CAT,
        (xdrproc_t) xdr_guestfs_cat_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, cat_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_cat");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CAT, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.content; /* caller will free */
}

struct ll_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ll_ret ret;
};

static void ll_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ll_ctx *ctx = (struct ll_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_ll");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_ll");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_ll");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ll_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_ll");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_ll (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ll_args args;
  struct ll_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ll") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LL,
        (xdrproc_t) xdr_guestfs_ll_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, ll_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_ll");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LL, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.listing; /* caller will free */
}

struct ls_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ls_ret ret;
};

static void ls_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ls_ctx *ctx = (struct ls_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_ls");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_ls");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_ls");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ls_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_ls");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_ls (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ls_args args;
  struct ls_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ls") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LS,
        (xdrproc_t) xdr_guestfs_ls_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, ls_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_ls");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.listing.listing_val =
    safe_realloc (g, ctx.ret.listing.listing_val,
                  sizeof (char *) * (ctx.ret.listing.listing_len + 1));
  ctx.ret.listing.listing_val[ctx.ret.listing.listing_len] = NULL;
  return ctx.ret.listing.listing_val;
}

struct list_devices_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_devices_ret ret;
};

static void list_devices_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct list_devices_ctx *ctx = (struct list_devices_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_list_devices");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_list_devices");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_list_devices");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_devices_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_list_devices");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_list_devices (guestfs_h *g)
{
  struct list_devices_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_list_devices") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LIST_DEVICES, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, list_devices_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_list_devices");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LIST_DEVICES, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.devices.devices_val =
    safe_realloc (g, ctx.ret.devices.devices_val,
                  sizeof (char *) * (ctx.ret.devices.devices_len + 1));
  ctx.ret.devices.devices_val[ctx.ret.devices.devices_len] = NULL;
  return ctx.ret.devices.devices_val;
}

struct list_partitions_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_partitions_ret ret;
};

static void list_partitions_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct list_partitions_ctx *ctx = (struct list_partitions_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_list_partitions");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_list_partitions");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_list_partitions");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_partitions_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_list_partitions");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_list_partitions (guestfs_h *g)
{
  struct list_partitions_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_list_partitions") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LIST_PARTITIONS, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, list_partitions_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_list_partitions");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LIST_PARTITIONS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.partitions.partitions_val =
    safe_realloc (g, ctx.ret.partitions.partitions_val,
                  sizeof (char *) * (ctx.ret.partitions.partitions_len + 1));
  ctx.ret.partitions.partitions_val[ctx.ret.partitions.partitions_len] = NULL;
  return ctx.ret.partitions.partitions_val;
}

struct pvs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_ret ret;
};

static void pvs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvs_ctx *ctx = (struct pvs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_pvs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_pvs (guestfs_h *g)
{
  struct pvs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_PVS, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvs");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.physvols.physvols_val =
    safe_realloc (g, ctx.ret.physvols.physvols_val,
                  sizeof (char *) * (ctx.ret.physvols.physvols_len + 1));
  ctx.ret.physvols.physvols_val[ctx.ret.physvols.physvols_len] = NULL;
  return ctx.ret.physvols.physvols_val;
}

struct vgs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_ret ret;
};

static void vgs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgs_ctx *ctx = (struct vgs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_vgs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_vgs (guestfs_h *g)
{
  struct vgs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_VGS, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgs");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.volgroups.volgroups_val =
    safe_realloc (g, ctx.ret.volgroups.volgroups_val,
                  sizeof (char *) * (ctx.ret.volgroups.volgroups_len + 1));
  ctx.ret.volgroups.volgroups_val[ctx.ret.volgroups.volgroups_len] = NULL;
  return ctx.ret.volgroups.volgroups_val;
}

struct lvs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_ret ret;
};

static void lvs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvs_ctx *ctx = (struct lvs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_lvs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_lvs (guestfs_h *g)
{
  struct lvs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LVS, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvs");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.logvols.logvols_val =
    safe_realloc (g, ctx.ret.logvols.logvols_val,
                  sizeof (char *) * (ctx.ret.logvols.logvols_len + 1));
  ctx.ret.logvols.logvols_val[ctx.ret.logvols.logvols_len] = NULL;
  return ctx.ret.logvols.logvols_val;
}

struct pvs_full_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_full_ret ret;
};

static void pvs_full_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvs_full_ctx *ctx = (struct pvs_full_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvs_full");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvs_full");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvs_full");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_full_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_pvs_full");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *g)
{
  struct pvs_full_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvs_full") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_PVS_FULL, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvs_full_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvs_full");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVS_FULL, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.physvols, sizeof (ctx.ret.physvols));
}

struct vgs_full_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_full_ret ret;
};

static void vgs_full_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgs_full_ctx *ctx = (struct vgs_full_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgs_full");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgs_full");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgs_full");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_full_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_vgs_full");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *g)
{
  struct vgs_full_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgs_full") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_VGS_FULL, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgs_full_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgs_full");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGS_FULL, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.volgroups, sizeof (ctx.ret.volgroups));
}

struct lvs_full_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_full_ret ret;
};

static void lvs_full_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvs_full_ctx *ctx = (struct lvs_full_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvs_full");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvs_full");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvs_full");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_full_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_lvs_full");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *g)
{
  struct lvs_full_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvs_full") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LVS_FULL, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvs_full_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvs_full");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVS_FULL, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.logvols, sizeof (ctx.ret.logvols));
}

struct read_lines_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_read_lines_ret ret;
};

static void read_lines_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct read_lines_ctx *ctx = (struct read_lines_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_read_lines");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_read_lines");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_read_lines");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_read_lines_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_read_lines");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_read_lines (guestfs_h *g,
		const char *path)
{
  struct guestfs_read_lines_args args;
  struct read_lines_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_read_lines") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_READ_LINES,
        (xdrproc_t) xdr_guestfs_read_lines_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, read_lines_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_read_lines");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_READ_LINES, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct aug_init_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_init_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_init_ctx *ctx = (struct aug_init_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_init");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_init");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_init");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_init (guestfs_h *g,
		const char *root,
		int flags)
{
  struct guestfs_aug_init_args args;
  struct aug_init_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_init") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.root = (char *) root;
  args.flags = flags;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_INIT,
        (xdrproc_t) xdr_guestfs_aug_init_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_init_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_init");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_INIT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_close_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_close_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_close_ctx *ctx = (struct aug_close_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_close");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_close");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_close");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_close (guestfs_h *g)
{
  struct aug_close_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_close") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_CLOSE, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_close_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_close");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_CLOSE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_defvar_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defvar_ret ret;
};

static void aug_defvar_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_defvar_ctx *ctx = (struct aug_defvar_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_defvar");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_defvar");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_defvar");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defvar_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_defvar");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_defvar (guestfs_h *g,
		const char *name,
		const char *expr)
{
  struct guestfs_aug_defvar_args args;
  struct aug_defvar_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_defvar") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.name = (char *) name;
  args.expr = expr ? (char **) &expr : NULL;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_DEFVAR,
        (xdrproc_t) xdr_guestfs_aug_defvar_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_defvar_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_defvar");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_DEFVAR, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.nrnodes;
}

struct aug_defnode_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defnode_ret ret;
};

static void aug_defnode_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_defnode_ctx *ctx = (struct aug_defnode_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_defnode");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_defnode");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_defnode");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defnode_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_defnode");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *g,
		const char *name,
		const char *expr,
		const char *val)
{
  struct guestfs_aug_defnode_args args;
  struct aug_defnode_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_defnode") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.name = (char *) name;
  args.expr = (char *) expr;
  args.val = (char *) val;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_DEFNODE,
        (xdrproc_t) xdr_guestfs_aug_defnode_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_defnode_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_defnode");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_DEFNODE, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.nrnodescreated, sizeof (ctx.ret.nrnodescreated));
}

struct aug_get_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_get_ret ret;
};

static void aug_get_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_get_ctx *ctx = (struct aug_get_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_get");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_get");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_get");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_get_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_get");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_aug_get (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_get_args args;
  struct aug_get_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_get") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_GET,
        (xdrproc_t) xdr_guestfs_aug_get_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_get_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_get");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_GET, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.val; /* caller will free */
}

struct aug_set_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_set_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_set_ctx *ctx = (struct aug_set_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_set");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_set");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_set");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_set (guestfs_h *g,
		const char *path,
		const char *val)
{
  struct guestfs_aug_set_args args;
  struct aug_set_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_set") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  args.val = (char *) val;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_SET,
        (xdrproc_t) xdr_guestfs_aug_set_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_set_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_set");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_SET, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_insert_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_insert_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_insert_ctx *ctx = (struct aug_insert_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_insert");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_insert");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_insert");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_insert (guestfs_h *g,
		const char *path,
		const char *label,
		int before)
{
  struct guestfs_aug_insert_args args;
  struct aug_insert_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_insert") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  args.label = (char *) label;
  args.before = before;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_INSERT,
        (xdrproc_t) xdr_guestfs_aug_insert_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_insert_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_insert");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_INSERT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_rm_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_rm_ret ret;
};

static void aug_rm_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_rm_ctx *ctx = (struct aug_rm_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_rm");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_rm");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_rm");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_rm_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_rm");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_rm_args args;
  struct aug_rm_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_rm") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_RM,
        (xdrproc_t) xdr_guestfs_aug_rm_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_rm_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_rm");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_RM, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.nrnodes;
}

struct aug_mv_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_mv_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_mv_ctx *ctx = (struct aug_mv_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_mv");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_mv");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_mv");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_mv (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_aug_mv_args args;
  struct aug_mv_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_mv") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_MV,
        (xdrproc_t) xdr_guestfs_aug_mv_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_mv_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_mv");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_MV, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_match_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_match_ret ret;
};

static void aug_match_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_match_ctx *ctx = (struct aug_match_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_match");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_match");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_match");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_match_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_match");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_aug_match (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_match_args args;
  struct aug_match_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_match") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_MATCH,
        (xdrproc_t) xdr_guestfs_aug_match_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_match_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_match");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_MATCH, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.matches.matches_val =
    safe_realloc (g, ctx.ret.matches.matches_val,
                  sizeof (char *) * (ctx.ret.matches.matches_len + 1));
  ctx.ret.matches.matches_val[ctx.ret.matches.matches_len] = NULL;
  return ctx.ret.matches.matches_val;
}

struct aug_save_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_save_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_save_ctx *ctx = (struct aug_save_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_save");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_save");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_save");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_save (guestfs_h *g)
{
  struct aug_save_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_save") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_SAVE, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_save_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_save");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_SAVE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_load_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_load_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_load_ctx *ctx = (struct aug_load_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_load");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_load");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_load");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_aug_load (guestfs_h *g)
{
  struct aug_load_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_load") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_LOAD, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_load_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_load");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_LOAD, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct aug_ls_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_ls_ret ret;
};

static void aug_ls_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_ls_ctx *ctx = (struct aug_ls_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_aug_ls");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_aug_ls");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_aug_ls");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_ls_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_aug_ls");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_aug_ls (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_ls_args args;
  struct aug_ls_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_ls") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_AUG_LS,
        (xdrproc_t) xdr_guestfs_aug_ls_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, aug_ls_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_aug_ls");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_AUG_LS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.matches.matches_val =
    safe_realloc (g, ctx.ret.matches.matches_val,
                  sizeof (char *) * (ctx.ret.matches.matches_len + 1));
  ctx.ret.matches.matches_val[ctx.ret.matches.matches_len] = NULL;
  return ctx.ret.matches.matches_val;
}

struct rm_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rm_ctx *ctx = (struct rm_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_rm");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_rm");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_rm");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_args args;
  struct rm_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rm") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RM,
        (xdrproc_t) xdr_guestfs_rm_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, rm_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_rm");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RM, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct rmdir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rmdir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rmdir_ctx *ctx = (struct rmdir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_rmdir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_rmdir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_rmdir");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_rmdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_rmdir_args args;
  struct rmdir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rmdir") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RMDIR,
        (xdrproc_t) xdr_guestfs_rmdir_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, rmdir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_rmdir");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RMDIR, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct rm_rf_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_rf_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rm_rf_ctx *ctx = (struct rm_rf_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_rm_rf");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_rm_rf");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_rm_rf");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_rm_rf (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_rf_args args;
  struct rm_rf_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rm_rf") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RM_RF,
        (xdrproc_t) xdr_guestfs_rm_rf_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, rm_rf_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_rm_rf");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RM_RF, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkdir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdir_ctx *ctx = (struct mkdir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkdir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkdir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkdir");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_args args;
  struct mkdir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdir") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKDIR,
        (xdrproc_t) xdr_guestfs_mkdir_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkdir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkdir");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKDIR, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkdir_p_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_p_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdir_p_ctx *ctx = (struct mkdir_p_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkdir_p");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkdir_p");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkdir_p");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkdir_p (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_p_args args;
  struct mkdir_p_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdir_p") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKDIR_P,
        (xdrproc_t) xdr_guestfs_mkdir_p_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkdir_p_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkdir_p");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKDIR_P, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct chmod_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chmod_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct chmod_ctx *ctx = (struct chmod_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_chmod");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_chmod");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_chmod");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_chmod (guestfs_h *g,
		int mode,
		const char *path)
{
  struct guestfs_chmod_args args;
  struct chmod_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_chmod") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mode = mode;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CHMOD,
        (xdrproc_t) xdr_guestfs_chmod_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, chmod_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_chmod");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CHMOD, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct chown_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chown_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct chown_ctx *ctx = (struct chown_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_chown");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_chown");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_chown");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_chown (guestfs_h *g,
		int owner,
		int group,
		const char *path)
{
  struct guestfs_chown_args args;
  struct chown_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_chown") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.owner = owner;
  args.group = group;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CHOWN,
        (xdrproc_t) xdr_guestfs_chown_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, chown_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_chown");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CHOWN, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct exists_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_exists_ret ret;
};

static void exists_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct exists_ctx *ctx = (struct exists_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_exists");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_exists");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_exists");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_exists_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_exists");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_exists (guestfs_h *g,
		const char *path)
{
  struct guestfs_exists_args args;
  struct exists_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_exists") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_EXISTS,
        (xdrproc_t) xdr_guestfs_exists_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, exists_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_exists");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_EXISTS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.existsflag;
}

struct is_file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_file_ret ret;
};

static void is_file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct is_file_ctx *ctx = (struct is_file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_is_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_is_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_is_file");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_file_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_is_file");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_is_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_file_args args;
  struct is_file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_is_file") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_IS_FILE,
        (xdrproc_t) xdr_guestfs_is_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, is_file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_is_file");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_IS_FILE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.fileflag;
}

struct is_dir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_dir_ret ret;
};

static void is_dir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct is_dir_ctx *ctx = (struct is_dir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_is_dir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_is_dir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_is_dir");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_dir_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_is_dir");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_is_dir (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_dir_args args;
  struct is_dir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_is_dir") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_IS_DIR,
        (xdrproc_t) xdr_guestfs_is_dir_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, is_dir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_is_dir");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_IS_DIR, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.dirflag;
}

struct pvcreate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvcreate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvcreate_ctx *ctx = (struct pvcreate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvcreate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvcreate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvcreate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_pvcreate (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvcreate_args args;
  struct pvcreate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvcreate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_PVCREATE,
        (xdrproc_t) xdr_guestfs_pvcreate_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvcreate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvcreate");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVCREATE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct vgcreate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vgcreate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgcreate_ctx *ctx = (struct vgcreate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgcreate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgcreate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgcreate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_vgcreate (guestfs_h *g,
		const char *volgroup,
		char * const* const physvols)
{
  struct guestfs_vgcreate_args args;
  struct vgcreate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgcreate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.volgroup = (char *) volgroup;
  args.physvols.physvols_val = (char **) physvols;
  for (args.physvols.physvols_len = 0; physvols[args.physvols.physvols_len]; args.physvols.physvols_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_VGCREATE,
        (xdrproc_t) xdr_guestfs_vgcreate_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgcreate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgcreate");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGCREATE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct lvcreate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvcreate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvcreate_ctx *ctx = (struct lvcreate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvcreate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvcreate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvcreate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvcreate (guestfs_h *g,
		const char *logvol,
		const char *volgroup,
		int mbytes)
{
  struct guestfs_lvcreate_args args;
  struct lvcreate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvcreate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.logvol = (char *) logvol;
  args.volgroup = (char *) volgroup;
  args.mbytes = mbytes;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LVCREATE,
        (xdrproc_t) xdr_guestfs_lvcreate_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvcreate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvcreate");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVCREATE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkfs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkfs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkfs_ctx *ctx = (struct mkfs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkfs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkfs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkfs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkfs (guestfs_h *g,
		const char *fstype,
		const char *device)
{
  struct guestfs_mkfs_args args;
  struct mkfs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkfs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.fstype = (char *) fstype;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKFS,
        (xdrproc_t) xdr_guestfs_mkfs_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkfs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkfs");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKFS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct sfdisk_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sfdisk_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_ctx *ctx = (struct sfdisk_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdisk");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdisk");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdisk");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sfdisk (guestfs_h *g,
		const char *device,
		int cyls,
		int heads,
		int sectors,
		char * const* const lines)
{
  struct guestfs_sfdisk_args args;
  struct sfdisk_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.cyls = cyls;
  args.heads = heads;
  args.sectors = sectors;
  args.lines.lines_val = (char **) lines;
  for (args.lines.lines_len = 0; lines[args.lines.lines_len]; args.lines.lines_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISK,
        (xdrproc_t) xdr_guestfs_sfdisk_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdisk_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdisk");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISK, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct write_file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void write_file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct write_file_ctx *ctx = (struct write_file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_write_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_write_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_write_file");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_write_file (guestfs_h *g,
		const char *path,
		const char *content,
		int size)
{
  struct guestfs_write_file_args args;
  struct write_file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_write_file") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  args.content = (char *) content;
  args.size = size;
  serial = guestfs__send_sync (g, GUESTFS_PROC_WRITE_FILE,
        (xdrproc_t) xdr_guestfs_write_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, write_file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_write_file");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_WRITE_FILE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct umount_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umount_ctx *ctx = (struct umount_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_umount");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_umount");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_umount");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_umount (guestfs_h *g,
		const char *pathordevice)
{
  struct guestfs_umount_args args;
  struct umount_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umount") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.pathordevice = (char *) pathordevice;
  serial = guestfs__send_sync (g, GUESTFS_PROC_UMOUNT,
        (xdrproc_t) xdr_guestfs_umount_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, umount_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_umount");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UMOUNT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mounts_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_mounts_ret ret;
};

static void mounts_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mounts_ctx *ctx = (struct mounts_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mounts");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mounts");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mounts");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_mounts_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_mounts");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_mounts (guestfs_h *g)
{
  struct mounts_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mounts") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNTS, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mounts_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mounts");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNTS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.devices.devices_val =
    safe_realloc (g, ctx.ret.devices.devices_val,
                  sizeof (char *) * (ctx.ret.devices.devices_len + 1));
  ctx.ret.devices.devices_val[ctx.ret.devices.devices_len] = NULL;
  return ctx.ret.devices.devices_val;
}

struct umount_all_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_all_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umount_all_ctx *ctx = (struct umount_all_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_umount_all");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_umount_all");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_umount_all");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_umount_all (guestfs_h *g)
{
  struct umount_all_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umount_all") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_UMOUNT_ALL, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, umount_all_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_umount_all");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UMOUNT_ALL, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct lvm_remove_all_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvm_remove_all_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvm_remove_all_ctx *ctx = (struct lvm_remove_all_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvm_remove_all");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvm_remove_all");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvm_remove_all");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvm_remove_all (guestfs_h *g)
{
  struct lvm_remove_all_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvm_remove_all") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_LVM_REMOVE_ALL, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvm_remove_all_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvm_remove_all");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVM_REMOVE_ALL, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_file_ret ret;
};

static void file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct file_ctx *ctx = (struct file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_file");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_file_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_file");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_file_args args;
  struct file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_file") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_FILE,
        (xdrproc_t) xdr_guestfs_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_file");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_FILE, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.description; /* caller will free */
}

struct command_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_ret ret;
};

static void command_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct command_ctx *ctx = (struct command_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_command");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_command");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_command");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_command");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_command (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_args args;
  struct command_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_command") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_COMMAND,
        (xdrproc_t) xdr_guestfs_command_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, command_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_command");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_COMMAND, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.output; /* caller will free */
}

struct command_lines_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_lines_ret ret;
};

static void command_lines_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct command_lines_ctx *ctx = (struct command_lines_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_command_lines");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_command_lines");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_command_lines");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_lines_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_command_lines");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_command_lines (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_lines_args args;
  struct command_lines_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_command_lines") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_COMMAND_LINES,
        (xdrproc_t) xdr_guestfs_command_lines_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, command_lines_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_command_lines");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_COMMAND_LINES, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct stat_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_stat_ret ret;
};

static void stat_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct stat_ctx *ctx = (struct stat_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_stat");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_stat");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_stat");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_stat_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_stat");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_stat *guestfs_stat (guestfs_h *g,
		const char *path)
{
  struct guestfs_stat_args args;
  struct stat_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_stat") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_STAT,
        (xdrproc_t) xdr_guestfs_stat_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, stat_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_stat");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_STAT, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.statbuf, sizeof (ctx.ret.statbuf));
}

struct lstat_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lstat_ret ret;
};

static void lstat_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lstat_ctx *ctx = (struct lstat_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lstat");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lstat");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lstat");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lstat_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_lstat");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_stat *guestfs_lstat (guestfs_h *g,
		const char *path)
{
  struct guestfs_lstat_args args;
  struct lstat_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lstat") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LSTAT,
        (xdrproc_t) xdr_guestfs_lstat_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lstat_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lstat");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LSTAT, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.statbuf, sizeof (ctx.ret.statbuf));
}

struct statvfs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_statvfs_ret ret;
};

static void statvfs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct statvfs_ctx *ctx = (struct statvfs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_statvfs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_statvfs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_statvfs");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_statvfs_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_statvfs");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_statvfs *guestfs_statvfs (guestfs_h *g,
		const char *path)
{
  struct guestfs_statvfs_args args;
  struct statvfs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_statvfs") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_STATVFS,
        (xdrproc_t) xdr_guestfs_statvfs_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, statvfs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_statvfs");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_STATVFS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.statbuf, sizeof (ctx.ret.statbuf));
}

struct tune2fs_l_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_tune2fs_l_ret ret;
};

static void tune2fs_l_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tune2fs_l_ctx *ctx = (struct tune2fs_l_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tune2fs_l");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tune2fs_l");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tune2fs_l");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_tune2fs_l_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_tune2fs_l");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_tune2fs_l (guestfs_h *g,
		const char *device)
{
  struct guestfs_tune2fs_l_args args;
  struct tune2fs_l_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tune2fs_l") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TUNE2FS_L,
        (xdrproc_t) xdr_guestfs_tune2fs_l_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tune2fs_l_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tune2fs_l");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TUNE2FS_L, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.superblock.superblock_val =
    safe_realloc (g, ctx.ret.superblock.superblock_val,
                  sizeof (char *) * (ctx.ret.superblock.superblock_len + 1));
  ctx.ret.superblock.superblock_val[ctx.ret.superblock.superblock_len] = NULL;
  return ctx.ret.superblock.superblock_val;
}

struct blockdev_setro_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setro_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setro_ctx *ctx = (struct blockdev_setro_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_setro");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_setro");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_setro");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_setro (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_setro_args args;
  struct blockdev_setro_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setro") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_SETRO,
        (xdrproc_t) xdr_guestfs_blockdev_setro_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_setro_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_setro");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_SETRO, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct blockdev_setrw_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setrw_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setrw_ctx *ctx = (struct blockdev_setrw_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_setrw");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_setrw");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_setrw");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_setrw (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_setrw_args args;
  struct blockdev_setrw_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setrw") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_SETRW,
        (xdrproc_t) xdr_guestfs_blockdev_setrw_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_setrw_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_setrw");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_SETRW, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct blockdev_getro_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getro_ret ret;
};

static void blockdev_getro_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getro_ctx *ctx = (struct blockdev_getro_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getro");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getro");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getro");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getro_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getro");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_getro (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getro_args args;
  struct blockdev_getro_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getro") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETRO,
        (xdrproc_t) xdr_guestfs_blockdev_getro_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getro_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getro");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETRO, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.ro;
}

struct blockdev_getss_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getss_ret ret;
};

static void blockdev_getss_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getss_ctx *ctx = (struct blockdev_getss_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getss");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getss");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getss");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getss_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getss");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_getss (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getss_args args;
  struct blockdev_getss_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getss") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETSS,
        (xdrproc_t) xdr_guestfs_blockdev_getss_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getss_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getss");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETSS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.sectorsize;
}

struct blockdev_getbsz_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getbsz_ret ret;
};

static void blockdev_getbsz_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getbsz_ctx *ctx = (struct blockdev_getbsz_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getbsz");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getbsz");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getbsz");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getbsz_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getbsz");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_getbsz (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getbsz_args args;
  struct blockdev_getbsz_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getbsz") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETBSZ,
        (xdrproc_t) xdr_guestfs_blockdev_getbsz_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getbsz_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getbsz");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETBSZ, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.blocksize;
}

struct blockdev_setbsz_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setbsz_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setbsz_ctx *ctx = (struct blockdev_setbsz_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_setbsz");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_setbsz");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_setbsz");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_setbsz (guestfs_h *g,
		const char *device,
		int blocksize)
{
  struct guestfs_blockdev_setbsz_args args;
  struct blockdev_setbsz_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setbsz") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.blocksize = blocksize;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_SETBSZ,
        (xdrproc_t) xdr_guestfs_blockdev_setbsz_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_setbsz_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_setbsz");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_SETBSZ, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct blockdev_getsz_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getsz_ret ret;
};

static void blockdev_getsz_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getsz_ctx *ctx = (struct blockdev_getsz_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getsz");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getsz");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getsz");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getsz_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getsz");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int64_t guestfs_blockdev_getsz (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getsz_args args;
  struct blockdev_getsz_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getsz") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETSZ,
        (xdrproc_t) xdr_guestfs_blockdev_getsz_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getsz_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getsz");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETSZ, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.sizeinsectors;
}

struct blockdev_getsize64_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getsize64_ret ret;
};

static void blockdev_getsize64_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getsize64_ctx *ctx = (struct blockdev_getsize64_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_getsize64");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_getsize64");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_getsize64");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getsize64_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_blockdev_getsize64");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int64_t guestfs_blockdev_getsize64 (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getsize64_args args;
  struct blockdev_getsize64_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getsize64") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_GETSIZE64,
        (xdrproc_t) xdr_guestfs_blockdev_getsize64_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_getsize64_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_getsize64");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_GETSIZE64, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.sizeinbytes;
}

struct blockdev_flushbufs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_flushbufs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_flushbufs_ctx *ctx = (struct blockdev_flushbufs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_flushbufs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_flushbufs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_flushbufs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_flushbufs (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_flushbufs_args args;
  struct blockdev_flushbufs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_flushbufs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_FLUSHBUFS,
        (xdrproc_t) xdr_guestfs_blockdev_flushbufs_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_flushbufs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_flushbufs");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_FLUSHBUFS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct blockdev_rereadpt_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_rereadpt_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_rereadpt_ctx *ctx = (struct blockdev_rereadpt_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_blockdev_rereadpt");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_blockdev_rereadpt");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_blockdev_rereadpt");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_blockdev_rereadpt (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_rereadpt_args args;
  struct blockdev_rereadpt_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_rereadpt") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_BLOCKDEV_REREADPT,
        (xdrproc_t) xdr_guestfs_blockdev_rereadpt_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, blockdev_rereadpt_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_blockdev_rereadpt");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_BLOCKDEV_REREADPT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct upload_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void upload_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct upload_ctx *ctx = (struct upload_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_upload");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_upload");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_upload");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_upload (guestfs_h *g,
		const char *filename,
		const char *remotefilename)
{
  struct guestfs_upload_args args;
  struct upload_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_upload") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.remotefilename = (char *) remotefilename;
  serial = guestfs__send_sync (g, GUESTFS_PROC_UPLOAD,
        (xdrproc_t) xdr_guestfs_upload_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  {
    int r;

    r = guestfs__send_file_sync (g, filename);
    if (r == -1) {
      guestfs_end_busy (g);
      return -1;
    }
    if (r == -2) /* daemon cancelled */
      goto read_reply;
  }

 read_reply:
  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, upload_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_upload");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UPLOAD, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct download_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void download_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct download_ctx *ctx = (struct download_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_download");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_download");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_download");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_download (guestfs_h *g,
		const char *remotefilename,
		const char *filename)
{
  struct guestfs_download_args args;
  struct download_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_download") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.remotefilename = (char *) remotefilename;
  serial = guestfs__send_sync (g, GUESTFS_PROC_DOWNLOAD,
        (xdrproc_t) xdr_guestfs_download_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, download_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_download");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DOWNLOAD, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  if (guestfs__receive_file_sync (g, filename) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct checksum_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_checksum_ret ret;
};

static void checksum_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct checksum_ctx *ctx = (struct checksum_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_checksum");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_checksum");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_checksum");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_checksum_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_checksum");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_checksum (guestfs_h *g,
		const char *csumtype,
		const char *path)
{
  struct guestfs_checksum_args args;
  struct checksum_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_checksum") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.csumtype = (char *) csumtype;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CHECKSUM,
        (xdrproc_t) xdr_guestfs_checksum_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, checksum_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_checksum");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CHECKSUM, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.checksum; /* caller will free */
}

struct tar_in_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tar_in_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tar_in_ctx *ctx = (struct tar_in_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tar_in");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tar_in");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tar_in");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tar_in (guestfs_h *g,
		const char *tarfile,
		const char *directory)
{
  struct guestfs_tar_in_args args;
  struct tar_in_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tar_in") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TAR_IN,
        (xdrproc_t) xdr_guestfs_tar_in_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  {
    int r;

    r = guestfs__send_file_sync (g, tarfile);
    if (r == -1) {
      guestfs_end_busy (g);
      return -1;
    }
    if (r == -2) /* daemon cancelled */
      goto read_reply;
  }

 read_reply:
  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tar_in_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tar_in");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TAR_IN, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct tar_out_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tar_out_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tar_out_ctx *ctx = (struct tar_out_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tar_out");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tar_out");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tar_out");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tar_out (guestfs_h *g,
		const char *directory,
		const char *tarfile)
{
  struct guestfs_tar_out_args args;
  struct tar_out_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tar_out") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TAR_OUT,
        (xdrproc_t) xdr_guestfs_tar_out_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tar_out_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tar_out");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TAR_OUT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  if (guestfs__receive_file_sync (g, tarfile) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct tgz_in_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tgz_in_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tgz_in_ctx *ctx = (struct tgz_in_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tgz_in");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tgz_in");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tgz_in");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tgz_in (guestfs_h *g,
		const char *tarball,
		const char *directory)
{
  struct guestfs_tgz_in_args args;
  struct tgz_in_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tgz_in") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TGZ_IN,
        (xdrproc_t) xdr_guestfs_tgz_in_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  {
    int r;

    r = guestfs__send_file_sync (g, tarball);
    if (r == -1) {
      guestfs_end_busy (g);
      return -1;
    }
    if (r == -2) /* daemon cancelled */
      goto read_reply;
  }

 read_reply:
  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tgz_in_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tgz_in");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TGZ_IN, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct tgz_out_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void tgz_out_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tgz_out_ctx *ctx = (struct tgz_out_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tgz_out");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tgz_out");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tgz_out");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_tgz_out (guestfs_h *g,
		const char *directory,
		const char *tarball)
{
  struct guestfs_tgz_out_args args;
  struct tgz_out_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tgz_out") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TGZ_OUT,
        (xdrproc_t) xdr_guestfs_tgz_out_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tgz_out_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tgz_out");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TGZ_OUT, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  if (guestfs__receive_file_sync (g, tarball) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mount_ro_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_ro_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_ro_ctx *ctx = (struct mount_ro_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_ro");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_ro");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_ro");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_ro (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_ro_args args;
  struct mount_ro_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_ro") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_RO,
        (xdrproc_t) xdr_guestfs_mount_ro_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_ro_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_ro");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_RO, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mount_options_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_options_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_options_ctx *ctx = (struct mount_options_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_options");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_options");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_options");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_options (guestfs_h *g,
		const char *options,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_options_args args;
  struct mount_options_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_options") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.options = (char *) options;
  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_OPTIONS,
        (xdrproc_t) xdr_guestfs_mount_options_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_options_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_options");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_OPTIONS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mount_vfs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_vfs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_vfs_ctx *ctx = (struct mount_vfs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_vfs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_vfs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_vfs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_vfs (guestfs_h *g,
		const char *options,
		const char *vfstype,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_vfs_args args;
  struct mount_vfs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_vfs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.options = (char *) options;
  args.vfstype = (char *) vfstype;
  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_VFS,
        (xdrproc_t) xdr_guestfs_mount_vfs_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_vfs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_vfs");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_VFS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct debug_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_debug_ret ret;
};

static void debug_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct debug_ctx *ctx = (struct debug_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_debug");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_debug");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_debug");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_debug_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_debug");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_debug (guestfs_h *g,
		const char *subcmd,
		char * const* const extraargs)
{
  struct guestfs_debug_args args;
  struct debug_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_debug") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.subcmd = (char *) subcmd;
  args.extraargs.extraargs_val = (char **) extraargs;
  for (args.extraargs.extraargs_len = 0; extraargs[args.extraargs.extraargs_len]; args.extraargs.extraargs_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_DEBUG,
        (xdrproc_t) xdr_guestfs_debug_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, debug_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_debug");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DEBUG, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.result; /* caller will free */
}

struct lvremove_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvremove_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvremove_ctx *ctx = (struct lvremove_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvremove");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvremove");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvremove");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvremove (guestfs_h *g,
		const char *device)
{
  struct guestfs_lvremove_args args;
  struct lvremove_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvremove") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LVREMOVE,
        (xdrproc_t) xdr_guestfs_lvremove_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvremove_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvremove");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVREMOVE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct vgremove_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vgremove_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgremove_ctx *ctx = (struct vgremove_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vgremove");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vgremove");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vgremove");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_vgremove (guestfs_h *g,
		const char *vgname)
{
  struct guestfs_vgremove_args args;
  struct vgremove_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgremove") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.vgname = (char *) vgname;
  serial = guestfs__send_sync (g, GUESTFS_PROC_VGREMOVE,
        (xdrproc_t) xdr_guestfs_vgremove_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vgremove_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vgremove");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VGREMOVE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct pvremove_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvremove_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvremove_ctx *ctx = (struct pvremove_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvremove");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvremove");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvremove");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_pvremove (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvremove_args args;
  struct pvremove_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvremove") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_PVREMOVE,
        (xdrproc_t) xdr_guestfs_pvremove_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvremove_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvremove");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVREMOVE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct set_e2label_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void set_e2label_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct set_e2label_ctx *ctx = (struct set_e2label_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_set_e2label");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_set_e2label");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_set_e2label");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_set_e2label (guestfs_h *g,
		const char *device,
		const char *label)
{
  struct guestfs_set_e2label_args args;
  struct set_e2label_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_set_e2label") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.label = (char *) label;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SET_E2LABEL,
        (xdrproc_t) xdr_guestfs_set_e2label_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, set_e2label_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_set_e2label");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SET_E2LABEL, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct get_e2label_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_get_e2label_ret ret;
};

static void get_e2label_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct get_e2label_ctx *ctx = (struct get_e2label_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_get_e2label");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_get_e2label");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_get_e2label");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_get_e2label_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_get_e2label");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_get_e2label (guestfs_h *g,
		const char *device)
{
  struct guestfs_get_e2label_args args;
  struct get_e2label_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_get_e2label") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GET_E2LABEL,
        (xdrproc_t) xdr_guestfs_get_e2label_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, get_e2label_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_get_e2label");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GET_E2LABEL, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.label; /* caller will free */
}

struct set_e2uuid_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void set_e2uuid_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct set_e2uuid_ctx *ctx = (struct set_e2uuid_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_set_e2uuid");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_set_e2uuid");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_set_e2uuid");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_set_e2uuid (guestfs_h *g,
		const char *device,
		const char *uuid)
{
  struct guestfs_set_e2uuid_args args;
  struct set_e2uuid_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_set_e2uuid") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.uuid = (char *) uuid;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SET_E2UUID,
        (xdrproc_t) xdr_guestfs_set_e2uuid_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, set_e2uuid_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_set_e2uuid");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SET_E2UUID, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct get_e2uuid_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_get_e2uuid_ret ret;
};

static void get_e2uuid_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct get_e2uuid_ctx *ctx = (struct get_e2uuid_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_get_e2uuid");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_get_e2uuid");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_get_e2uuid");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_get_e2uuid_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_get_e2uuid");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_get_e2uuid (guestfs_h *g,
		const char *device)
{
  struct guestfs_get_e2uuid_args args;
  struct get_e2uuid_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_get_e2uuid") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GET_E2UUID,
        (xdrproc_t) xdr_guestfs_get_e2uuid_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, get_e2uuid_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_get_e2uuid");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GET_E2UUID, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.uuid; /* caller will free */
}

struct fsck_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_fsck_ret ret;
};

static void fsck_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct fsck_ctx *ctx = (struct fsck_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_fsck");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_fsck");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_fsck");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_fsck_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_fsck");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_fsck (guestfs_h *g,
		const char *fstype,
		const char *device)
{
  struct guestfs_fsck_args args;
  struct fsck_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_fsck") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.fstype = (char *) fstype;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_FSCK,
        (xdrproc_t) xdr_guestfs_fsck_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, fsck_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_fsck");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_FSCK, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.status;
}

struct zero_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void zero_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct zero_ctx *ctx = (struct zero_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_zero");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_zero");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_zero");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_zero (guestfs_h *g,
		const char *device)
{
  struct guestfs_zero_args args;
  struct zero_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_zero") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_ZERO,
        (xdrproc_t) xdr_guestfs_zero_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, zero_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_zero");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_ZERO, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct grub_install_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void grub_install_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct grub_install_ctx *ctx = (struct grub_install_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_grub_install");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_grub_install");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_grub_install");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_grub_install (guestfs_h *g,
		const char *root,
		const char *device)
{
  struct guestfs_grub_install_args args;
  struct grub_install_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_grub_install") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.root = (char *) root;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GRUB_INSTALL,
        (xdrproc_t) xdr_guestfs_grub_install_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, grub_install_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_grub_install");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GRUB_INSTALL, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct cp_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void cp_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct cp_ctx *ctx = (struct cp_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_cp");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_cp");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_cp");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_cp (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_cp_args args;
  struct cp_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_cp") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CP,
        (xdrproc_t) xdr_guestfs_cp_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, cp_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_cp");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CP, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct cp_a_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void cp_a_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct cp_a_ctx *ctx = (struct cp_a_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_cp_a");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_cp_a");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_cp_a");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_cp_a (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_cp_a_args args;
  struct cp_a_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_cp_a") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = guestfs__send_sync (g, GUESTFS_PROC_CP_A,
        (xdrproc_t) xdr_guestfs_cp_a_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, cp_a_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_cp_a");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_CP_A, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mv_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mv_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mv_ctx *ctx = (struct mv_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mv");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mv");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mv");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mv (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_mv_args args;
  struct mv_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mv") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MV,
        (xdrproc_t) xdr_guestfs_mv_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mv_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mv");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MV, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct drop_caches_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void drop_caches_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct drop_caches_ctx *ctx = (struct drop_caches_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_drop_caches");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_drop_caches");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_drop_caches");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_drop_caches (guestfs_h *g,
		int whattodrop)
{
  struct guestfs_drop_caches_args args;
  struct drop_caches_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_drop_caches") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.whattodrop = whattodrop;
  serial = guestfs__send_sync (g, GUESTFS_PROC_DROP_CACHES,
        (xdrproc_t) xdr_guestfs_drop_caches_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, drop_caches_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_drop_caches");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DROP_CACHES, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct dmesg_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_dmesg_ret ret;
};

static void dmesg_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct dmesg_ctx *ctx = (struct dmesg_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_dmesg");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_dmesg");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_dmesg");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_dmesg_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_dmesg");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_dmesg (guestfs_h *g)
{
  struct dmesg_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_dmesg") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_DMESG, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, dmesg_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_dmesg");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DMESG, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.kmsgs; /* caller will free */
}

struct ping_daemon_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void ping_daemon_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ping_daemon_ctx *ctx = (struct ping_daemon_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_ping_daemon");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_ping_daemon");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_ping_daemon");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_ping_daemon (guestfs_h *g)
{
  struct ping_daemon_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ping_daemon") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_PING_DAEMON, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, ping_daemon_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_ping_daemon");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PING_DAEMON, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct equal_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_equal_ret ret;
};

static void equal_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct equal_ctx *ctx = (struct equal_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_equal");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_equal");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_equal");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_equal_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_equal");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_equal (guestfs_h *g,
		const char *file1,
		const char *file2)
{
  struct guestfs_equal_args args;
  struct equal_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_equal") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.file1 = (char *) file1;
  args.file2 = (char *) file2;
  serial = guestfs__send_sync (g, GUESTFS_PROC_EQUAL,
        (xdrproc_t) xdr_guestfs_equal_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, equal_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_equal");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_EQUAL, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.equality;
}

struct strings_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_strings_ret ret;
};

static void strings_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct strings_ctx *ctx = (struct strings_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_strings");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_strings");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_strings");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_strings_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_strings");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_strings (guestfs_h *g,
		const char *path)
{
  struct guestfs_strings_args args;
  struct strings_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_strings") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_STRINGS,
        (xdrproc_t) xdr_guestfs_strings_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, strings_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_strings");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_STRINGS, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.stringsout.stringsout_val =
    safe_realloc (g, ctx.ret.stringsout.stringsout_val,
                  sizeof (char *) * (ctx.ret.stringsout.stringsout_len + 1));
  ctx.ret.stringsout.stringsout_val[ctx.ret.stringsout.stringsout_len] = NULL;
  return ctx.ret.stringsout.stringsout_val;
}

struct strings_e_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_strings_e_ret ret;
};

static void strings_e_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct strings_e_ctx *ctx = (struct strings_e_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_strings_e");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_strings_e");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_strings_e");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_strings_e_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_strings_e");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_strings_e (guestfs_h *g,
		const char *encoding,
		const char *path)
{
  struct guestfs_strings_e_args args;
  struct strings_e_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_strings_e") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.encoding = (char *) encoding;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_STRINGS_E,
        (xdrproc_t) xdr_guestfs_strings_e_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, strings_e_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_strings_e");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_STRINGS_E, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.stringsout.stringsout_val =
    safe_realloc (g, ctx.ret.stringsout.stringsout_val,
                  sizeof (char *) * (ctx.ret.stringsout.stringsout_len + 1));
  ctx.ret.stringsout.stringsout_val[ctx.ret.stringsout.stringsout_len] = NULL;
  return ctx.ret.stringsout.stringsout_val;
}

struct hexdump_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_hexdump_ret ret;
};

static void hexdump_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct hexdump_ctx *ctx = (struct hexdump_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_hexdump");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_hexdump");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_hexdump");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_hexdump_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_hexdump");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_hexdump (guestfs_h *g,
		const char *path)
{
  struct guestfs_hexdump_args args;
  struct hexdump_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_hexdump") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_HEXDUMP,
        (xdrproc_t) xdr_guestfs_hexdump_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, hexdump_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_hexdump");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_HEXDUMP, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.dump; /* caller will free */
}

struct zerofree_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void zerofree_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct zerofree_ctx *ctx = (struct zerofree_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_zerofree");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_zerofree");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_zerofree");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_zerofree (guestfs_h *g,
		const char *device)
{
  struct guestfs_zerofree_args args;
  struct zerofree_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_zerofree") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_ZEROFREE,
        (xdrproc_t) xdr_guestfs_zerofree_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, zerofree_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_zerofree");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_ZEROFREE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct pvresize_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvresize_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvresize_ctx *ctx = (struct pvresize_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_pvresize");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_pvresize");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_pvresize");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_pvresize (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvresize_args args;
  struct pvresize_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvresize") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_PVRESIZE,
        (xdrproc_t) xdr_guestfs_pvresize_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, pvresize_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_pvresize");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_PVRESIZE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct sfdisk_N_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sfdisk_N_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_N_ctx *ctx = (struct sfdisk_N_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdisk_N");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdisk_N");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdisk_N");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sfdisk_N (guestfs_h *g,
		const char *device,
		int partnum,
		int cyls,
		int heads,
		int sectors,
		const char *line)
{
  struct guestfs_sfdisk_N_args args;
  struct sfdisk_N_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk_N") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.partnum = partnum;
  args.cyls = cyls;
  args.heads = heads;
  args.sectors = sectors;
  args.line = (char *) line;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISK_N,
        (xdrproc_t) xdr_guestfs_sfdisk_N_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdisk_N_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdisk_N");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISK_N, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct sfdisk_l_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_sfdisk_l_ret ret;
};

static void sfdisk_l_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_l_ctx *ctx = (struct sfdisk_l_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdisk_l");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdisk_l");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdisk_l");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_sfdisk_l_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_sfdisk_l");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_sfdisk_l (guestfs_h *g,
		const char *device)
{
  struct guestfs_sfdisk_l_args args;
  struct sfdisk_l_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk_l") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISK_L,
        (xdrproc_t) xdr_guestfs_sfdisk_l_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdisk_l_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdisk_l");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISK_L, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.partitions; /* caller will free */
}

struct sfdisk_kernel_geometry_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_sfdisk_kernel_geometry_ret ret;
};

static void sfdisk_kernel_geometry_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_kernel_geometry_ctx *ctx = (struct sfdisk_kernel_geometry_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdisk_kernel_geometry");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdisk_kernel_geometry");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdisk_kernel_geometry");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_sfdisk_kernel_geometry_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_sfdisk_kernel_geometry");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_sfdisk_kernel_geometry (guestfs_h *g,
		const char *device)
{
  struct guestfs_sfdisk_kernel_geometry_args args;
  struct sfdisk_kernel_geometry_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk_kernel_geometry") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISK_KERNEL_GEOMETRY,
        (xdrproc_t) xdr_guestfs_sfdisk_kernel_geometry_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdisk_kernel_geometry_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdisk_kernel_geometry");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISK_KERNEL_GEOMETRY, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.partitions; /* caller will free */
}

struct sfdisk_disk_geometry_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_sfdisk_disk_geometry_ret ret;
};

static void sfdisk_disk_geometry_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_disk_geometry_ctx *ctx = (struct sfdisk_disk_geometry_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdisk_disk_geometry");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdisk_disk_geometry");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdisk_disk_geometry");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_sfdisk_disk_geometry_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_sfdisk_disk_geometry");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_sfdisk_disk_geometry (guestfs_h *g,
		const char *device)
{
  struct guestfs_sfdisk_disk_geometry_args args;
  struct sfdisk_disk_geometry_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk_disk_geometry") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISK_DISK_GEOMETRY,
        (xdrproc_t) xdr_guestfs_sfdisk_disk_geometry_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdisk_disk_geometry_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdisk_disk_geometry");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISK_DISK_GEOMETRY, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.partitions; /* caller will free */
}

struct vg_activate_all_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vg_activate_all_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vg_activate_all_ctx *ctx = (struct vg_activate_all_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vg_activate_all");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vg_activate_all");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vg_activate_all");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_vg_activate_all (guestfs_h *g,
		int activate)
{
  struct guestfs_vg_activate_all_args args;
  struct vg_activate_all_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vg_activate_all") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.activate = activate;
  serial = guestfs__send_sync (g, GUESTFS_PROC_VG_ACTIVATE_ALL,
        (xdrproc_t) xdr_guestfs_vg_activate_all_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vg_activate_all_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vg_activate_all");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VG_ACTIVATE_ALL, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct vg_activate_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vg_activate_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vg_activate_ctx *ctx = (struct vg_activate_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_vg_activate");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_vg_activate");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_vg_activate");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_vg_activate (guestfs_h *g,
		int activate,
		char * const* const volgroups)
{
  struct guestfs_vg_activate_args args;
  struct vg_activate_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vg_activate") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.activate = activate;
  args.volgroups.volgroups_val = (char **) volgroups;
  for (args.volgroups.volgroups_len = 0; volgroups[args.volgroups.volgroups_len]; args.volgroups.volgroups_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_VG_ACTIVATE,
        (xdrproc_t) xdr_guestfs_vg_activate_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, vg_activate_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_vg_activate");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_VG_ACTIVATE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct lvresize_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvresize_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvresize_ctx *ctx = (struct lvresize_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_lvresize");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_lvresize");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_lvresize");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_lvresize (guestfs_h *g,
		const char *device,
		int mbytes)
{
  struct guestfs_lvresize_args args;
  struct lvresize_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvresize") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.mbytes = mbytes;
  serial = guestfs__send_sync (g, GUESTFS_PROC_LVRESIZE,
        (xdrproc_t) xdr_guestfs_lvresize_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, lvresize_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_lvresize");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_LVRESIZE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct resize2fs_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void resize2fs_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct resize2fs_ctx *ctx = (struct resize2fs_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_resize2fs");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_resize2fs");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_resize2fs");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_resize2fs (guestfs_h *g,
		const char *device)
{
  struct guestfs_resize2fs_args args;
  struct resize2fs_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_resize2fs") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_RESIZE2FS,
        (xdrproc_t) xdr_guestfs_resize2fs_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, resize2fs_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_resize2fs");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_RESIZE2FS, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct find_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_find_ret ret;
};

static void find_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct find_ctx *ctx = (struct find_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_find");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_find");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_find");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_find_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_find");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_find (guestfs_h *g,
		const char *directory)
{
  struct guestfs_find_args args;
  struct find_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_find") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.directory = (char *) directory;
  serial = guestfs__send_sync (g, GUESTFS_PROC_FIND,
        (xdrproc_t) xdr_guestfs_find_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, find_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_find");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_FIND, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.names.names_val =
    safe_realloc (g, ctx.ret.names.names_val,
                  sizeof (char *) * (ctx.ret.names.names_len + 1));
  ctx.ret.names.names_val[ctx.ret.names.names_len] = NULL;
  return ctx.ret.names.names_val;
}

struct e2fsck_f_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void e2fsck_f_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct e2fsck_f_ctx *ctx = (struct e2fsck_f_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_e2fsck_f");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_e2fsck_f");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_e2fsck_f");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_e2fsck_f (guestfs_h *g,
		const char *device)
{
  struct guestfs_e2fsck_f_args args;
  struct e2fsck_f_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_e2fsck_f") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_E2FSCK_F,
        (xdrproc_t) xdr_guestfs_e2fsck_f_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, e2fsck_f_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_e2fsck_f");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_E2FSCK_F, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct sleep_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sleep_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sleep_ctx *ctx = (struct sleep_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sleep");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sleep");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sleep");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sleep (guestfs_h *g,
		int secs)
{
  struct guestfs_sleep_args args;
  struct sleep_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sleep") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.secs = secs;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SLEEP,
        (xdrproc_t) xdr_guestfs_sleep_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sleep_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sleep");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SLEEP, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct ntfs_3g_probe_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ntfs_3g_probe_ret ret;
};

static void ntfs_3g_probe_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ntfs_3g_probe_ctx *ctx = (struct ntfs_3g_probe_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_ntfs_3g_probe");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_ntfs_3g_probe");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_ntfs_3g_probe");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ntfs_3g_probe_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_ntfs_3g_probe");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_ntfs_3g_probe (guestfs_h *g,
		int rw,
		const char *device)
{
  struct guestfs_ntfs_3g_probe_args args;
  struct ntfs_3g_probe_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ntfs_3g_probe") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.rw = rw;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_NTFS_3G_PROBE,
        (xdrproc_t) xdr_guestfs_ntfs_3g_probe_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, ntfs_3g_probe_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_ntfs_3g_probe");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_NTFS_3G_PROBE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.status;
}

struct sh_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_sh_ret ret;
};

static void sh_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sh_ctx *ctx = (struct sh_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sh");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sh");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sh");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_sh_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_sh");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_sh (guestfs_h *g,
		const char *command)
{
  struct guestfs_sh_args args;
  struct sh_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sh") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.command = (char *) command;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SH,
        (xdrproc_t) xdr_guestfs_sh_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sh_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sh");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SH, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.output; /* caller will free */
}

struct sh_lines_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_sh_lines_ret ret;
};

static void sh_lines_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sh_lines_ctx *ctx = (struct sh_lines_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sh_lines");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sh_lines");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sh_lines");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_sh_lines_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_sh_lines");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_sh_lines (guestfs_h *g,
		const char *command)
{
  struct guestfs_sh_lines_args args;
  struct sh_lines_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sh_lines") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.command = (char *) command;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SH_LINES,
        (xdrproc_t) xdr_guestfs_sh_lines_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sh_lines_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sh_lines");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SH_LINES, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct glob_expand_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_glob_expand_ret ret;
};

static void glob_expand_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct glob_expand_ctx *ctx = (struct glob_expand_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_glob_expand");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_glob_expand");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_glob_expand");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_glob_expand_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_glob_expand");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_glob_expand (guestfs_h *g,
		const char *pattern)
{
  struct guestfs_glob_expand_args args;
  struct glob_expand_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_glob_expand") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.pattern = (char *) pattern;
  serial = guestfs__send_sync (g, GUESTFS_PROC_GLOB_EXPAND,
        (xdrproc_t) xdr_guestfs_glob_expand_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, glob_expand_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_glob_expand");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_GLOB_EXPAND, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.paths.paths_val =
    safe_realloc (g, ctx.ret.paths.paths_val,
                  sizeof (char *) * (ctx.ret.paths.paths_len + 1));
  ctx.ret.paths.paths_val[ctx.ret.paths.paths_len] = NULL;
  return ctx.ret.paths.paths_val;
}

struct scrub_device_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void scrub_device_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct scrub_device_ctx *ctx = (struct scrub_device_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_scrub_device");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_scrub_device");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_scrub_device");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_scrub_device (guestfs_h *g,
		const char *device)
{
  struct guestfs_scrub_device_args args;
  struct scrub_device_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_scrub_device") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SCRUB_DEVICE,
        (xdrproc_t) xdr_guestfs_scrub_device_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, scrub_device_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_scrub_device");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SCRUB_DEVICE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct scrub_file_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void scrub_file_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct scrub_file_ctx *ctx = (struct scrub_file_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_scrub_file");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_scrub_file");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_scrub_file");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_scrub_file (guestfs_h *g,
		const char *file)
{
  struct guestfs_scrub_file_args args;
  struct scrub_file_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_scrub_file") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.file = (char *) file;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SCRUB_FILE,
        (xdrproc_t) xdr_guestfs_scrub_file_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, scrub_file_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_scrub_file");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SCRUB_FILE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct scrub_freespace_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void scrub_freespace_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct scrub_freespace_ctx *ctx = (struct scrub_freespace_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_scrub_freespace");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_scrub_freespace");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_scrub_freespace");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_scrub_freespace (guestfs_h *g,
		const char *dir)
{
  struct guestfs_scrub_freespace_args args;
  struct scrub_freespace_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_scrub_freespace") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.dir = (char *) dir;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SCRUB_FREESPACE,
        (xdrproc_t) xdr_guestfs_scrub_freespace_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, scrub_freespace_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_scrub_freespace");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SCRUB_FREESPACE, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkdtemp_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_mkdtemp_ret ret;
};

static void mkdtemp_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdtemp_ctx *ctx = (struct mkdtemp_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkdtemp");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkdtemp");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkdtemp");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_mkdtemp_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_mkdtemp");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_mkdtemp (guestfs_h *g,
		const char *template)
{
  struct guestfs_mkdtemp_args args;
  struct mkdtemp_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdtemp") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.template = (char *) template;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKDTEMP,
        (xdrproc_t) xdr_guestfs_mkdtemp_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkdtemp_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkdtemp");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKDTEMP, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.dir; /* caller will free */
}

struct wc_l_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_wc_l_ret ret;
};

static void wc_l_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct wc_l_ctx *ctx = (struct wc_l_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_wc_l");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_wc_l");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_wc_l");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_wc_l_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_wc_l");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_wc_l (guestfs_h *g,
		const char *path)
{
  struct guestfs_wc_l_args args;
  struct wc_l_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_wc_l") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_WC_L,
        (xdrproc_t) xdr_guestfs_wc_l_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, wc_l_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_wc_l");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_WC_L, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.lines;
}

struct wc_w_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_wc_w_ret ret;
};

static void wc_w_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct wc_w_ctx *ctx = (struct wc_w_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_wc_w");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_wc_w");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_wc_w");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_wc_w_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_wc_w");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_wc_w (guestfs_h *g,
		const char *path)
{
  struct guestfs_wc_w_args args;
  struct wc_w_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_wc_w") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_WC_W,
        (xdrproc_t) xdr_guestfs_wc_w_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, wc_w_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_wc_w");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_WC_W, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.words;
}

struct wc_c_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_wc_c_ret ret;
};

static void wc_c_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct wc_c_ctx *ctx = (struct wc_c_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_wc_c");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_wc_c");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_wc_c");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_wc_c_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_wc_c");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_wc_c (guestfs_h *g,
		const char *path)
{
  struct guestfs_wc_c_args args;
  struct wc_c_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_wc_c") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_WC_C,
        (xdrproc_t) xdr_guestfs_wc_c_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, wc_c_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_wc_c");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_WC_C, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.chars;
}

struct head_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_head_ret ret;
};

static void head_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct head_ctx *ctx = (struct head_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_head");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_head");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_head");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_head_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_head");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_head (guestfs_h *g,
		const char *path)
{
  struct guestfs_head_args args;
  struct head_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_head") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_HEAD,
        (xdrproc_t) xdr_guestfs_head_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, head_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_head");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_HEAD, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct head_n_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_head_n_ret ret;
};

static void head_n_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct head_n_ctx *ctx = (struct head_n_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_head_n");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_head_n");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_head_n");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_head_n_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_head_n");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_head_n (guestfs_h *g,
		int nrlines,
		const char *path)
{
  struct guestfs_head_n_args args;
  struct head_n_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_head_n") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.nrlines = nrlines;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_HEAD_N,
        (xdrproc_t) xdr_guestfs_head_n_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, head_n_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_head_n");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_HEAD_N, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct tail_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_tail_ret ret;
};

static void tail_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tail_ctx *ctx = (struct tail_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tail");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tail");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tail");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_tail_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_tail");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_tail (guestfs_h *g,
		const char *path)
{
  struct guestfs_tail_args args;
  struct tail_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tail") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TAIL,
        (xdrproc_t) xdr_guestfs_tail_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tail_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tail");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TAIL, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct tail_n_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_tail_n_ret ret;
};

static void tail_n_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tail_n_ctx *ctx = (struct tail_n_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_tail_n");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_tail_n");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_tail_n");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_tail_n_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_tail_n");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_tail_n (guestfs_h *g,
		int nrlines,
		const char *path)
{
  struct guestfs_tail_n_args args;
  struct tail_n_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tail_n") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.nrlines = nrlines;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_TAIL_N,
        (xdrproc_t) xdr_guestfs_tail_n_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, tail_n_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_tail_n");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_TAIL_N, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.lines.lines_val =
    safe_realloc (g, ctx.ret.lines.lines_val,
                  sizeof (char *) * (ctx.ret.lines.lines_len + 1));
  ctx.ret.lines.lines_val[ctx.ret.lines.lines_len] = NULL;
  return ctx.ret.lines.lines_val;
}

struct df_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_df_ret ret;
};

static void df_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct df_ctx *ctx = (struct df_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_df");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_df");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_df");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_df_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_df");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_df (guestfs_h *g)
{
  struct df_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_df") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_DF, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, df_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_df");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DF, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.output; /* caller will free */
}

struct df_h_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_df_h_ret ret;
};

static void df_h_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct df_h_ctx *ctx = (struct df_h_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_df_h");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_df_h");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_df_h");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_df_h_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_df_h");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char *guestfs_df_h (guestfs_h *g)
{
  struct df_h_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_df_h") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  serial = guestfs__send_sync (g, GUESTFS_PROC_DF_H, NULL, NULL);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, df_h_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_df_h");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DF_H, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  return ctx.ret.output; /* caller will free */
}

struct du_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_du_ret ret;
};

static void du_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct du_ctx *ctx = (struct du_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_du");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_du");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_du");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_du_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_du");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int64_t guestfs_du (guestfs_h *g,
		const char *path)
{
  struct guestfs_du_args args;
  struct du_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_du") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_DU,
        (xdrproc_t) xdr_guestfs_du_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, du_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_du");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_DU, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.sizekb;
}

struct initrd_list_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_initrd_list_ret ret;
};

static void initrd_list_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct initrd_list_ctx *ctx = (struct initrd_list_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_initrd_list");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_initrd_list");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_initrd_list");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_initrd_list_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_initrd_list");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

char **guestfs_initrd_list (guestfs_h *g,
		const char *path)
{
  struct guestfs_initrd_list_args args;
  struct initrd_list_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_initrd_list") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_INITRD_LIST,
        (xdrproc_t) xdr_guestfs_initrd_list_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, initrd_list_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_initrd_list");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_INITRD_LIST, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this, but we need to add a NULL entry */
  ctx.ret.filenames.filenames_val =
    safe_realloc (g, ctx.ret.filenames.filenames_val,
                  sizeof (char *) * (ctx.ret.filenames.filenames_len + 1));
  ctx.ret.filenames.filenames_val[ctx.ret.filenames.filenames_len] = NULL;
  return ctx.ret.filenames.filenames_val;
}

struct mount_loop_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_loop_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_loop_ctx *ctx = (struct mount_loop_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mount_loop");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mount_loop");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mount_loop");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mount_loop (guestfs_h *g,
		const char *file,
		const char *mountpoint)
{
  struct guestfs_mount_loop_args args;
  struct mount_loop_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount_loop") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.file = (char *) file;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MOUNT_LOOP,
        (xdrproc_t) xdr_guestfs_mount_loop_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mount_loop_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mount_loop");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MOUNT_LOOP, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkswap_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkswap_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkswap_ctx *ctx = (struct mkswap_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkswap");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkswap");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkswap");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkswap (guestfs_h *g,
		const char *device)
{
  struct guestfs_mkswap_args args;
  struct mkswap_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkswap") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKSWAP,
        (xdrproc_t) xdr_guestfs_mkswap_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkswap_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkswap");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKSWAP, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkswap_L_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkswap_L_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkswap_L_ctx *ctx = (struct mkswap_L_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkswap_L");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkswap_L");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkswap_L");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkswap_L (guestfs_h *g,
		const char *label,
		const char *device)
{
  struct guestfs_mkswap_L_args args;
  struct mkswap_L_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkswap_L") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.label = (char *) label;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKSWAP_L,
        (xdrproc_t) xdr_guestfs_mkswap_L_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkswap_L_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkswap_L");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKSWAP_L, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkswap_U_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkswap_U_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkswap_U_ctx *ctx = (struct mkswap_U_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkswap_U");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkswap_U");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkswap_U");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkswap_U (guestfs_h *g,
		const char *uuid,
		const char *device)
{
  struct guestfs_mkswap_U_args args;
  struct mkswap_U_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkswap_U") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.uuid = (char *) uuid;
  args.device = (char *) device;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKSWAP_U,
        (xdrproc_t) xdr_guestfs_mkswap_U_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkswap_U_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkswap_U");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKSWAP_U, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mknod_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mknod_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mknod_ctx *ctx = (struct mknod_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mknod");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mknod");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mknod");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mknod (guestfs_h *g,
		int mode,
		int devmajor,
		int devminor,
		const char *path)
{
  struct guestfs_mknod_args args;
  struct mknod_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mknod") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mode = mode;
  args.devmajor = devmajor;
  args.devminor = devminor;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKNOD,
        (xdrproc_t) xdr_guestfs_mknod_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mknod_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mknod");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKNOD, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mkfifo_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkfifo_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkfifo_ctx *ctx = (struct mkfifo_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mkfifo");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mkfifo");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mkfifo");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mkfifo (guestfs_h *g,
		int mode,
		const char *path)
{
  struct guestfs_mkfifo_args args;
  struct mkfifo_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkfifo") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mode = mode;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKFIFO,
        (xdrproc_t) xdr_guestfs_mkfifo_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mkfifo_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mkfifo");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKFIFO, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mknod_b_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mknod_b_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mknod_b_ctx *ctx = (struct mknod_b_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mknod_b");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mknod_b");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mknod_b");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mknod_b (guestfs_h *g,
		int mode,
		int devmajor,
		int devminor,
		const char *path)
{
  struct guestfs_mknod_b_args args;
  struct mknod_b_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mknod_b") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mode = mode;
  args.devmajor = devmajor;
  args.devminor = devminor;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKNOD_B,
        (xdrproc_t) xdr_guestfs_mknod_b_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mknod_b_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mknod_b");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKNOD_B, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct mknod_c_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mknod_c_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mknod_c_ctx *ctx = (struct mknod_c_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_mknod_c");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_mknod_c");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_mknod_c");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_mknod_c (guestfs_h *g,
		int mode,
		int devmajor,
		int devminor,
		const char *path)
{
  struct guestfs_mknod_c_args args;
  struct mknod_c_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mknod_c") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mode = mode;
  args.devmajor = devmajor;
  args.devminor = devminor;
  args.path = (char *) path;
  serial = guestfs__send_sync (g, GUESTFS_PROC_MKNOD_C,
        (xdrproc_t) xdr_guestfs_mknod_c_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, mknod_c_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_mknod_c");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_MKNOD_C, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

struct umask_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_umask_ret ret;
};

static void umask_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umask_ctx *ctx = (struct umask_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_umask");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_umask");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_umask");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_umask_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_umask");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_umask (guestfs_h *g,
		int mask)
{
  struct guestfs_umask_args args;
  struct umask_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umask") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.mask = mask;
  serial = guestfs__send_sync (g, GUESTFS_PROC_UMASK,
        (xdrproc_t) xdr_guestfs_umask_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, umask_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_umask");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_UMASK, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return ctx.ret.oldmask;
}

struct readdir_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_readdir_ret ret;
};

static void readdir_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct readdir_ctx *ctx = (struct readdir_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_readdir");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_readdir");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_readdir");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_readdir_ret (xdr, &ctx->ret)) {
    error (g, "%s: failed to parse reply", "guestfs_readdir");
    return;
  }
 done:
  ctx->cb_sequence = 1;
}

struct guestfs_dirent_list *guestfs_readdir (guestfs_h *g,
		const char *dir)
{
  struct guestfs_readdir_args args;
  struct readdir_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_readdir") == -1) return NULL;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.dir = (char *) dir;
  serial = guestfs__send_sync (g, GUESTFS_PROC_READDIR,
        (xdrproc_t) xdr_guestfs_readdir_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, readdir_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_readdir");
    guestfs_end_busy (g);
    return NULL;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_READDIR, serial) == -1) {
    guestfs_end_busy (g);
    return NULL;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return NULL;
  }

  guestfs_end_busy (g);
  /* caller will free this */
  return safe_memdup (g, &ctx.ret.entries, sizeof (ctx.ret.entries));
}

struct sfdiskM_ctx {
  /* This flag is set by the callbacks, so we know we've done
   * the callbacks as expected, and in the right sequence.
   * 0 = not called, 1 = reply_cb called.
   */
  int cb_sequence;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sfdiskM_reply_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdiskM_ctx *ctx = (struct sfdiskM_ctx *) data;

  /* This should definitely not happen. */
  if (ctx->cb_sequence != 0) {
    ctx->cb_sequence = 9999;
    error (g, "%s: internal error: reply callback called twice", "guestfs_sfdiskM");
    return;
  }

  ml->main_loop_quit (ml, g);

  if (!xdr_guestfs_message_header (xdr, &ctx->hdr)) {
    error (g, "%s: failed to parse reply header", "guestfs_sfdiskM");
    return;
  }
  if (ctx->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &ctx->err)) {
      error (g, "%s: failed to parse reply error", "guestfs_sfdiskM");
      return;
    }
    goto done;
  }
 done:
  ctx->cb_sequence = 1;
}

int guestfs_sfdiskM (guestfs_h *g,
		const char *device,
		char * const* const lines)
{
  struct guestfs_sfdiskM_args args;
  struct sfdiskM_ctx ctx;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdiskM") == -1) return -1;
  guestfs_set_busy (g);

  memset (&ctx, 0, sizeof ctx);

  args.device = (char *) device;
  args.lines.lines_val = (char **) lines;
  for (args.lines.lines_len = 0; lines[args.lines.lines_len]; args.lines.lines_len++) ;
  serial = guestfs__send_sync (g, GUESTFS_PROC_SFDISKM,
        (xdrproc_t) xdr_guestfs_sfdiskM_args, (char *) &args);
  if (serial == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  guestfs__switch_to_receiving (g);
  ctx.cb_sequence = 0;
  guestfs_set_reply_callback (g, sfdiskM_reply_cb, &ctx);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (ctx.cb_sequence != 1) {
    error (g, "%s reply failed, see earlier error messages", "guestfs_sfdiskM");
    guestfs_end_busy (g);
    return -1;
  }

  if (check_reply_header (g, &ctx.hdr, GUESTFS_PROC_SFDISKM, serial) == -1) {
    guestfs_end_busy (g);
    return -1;
  }

  if (ctx.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", ctx.err.error_message);
    free (ctx.err.error_message);
    guestfs_end_busy (g);
    return -1;
  }

  guestfs_end_busy (g);
  return 0;
}

/* Structure-freeing functions.  These rely on the fact that the
 * structure format is identical to the XDR format.  See note in
 * generator.ml.
 */

void
guestfs_free_int_bool (struct guestfs_int_bool *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_int_bool, (char *) x);
  free (x);
}

void
guestfs_free_int_bool_list (struct guestfs_int_bool_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_int_bool_list, (char *) x);
  free (x);
}

void
guestfs_free_lvm_pv (struct guestfs_lvm_pv *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_lvm_pv, (char *) x);
  free (x);
}

void
guestfs_free_lvm_pv_list (struct guestfs_lvm_pv_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_lvm_pv_list, (char *) x);
  free (x);
}

void
guestfs_free_lvm_vg (struct guestfs_lvm_vg *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_lvm_vg, (char *) x);
  free (x);
}

void
guestfs_free_lvm_vg_list (struct guestfs_lvm_vg_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_lvm_vg_list, (char *) x);
  free (x);
}

void
guestfs_free_lvm_lv (struct guestfs_lvm_lv *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_lvm_lv, (char *) x);
  free (x);
}

void
guestfs_free_lvm_lv_list (struct guestfs_lvm_lv_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_lvm_lv_list, (char *) x);
  free (x);
}

void
guestfs_free_stat (struct guestfs_stat *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_stat, (char *) x);
  free (x);
}

void
guestfs_free_stat_list (struct guestfs_stat_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_stat_list, (char *) x);
  free (x);
}

void
guestfs_free_statvfs (struct guestfs_statvfs *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_statvfs, (char *) x);
  free (x);
}

void
guestfs_free_statvfs_list (struct guestfs_statvfs_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_statvfs_list, (char *) x);
  free (x);
}

void
guestfs_free_dirent (struct guestfs_dirent *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_dirent, (char *) x);
  free (x);
}

void
guestfs_free_dirent_list (struct guestfs_dirent_list *x)
{
  xdr_free ((xdrproc_t) xdr_guestfs_int_dirent_list, (char *) x);
  free (x);
}

