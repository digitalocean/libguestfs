=head2 guestfs_add_cdrom

 int guestfs_add_cdrom (guestfs_h *handle,
		const char *filename);

This function adds a virtual CD-ROM disk image to the guest.

This is equivalent to the qemu parameter C<-cdrom filename>.

Notes:

=over 4

=item *

This call checks for the existence of C<filename>.  This
stops you from specifying other types of drive which are supported
by qemu such as C<nbd:> and C<http:> URLs.  To specify those, use
the general C<guestfs_config> call instead.

=item *

If you just want to add an ISO file (often you use this as an
efficient way to transfer large files into the guest), then you
should probably use C<guestfs_add_drive_ro> instead.

=back

This function returns 0 on success or -1 on error.

=head2 guestfs_add_drive

 int guestfs_add_drive (guestfs_h *handle,
		const char *filename);

This function adds a virtual machine disk image C<filename> to the
guest.  The first time you call this function, the disk appears as IDE
disk 0 (C</dev/sda>) in the guest, the second time as C</dev/sdb>, and
so on.

You don't necessarily need to be root when using libguestfs.  However
you obviously do need sufficient permissions to access the filename
for whatever operations you want to perform (ie. read access if you
just want to read the image or write access if you want to modify the
image).

This is equivalent to the qemu parameter
C<-drive file=filename,cache=off,if=...>.

C<cache=off> is omitted in cases where it is not supported by
the underlying filesystem.

C<if=...> is set at compile time by the configuration option
C<./configure --with-drive-if=...>.  In the rare case where you
might need to change this at run time, use C<guestfs_add_drive_with_if>
or C<guestfs_add_drive_ro_with_if>.

Note that this call checks for the existence of C<filename>.  This
stops you from specifying other types of drive which are supported
by qemu such as C<nbd:> and C<http:> URLs.  To specify those, use
the general C<guestfs_config> call instead.

This function returns 0 on success or -1 on error.

=head2 guestfs_add_drive_ro

 int guestfs_add_drive_ro (guestfs_h *handle,
		const char *filename);

This adds a drive in snapshot mode, making it effectively
read-only.

Note that writes to the device are allowed, and will be seen for
the duration of the guestfs handle, but they are written
to a temporary file which is discarded as soon as the guestfs
handle is closed.  We don't currently have any method to enable
changes to be committed, although qemu can support this.

This is equivalent to the qemu parameter
C<-drive file=filename,snapshot=on,if=...>.

C<if=...> is set at compile time by the configuration option
C<./configure --with-drive-if=...>.  In the rare case where you
might need to change this at run time, use C<guestfs_add_drive_with_if>
or C<guestfs_add_drive_ro_with_if>.

Note that this call checks for the existence of C<filename>.  This
stops you from specifying other types of drive which are supported
by qemu such as C<nbd:> and C<http:> URLs.  To specify those, use
the general C<guestfs_config> call instead.

This function returns 0 on success or -1 on error.

=head2 guestfs_add_drive_ro_with_if

 int guestfs_add_drive_ro_with_if (guestfs_h *handle,
		const char *filename,
		const char *iface);

This is the same as C<guestfs_add_drive_ro> but it allows you
to specify the QEMU interface emulation to use at run time.

This function returns 0 on success or -1 on error.

=head2 guestfs_add_drive_with_if

 int guestfs_add_drive_with_if (guestfs_h *handle,
		const char *filename,
		const char *iface);

This is the same as C<guestfs_add_drive> but it allows you
to specify the QEMU interface emulation to use at run time.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_close

 int guestfs_aug_close (guestfs_h *handle);

Close the current Augeas handle and free up any resources
used by it.  After calling this, you have to call
C<guestfs_aug_init> again before you can use any other
Augeas functions.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_defnode

 struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *handle,
		const char *name,
		const char *expr,
		const char *val);

Defines a variable C<name> whose value is the result of
evaluating C<expr>.

If C<expr> evaluates to an empty nodeset, a node is created,
equivalent to calling C<guestfs_aug_set> C<expr>, C<value>.
C<name> will be the nodeset containing that single node.

On success this returns a pair containing the
number of nodes in the nodeset, and a boolean flag
if a node was created.

This function returns a C<struct guestfs_int_bool *>,
or NULL if there was an error.
I<The caller must call C<guestfs_free_int_bool> after use>.

=head2 guestfs_aug_defvar

 int guestfs_aug_defvar (guestfs_h *handle,
		const char *name,
		const char *expr);

Defines an Augeas variable C<name> whose value is the result
of evaluating C<expr>.  If C<expr> is NULL, then C<name> is
undefined.

On success this returns the number of nodes in C<expr>, or
C<0> if C<expr> evaluates to something which is not a nodeset.

On error this function returns -1.

=head2 guestfs_aug_get

 char *guestfs_aug_get (guestfs_h *handle,
		const char *augpath);

Look up the value associated with C<path>.  If C<path>
matches exactly one node, the C<value> is returned.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_aug_init

 int guestfs_aug_init (guestfs_h *handle,
		const char *root,
		int flags);

Create a new Augeas handle for editing configuration files.
If there was any previous Augeas handle associated with this
guestfs session, then it is closed.

You must call this before using any other C<guestfs_aug_*>
commands.

C<root> is the filesystem root.  C<root> must not be NULL,
use C</> instead.

The flags are the same as the flags defined in
E<lt>augeas.hE<gt>, the logical I<or> of the following
integers:

=over 4

=item C<AUG_SAVE_BACKUP> = 1

Keep the original file with a C<.augsave> extension.

=item C<AUG_SAVE_NEWFILE> = 2

Save changes into a file with extension C<.augnew>, and
do not overwrite original.  Overrides C<AUG_SAVE_BACKUP>.

=item C<AUG_TYPE_CHECK> = 4

Typecheck lenses (can be expensive).

=item C<AUG_NO_STDINC> = 8

Do not use standard load path for modules.

=item C<AUG_SAVE_NOOP> = 16

Make save a no-op, just record what would have been changed.

=item C<AUG_NO_LOAD> = 32

Do not load the tree in C<guestfs_aug_init>.

=back

To close the handle, you can call C<guestfs_aug_close>.

To find out more about Augeas, see L<http://augeas.net/>.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_insert

 int guestfs_aug_insert (guestfs_h *handle,
		const char *augpath,
		const char *label,
		int before);

Create a new sibling C<label> for C<path>, inserting it into
the tree before or after C<path> (depending on the boolean
flag C<before>).

C<path> must match exactly one existing node in the tree, and
C<label> must be a label, ie. not contain C</>, C<*> or end
with a bracketed index C<[N]>.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_load

 int guestfs_aug_load (guestfs_h *handle);

Load files into the tree.

See C<aug_load> in the Augeas documentation for the full gory
details.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_ls

 char **guestfs_aug_ls (guestfs_h *handle,
		const char *augpath);

This is just a shortcut for listing C<guestfs_aug_match>
C<path/*> and sorting the resulting nodes into alphabetical order.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_aug_match

 char **guestfs_aug_match (guestfs_h *handle,
		const char *augpath);

Returns a list of paths which match the path expression C<path>.
The returned paths are sufficiently qualified so that they match
exactly one node in the current tree.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_aug_mv

 int guestfs_aug_mv (guestfs_h *handle,
		const char *src,
		const char *dest);

Move the node C<src> to C<dest>.  C<src> must match exactly
one node.  C<dest> is overwritten if it exists.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_rm

 int guestfs_aug_rm (guestfs_h *handle,
		const char *augpath);

Remove C<path> and all of its children.

On success this returns the number of entries which were removed.

On error this function returns -1.

=head2 guestfs_aug_save

 int guestfs_aug_save (guestfs_h *handle);

This writes all pending changes to disk.

The flags which were passed to C<guestfs_aug_init> affect exactly
how files are saved.

This function returns 0 on success or -1 on error.

=head2 guestfs_aug_set

 int guestfs_aug_set (guestfs_h *handle,
		const char *augpath,
		const char *val);

Set the value associated with C<path> to C<value>.

This function returns 0 on success or -1 on error.

=head2 guestfs_available

 int guestfs_available (guestfs_h *handle,
		char *const *groups);

This command is used to check the availability of some
groups of functionality in the appliance, which not all builds of
the libguestfs appliance will be able to provide.

The libguestfs groups, and the functions that those
groups correspond to, are listed in L<guestfs(3)/AVAILABILITY>.

The argument C<groups> is a list of group names, eg:
C<["inotify", "augeas"]> would check for the availability of
the Linux inotify functions and Augeas (configuration file
editing) functions.

The command returns no error if I<all> requested groups are available.

It fails with an error if one or more of the requested
groups is unavailable in the appliance.

If an unknown group name is included in the
list of groups then an error is always returned.

I<Notes:>

=over 4

=item *

You must call C<guestfs_launch> before calling this function.

The reason is because we don't know what groups are
supported by the appliance/daemon until it is running and can
be queried.

=item *

If a group of functions is available, this does not necessarily
mean that they will work.  You still have to check for errors
when calling individual API functions even if they are
available.

=item *

It is usually the job of distro packagers to build
complete functionality into the libguestfs appliance.
Upstream libguestfs, if built from source with all
requirements satisfied, will support everything.

=item *

This call was added in version C<1.0.80>.  In previous
versions of libguestfs all you could do would be to speculatively
execute a command to find out if the daemon implemented it.
See also C<guestfs_version>.

=back

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_flushbufs

 int guestfs_blockdev_flushbufs (guestfs_h *handle,
		const char *device);

This tells the kernel to flush internal buffers associated
with C<device>.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_getbsz

 int guestfs_blockdev_getbsz (guestfs_h *handle,
		const char *device);

This returns the block size of a device.

(Note this is different from both I<size in blocks> and
I<filesystem block size>).

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_getro

 int guestfs_blockdev_getro (guestfs_h *handle,
		const char *device);

Returns a boolean indicating if the block device is read-only
(true if read-only, false if not).

This uses the L<blockdev(8)> command.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_blockdev_getsize64

 int64_t guestfs_blockdev_getsize64 (guestfs_h *handle,
		const char *device);

This returns the size of the device in bytes.

See also C<guestfs_blockdev_getsz>.

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_getss

 int guestfs_blockdev_getss (guestfs_h *handle,
		const char *device);

This returns the size of sectors on a block device.
Usually 512, but can be larger for modern devices.

(Note, this is not the size in sectors, use C<guestfs_blockdev_getsz>
for that).

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_getsz

 int64_t guestfs_blockdev_getsz (guestfs_h *handle,
		const char *device);

This returns the size of the device in units of 512-byte sectors
(even if the sectorsize isn't 512 bytes ... weird).

See also C<guestfs_blockdev_getss> for the real sector size of
the device, and C<guestfs_blockdev_getsize64> for the more
useful I<size in bytes>.

This uses the L<blockdev(8)> command.

On error this function returns -1.

=head2 guestfs_blockdev_rereadpt

 int guestfs_blockdev_rereadpt (guestfs_h *handle,
		const char *device);

Reread the partition table on C<device>.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_setbsz

 int guestfs_blockdev_setbsz (guestfs_h *handle,
		const char *device,
		int blocksize);

This sets the block size of a device.

(Note this is different from both I<size in blocks> and
I<filesystem block size>).

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_setro

 int guestfs_blockdev_setro (guestfs_h *handle,
		const char *device);

Sets the block device named C<device> to read-only.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_blockdev_setrw

 int guestfs_blockdev_setrw (guestfs_h *handle,
		const char *device);

Sets the block device named C<device> to read-write.

This uses the L<blockdev(8)> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_case_sensitive_path

 char *guestfs_case_sensitive_path (guestfs_h *handle,
		const char *path);

This can be used to resolve case insensitive paths on
a filesystem which is case sensitive.  The use case is
to resolve paths which you have read from Windows configuration
files or the Windows Registry, to the true path.

The command handles a peculiarity of the Linux ntfs-3g
filesystem driver (and probably others), which is that although
the underlying filesystem is case-insensitive, the driver
exports the filesystem to Linux as case-sensitive.

One consequence of this is that special directories such
as C<c:\windows> may appear as C</WINDOWS> or C</windows>
(or other things) depending on the precise details of how
they were created.  In Windows itself this would not be
a problem.

Bug or feature?  You decide:
L<http://www.tuxera.com/community/ntfs-3g-faq/#posixfilenames1>

This function resolves the true case of each element in the
path and returns the case-sensitive path.

Thus C<guestfs_case_sensitive_path> ("/Windows/System32")
might return C<"/WINDOWS/system32"> (the exact return value
would depend on details of how the directories were originally
created under Windows).

I<Note>:
This function does not handle drive names, backslashes etc.

See also C<guestfs_realpath>.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_cat

 char *guestfs_cat (guestfs_h *handle,
		const char *path);

Return the contents of the file named C<path>.

Note that this function cannot correctly handle binary files
(specifically, files containing C<\0> character which is treated
as end of string).  For those you need to use the C<guestfs_read_file>
or C<guestfs_download> functions which have a more complex interface.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_checksum

 char *guestfs_checksum (guestfs_h *handle,
		const char *csumtype,
		const char *path);

This call computes the MD5, SHAx or CRC checksum of the
file named C<path>.

The type of checksum to compute is given by the C<csumtype>
parameter which must have one of the following values:

=over 4

=item C<crc>

Compute the cyclic redundancy check (CRC) specified by POSIX
for the C<cksum> command.

=item C<md5>

Compute the MD5 hash (using the C<md5sum> program).

=item C<sha1>

Compute the SHA1 hash (using the C<sha1sum> program).

=item C<sha224>

Compute the SHA224 hash (using the C<sha224sum> program).

=item C<sha256>

Compute the SHA256 hash (using the C<sha256sum> program).

=item C<sha384>

Compute the SHA384 hash (using the C<sha384sum> program).

=item C<sha512>

Compute the SHA512 hash (using the C<sha512sum> program).

=back

The checksum is returned as a printable string.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_chmod

 int guestfs_chmod (guestfs_h *handle,
		int mode,
		const char *path);

Change the mode (permissions) of C<path> to C<mode>.  Only
numeric modes are supported.

I<Note>: When using this command from guestfish, C<mode>
by default would be decimal, unless you prefix it with
C<0> to get octal, ie. use C<0700> not C<700>.

This function returns 0 on success or -1 on error.

=head2 guestfs_chown

 int guestfs_chown (guestfs_h *handle,
		int owner,
		int group,
		const char *path);

Change the file owner to C<owner> and group to C<group>.

Only numeric uid and gid are supported.  If you want to use
names, you will need to locate and parse the password file
yourself (Augeas support makes this relatively easy).

This function returns 0 on success or -1 on error.

=head2 guestfs_command

 char *guestfs_command (guestfs_h *handle,
		char *const *arguments);

This call runs a command from the guest filesystem.  The
filesystem must be mounted, and must contain a compatible
operating system (ie. something Linux, with the same
or compatible processor architecture).

The single parameter is an argv-style list of arguments.
The first element is the name of the program to run.
Subsequent elements are parameters.  The list must be
non-empty (ie. must contain a program name).  Note that
the command runs directly, and is I<not> invoked via
the shell (see C<guestfs_sh>).

The return value is anything printed to I<stdout> by
the command.

If the command returns a non-zero exit status, then
this function returns an error message.  The error message
string is the content of I<stderr> from the command.

The C<$PATH> environment variable will contain at least
C</usr/bin> and C</bin>.  If you require a program from
another location, you should provide the full path in the
first parameter.

Shared libraries and data files required by the program
must be available on filesystems which are mounted in the
correct places.  It is the caller's responsibility to ensure
all filesystems that are needed are mounted at the right
locations.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_command_lines

 char **guestfs_command_lines (guestfs_h *handle,
		char *const *arguments);

This is the same as C<guestfs_command>, but splits the
result into a list of lines.

See also: C<guestfs_sh_lines>

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_config

 int guestfs_config (guestfs_h *handle,
		const char *qemuparam,
		const char *qemuvalue);

This can be used to add arbitrary qemu command line parameters
of the form C<-param value>.  Actually it's not quite arbitrary - we
prevent you from setting some parameters which would interfere with
parameters that we use.

The first character of C<param> string must be a C<-> (dash).

C<value> can be NULL.

This function returns 0 on success or -1 on error.

=head2 guestfs_cp

 int guestfs_cp (guestfs_h *handle,
		const char *src,
		const char *dest);

This copies a file from C<src> to C<dest> where C<dest> is
either a destination filename or destination directory.

This function returns 0 on success or -1 on error.

=head2 guestfs_cp_a

 int guestfs_cp_a (guestfs_h *handle,
		const char *src,
		const char *dest);

This copies a file or directory from C<src> to C<dest>
recursively using the C<cp -a> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_dd

 int guestfs_dd (guestfs_h *handle,
		const char *src,
		const char *dest);

This command copies from one source device or file C<src>
to another destination device or file C<dest>.  Normally you
would use this to copy to or from a device or partition, for
example to duplicate a filesystem.

If the destination is a device, it must be as large or larger
than the source file or device, otherwise the copy will fail.
This command cannot do partial copies.

This function returns 0 on success or -1 on error.

=head2 guestfs_debug

 char *guestfs_debug (guestfs_h *handle,
		const char *subcmd,
		char *const *extraargs);

The C<guestfs_debug> command exposes some internals of
C<guestfsd> (the guestfs daemon) that runs inside the
qemu subprocess.

There is no comprehensive help for this command.  You have
to look at the file C<daemon/debug.c> in the libguestfs source
to find out what you can do.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_df

 char *guestfs_df (guestfs_h *handle);

This command runs the C<df> command to report disk space used.

This command is mostly useful for interactive sessions.  It
is I<not> intended that you try to parse the output string.
Use C<statvfs> from programs.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_df_h

 char *guestfs_df_h (guestfs_h *handle);

This command runs the C<df -h> command to report disk space used
in human-readable format.

This command is mostly useful for interactive sessions.  It
is I<not> intended that you try to parse the output string.
Use C<statvfs> from programs.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_dmesg

 char *guestfs_dmesg (guestfs_h *handle);

This returns the kernel messages (C<dmesg> output) from
the guest kernel.  This is sometimes useful for extended
debugging of problems.

Another way to get the same information is to enable
verbose messages with C<guestfs_set_verbose> or by setting
the environment variable C<LIBGUESTFS_DEBUG=1> before
running the program.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_download

 int guestfs_download (guestfs_h *handle,
		const char *remotefilename,
		const char *filename);

Download file C<remotefilename> and save it as C<filename>
on the local machine.

C<filename> can also be a named pipe.

See also C<guestfs_upload>, C<guestfs_cat>.

This function returns 0 on success or -1 on error.

=head2 guestfs_drop_caches

 int guestfs_drop_caches (guestfs_h *handle,
		int whattodrop);

This instructs the guest kernel to drop its page cache,
and/or dentries and inode caches.  The parameter C<whattodrop>
tells the kernel what precisely to drop, see
L<http://linux-mm.org/Drop_Caches>

Setting C<whattodrop> to 3 should drop everything.

This automatically calls L<sync(2)> before the operation,
so that the maximum guest memory is freed.

This function returns 0 on success or -1 on error.

=head2 guestfs_du

 int64_t guestfs_du (guestfs_h *handle,
		const char *path);

This command runs the C<du -s> command to estimate file space
usage for C<path>.

C<path> can be a file or a directory.  If C<path> is a directory
then the estimate includes the contents of the directory and all
subdirectories (recursively).

The result is the estimated size in I<kilobytes>
(ie. units of 1024 bytes).

On error this function returns -1.

=head2 guestfs_e2fsck_f

 int guestfs_e2fsck_f (guestfs_h *handle,
		const char *device);

This runs C<e2fsck -p -f device>, ie. runs the ext2/ext3
filesystem checker on C<device>, noninteractively (C<-p>),
even if the filesystem appears to be clean (C<-f>).

This command is only needed because of C<guestfs_resize2fs>
(q.v.).  Normally you should use C<guestfs_fsck>.

This function returns 0 on success or -1 on error.

=head2 guestfs_echo_daemon

 char *guestfs_echo_daemon (guestfs_h *handle,
		char *const *words);

This command concatenate the list of C<words> passed with single spaces between
them and returns the resulting string.

You can use this command to test the connection through to the daemon.

See also C<guestfs_ping_daemon>.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_egrep

 char **guestfs_egrep (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<egrep> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_egrepi

 char **guestfs_egrepi (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<egrep -i> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_equal

 int guestfs_equal (guestfs_h *handle,
		const char *file1,
		const char *file2);

This compares the two files C<file1> and C<file2> and returns
true if their content is exactly equal, or false otherwise.

The external L<cmp(1)> program is used for the comparison.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_exists

 int guestfs_exists (guestfs_h *handle,
		const char *path);

This returns C<true> if and only if there is a file, directory
(or anything) with the given C<path> name.

See also C<guestfs_is_file>, C<guestfs_is_dir>, C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_fallocate

 int guestfs_fallocate (guestfs_h *handle,
		const char *path,
		int len);

This command preallocates a file (containing zero bytes) named
C<path> of size C<len> bytes.  If the file exists already, it
is overwritten.

Do not confuse this with the guestfish-specific
C<alloc> command which allocates a file in the host and
attaches it as a device.

This function returns 0 on success or -1 on error.

=head2 guestfs_fgrep

 char **guestfs_fgrep (guestfs_h *handle,
		const char *pattern,
		const char *path);

This calls the external C<fgrep> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_fgrepi

 char **guestfs_fgrepi (guestfs_h *handle,
		const char *pattern,
		const char *path);

This calls the external C<fgrep -i> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_file

 char *guestfs_file (guestfs_h *handle,
		const char *path);

This call uses the standard L<file(1)> command to determine
the type or contents of the file.  This also works on devices,
for example to find out whether a partition contains a filesystem.

This call will also transparently look inside various types
of compressed file.

The exact command which runs is C<file -zbsL path>.  Note in
particular that the filename is not prepended to the output
(the C<-b> option).

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_filesize

 int64_t guestfs_filesize (guestfs_h *handle,
		const char *file);

This command returns the size of C<file> in bytes.

To get other stats about a file, use C<guestfs_stat>, C<guestfs_lstat>,
C<guestfs_is_dir>, C<guestfs_is_file> etc.
To get the size of block devices, use C<guestfs_blockdev_getsize64>.

On error this function returns -1.

=head2 guestfs_fill

 int guestfs_fill (guestfs_h *handle,
		int c,
		int len,
		const char *path);

This command creates a new file called C<path>.  The initial
content of the file is C<len> octets of C<c>, where C<c>
must be a number in the range C<[0..255]>.

To fill a file with zero bytes (sparsely), it is
much more efficient to use C<guestfs_truncate_size>.

This function returns 0 on success or -1 on error.

=head2 guestfs_find

 char **guestfs_find (guestfs_h *handle,
		const char *directory);

This command lists out all files and directories, recursively,
starting at C<directory>.  It is essentially equivalent to
running the shell command C<find directory -print> but some
post-processing happens on the output, described below.

This returns a list of strings I<without any prefix>.  Thus
if the directory structure was:

 /tmp/a
 /tmp/b
 /tmp/c/d

then the returned list from C<guestfs_find> C</tmp> would be
4 elements:

 a
 b
 c
 c/d

If C<directory> is not a directory, then this command returns
an error.

The returned list is sorted.

See also C<guestfs_find0>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_find0

 int guestfs_find0 (guestfs_h *handle,
		const char *directory,
		const char *files);

This command lists out all files and directories, recursively,
starting at C<directory>, placing the resulting list in the
external file called C<files>.

This command works the same way as C<guestfs_find> with the
following exceptions:

=over 4

=item *

The resulting list is written to an external file.

=item *

Items (filenames) in the result are separated
by C<\0> characters.  See L<find(1)> option I<-print0>.

=item *

This command is not limited in the number of names that it
can return.

=item *

The result list is not sorted.

=back

This function returns 0 on success or -1 on error.

=head2 guestfs_fsck

 int guestfs_fsck (guestfs_h *handle,
		const char *fstype,
		const char *device);

This runs the filesystem checker (fsck) on C<device> which
should have filesystem type C<fstype>.

The returned integer is the status.  See L<fsck(8)> for the
list of status codes from C<fsck>.

Notes:

=over 4

=item *

Multiple status codes can be summed together.

=item *

A non-zero return code can mean "success", for example if
errors have been corrected on the filesystem.

=item *

Checking or repairing NTFS volumes is not supported
(by linux-ntfs).

=back

This command is entirely equivalent to running C<fsck -a -t fstype device>.

On error this function returns -1.

=head2 guestfs_get_append

 const char *guestfs_get_append (guestfs_h *handle);

Return the additional kernel options which are added to the
guest kernel command line.

If C<NULL> then no options are added.

This function returns a string which may be NULL.
There is way to return an error from this function.
The string is owned by the guest handle and must I<not> be freed.

=head2 guestfs_get_autosync

 int guestfs_get_autosync (guestfs_h *handle);

Get the autosync flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_get_direct

 int guestfs_get_direct (guestfs_h *handle);

Return the direct appliance mode flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_get_e2label

 char *guestfs_get_e2label (guestfs_h *handle,
		const char *device);

This returns the ext2/3/4 filesystem label of the filesystem on
C<device>.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_get_e2uuid

 char *guestfs_get_e2uuid (guestfs_h *handle,
		const char *device);

This returns the ext2/3/4 filesystem UUID of the filesystem on
C<device>.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_get_memsize

 int guestfs_get_memsize (guestfs_h *handle);

This gets the memory size in megabytes allocated to the
qemu subprocess.

If C<guestfs_set_memsize> was not called
on this handle, and if C<LIBGUESTFS_MEMSIZE> was not set,
then this returns the compiled-in default value for memsize.

For more information on the architecture of libguestfs,
see L<guestfs(3)>.

On error this function returns -1.

=head2 guestfs_get_path

 const char *guestfs_get_path (guestfs_h *handle);

Return the current search path.

This is always non-NULL.  If it wasn't set already, then this will
return the default path.

This function returns a string, or NULL on error.
The string is owned by the guest handle and must I<not> be freed.

=head2 guestfs_get_pid

 int guestfs_get_pid (guestfs_h *handle);

Return the process ID of the qemu subprocess.  If there is no
qemu subprocess, then this will return an error.

This is an internal call used for debugging and testing.

On error this function returns -1.

=head2 guestfs_get_qemu

 const char *guestfs_get_qemu (guestfs_h *handle);

Return the current qemu binary.

This is always non-NULL.  If it wasn't set already, then this will
return the default qemu binary name.

This function returns a string, or NULL on error.
The string is owned by the guest handle and must I<not> be freed.

=head2 guestfs_get_recovery_proc

 int guestfs_get_recovery_proc (guestfs_h *handle);

Return the recovery process enabled flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_get_selinux

 int guestfs_get_selinux (guestfs_h *handle);

This returns the current setting of the selinux flag which
is passed to the appliance at boot time.  See C<guestfs_set_selinux>.

For more information on the architecture of libguestfs,
see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_get_state

 int guestfs_get_state (guestfs_h *handle);

This returns the current state as an opaque integer.  This is
only useful for printing debug and internal error messages.

For more information on states, see L<guestfs(3)>.

On error this function returns -1.

=head2 guestfs_get_trace

 int guestfs_get_trace (guestfs_h *handle);

Return the command trace flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_get_verbose

 int guestfs_get_verbose (guestfs_h *handle);

This returns the verbose messages flag.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_getcon

 char *guestfs_getcon (guestfs_h *handle);

This gets the SELinux security context of the daemon.

See the documentation about SELINUX in L<guestfs(3)>,
and C<guestfs_setcon>

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_getxattrs

 struct guestfs_xattr_list *guestfs_getxattrs (guestfs_h *handle,
		const char *path);

This call lists the extended attributes of the file or directory
C<path>.

At the system call level, this is a combination of the
L<listxattr(2)> and L<getxattr(2)> calls.

See also: C<guestfs_lgetxattrs>, L<attr(5)>.

This function returns a C<struct guestfs_xattr_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_xattr_list> after use>.

=head2 guestfs_glob_expand

 char **guestfs_glob_expand (guestfs_h *handle,
		const char *pattern);

This command searches for all the pathnames matching
C<pattern> according to the wildcard expansion rules
used by the shell.

If no paths match, then this returns an empty list
(note: not an error).

It is just a wrapper around the C L<glob(3)> function
with flags C<GLOB_MARK|GLOB_BRACE>.
See that manual page for more details.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_grep

 char **guestfs_grep (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<grep> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_grepi

 char **guestfs_grepi (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<grep -i> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_grub_install

 int guestfs_grub_install (guestfs_h *handle,
		const char *root,
		const char *device);

This command installs GRUB (the Grand Unified Bootloader) on
C<device>, with the root directory being C<root>.

This function returns 0 on success or -1 on error.

=head2 guestfs_head

 char **guestfs_head (guestfs_h *handle,
		const char *path);

This command returns up to the first 10 lines of a file as
a list of strings.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_head_n

 char **guestfs_head_n (guestfs_h *handle,
		int nrlines,
		const char *path);

If the parameter C<nrlines> is a positive number, this returns the first
C<nrlines> lines of the file C<path>.

If the parameter C<nrlines> is a negative number, this returns lines
from the file C<path>, excluding the last C<nrlines> lines.

If the parameter C<nrlines> is zero, this returns an empty list.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_hexdump

 char *guestfs_hexdump (guestfs_h *handle,
		const char *path);

This runs C<hexdump -C> on the given C<path>.  The result is
the human-readable, canonical hex dump of the file.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_initrd_cat

 char *guestfs_initrd_cat (guestfs_h *handle,
		const char *initrdpath,
		const char *filename,
		size_t *size_r);

This command unpacks the file C<filename> from the initrd file
called C<initrdpath>.  The filename must be given I<without> the
initial C</> character.

For example, in guestfish you could use the following command
to examine the boot script (usually called C</init>)
contained in a Linux initrd or initramfs image:

 initrd-cat /boot/initrd-<version>.img init

See also C<guestfs_initrd_list>.

This function returns a buffer, or NULL on error.
The size of the returned buffer is written to C<*size_r>.
I<The caller must free the returned buffer after use>.

=head2 guestfs_initrd_list

 char **guestfs_initrd_list (guestfs_h *handle,
		const char *path);

This command lists out files contained in an initrd.

The files are listed without any initial C</> character.  The
files are listed in the order they appear (not necessarily
alphabetical).  Directory names are listed as separate items.

Old Linux kernels (2.4 and earlier) used a compressed ext2
filesystem as initrd.  We I<only> support the newer initramfs
format (compressed cpio files).

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_inotify_add_watch

 int64_t guestfs_inotify_add_watch (guestfs_h *handle,
		const char *path,
		int mask);

Watch C<path> for the events listed in C<mask>.

Note that if C<path> is a directory then events within that
directory are watched, but this does I<not> happen recursively
(in subdirectories).

Note for non-C or non-Linux callers: the inotify events are
defined by the Linux kernel ABI and are listed in
C</usr/include/sys/inotify.h>.

On error this function returns -1.

=head2 guestfs_inotify_close

 int guestfs_inotify_close (guestfs_h *handle);

This closes the inotify handle which was previously
opened by inotify_init.  It removes all watches, throws
away any pending events, and deallocates all resources.

This function returns 0 on success or -1 on error.

=head2 guestfs_inotify_files

 char **guestfs_inotify_files (guestfs_h *handle);

This function is a helpful wrapper around C<guestfs_inotify_read>
which just returns a list of pathnames of objects that were
touched.  The returned pathnames are sorted and deduplicated.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_inotify_init

 int guestfs_inotify_init (guestfs_h *handle,
		int maxevents);

This command creates a new inotify handle.
The inotify subsystem can be used to notify events which happen to
objects in the guest filesystem.

C<maxevents> is the maximum number of events which will be
queued up between calls to C<guestfs_inotify_read> or
C<guestfs_inotify_files>.
If this is passed as C<0>, then the kernel (or previously set)
default is used.  For Linux 2.6.29 the default was 16384 events.
Beyond this limit, the kernel throws away events, but records
the fact that it threw them away by setting a flag
C<IN_Q_OVERFLOW> in the returned structure list (see
C<guestfs_inotify_read>).

Before any events are generated, you have to add some
watches to the internal watch list.  See:
C<guestfs_inotify_add_watch>,
C<guestfs_inotify_rm_watch> and
C<guestfs_inotify_watch_all>.

Queued up events should be read periodically by calling
C<guestfs_inotify_read>
(or C<guestfs_inotify_files> which is just a helpful
wrapper around C<guestfs_inotify_read>).  If you don't
read the events out often enough then you risk the internal
queue overflowing.

The handle should be closed after use by calling
C<guestfs_inotify_close>.  This also removes any
watches automatically.

See also L<inotify(7)> for an overview of the inotify interface
as exposed by the Linux kernel, which is roughly what we expose
via libguestfs.  Note that there is one global inotify handle
per libguestfs instance.

This function returns 0 on success or -1 on error.

=head2 guestfs_inotify_read

 struct guestfs_inotify_event_list *guestfs_inotify_read (guestfs_h *handle);

Return the complete queue of events that have happened
since the previous read call.

If no events have happened, this returns an empty list.

I<Note>: In order to make sure that all events have been
read, you must call this function repeatedly until it
returns an empty list.  The reason is that the call will
read events up to the maximum appliance-to-host message
size and leave remaining events in the queue.

This function returns a C<struct guestfs_inotify_event_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_inotify_event_list> after use>.

=head2 guestfs_inotify_rm_watch

 int guestfs_inotify_rm_watch (guestfs_h *handle,
		int wd);

Remove a previously defined inotify watch.
See C<guestfs_inotify_add_watch>.

This function returns 0 on success or -1 on error.

=head2 guestfs_is_busy

 int guestfs_is_busy (guestfs_h *handle);

This returns true iff this handle is busy processing a command
(in the C<BUSY> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_config

 int guestfs_is_config (guestfs_h *handle);

This returns true iff this handle is being configured
(in the C<CONFIG> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_dir

 int guestfs_is_dir (guestfs_h *handle,
		const char *path);

This returns C<true> if and only if there is a directory
with the given C<path> name.  Note that it returns false for
other objects like files.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_file

 int guestfs_is_file (guestfs_h *handle,
		const char *path);

This returns C<true> if and only if there is a file
with the given C<path> name.  Note that it returns false for
other objects like directories.

See also C<guestfs_stat>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_launching

 int guestfs_is_launching (guestfs_h *handle);

This returns true iff this handle is launching the subprocess
(in the C<LAUNCHING> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_is_ready

 int guestfs_is_ready (guestfs_h *handle);

This returns true iff this handle is ready to accept commands
(in the C<READY> state).

For more information on states, see L<guestfs(3)>.

This function returns a C truth value on success or -1 on error.

=head2 guestfs_kill_subprocess

 int guestfs_kill_subprocess (guestfs_h *handle);

This kills the qemu subprocess.  You should never need to call this.

This function returns 0 on success or -1 on error.

=head2 guestfs_launch

 int guestfs_launch (guestfs_h *handle);

Internally libguestfs is implemented by running a virtual machine
using L<qemu(1)>.

You should call this after configuring the handle
(eg. adding drives) but before performing any actions.

This function returns 0 on success or -1 on error.

=head2 guestfs_lchown

 int guestfs_lchown (guestfs_h *handle,
		int owner,
		int group,
		const char *path);

Change the file owner to C<owner> and group to C<group>.
This is like C<guestfs_chown> but if C<path> is a symlink then
the link itself is changed, not the target.

Only numeric uid and gid are supported.  If you want to use
names, you will need to locate and parse the password file
yourself (Augeas support makes this relatively easy).

This function returns 0 on success or -1 on error.

=head2 guestfs_lgetxattrs

 struct guestfs_xattr_list *guestfs_lgetxattrs (guestfs_h *handle,
		const char *path);

This is the same as C<guestfs_getxattrs>, but if C<path>
is a symbolic link, then it returns the extended attributes
of the link itself.

This function returns a C<struct guestfs_xattr_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_xattr_list> after use>.

=head2 guestfs_list_devices

 char **guestfs_list_devices (guestfs_h *handle);

List all the block devices.

The full block device names are returned, eg. C</dev/sda>

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_list_partitions

 char **guestfs_list_partitions (guestfs_h *handle);

List all the partitions detected on all block devices.

The full partition device names are returned, eg. C</dev/sda1>

This does not return logical volumes.  For that you will need to
call C<guestfs_lvs>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_ll

 char *guestfs_ll (guestfs_h *handle,
		const char *directory);

List the files in C<directory> (relative to the root directory,
there is no cwd) in the format of 'ls -la'.

This command is mostly useful for interactive sessions.  It
is I<not> intended that you try to parse the output string.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_ln

 int guestfs_ln (guestfs_h *handle,
		const char *target,
		const char *linkname);

This command creates a hard link using the C<ln> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_ln_f

 int guestfs_ln_f (guestfs_h *handle,
		const char *target,
		const char *linkname);

This command creates a hard link using the C<ln -f> command.
The C<-f> option removes the link (C<linkname>) if it exists already.

This function returns 0 on success or -1 on error.

=head2 guestfs_ln_s

 int guestfs_ln_s (guestfs_h *handle,
		const char *target,
		const char *linkname);

This command creates a symbolic link using the C<ln -s> command.

This function returns 0 on success or -1 on error.

=head2 guestfs_ln_sf

 int guestfs_ln_sf (guestfs_h *handle,
		const char *target,
		const char *linkname);

This command creates a symbolic link using the C<ln -sf> command,
The C<-f> option removes the link (C<linkname>) if it exists already.

This function returns 0 on success or -1 on error.

=head2 guestfs_lremovexattr

 int guestfs_lremovexattr (guestfs_h *handle,
		const char *xattr,
		const char *path);

This is the same as C<guestfs_removexattr>, but if C<path>
is a symbolic link, then it removes an extended attribute
of the link itself.

This function returns 0 on success or -1 on error.

=head2 guestfs_ls

 char **guestfs_ls (guestfs_h *handle,
		const char *directory);

List the files in C<directory> (relative to the root directory,
there is no cwd).  The '.' and '..' entries are not returned, but
hidden files are shown.

This command is mostly useful for interactive sessions.  Programs
should probably use C<guestfs_readdir> instead.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_lsetxattr

 int guestfs_lsetxattr (guestfs_h *handle,
		const char *xattr,
		const char *val,
		int vallen,
		const char *path);

This is the same as C<guestfs_setxattr>, but if C<path>
is a symbolic link, then it sets an extended attribute
of the link itself.

This function returns 0 on success or -1 on error.

=head2 guestfs_lstat

 struct guestfs_stat *guestfs_lstat (guestfs_h *handle,
		const char *path);

Returns file information for the given C<path>.

This is the same as C<guestfs_stat> except that if C<path>
is a symbolic link, then the link is stat-ed, not the file it
refers to.

This is the same as the C<lstat(2)> system call.

This function returns a C<struct guestfs_stat *>,
or NULL if there was an error.
I<The caller must call C<guestfs_free_stat> after use>.

=head2 guestfs_lstatlist

 struct guestfs_stat_list *guestfs_lstatlist (guestfs_h *handle,
		const char *path,
		char *const *names);

This call allows you to perform the C<guestfs_lstat> operation
on multiple files, where all files are in the directory C<path>.
C<names> is the list of files from this directory.

On return you get a list of stat structs, with a one-to-one
correspondence to the C<names> list.  If any name did not exist
or could not be lstat'd, then the C<ino> field of that structure
is set to C<-1>.

This call is intended for programs that want to efficiently
list a directory contents without making many round-trips.
See also C<guestfs_lxattrlist> for a similarly efficient call
for getting extended attributes.  Very long directory listings
might cause the protocol message size to be exceeded, causing
this call to fail.  The caller must split up such requests
into smaller groups of names.

This function returns a C<struct guestfs_stat_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_stat_list> after use>.

=head2 guestfs_lvcreate

 int guestfs_lvcreate (guestfs_h *handle,
		const char *logvol,
		const char *volgroup,
		int mbytes);

This creates an LVM volume group called C<logvol>
on the volume group C<volgroup>, with C<size> megabytes.

This function returns 0 on success or -1 on error.

=head2 guestfs_lvm_remove_all

 int guestfs_lvm_remove_all (guestfs_h *handle);

This command removes all LVM logical volumes, volume groups
and physical volumes.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_lvremove

 int guestfs_lvremove (guestfs_h *handle,
		const char *device);

Remove an LVM logical volume C<device>, where C<device> is
the path to the LV, such as C</dev/VG/LV>.

You can also remove all LVs in a volume group by specifying
the VG name, C</dev/VG>.

This function returns 0 on success or -1 on error.

=head2 guestfs_lvrename

 int guestfs_lvrename (guestfs_h *handle,
		const char *logvol,
		const char *newlogvol);

Rename a logical volume C<logvol> with the new name C<newlogvol>.

This function returns 0 on success or -1 on error.

=head2 guestfs_lvresize

 int guestfs_lvresize (guestfs_h *handle,
		const char *device,
		int mbytes);

This resizes (expands or shrinks) an existing LVM logical
volume to C<mbytes>.  When reducing, data in the reduced part
is lost.

This function returns 0 on success or -1 on error.

=head2 guestfs_lvs

 char **guestfs_lvs (guestfs_h *handle);

List all the logical volumes detected.  This is the equivalent
of the L<lvs(8)> command.

This returns a list of the logical volume device names
(eg. C</dev/VolGroup00/LogVol00>).

See also C<guestfs_lvs_full>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_lvs_full

 struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *handle);

List all the logical volumes detected.  This is the equivalent
of the L<lvs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_lv_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_lvm_lv_list> after use>.

=head2 guestfs_lxattrlist

 struct guestfs_xattr_list *guestfs_lxattrlist (guestfs_h *handle,
		const char *path,
		char *const *names);

This call allows you to get the extended attributes
of multiple files, where all files are in the directory C<path>.
C<names> is the list of files from this directory.

On return you get a flat list of xattr structs which must be
interpreted sequentially.  The first xattr struct always has a zero-length
C<attrname>.  C<attrval> in this struct is zero-length
to indicate there was an error doing C<lgetxattr> for this
file, I<or> is a C string which is a decimal number
(the number of following attributes for this file, which could
be C<"0">).  Then after the first xattr struct are the
zero or more attributes for the first named file.
This repeats for the second and subsequent files.

This call is intended for programs that want to efficiently
list a directory contents without making many round-trips.
See also C<guestfs_lstatlist> for a similarly efficient call
for getting standard stats.  Very long directory listings
might cause the protocol message size to be exceeded, causing
this call to fail.  The caller must split up such requests
into smaller groups of names.

This function returns a C<struct guestfs_xattr_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_xattr_list> after use>.

=head2 guestfs_mkdir

 int guestfs_mkdir (guestfs_h *handle,
		const char *path);

Create a directory named C<path>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkdir_mode

 int guestfs_mkdir_mode (guestfs_h *handle,
		const char *path,
		int mode);

This command creates a directory, setting the initial permissions
of the directory to C<mode>.  See also C<guestfs_mkdir>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkdir_p

 int guestfs_mkdir_p (guestfs_h *handle,
		const char *path);

Create a directory named C<path>, creating any parent directories
as necessary.  This is like the C<mkdir -p> shell command.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkdtemp

 char *guestfs_mkdtemp (guestfs_h *handle,
		const char *template);

This command creates a temporary directory.  The
C<template> parameter should be a full pathname for the
temporary directory name with the final six characters being
"XXXXXX".

For example: "/tmp/myprogXXXXXX" or "/Temp/myprogXXXXXX",
the second one being suitable for Windows filesystems.

The name of the temporary directory that was created
is returned.

The temporary directory is created with mode 0700
and is owned by root.

The caller is responsible for deleting the temporary
directory and its contents after use.

See also: L<mkdtemp(3)>

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_mke2fs_J

 int guestfs_mke2fs_J (guestfs_h *handle,
		const char *fstype,
		int blocksize,
		const char *device,
		const char *journal);

This creates an ext2/3/4 filesystem on C<device> with
an external journal on C<journal>.  It is equivalent
to the command:

 mke2fs -t fstype -b blocksize -J device=<journal> <device>

See also C<guestfs_mke2journal>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mke2fs_JL

 int guestfs_mke2fs_JL (guestfs_h *handle,
		const char *fstype,
		int blocksize,
		const char *device,
		const char *label);

This creates an ext2/3/4 filesystem on C<device> with
an external journal on the journal labeled C<label>.

See also C<guestfs_mke2journal_L>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mke2fs_JU

 int guestfs_mke2fs_JU (guestfs_h *handle,
		const char *fstype,
		int blocksize,
		const char *device,
		const char *uuid);

This creates an ext2/3/4 filesystem on C<device> with
an external journal on the journal with UUID C<uuid>.

See also C<guestfs_mke2journal_U>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mke2journal

 int guestfs_mke2journal (guestfs_h *handle,
		int blocksize,
		const char *device);

This creates an ext2 external journal on C<device>.  It is equivalent
to the command:

 mke2fs -O journal_dev -b blocksize device

This function returns 0 on success or -1 on error.

=head2 guestfs_mke2journal_L

 int guestfs_mke2journal_L (guestfs_h *handle,
		int blocksize,
		const char *label,
		const char *device);

This creates an ext2 external journal on C<device> with label C<label>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mke2journal_U

 int guestfs_mke2journal_U (guestfs_h *handle,
		int blocksize,
		const char *uuid,
		const char *device);

This creates an ext2 external journal on C<device> with UUID C<uuid>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkfifo

 int guestfs_mkfifo (guestfs_h *handle,
		int mode,
		const char *path);

This call creates a FIFO (named pipe) called C<path> with
mode C<mode>.  It is just a convenient wrapper around
C<guestfs_mknod>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkfs

 int guestfs_mkfs (guestfs_h *handle,
		const char *fstype,
		const char *device);

This creates a filesystem on C<device> (usually a partition
or LVM logical volume).  The filesystem type is C<fstype>, for
example C<ext3>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkfs_b

 int guestfs_mkfs_b (guestfs_h *handle,
		const char *fstype,
		int blocksize,
		const char *device);

This call is similar to C<guestfs_mkfs>, but it allows you to
control the block size of the resulting filesystem.  Supported
block sizes depend on the filesystem type, but typically they
are C<1024>, C<2048> or C<4096> only.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkmountpoint

 int guestfs_mkmountpoint (guestfs_h *handle,
		const char *exemptpath);

C<guestfs_mkmountpoint> and C<guestfs_rmmountpoint> are
specialized calls that can be used to create extra mountpoints
before mounting the first filesystem.

These calls are I<only> necessary in some very limited circumstances,
mainly the case where you want to mount a mix of unrelated and/or
read-only filesystems together.

For example, live CDs often contain a "Russian doll" nest of
filesystems, an ISO outer layer, with a squashfs image inside, with
an ext2/3 image inside that.  You can unpack this as follows
in guestfish:

 add-ro Fedora-11-i686-Live.iso
 run
 mkmountpoint /cd
 mkmountpoint /squash
 mkmountpoint /ext3
 mount /dev/sda /cd
 mount-loop /cd/LiveOS/squashfs.img /squash
 mount-loop /squash/LiveOS/ext3fs.img /ext3

The inner filesystem is now unpacked under the /ext3 mountpoint.

This function returns 0 on success or -1 on error.

=head2 guestfs_mknod

 int guestfs_mknod (guestfs_h *handle,
		int mode,
		int devmajor,
		int devminor,
		const char *path);

This call creates block or character special devices, or
named pipes (FIFOs).

The C<mode> parameter should be the mode, using the standard
constants.  C<devmajor> and C<devminor> are the
device major and minor numbers, only used when creating block
and character special devices.

This function returns 0 on success or -1 on error.

=head2 guestfs_mknod_b

 int guestfs_mknod_b (guestfs_h *handle,
		int mode,
		int devmajor,
		int devminor,
		const char *path);

This call creates a block device node called C<path> with
mode C<mode> and device major/minor C<devmajor> and C<devminor>.
It is just a convenient wrapper around C<guestfs_mknod>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mknod_c

 int guestfs_mknod_c (guestfs_h *handle,
		int mode,
		int devmajor,
		int devminor,
		const char *path);

This call creates a char device node called C<path> with
mode C<mode> and device major/minor C<devmajor> and C<devminor>.
It is just a convenient wrapper around C<guestfs_mknod>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkswap

 int guestfs_mkswap (guestfs_h *handle,
		const char *device);

Create a swap partition on C<device>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkswap_L

 int guestfs_mkswap_L (guestfs_h *handle,
		const char *label,
		const char *device);

Create a swap partition on C<device> with label C<label>.

Note that you cannot attach a swap label to a block device
(eg. C</dev/sda>), just to a partition.  This appears to be
a limitation of the kernel or swap tools.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkswap_U

 int guestfs_mkswap_U (guestfs_h *handle,
		const char *uuid,
		const char *device);

Create a swap partition on C<device> with UUID C<uuid>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mkswap_file

 int guestfs_mkswap_file (guestfs_h *handle,
		const char *path);

Create a swap file.

This command just writes a swap file signature to an existing
file.  To create the file itself, use something like C<guestfs_fallocate>.

This function returns 0 on success or -1 on error.

=head2 guestfs_modprobe

 int guestfs_modprobe (guestfs_h *handle,
		const char *modulename);

This loads a kernel module in the appliance.

The kernel module must have been whitelisted when libguestfs
was built (see C<appliance/kmod.whitelist.in> in the source).

This function returns 0 on success or -1 on error.

=head2 guestfs_mount

 int guestfs_mount (guestfs_h *handle,
		const char *device,
		const char *mountpoint);

Mount a guest disk at a position in the filesystem.  Block devices
are named C</dev/sda>, C</dev/sdb> and so on, as they were added to
the guest.  If those block devices contain partitions, they will have
the usual names (eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style
names can be used.

The rules are the same as for L<mount(2)>:  A filesystem must
first be mounted on C</> before others can be mounted.  Other
filesystems can only be mounted on directories which already
exist.

The mounted filesystem is writable, if we have sufficient permissions
on the underlying device.

The filesystem options C<sync> and C<noatime> are set with this
call, in order to improve reliability.

This function returns 0 on success or -1 on error.

=head2 guestfs_mount_loop

 int guestfs_mount_loop (guestfs_h *handle,
		const char *file,
		const char *mountpoint);

This command lets you mount C<file> (a filesystem image
in a file) on a mount point.  It is entirely equivalent to
the command C<mount -o loop file mountpoint>.

This function returns 0 on success or -1 on error.

=head2 guestfs_mount_options

 int guestfs_mount_options (guestfs_h *handle,
		const char *options,
		const char *device,
		const char *mountpoint);

This is the same as the C<guestfs_mount> command, but it
allows you to set the mount options as for the
L<mount(8)> I<-o> flag.

This function returns 0 on success or -1 on error.

=head2 guestfs_mount_ro

 int guestfs_mount_ro (guestfs_h *handle,
		const char *device,
		const char *mountpoint);

This is the same as the C<guestfs_mount> command, but it
mounts the filesystem with the read-only (I<-o ro>) flag.

This function returns 0 on success or -1 on error.

=head2 guestfs_mount_vfs

 int guestfs_mount_vfs (guestfs_h *handle,
		const char *options,
		const char *vfstype,
		const char *device,
		const char *mountpoint);

This is the same as the C<guestfs_mount> command, but it
allows you to set both the mount options and the vfstype
as for the L<mount(8)> I<-o> and I<-t> flags.

This function returns 0 on success or -1 on error.

=head2 guestfs_mountpoints

 char **guestfs_mountpoints (guestfs_h *handle);

This call is similar to C<guestfs_mounts>.  That call returns
a list of devices.  This one returns a hash table (map) of
device name to directory where the device is mounted.

This function returns a NULL-terminated array of
strings, or NULL if there was an error.
The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.
I<The caller must free the strings and the array after use>.

=head2 guestfs_mounts

 char **guestfs_mounts (guestfs_h *handle);

This returns the list of currently mounted filesystems.  It returns
the list of devices (eg. C</dev/sda1>, C</dev/VG/LV>).

Some internal mounts are not shown.

See also: C<guestfs_mountpoints>

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_mv

 int guestfs_mv (guestfs_h *handle,
		const char *src,
		const char *dest);

This moves a file from C<src> to C<dest> where C<dest> is
either a destination filename or destination directory.

This function returns 0 on success or -1 on error.

=head2 guestfs_ntfs_3g_probe

 int guestfs_ntfs_3g_probe (guestfs_h *handle,
		int rw,
		const char *device);

This command runs the L<ntfs-3g.probe(8)> command which probes
an NTFS C<device> for mountability.  (Not all NTFS volumes can
be mounted read-write, and some cannot be mounted at all).

C<rw> is a boolean flag.  Set it to true if you want to test
if the volume can be mounted read-write.  Set it to false if
you want to test if the volume can be mounted read-only.

The return value is an integer which C<0> if the operation
would succeed, or some non-zero value documented in the
L<ntfs-3g.probe(8)> manual page.

On error this function returns -1.

=head2 guestfs_part_add

 int guestfs_part_add (guestfs_h *handle,
		const char *device,
		const char *prlogex,
		int64_t startsect,
		int64_t endsect);

This command adds a partition to C<device>.  If there is no partition
table on the device, call C<guestfs_part_init> first.

The C<prlogex> parameter is the type of partition.  Normally you
should pass C<p> or C<primary> here, but MBR partition tables also
support C<l> (or C<logical>) and C<e> (or C<extended>) partition
types.

C<startsect> and C<endsect> are the start and end of the partition
in I<sectors>.  C<endsect> may be negative, which means it counts
backwards from the end of the disk (C<-1> is the last sector).

Creating a partition which covers the whole disk is not so easy.
Use C<guestfs_part_disk> to do that.

This function returns 0 on success or -1 on error.

=head2 guestfs_part_disk

 int guestfs_part_disk (guestfs_h *handle,
		const char *device,
		const char *parttype);

This command is simply a combination of C<guestfs_part_init>
followed by C<guestfs_part_add> to create a single primary partition
covering the whole disk.

C<parttype> is the partition table type, usually C<mbr> or C<gpt>,
but other possible values are described in C<guestfs_part_init>.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_part_get_parttype

 char *guestfs_part_get_parttype (guestfs_h *handle,
		const char *device);

This command examines the partition table on C<device> and
returns the partition table type (format) being used.

Common return values include: C<msdos> (a DOS/Windows style MBR
partition table), C<gpt> (a GPT/EFI-style partition table).  Other
values are possible, although unusual.  See C<guestfs_part_init>
for a full list.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_part_init

 int guestfs_part_init (guestfs_h *handle,
		const char *device,
		const char *parttype);

This creates an empty partition table on C<device> of one of the
partition types listed below.  Usually C<parttype> should be
either C<msdos> or C<gpt> (for large disks).

Initially there are no partitions.  Following this, you should
call C<guestfs_part_add> for each partition required.

Possible values for C<parttype> are:

=over 4

=item B<efi> | B<gpt>

Intel EFI / GPT partition table.

This is recommended for >= 2 TB partitions that will be accessed
from Linux and Intel-based Mac OS X.  It also has limited backwards
compatibility with the C<mbr> format.

=item B<mbr> | B<msdos>

The standard PC "Master Boot Record" (MBR) format used
by MS-DOS and Windows.  This partition type will B<only> work
for device sizes up to 2 TB.  For large disks we recommend
using C<gpt>.

=back

Other partition table types that may work but are not
supported include:

=over 4

=item B<aix>

AIX disk labels.

=item B<amiga> | B<rdb>

Amiga "Rigid Disk Block" format.

=item B<bsd>

BSD disk labels.

=item B<dasd>

DASD, used on IBM mainframes.

=item B<dvh>

MIPS/SGI volumes.

=item B<mac>

Old Mac partition format.  Modern Macs use C<gpt>.

=item B<pc98>

NEC PC-98 format, common in Japan apparently.

=item B<sun>

Sun disk labels.

=back

This function returns 0 on success or -1 on error.

=head2 guestfs_part_list

 struct guestfs_partition_list *guestfs_part_list (guestfs_h *handle,
		const char *device);

This command parses the partition table on C<device> and
returns the list of partitions found.

The fields in the returned structure are:

=over 4

=item B<part_num>

Partition number, counting from 1.

=item B<part_start>

Start of the partition I<in bytes>.  To get sectors you have to
divide by the device's sector size, see C<guestfs_blockdev_getss>.

=item B<part_end>

End of the partition in bytes.

=item B<part_size>

Size of the partition in bytes.

=back

This function returns a C<struct guestfs_partition_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_partition_list> after use>.

=head2 guestfs_part_set_bootable

 int guestfs_part_set_bootable (guestfs_h *handle,
		const char *device,
		int partnum,
		int bootable);

This sets the bootable flag on partition numbered C<partnum> on
device C<device>.  Note that partitions are numbered from 1.

The bootable flag is used by some PC BIOSes to determine which
partition to boot from.  It is by no means universally recognized,
and in any case if your operating system installed a boot
sector on the device itself, then that takes precedence.

This function returns 0 on success or -1 on error.

=head2 guestfs_part_set_name

 int guestfs_part_set_name (guestfs_h *handle,
		const char *device,
		int partnum,
		const char *name);

This sets the partition name on partition numbered C<partnum> on
device C<device>.  Note that partitions are numbered from 1.

The partition name can only be set on certain types of partition
table.  This works on C<gpt> but not on C<mbr> partitions.

This function returns 0 on success or -1 on error.

=head2 guestfs_ping_daemon

 int guestfs_ping_daemon (guestfs_h *handle);

This is a test probe into the guestfs daemon running inside
the qemu subprocess.  Calling this function checks that the
daemon responds to the ping message, without affecting the daemon
or attached block device(s) in any other way.

This function returns 0 on success or -1 on error.

=head2 guestfs_pread

 char *guestfs_pread (guestfs_h *handle,
		const char *path,
		int count,
		int64_t offset,
		size_t *size_r);

This command lets you read part of a file.  It reads C<count>
bytes of the file, starting at C<offset>, from file C<path>.

This may read fewer bytes than requested.  For further details
see the L<pread(2)> system call.

This function returns a buffer, or NULL on error.
The size of the returned buffer is written to C<*size_r>.
I<The caller must free the returned buffer after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_pvcreate

 int guestfs_pvcreate (guestfs_h *handle,
		const char *device);

This creates an LVM physical volume on the named C<device>,
where C<device> should usually be a partition name such
as C</dev/sda1>.

This function returns 0 on success or -1 on error.

=head2 guestfs_pvremove

 int guestfs_pvremove (guestfs_h *handle,
		const char *device);

This wipes a physical volume C<device> so that LVM will no longer
recognise it.

The implementation uses the C<pvremove> command which refuses to
wipe physical volumes that contain any volume groups, so you have
to remove those first.

This function returns 0 on success or -1 on error.

=head2 guestfs_pvresize

 int guestfs_pvresize (guestfs_h *handle,
		const char *device);

This resizes (expands or shrinks) an existing LVM physical
volume to match the new size of the underlying device.

This function returns 0 on success or -1 on error.

=head2 guestfs_pvs

 char **guestfs_pvs (guestfs_h *handle);

List all the physical volumes detected.  This is the equivalent
of the L<pvs(8)> command.

This returns a list of just the device names that contain
PVs (eg. C</dev/sda2>).

See also C<guestfs_pvs_full>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_pvs_full

 struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *handle);

List all the physical volumes detected.  This is the equivalent
of the L<pvs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_pv_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_lvm_pv_list> after use>.

=head2 guestfs_read_file

 char *guestfs_read_file (guestfs_h *handle,
		const char *path,
		size_t *size_r);

This calls returns the contents of the file C<path> as a
buffer.

Unlike C<guestfs_cat>, this function can correctly
handle files that contain embedded ASCII NUL characters.
However unlike C<guestfs_download>, this function is limited
in the total size of file that can be handled.

This function returns a buffer, or NULL on error.
The size of the returned buffer is written to C<*size_r>.
I<The caller must free the returned buffer after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_read_lines

 char **guestfs_read_lines (guestfs_h *handle,
		const char *path);

Return the contents of the file named C<path>.

The file contents are returned as a list of lines.  Trailing
C<LF> and C<CRLF> character sequences are I<not> returned.

Note that this function cannot correctly handle binary files
(specifically, files containing C<\0> character which is treated
as end of line).  For those you need to use the C<guestfs_read_file>
function which has a more complex interface.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_readdir

 struct guestfs_dirent_list *guestfs_readdir (guestfs_h *handle,
		const char *dir);

This returns the list of directory entries in directory C<dir>.

All entries in the directory are returned, including C<.> and
C<..>.  The entries are I<not> sorted, but returned in the same
order as the underlying filesystem.

Also this call returns basic file type information about each
file.  The C<ftyp> field will contain one of the following characters:

=over 4

=item 'b'

Block special

=item 'c'

Char special

=item 'd'

Directory

=item 'f'

FIFO (named pipe)

=item 'l'

Symbolic link

=item 'r'

Regular file

=item 's'

Socket

=item 'u'

Unknown file type

=item '?'

The L<readdir(3)> returned a C<d_type> field with an
unexpected value

=back

This function is primarily intended for use by programs.  To
get a simple list of names, use C<guestfs_ls>.  To get a printable
directory for human consumption, use C<guestfs_ll>.

This function returns a C<struct guestfs_dirent_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_dirent_list> after use>.

=head2 guestfs_readlink

 char *guestfs_readlink (guestfs_h *handle,
		const char *path);

This command reads the target of a symbolic link.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_readlinklist

 char **guestfs_readlinklist (guestfs_h *handle,
		const char *path,
		char *const *names);

This call allows you to do a C<readlink> operation
on multiple files, where all files are in the directory C<path>.
C<names> is the list of files from this directory.

On return you get a list of strings, with a one-to-one
correspondence to the C<names> list.  Each string is the
value of the symbol link.

If the C<readlink(2)> operation fails on any name, then
the corresponding result string is the empty string C<"">.
However the whole operation is completed even if there
were C<readlink(2)> errors, and so you can call this
function with names where you don't know if they are
symbolic links already (albeit slightly less efficient).

This call is intended for programs that want to efficiently
list a directory contents without making many round-trips.
Very long directory listings might cause the protocol
message size to be exceeded, causing
this call to fail.  The caller must split up such requests
into smaller groups of names.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_realpath

 char *guestfs_realpath (guestfs_h *handle,
		const char *path);

Return the canonicalized absolute pathname of C<path>.  The
returned path has no C<.>, C<..> or symbolic link path elements.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_removexattr

 int guestfs_removexattr (guestfs_h *handle,
		const char *xattr,
		const char *path);

This call removes the extended attribute named C<xattr>
of the file C<path>.

See also: C<guestfs_lremovexattr>, L<attr(5)>.

This function returns 0 on success or -1 on error.

=head2 guestfs_resize2fs

 int guestfs_resize2fs (guestfs_h *handle,
		const char *device);

This resizes an ext2 or ext3 filesystem to match the size of
the underlying device.

I<Note:> It is sometimes required that you run C<guestfs_e2fsck_f>
on the C<device> before calling this command.  For unknown reasons
C<resize2fs> sometimes gives an error about this and sometimes not.
In any case, it is always safe to call C<guestfs_e2fsck_f> before
calling this function.

This function returns 0 on success or -1 on error.

=head2 guestfs_rm

 int guestfs_rm (guestfs_h *handle,
		const char *path);

Remove the single file C<path>.

This function returns 0 on success or -1 on error.

=head2 guestfs_rm_rf

 int guestfs_rm_rf (guestfs_h *handle,
		const char *path);

Remove the file or directory C<path>, recursively removing the
contents if its a directory.  This is like the C<rm -rf> shell
command.

This function returns 0 on success or -1 on error.

=head2 guestfs_rmdir

 int guestfs_rmdir (guestfs_h *handle,
		const char *path);

Remove the single directory C<path>.

This function returns 0 on success or -1 on error.

=head2 guestfs_rmmountpoint

 int guestfs_rmmountpoint (guestfs_h *handle,
		const char *exemptpath);

This calls removes a mountpoint that was previously created
with C<guestfs_mkmountpoint>.  See C<guestfs_mkmountpoint>
for full details.

This function returns 0 on success or -1 on error.

=head2 guestfs_scrub_device

 int guestfs_scrub_device (guestfs_h *handle,
		const char *device);

This command writes patterns over C<device> to make data retrieval
more difficult.

It is an interface to the L<scrub(1)> program.  See that
manual page for more details.

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_scrub_file

 int guestfs_scrub_file (guestfs_h *handle,
		const char *file);

This command writes patterns over a file to make data retrieval
more difficult.

The file is I<removed> after scrubbing.

It is an interface to the L<scrub(1)> program.  See that
manual page for more details.

This function returns 0 on success or -1 on error.

=head2 guestfs_scrub_freespace

 int guestfs_scrub_freespace (guestfs_h *handle,
		const char *dir);

This command creates the directory C<dir> and then fills it
with files until the filesystem is full, and scrubs the files
as for C<guestfs_scrub_file>, and deletes them.
The intention is to scrub any free space on the partition
containing C<dir>.

It is an interface to the L<scrub(1)> program.  See that
manual page for more details.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_append

 int guestfs_set_append (guestfs_h *handle,
		const char *append);

This function is used to add additional options to the
guest kernel command line.

The default is C<NULL> unless overridden by setting
C<LIBGUESTFS_APPEND> environment variable.

Setting C<append> to C<NULL> means I<no> additional options
are passed (libguestfs always adds a few of its own).

This function returns 0 on success or -1 on error.

=head2 guestfs_set_autosync

 int guestfs_set_autosync (guestfs_h *handle,
		int autosync);

If C<autosync> is true, this enables autosync.  Libguestfs will make a
best effort attempt to run C<guestfs_umount_all> followed by
C<guestfs_sync> when the handle is closed
(also if the program exits without closing handles).

This is disabled by default (except in guestfish where it is
enabled by default).

This function returns 0 on success or -1 on error.

=head2 guestfs_set_direct

 int guestfs_set_direct (guestfs_h *handle,
		int direct);

If the direct appliance mode flag is enabled, then stdin and
stdout are passed directly through to the appliance once it
is launched.

One consequence of this is that log messages aren't caught
by the library and handled by C<guestfs_set_log_message_callback>,
but go straight to stdout.

You probably don't want to use this unless you know what you
are doing.

The default is disabled.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_e2label

 int guestfs_set_e2label (guestfs_h *handle,
		const char *device,
		const char *label);

This sets the ext2/3/4 filesystem label of the filesystem on
C<device> to C<label>.  Filesystem labels are limited to
16 characters.

You can use either C<guestfs_tune2fs_l> or C<guestfs_get_e2label>
to return the existing label on a filesystem.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_e2uuid

 int guestfs_set_e2uuid (guestfs_h *handle,
		const char *device,
		const char *uuid);

This sets the ext2/3/4 filesystem UUID of the filesystem on
C<device> to C<uuid>.  The format of the UUID and alternatives
such as C<clear>, C<random> and C<time> are described in the
L<tune2fs(8)> manpage.

You can use either C<guestfs_tune2fs_l> or C<guestfs_get_e2uuid>
to return the existing UUID of a filesystem.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_memsize

 int guestfs_set_memsize (guestfs_h *handle,
		int memsize);

This sets the memory size in megabytes allocated to the
qemu subprocess.  This only has any effect if called before
C<guestfs_launch>.

You can also change this by setting the environment
variable C<LIBGUESTFS_MEMSIZE> before the handle is
created.

For more information on the architecture of libguestfs,
see L<guestfs(3)>.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_path

 int guestfs_set_path (guestfs_h *handle,
		const char *searchpath);

Set the path that libguestfs searches for kernel and initrd.img.

The default is C<$libdir/guestfs> unless overridden by setting
C<LIBGUESTFS_PATH> environment variable.

Setting C<path> to C<NULL> restores the default path.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_qemu

 int guestfs_set_qemu (guestfs_h *handle,
		const char *qemu);

Set the qemu binary that we will use.

The default is chosen when the library was compiled by the
configure script.

You can also override this by setting the C<LIBGUESTFS_QEMU>
environment variable.

Setting C<qemu> to C<NULL> restores the default qemu binary.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_recovery_proc

 int guestfs_set_recovery_proc (guestfs_h *handle,
		int recoveryproc);

If this is called with the parameter C<false> then
C<guestfs_launch> does not create a recovery process.  The
purpose of the recovery process is to stop runaway qemu
processes in the case where the main program aborts abruptly.

This only has any effect if called before C<guestfs_launch>,
and the default is true.

About the only time when you would want to disable this is
if the main process will fork itself into the background
("daemonize" itself).  In this case the recovery process
thinks that the main program has disappeared and so kills
qemu, which is not very helpful.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_selinux

 int guestfs_set_selinux (guestfs_h *handle,
		int selinux);

This sets the selinux flag that is passed to the appliance
at boot time.  The default is C<selinux=0> (disabled).

Note that if SELinux is enabled, it is always in
Permissive mode (C<enforcing=0>).

For more information on the architecture of libguestfs,
see L<guestfs(3)>.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_trace

 int guestfs_set_trace (guestfs_h *handle,
		int trace);

If the command trace flag is set to 1, then commands are
printed on stdout before they are executed in a format
which is very similar to the one used by guestfish.  In
other words, you can run a program with this enabled, and
you will get out a script which you can feed to guestfish
to perform the same set of actions.

If you want to trace C API calls into libguestfs (and
other libraries) then possibly a better way is to use
the external ltrace(1) command.

Command traces are disabled unless the environment variable
C<LIBGUESTFS_TRACE> is defined and set to C<1>.

This function returns 0 on success or -1 on error.

=head2 guestfs_set_verbose

 int guestfs_set_verbose (guestfs_h *handle,
		int verbose);

If C<verbose> is true, this turns on verbose messages (to C<stderr>).

Verbose messages are disabled unless the environment variable
C<LIBGUESTFS_DEBUG> is defined and set to C<1>.

This function returns 0 on success or -1 on error.

=head2 guestfs_setcon

 int guestfs_setcon (guestfs_h *handle,
		const char *context);

This sets the SELinux security context of the daemon
to the string C<context>.

See the documentation about SELINUX in L<guestfs(3)>.

This function returns 0 on success or -1 on error.

=head2 guestfs_setxattr

 int guestfs_setxattr (guestfs_h *handle,
		const char *xattr,
		const char *val,
		int vallen,
		const char *path);

This call sets the extended attribute named C<xattr>
of the file C<path> to the value C<val> (of length C<vallen>).
The value is arbitrary 8 bit data.

See also: C<guestfs_lsetxattr>, L<attr(5)>.

This function returns 0 on success or -1 on error.

=head2 guestfs_sfdisk

 int guestfs_sfdisk (guestfs_h *handle,
		const char *device,
		int cyls,
		int heads,
		int sectors,
		char *const *lines);

This is a direct interface to the L<sfdisk(8)> program for creating
partitions on block devices.

C<device> should be a block device, for example C</dev/sda>.

C<cyls>, C<heads> and C<sectors> are the number of cylinders, heads
and sectors on the device, which are passed directly to sfdisk as
the I<-C>, I<-H> and I<-S> parameters.  If you pass C<0> for any
of these, then the corresponding parameter is omitted.  Usually for
'large' disks, you can just pass C<0> for these, but for small
(floppy-sized) disks, sfdisk (or rather, the kernel) cannot work
out the right geometry and you will need to tell it.

C<lines> is a list of lines that we feed to C<sfdisk>.  For more
information refer to the L<sfdisk(8)> manpage.

To create a single partition occupying the whole disk, you would
pass C<lines> as a single element list, when the single element being
the string C<,> (comma).

See also: C<guestfs_sfdisk_l>, C<guestfs_sfdisk_N>,
C<guestfs_part_init>

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_sfdiskM

 int guestfs_sfdiskM (guestfs_h *handle,
		const char *device,
		char *const *lines);

This is a simplified interface to the C<guestfs_sfdisk>
command, where partition sizes are specified in megabytes
only (rounded to the nearest cylinder) and you don't need
to specify the cyls, heads and sectors parameters which
were rarely if ever used anyway.

See also: C<guestfs_sfdisk>, the L<sfdisk(8)> manpage
and C<guestfs_part_disk>

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_sfdisk_N

 int guestfs_sfdisk_N (guestfs_h *handle,
		const char *device,
		int partnum,
		int cyls,
		int heads,
		int sectors,
		const char *line);

This runs L<sfdisk(8)> option to modify just the single
partition C<n> (note: C<n> counts from 1).

For other parameters, see C<guestfs_sfdisk>.  You should usually
pass C<0> for the cyls/heads/sectors parameters.

See also: C<guestfs_part_add>

This function returns 0 on success or -1 on error.

B<This command is dangerous.  Without careful use you
can easily destroy all your data>.

=head2 guestfs_sfdisk_disk_geometry

 char *guestfs_sfdisk_disk_geometry (guestfs_h *handle,
		const char *device);

This displays the disk geometry of C<device> read from the
partition table.  Especially in the case where the underlying
block device has been resized, this can be different from the
kernel's idea of the geometry (see C<guestfs_sfdisk_kernel_geometry>).

The result is in human-readable format, and not designed to
be parsed.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_sfdisk_kernel_geometry

 char *guestfs_sfdisk_kernel_geometry (guestfs_h *handle,
		const char *device);

This displays the kernel's idea of the geometry of C<device>.

The result is in human-readable format, and not designed to
be parsed.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_sfdisk_l

 char *guestfs_sfdisk_l (guestfs_h *handle,
		const char *device);

This displays the partition table on C<device>, in the
human-readable output of the L<sfdisk(8)> command.  It is
not intended to be parsed.

See also: C<guestfs_part_list>

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_sh

 char *guestfs_sh (guestfs_h *handle,
		const char *command);

This call runs a command from the guest filesystem via the
guest's C</bin/sh>.

This is like C<guestfs_command>, but passes the command to:

 /bin/sh -c "command"

Depending on the guest's shell, this usually results in
wildcards being expanded, shell expressions being interpolated
and so on.

All the provisos about C<guestfs_command> apply to this call.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_sh_lines

 char **guestfs_sh_lines (guestfs_h *handle,
		const char *command);

This is the same as C<guestfs_sh>, but splits the result
into a list of lines.

See also: C<guestfs_command_lines>

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_sleep

 int guestfs_sleep (guestfs_h *handle,
		int secs);

Sleep for C<secs> seconds.

This function returns 0 on success or -1 on error.

=head2 guestfs_stat

 struct guestfs_stat *guestfs_stat (guestfs_h *handle,
		const char *path);

Returns file information for the given C<path>.

This is the same as the C<stat(2)> system call.

This function returns a C<struct guestfs_stat *>,
or NULL if there was an error.
I<The caller must call C<guestfs_free_stat> after use>.

=head2 guestfs_statvfs

 struct guestfs_statvfs *guestfs_statvfs (guestfs_h *handle,
		const char *path);

Returns file system statistics for any mounted file system.
C<path> should be a file or directory in the mounted file system
(typically it is the mount point itself, but it doesn't need to be).

This is the same as the C<statvfs(2)> system call.

This function returns a C<struct guestfs_statvfs *>,
or NULL if there was an error.
I<The caller must call C<guestfs_free_statvfs> after use>.

=head2 guestfs_strings

 char **guestfs_strings (guestfs_h *handle,
		const char *path);

This runs the L<strings(1)> command on a file and returns
the list of printable strings found.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_strings_e

 char **guestfs_strings_e (guestfs_h *handle,
		const char *encoding,
		const char *path);

This is like the C<guestfs_strings> command, but allows you to
specify the encoding.

See the L<strings(1)> manpage for the full list of encodings.

Commonly useful encodings are C<l> (lower case L) which will
show strings inside Windows/x86 files.

The returned strings are transcoded to UTF-8.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_swapoff_device

 int guestfs_swapoff_device (guestfs_h *handle,
		const char *device);

This command disables the libguestfs appliance swap
device or partition named C<device>.
See C<guestfs_swapon_device>.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapoff_file

 int guestfs_swapoff_file (guestfs_h *handle,
		const char *file);

This command disables the libguestfs appliance swap on file.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapoff_label

 int guestfs_swapoff_label (guestfs_h *handle,
		const char *label);

This command disables the libguestfs appliance swap on
labeled swap partition.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapoff_uuid

 int guestfs_swapoff_uuid (guestfs_h *handle,
		const char *uuid);

This command disables the libguestfs appliance swap partition
with the given UUID.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapon_device

 int guestfs_swapon_device (guestfs_h *handle,
		const char *device);

This command enables the libguestfs appliance to use the
swap device or partition named C<device>.  The increased
memory is made available for all commands, for example
those run using C<guestfs_command> or C<guestfs_sh>.

Note that you should not swap to existing guest swap
partitions unless you know what you are doing.  They may
contain hibernation information, or other information that
the guest doesn't want you to trash.  You also risk leaking
information about the host to the guest this way.  Instead,
attach a new host device to the guest and swap on that.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapon_file

 int guestfs_swapon_file (guestfs_h *handle,
		const char *file);

This command enables swap to a file.
See C<guestfs_swapon_device> for other notes.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapon_label

 int guestfs_swapon_label (guestfs_h *handle,
		const char *label);

This command enables swap to a labeled swap partition.
See C<guestfs_swapon_device> for other notes.

This function returns 0 on success or -1 on error.

=head2 guestfs_swapon_uuid

 int guestfs_swapon_uuid (guestfs_h *handle,
		const char *uuid);

This command enables swap to a swap partition with the given UUID.
See C<guestfs_swapon_device> for other notes.

This function returns 0 on success or -1 on error.

=head2 guestfs_sync

 int guestfs_sync (guestfs_h *handle);

This syncs the disk, so that any writes are flushed through to the
underlying disk image.

You should always call this if you have modified a disk image, before
closing the handle.

This function returns 0 on success or -1 on error.

=head2 guestfs_tail

 char **guestfs_tail (guestfs_h *handle,
		const char *path);

This command returns up to the last 10 lines of a file as
a list of strings.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_tail_n

 char **guestfs_tail_n (guestfs_h *handle,
		int nrlines,
		const char *path);

If the parameter C<nrlines> is a positive number, this returns the last
C<nrlines> lines of the file C<path>.

If the parameter C<nrlines> is a negative number, this returns lines
from the file C<path>, starting with the C<-nrlines>th line.

If the parameter C<nrlines> is zero, this returns an empty list.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_tar_in

 int guestfs_tar_in (guestfs_h *handle,
		const char *tarfile,
		const char *directory);

This command uploads and unpacks local file C<tarfile> (an
I<uncompressed> tar file) into C<directory>.

To upload a compressed tarball, use C<guestfs_tgz_in>.

This function returns 0 on success or -1 on error.

=head2 guestfs_tar_out

 int guestfs_tar_out (guestfs_h *handle,
		const char *directory,
		const char *tarfile);

This command packs the contents of C<directory> and downloads
it to local file C<tarfile>.

To download a compressed tarball, use C<guestfs_tgz_out>.

This function returns 0 on success or -1 on error.

=head2 guestfs_tgz_in

 int guestfs_tgz_in (guestfs_h *handle,
		const char *tarball,
		const char *directory);

This command uploads and unpacks local file C<tarball> (a
I<gzip compressed> tar file) into C<directory>.

To upload an uncompressed tarball, use C<guestfs_tar_in>.

This function returns 0 on success or -1 on error.

=head2 guestfs_tgz_out

 int guestfs_tgz_out (guestfs_h *handle,
		const char *directory,
		const char *tarball);

This command packs the contents of C<directory> and downloads
it to local file C<tarball>.

To download an uncompressed tarball, use C<guestfs_tar_out>.

This function returns 0 on success or -1 on error.

=head2 guestfs_touch

 int guestfs_touch (guestfs_h *handle,
		const char *path);

Touch acts like the L<touch(1)> command.  It can be used to
update the timestamps on a file, or, if the file does not exist,
to create a new zero-length file.

This function returns 0 on success or -1 on error.

=head2 guestfs_truncate

 int guestfs_truncate (guestfs_h *handle,
		const char *path);

This command truncates C<path> to a zero-length file.  The
file must exist already.

This function returns 0 on success or -1 on error.

=head2 guestfs_truncate_size

 int guestfs_truncate_size (guestfs_h *handle,
		const char *path,
		int64_t size);

This command truncates C<path> to size C<size> bytes.  The file
must exist already.  If the file is smaller than C<size> then
the file is extended to the required size with null bytes.

This function returns 0 on success or -1 on error.

=head2 guestfs_tune2fs_l

 char **guestfs_tune2fs_l (guestfs_h *handle,
		const char *device);

This returns the contents of the ext2, ext3 or ext4 filesystem
superblock on C<device>.

It is the same as running C<tune2fs -l device>.  See L<tune2fs(8)>
manpage for more details.  The list of fields returned isn't
clearly defined, and depends on both the version of C<tune2fs>
that libguestfs was built against, and the filesystem itself.

This function returns a NULL-terminated array of
strings, or NULL if there was an error.
The array of strings will always have length C<2n+1>, where
C<n> keys and values alternate, followed by the trailing NULL entry.
I<The caller must free the strings and the array after use>.

=head2 guestfs_umask

 int guestfs_umask (guestfs_h *handle,
		int mask);

This function sets the mask used for creating new files and
device nodes to C<mask & 0777>.

Typical umask values would be C<022> which creates new files
with permissions like "-rw-r--r--" or "-rwxr-xr-x", and
C<002> which creates new files with permissions like
"-rw-rw-r--" or "-rwxrwxr-x".

The default umask is C<022>.  This is important because it
means that directories and device nodes will be created with
C<0644> or C<0755> mode even if you specify C<0777>.

See also L<umask(2)>, C<guestfs_mknod>, C<guestfs_mkdir>.

This call returns the previous umask.

On error this function returns -1.

=head2 guestfs_umount

 int guestfs_umount (guestfs_h *handle,
		const char *pathordevice);

This unmounts the given filesystem.  The filesystem may be
specified either by its mountpoint (path) or the device which
contains the filesystem.

This function returns 0 on success or -1 on error.

=head2 guestfs_umount_all

 int guestfs_umount_all (guestfs_h *handle);

This unmounts all mounted filesystems.

Some internal mounts are not unmounted by this call.

This function returns 0 on success or -1 on error.

=head2 guestfs_upload

 int guestfs_upload (guestfs_h *handle,
		const char *filename,
		const char *remotefilename);

Upload local file C<filename> to C<remotefilename> on the
filesystem.

C<filename> can also be a named pipe.

See also C<guestfs_download>.

This function returns 0 on success or -1 on error.

=head2 guestfs_utimens

 int guestfs_utimens (guestfs_h *handle,
		const char *path,
		int64_t atsecs,
		int64_t atnsecs,
		int64_t mtsecs,
		int64_t mtnsecs);

This command sets the timestamps of a file with nanosecond
precision.

C<atsecs, atnsecs> are the last access time (atime) in secs and
nanoseconds from the epoch.

C<mtsecs, mtnsecs> are the last modification time (mtime) in
secs and nanoseconds from the epoch.

If the C<*nsecs> field contains the special value C<-1> then
the corresponding timestamp is set to the current time.  (The
C<*secs> field is ignored in this case).

If the C<*nsecs> field contains the special value C<-2> then
the corresponding timestamp is left unchanged.  (The
C<*secs> field is ignored in this case).

This function returns 0 on success or -1 on error.

=head2 guestfs_version

 struct guestfs_version *guestfs_version (guestfs_h *handle);

Return the libguestfs version number that the program is linked
against.

Note that because of dynamic linking this is not necessarily
the version of libguestfs that you compiled against.  You can
compile the program, and then at runtime dynamically link
against a completely different C<libguestfs.so> library.

This call was added in version C<1.0.58>.  In previous
versions of libguestfs there was no way to get the version
number.  From C code you can use ELF weak linking tricks to find out if
this symbol exists (if it doesn't, then it's an earlier version).

The call returns a structure with four elements.  The first
three (C<major>, C<minor> and C<release>) are numbers and
correspond to the usual version triplet.  The fourth element
(C<extra>) is a string and is normally empty, but may be
used for distro-specific information.

To construct the original version string:
C<$major.$minor.$release$extra>

I<Note:> Don't use this call to test for availability
of features.  Distro backports makes this unreliable.  Use
C<guestfs_available> instead.

This function returns a C<struct guestfs_version *>,
or NULL if there was an error.
I<The caller must call C<guestfs_free_version> after use>.

=head2 guestfs_vfs_type

 char *guestfs_vfs_type (guestfs_h *handle,
		const char *device);

This command gets the block device type corresponding to
a mounted device called C<device>.

Usually the result is the name of the Linux VFS module that
is used to mount this device (probably determined automatically
if you used the C<guestfs_mount> call).

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

=head2 guestfs_vg_activate

 int guestfs_vg_activate (guestfs_h *handle,
		int activate,
		char *const *volgroups);

This command activates or (if C<activate> is false) deactivates
all logical volumes in the listed volume groups C<volgroups>.
If activated, then they are made known to the
kernel, ie. they appear as C</dev/mapper> devices.  If deactivated,
then those devices disappear.

This command is the same as running C<vgchange -a y|n volgroups...>

Note that if C<volgroups> is an empty list then B<all> volume groups
are activated or deactivated.

This function returns 0 on success or -1 on error.

=head2 guestfs_vg_activate_all

 int guestfs_vg_activate_all (guestfs_h *handle,
		int activate);

This command activates or (if C<activate> is false) deactivates
all logical volumes in all volume groups.
If activated, then they are made known to the
kernel, ie. they appear as C</dev/mapper> devices.  If deactivated,
then those devices disappear.

This command is the same as running C<vgchange -a y|n>

This function returns 0 on success or -1 on error.

=head2 guestfs_vgcreate

 int guestfs_vgcreate (guestfs_h *handle,
		const char *volgroup,
		char *const *physvols);

This creates an LVM volume group called C<volgroup>
from the non-empty list of physical volumes C<physvols>.

This function returns 0 on success or -1 on error.

=head2 guestfs_vgremove

 int guestfs_vgremove (guestfs_h *handle,
		const char *vgname);

Remove an LVM volume group C<vgname>, (for example C<VG>).

This also forcibly removes all logical volumes in the volume
group (if any).

This function returns 0 on success or -1 on error.

=head2 guestfs_vgrename

 int guestfs_vgrename (guestfs_h *handle,
		const char *volgroup,
		const char *newvolgroup);

Rename a volume group C<volgroup> with the new name C<newvolgroup>.

This function returns 0 on success or -1 on error.

=head2 guestfs_vgs

 char **guestfs_vgs (guestfs_h *handle);

List all the volumes groups detected.  This is the equivalent
of the L<vgs(8)> command.

This returns a list of just the volume group names that were
detected (eg. C<VolGroup00>).

See also C<guestfs_vgs_full>.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

=head2 guestfs_vgs_full

 struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *handle);

List all the volumes groups detected.  This is the equivalent
of the L<vgs(8)> command.  The "full" version includes all fields.

This function returns a C<struct guestfs_lvm_vg_list *>
(see E<lt>guestfs-structs.hE<gt>),
or NULL if there was an error.
I<The caller must call C<guestfs_free_lvm_vg_list> after use>.

=head2 guestfs_wait_ready

 int guestfs_wait_ready (guestfs_h *handle);

This function is a no op.

In versions of the API E<lt> 1.0.71 you had to call this function
just after calling C<guestfs_launch> to wait for the launch
to complete.  However this is no longer necessary because
C<guestfs_launch> now does the waiting.

If you see any calls to this function in code then you can just
remove them, unless you want to retain compatibility with older
versions of the API.

This function returns 0 on success or -1 on error.

=head2 guestfs_wc_c

 int guestfs_wc_c (guestfs_h *handle,
		const char *path);

This command counts the characters in a file, using the
C<wc -c> external command.

On error this function returns -1.

=head2 guestfs_wc_l

 int guestfs_wc_l (guestfs_h *handle,
		const char *path);

This command counts the lines in a file, using the
C<wc -l> external command.

On error this function returns -1.

=head2 guestfs_wc_w

 int guestfs_wc_w (guestfs_h *handle,
		const char *path);

This command counts the words in a file, using the
C<wc -w> external command.

On error this function returns -1.

=head2 guestfs_write_file

 int guestfs_write_file (guestfs_h *handle,
		const char *path,
		const char *content,
		int size);

This call creates a file called C<path>.  The contents of the
file is the string C<content> (which can contain any 8 bit data),
with length C<size>.

As a special case, if C<size> is C<0>
then the length is calculated using C<strlen> (so in this case
the content cannot contain embedded ASCII NULs).

I<NB.> Owing to a bug, writing content containing ASCII NUL
characters does I<not> work, even if the length is specified.
We hope to resolve this bug in a future version.  In the meantime
use C<guestfs_upload>.

This function returns 0 on success or -1 on error.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_zegrep

 char **guestfs_zegrep (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<zegrep> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_zegrepi

 char **guestfs_zegrepi (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<zegrep -i> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_zero

 int guestfs_zero (guestfs_h *handle,
		const char *device);

This command writes zeroes over the first few blocks of C<device>.

How many blocks are zeroed isn't specified (but it's I<not> enough
to securely wipe the device).  It should be sufficient to remove
any partition tables, filesystem superblocks and so on.

See also: C<guestfs_scrub_device>.

This function returns 0 on success or -1 on error.

=head2 guestfs_zerofree

 int guestfs_zerofree (guestfs_h *handle,
		const char *device);

This runs the I<zerofree> program on C<device>.  This program
claims to zero unused inodes and disk blocks on an ext2/3
filesystem, thus making it possible to compress the filesystem
more effectively.

You should B<not> run this program if the filesystem is
mounted.

It is possible that using this program can damage the filesystem
or data on the filesystem.

This function returns 0 on success or -1 on error.

=head2 guestfs_zfgrep

 char **guestfs_zfgrep (guestfs_h *handle,
		const char *pattern,
		const char *path);

This calls the external C<zfgrep> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_zfgrepi

 char **guestfs_zfgrepi (guestfs_h *handle,
		const char *pattern,
		const char *path);

This calls the external C<zfgrep -i> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_zfile

 char *guestfs_zfile (guestfs_h *handle,
		const char *meth,
		const char *path);

This command runs C<file> after first decompressing C<path>
using C<method>.

C<method> must be one of C<gzip>, C<compress> or C<bzip2>.

Since 1.0.63, use C<guestfs_file> instead which can now
process compressed files.

This function returns a string, or NULL on error.
I<The caller must free the returned string after use>.

This function is deprecated.
In new code, use the C<file> call instead.

Deprecated functions will not be removed from the API, but the
fact that they are deprecated indicates that there are problems
with correct use of these functions.

=head2 guestfs_zgrep

 char **guestfs_zgrep (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<zgrep> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

=head2 guestfs_zgrepi

 char **guestfs_zgrepi (guestfs_h *handle,
		const char *regex,
		const char *path);

This calls the external C<zgrep -i> program and returns the
matching lines.

This function returns a NULL-terminated array of strings
(like L<environ(3)>), or NULL if there was an error.
I<The caller must free the strings and the array after use>.

Because of the message protocol, there is a transfer limit
of somewhere between 2MB and 4MB.  To transfer large files you should use
FTP.

